# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-06-08 13:30+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: bloom.xml:5(title)
msgid "bloom"
msgstr ""

#: bloom.xml:7(indexterm)
#, fuzzy
msgid "<primary>bloom</primary>"
msgstr "<primary>lo</primary>"

#: bloom.xml:11(para)
msgid ""
"<literal>bloom</literal> is a module which implements an index access "
"method. It comes as an example of custom access methods and generic WAL "
"records usage. But it is also useful in itself."
msgstr ""

#: bloom.xml:18(title)
msgid "Introduction"
msgstr "Введение"

#: bloom.xml:20(para)
msgid ""
"The implementation of a <ulink url=\"http://en.wikipedia.org/wiki/"
"Bloom_filter\">Bloom filter</ulink> allows fast exclusion of non-candidate "
"tuples via signatures. Since a signature is a lossy representation of all "
"indexed attributes, search results must be rechecked using heap information. "
"The user can specify signature length (in uint16, default is 5) and the "
"number of bits, which can be set per attribute (1 &lt; colN &lt; 2048)."
msgstr ""

#: bloom.xml:30(para)
msgid ""
"This index is useful if a table has many attributes and queries include "
"arbitrary combinations of them. A traditional <literal>btree</literal> index "
"is faster than a bloom index, but it can require many indexes to support all "
"possible queries where one needs only a single bloom index. A Bloom index "
"supports only equality comparison. Since it's a signature file, and not a "
"tree, it always must be read fully, but sequentially, so that index search "
"performance is constant and doesn't depend on a query."
msgstr ""

#: bloom.xml:42(title)
msgid "Parameters"
msgstr "Параметры"

#: bloom.xml:44(para)
#, fuzzy
msgid ""
"<literal>bloom</literal> indexes accept the following parameters in the "
"<literal>WITH</literal> clause."
msgstr ""
"Предложение <literal>USER</literal> является устаревшим написанием "
"предложения <literal>ROLE</literal>."

#: bloom.xml:52(literal)
#, fuzzy
msgid "length"
msgstr ""
"#-#-#-#-#  -  #-#-#-#-#\n"
"length\n"
"#-#-#-#-#  -  #-#-#-#-#\n"
"длина\n"
"#-#-#-#-#  -  #-#-#-#-#\n"
"length"

#: bloom.xml:54(para)
msgid "Length of signature in uint16 type values"
msgstr ""

#: bloom.xml:62(literal)
msgid "col1 &mdash; col16"
msgstr ""

#: bloom.xml:64(para)
#, fuzzy
msgid "Number of bits for corresponding column"
msgstr "Имя нового или существующего столбца."

#: bloom.xml:73(title)
msgid "Examples"
msgstr "Примеры"

#: bloom.xml:75(para)
msgid "An example of an index definition is given below."
msgstr ""

#: bloom.xml:79(programlisting)
#, no-wrap
msgid ""
"CREATE INDEX bloomidx ON tbloom(i1,i2,i3) \n"
"       WITH (length=5, col1=2, col2=2, col3=4);"
msgstr ""

#: bloom.xml:82(para)
msgid ""
"Here, we created a bloom index with a signature length of 80 bits, and "
"attributes i1 and i2 mapped to 2 bits, and attribute i3 to 4 bits."
msgstr ""

#: bloom.xml:87(para)
#, fuzzy
msgid "Here is a fuller example of index definition and usage:"
msgstr "Пример его использования:"

#: bloom.xml:91(programlisting)
#, no-wrap
msgid ""
"CREATE TABLE tbloom AS\n"
"SELECT\n"
"    random()::int as i1,\n"
"    random()::int as i2,\n"
"    random()::int as i3,\n"
"    random()::int as i4,\n"
"    random()::int as i5,\n"
"    random()::int as i6,\n"
"    random()::int as i7,\n"
"    random()::int as i8,\n"
"    random()::int as i9,\n"
"    random()::int as i10,\n"
"    random()::int as i11,\n"
"    random()::int as i12,\n"
"    random()::int as i13\n"
"FROM\n"
"    generate_series(1,1000);\n"
"CREATE INDEX bloomidx ON tbloom USING\n"
"             bloom (i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12);\n"
"SELECT pg_relation_size('bloomidx');\n"
"CREATE index btree_idx ON tbloom(i1,i2,i3,i4,i5,i6,i7,i8,i9,i10,i11,i12);\n"
"SELECT pg_relation_size('btree_idx');"
msgstr ""

#: bloom.xml:114(programlisting)
#, fuzzy, no-wrap
msgid ""
"=# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 20 AND i10 = 15;\n"
"                                                   QUERY PLAN\n"
"-----------------------------------------------------------------------------------------------------------------\n"
" Bitmap Heap Scan on tbloom  (cost=1.50..5.52 rows=1 width=52) (actual time=0.057..0.057 rows=0 loops=1)\n"
"   Recheck Cond: ((i2 = 20) AND (i10 = 15))\n"
"   -&gt;  Bitmap Index Scan on bloomidx  (cost=0.00..1.50 rows=1 width=0) (actual time=0.041..0.041 rows=9 loops=1)\n"
"         Index Cond: ((i2 = 20) AND (i10 = 15))\n"
" Total runtime: 0.081 ms\n"
"(5 rows)"
msgstr ""
"PREPARE query(int, int) AS SELECT sum(bar) FROM test\n"
"    WHERE id &gt; $1 AND id &lt; $2\n"
"    GROUP BY foo;\n"
"\n"
"EXPLAIN ANALYZE EXECUTE query(100, 200);\n"
"\n"
"                                                       QUERY PLAN                                                       \n"
"------------------------------------------------------------------------------------------------------------------------\n"
" HashAggregate  (cost=9.54..9.54 rows=1 width=8) (actual time=0.156..0.161 rows=11 loops=1)\n"
"   Group Key: foo\n"
"   -&gt;  Index Scan using test_pkey on test  (cost=0.29..9.29 rows=50 width=8) (actual time=0.039..0.091 rows=99 loops=1)\n"
"         Index Cond: ((id &gt; $1) AND (id &lt; $2))\n"
" Planning time: 0.197 ms\n"
" Execution time: 0.225 ms\n"
"(6 rows)"

#: bloom.xml:124(para)
msgid "Seqscan is slow."
msgstr ""

#: bloom.xml:128(programlisting)
#, no-wrap
msgid ""
"=# SET enable_bitmapscan = off;\n"
"=# SET enable_indexscan = off;\n"
"=# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 20 AND i10 = 15;\n"
"                                            QUERY PLAN\n"
"--------------------------------------------------------------------------------------------------\n"
" Seq Scan on tbloom  (cost=0.00..25.00 rows=1 width=52) (actual time=0.162..0.162 rows=0 loops=1)\n"
"   Filter: ((i2 = 20) AND (i10 = 15))\n"
" Total runtime: 0.181 ms\n"
"(3 rows)"
msgstr ""

#: bloom.xml:138(para)
msgid "A btree index will be not used for this query."
msgstr ""

#: bloom.xml:142(programlisting)
#, no-wrap
msgid ""
"=# DROP INDEX bloomidx;\n"
"=# CREATE INDEX btree_idx ON tbloom(i1, i2, i3, i4, i5, i6, i7, i8, i9, i10, i11, i12);\n"
"=# EXPLAIN ANALYZE SELECT * FROM tbloom WHERE i2 = 20 AND i10 = 15;\n"
"                                            QUERY PLAN\n"
"--------------------------------------------------------------------------------------------------\n"
" Seq Scan on tbloom (cost=0.00..25.00 rows=1 width=52) (actual time=0.210..0.210 rows=0 loops=1)\n"
"   Filter: ((i2 = 20) AND (i10 = 15))\n"
" Total runtime: 0.250 ms\n"
"(3 rows)"
msgstr ""

#: bloom.xml:154(title)
msgid "Opclass interface"
msgstr ""

#: bloom.xml:156(para)
msgid ""
"The Bloom opclass interface is simple. It requires 1 supporting function: a "
"hash function for the indexing datatype. It provides 1 search operator: the "
"equality operator. The example below shows <literal>opclass</literal> "
"definition for <literal>text</literal> datatype."
msgstr ""

#: bloom.xml:163(programlisting)
#, fuzzy, no-wrap
msgid ""
"CREATE OPERATOR CLASS text_ops\n"
"DEFAULT FOR TYPE text USING bloom AS\n"
"    OPERATOR    1   =(text, text),\n"
"    FUNCTION    1   hashtext(text);"
msgstr ""
"CREATE OPERATOR CLASS polygon_ops\n"
"    DEFAULT FOR TYPE polygon USING gist AS\n"
"        ...\n"
"        STORAGE box;"

#: bloom.xml:170(title)
#, fuzzy
msgid "Limitation"
msgstr "Ограничения"

#: bloom.xml:175(para)
msgid ""
"For now, only opclasses for <literal>int4</literal>, <literal>text</literal> "
"come with the module. However, users may define more of them."
msgstr ""

#: bloom.xml:182(para)
msgid ""
"Only the <literal>=</literal> operator is supported for search at the "
"moment. But it's possible to add support for arrays with contains and "
"intersection operations in the future."
msgstr ""

#: bloom.xml:193(title)
msgid "Authors"
msgstr "Авторы"

#: bloom.xml:195(para)
#, fuzzy
msgid ""
"Teodor Sigaev <email>teodor@postgrespro.ru</email>, Postgres Professional, "
"Moscow, Russia"
msgstr ""
"Фёдор Сигаев <email>teodor@sigaev.ru</email>, Москва, ООО &laquo;Дельта-"
"Софт&raquo;, Россия"

#: bloom.xml:200(para)
msgid ""
"Alexander Korotkov <email>a.korotkov@postgrespro.ru</email>, Postgres "
"Professional, Moscow, Russia"
msgstr ""

#: bloom.xml:205(para)
#, fuzzy
msgid ""
"Oleg Bartunov <email>obartunov@postgrespro.ru</email>, Postgres "
"Professional, Moscow, Russia"
msgstr ""
"Олег Бартунов <email>oleg@sai.msu.su</email>, Москва, Московский "
"Государственный Университет, Россия"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: bloom.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"
