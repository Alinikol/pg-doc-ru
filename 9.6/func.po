# Alexander Lakhin <a.lakhin@postgrespro.ru>, 2012, 2013, 2015, 2016.
# Pavel Luzanov <p.luzanov@postgrespro.ru>, 2015, 2016.
msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: 2016-08-19 11:32+0300\n"
"PO-Revision-Date: 2016-04-13 09:36+0300\n"
"Language-Team: Russian <pgsql-docs@lists.postgrespro.ru>\n"
"Language: ru\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=3; plural=(n%10==1 && n%100!=11 ? 0 : n%10>=2 && n"
"%10<=4 && (n%100<10 || n%100>=20) ? 1 : 2);\n"
"X-Generator: Lokalize 2.0\n"

#: func.xml:5(title)
msgid "Functions and Operators"
msgstr "Функции и операторы"

#: func.xml:7(indexterm)
msgid "<primary>function</primary>"
msgstr "<primary>функция</primary>"

#: func.xml:11(indexterm)
msgid "<primary>operator</primary>"
msgstr "<primary>оператор</primary>"

#: func.xml:15(para)
msgid ""
"<productname>PostgreSQL</productname> provides a large number of functions "
"and operators for the built-in data types. Users can also define their own "
"functions and operators, as described in <xref linkend=\"server-programming"
"\"/>. The <application>psql</application> commands <command>\\df</command> "
"and <command>\\do</command> can be used to list all available functions and "
"operators, respectively."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет огромное количество "
"функций и операторов для встроенных типов данных. Кроме того, пользователи "
"могут определять свои функции операторы, как описано в <xref remap=\"6\" "
"linkend=\"server-programming\"/>. Просмотреть все существующие функции и "
"операторы можно в <application>psql</application> с помощью команд <command>"
"\\df</command> и <command>\\do</command>, соответственно."

#: func.xml:25(para)
msgid ""
"If you are concerned about portability then note that most of the functions "
"and operators described in this chapter, with the exception of the most "
"trivial arithmetic and comparison operators and some explicitly marked "
"functions, are not specified by the <acronym>SQL</acronym> standard. Some of "
"this extended functionality is present in other <acronym>SQL</acronym> "
"database management systems, and in many cases this functionality is "
"compatible and consistent between the various implementations. This chapter "
"is also not exhaustive; additional functions appear in relevant sections of "
"the manual."
msgstr ""
"Если для вас важна переносимость, учтите, что практически все функции и "
"операторы, описанные в этой главе, за исключением простейших арифметических "
"и операторов сравнения, а также явно отмеченных функций, не описаны в "
"стандарте <acronym>SQL</acronym>. Тем не менее, частично эта расширенная "
"функциональность присутствует и в других СУБД <acronym>SQL</acronym> и во "
"многих случаях различные реализации одинаковых функций оказываются "
"аналогичными и совместимыми. В этой главе не описываются абсолютно все "
"функции; некоторые дополнительные функции рассматриваются в других разделах "
"документации."

#: func.xml:40(title)
msgid "Logical Operators"
msgstr "Логические операторы"

#: func.xml:42(indexterm)
msgid "<primary>operator</primary> <secondary>logical</secondary>"
msgstr "<primary>оператор</primary> <secondary>логический</secondary>"

#: func.xml:47(indexterm)
msgid ""
"<primary>Boolean</primary> <secondary>operators</secondary> <see>operators, "
"logical</see>"
msgstr ""
"<primary>Булевы</primary> <secondary>операторы</secondary> <see>операторы, "
"логические</see>"

#: func.xml:56(indexterm)
msgid "<primary>AND (operator)</primary>"
msgstr "<primary>AND (оператор)</primary>"

#: func.xml:60(indexterm)
msgid "<primary>OR (operator)</primary>"
msgstr "<primary>OR (оператор)</primary>"

#: func.xml:64(indexterm)
msgid "<primary>NOT (operator)</primary>"
msgstr "<primary>NOT (оператор)</primary>"

#: func.xml:68(indexterm)
msgid "<primary>conjunction</primary>"
msgstr "<primary>конъюнкция</primary>"

#: func.xml:72(indexterm)
msgid "<primary>disjunction</primary>"
msgstr "<primary>дизъюнкция</primary>"

#: func.xml:76(indexterm)
msgid "<primary>negation</primary>"
msgstr "<primary>отрицание</primary>"

#: func.xml:81(literal) func.xml:278(literal) func.xml:283(literal)
#: func.xml:288(literal) func.xml:293(literal)
msgid "AND"
msgstr "AND"

#: func.xml:82(literal)
msgid "OR"
msgstr "OR"

#: func.xml:83(literal)
msgid "NOT"
msgstr "NOT"

#: func.xml:94(replaceable) func.xml:151(replaceable) func.xml:278(replaceable)
#: func.xml:283(replaceable) func.xml:288(replaceable)
#: func.xml:293(replaceable) func.xml:298(replaceable)
#: func.xml:303(replaceable)
msgctxt "replaceable"
msgid "a"
msgstr "a"

#: func.xml:95(replaceable) func.xml:298(replaceable) func.xml:303(replaceable)
msgctxt "replaceable"
msgid "b"
msgstr "b"

#: func.xml:96(entry)
msgid "<replaceable>a</replaceable> AND <replaceable>b</replaceable>"
msgstr "<replaceable>a</replaceable> AND <replaceable>b</replaceable>"

#: func.xml:97(entry)
msgid "<replaceable>a</replaceable> OR <replaceable>b</replaceable>"
msgstr "<replaceable>a</replaceable> OR <replaceable>b</replaceable>"

#: func.xml:103(entry) func.xml:104(entry) func.xml:105(entry)
#: func.xml:106(entry) func.xml:110(entry) func.xml:113(entry)
#: func.xml:117(entry) func.xml:120(entry) func.xml:158(entry)
#: func.xml:164(entry)
msgid "TRUE"
msgstr "TRUE"

#: func.xml:111(entry) func.xml:112(entry) func.xml:124(entry)
#: func.xml:125(entry) func.xml:126(entry) func.xml:127(entry)
#: func.xml:131(entry) func.xml:133(entry) func.xml:159(entry)
#: func.xml:163(entry)
msgid "FALSE"
msgstr "FALSE"

#: func.xml:118(entry) func.xml:119(entry) func.xml:132(entry)
#: func.xml:134(entry) func.xml:138(entry) func.xml:139(entry)
#: func.xml:140(entry) func.xml:141(entry) func.xml:168(entry)
#: func.xml:169(entry)
msgctxt "entry"
msgid "NULL"
msgstr "NULL"

#: func.xml:152(entry)
msgid "NOT <replaceable>a</replaceable>"
msgstr "NOT <replaceable>a</replaceable>"

#: func.xml:53(para)
msgid ""
"The usual logical operators are available: <placeholder-1/> <placeholder-2/> "
"<placeholder-3/> <placeholder-4/> <placeholder-5/> <placeholder-6/> "
"<placeholder-7/> <acronym>SQL</acronym> uses a three-valued logic system "
"with true, false, and <literal>null</literal>, which represents "
"<quote>unknown</quote>. Observe the following truth tables: <placeholder-8/> "
"<placeholder-9/>"
msgstr ""
"Набор логических операторов включает обычные: <placeholder-1/> "
"<placeholder-2/> <placeholder-3/> <placeholder-4/> <placeholder-5/> "
"<placeholder-6/> <placeholder-7/> В <acronym>SQL</acronym> работает "
"логическая система с тремя состояниями: true (истина), false (ложь) и "
"<literal>NULL</literal>, <quote>неопределённое</quote> состояние. "
"Рассмотрите следующие таблицы истинности: <placeholder-8/> <placeholder-9/>"

#: func.xml:176(para)
msgid ""
"The operators <literal>AND</literal> and <literal>OR</literal> are "
"commutative, that is, you can switch the left and right operand without "
"affecting the result. But see <xref linkend=\"syntax-express-eval\"/> for "
"more information about the order of evaluation of subexpressions."
msgstr ""
"Операторы <literal>AND</literal> и <literal>OR</literal> коммутативны, то "
"есть от перемены мест операндов результат не меняется. Однако значение может "
"иметь порядок вычисления подвыражений. Подробнее это описано в <xref remap="
"\"6\" linkend=\"syntax-express-eval\"/>."

#: func.xml:186(title)
msgid "Comparison Functions and Operators"
msgstr "Функции и операторы сравнения"

#: func.xml:188(indexterm)
msgid "<primary>comparison</primary> <secondary>operators</secondary>"
msgstr "<primary>сравнение</primary> <secondary>операторы</secondary>"

#: func.xml:193(para)
msgid ""
"The usual comparison operators are available, as shown in <xref linkend="
"\"functions-comparison-op-table\"/>."
msgstr ""
"Набор операторов сравнения включает обычные операторы, перечисленные в <xref "
"remap=\"6\" linkend=\"functions-comparison-op-table\"/>."

#: func.xml:199(title)
msgid "Comparison Operators"
msgstr "Операторы сравнения"

#: func.xml:203(entry) func.xml:604(entry) func.xml:3706(entry)
#: func.xml:4137(entry) func.xml:6650(entry) func.xml:8277(entry)
#: func.xml:8813(entry) func.xml:9185(entry) func.xml:10623(entry)
#: func.xml:10716(entry) func.xml:11988(entry) func.xml:12463(entry)
msgid "Operator"
msgstr "Оператор"

#: func.xml:204(entry) func.xml:272(entry) func.xml:549(entry)
#: func.xml:605(entry) func.xml:762(entry) func.xml:1109(entry)
#: func.xml:1163(entry) func.xml:1359(entry) func.xml:1591(entry)
#: func.xml:3382(entry) func.xml:3497(entry) func.xml:3707(entry)
#: func.xml:4138(entry) func.xml:4501(entry) func.xml:4687(entry)
#: func.xml:4901(entry) func.xml:5042(entry) func.xml:5099(entry)
#: func.xml:5155(entry) func.xml:5236(entry) func.xml:5688(entry)
#: func.xml:5793(entry) func.xml:6020(entry) func.xml:6271(entry)
#: func.xml:6425(entry) func.xml:6781(entry) func.xml:7873(entry)
#: func.xml:8173(entry) func.xml:8278(entry) func.xml:8495(entry)
#: func.xml:8598(entry) func.xml:8814(entry) func.xml:8924(entry)
#: func.xml:9124(entry) func.xml:9187(entry) func.xml:9282(entry)
#: func.xml:9625(entry) func.xml:10625(entry) func.xml:10718(entry)
#: func.xml:10845(entry) func.xml:11068(entry) func.xml:11508(entry)
#: func.xml:11989(entry) func.xml:12173(entry) func.xml:12464(entry)
#: func.xml:12662(entry) func.xml:12804(entry) func.xml:13251(entry)
#: func.xml:13668(entry) func.xml:13830(entry) func.xml:13950(entry)
#: func.xml:14050(entry) func.xml:15029(entry) func.xml:15138(entry)
#: func.xml:15286(entry) func.xml:15667(entry) func.xml:16095(entry)
#: func.xml:16354(entry) func.xml:16727(entry) func.xml:16836(entry)
#: func.xml:16926(entry) func.xml:16981(entry) func.xml:17042(entry)
#: func.xml:17082(entry) func.xml:17445(entry) func.xml:17563(entry)
#: func.xml:17698(entry) func.xml:17941(entry) func.xml:18021(entry)
#: func.xml:18112(entry) func.xml:18181(entry) func.xml:18598(entry)
#: func.xml:18848(entry) func.xml:18935(entry) func.xml:18997(entry)
#: func.xml:19121(entry) func.xml:19481(entry) func.xml:19568(entry)
#: func.xml:19703(entry)
msgid "Description"
msgstr "Описание"

#: func.xml:210(literal) func.xml:8820(literal) func.xml:12010(literal)
#: func.xml:12485(literal)
msgid "&lt;"
msgstr "&lt;"

#: func.xml:211(entry) func.xml:12011(entry) func.xml:12486(entry)
msgid "less than"
msgstr "меньше"

#: func.xml:215(literal) func.xml:8840(literal) func.xml:12017(literal)
#: func.xml:12492(literal)
msgid "&gt;"
msgstr "&gt;"

#: func.xml:216(entry) func.xml:12018(entry) func.xml:12493(entry)
msgid "greater than"
msgstr "больше"

#: func.xml:220(literal) func.xml:8825(literal) func.xml:12024(literal)
#: func.xml:12499(literal)
msgid "&lt;="
msgstr "&lt;="

#: func.xml:221(entry)
msgid "less than or equal to"
msgstr "меньше или равно"

#: func.xml:225(literal) func.xml:8835(literal) func.xml:12031(literal)
#: func.xml:12506(literal)
msgid "&gt;="
msgstr "&gt;="

#: func.xml:226(entry)
msgid "greater than or equal to"
msgstr "больше или равно"

#: func.xml:230(literal) func.xml:8830(literal) func.xml:11996(literal)
#: func.xml:12471(literal)
msgid "="
msgstr "="

#: func.xml:231(entry) func.xml:11997(entry) func.xml:12472(entry)
msgid "equal"
msgstr "равно"

#: func.xml:235(entry)
msgid "<literal>&lt;&gt;</literal> or <literal>!=</literal>"
msgstr "<literal>&lt;&gt;</literal> или <literal>!=</literal>"

#: func.xml:236(entry) func.xml:12004(entry) func.xml:12479(entry)
msgid "not equal"
msgstr "не равно"

#: func.xml:243(para)
msgid ""
"The <literal>!=</literal> operator is converted to <literal>&lt;&gt;</"
"literal> in the parser stage. It is not possible to implement <literal>!=</"
"literal> and <literal>&lt;&gt;</literal> operators that do different things."
msgstr ""
"Оператор <literal>!=</literal> преобразуется в <literal>&lt;&gt;</literal> "
"на стадии разбора запроса. Как следствие, реализовать операторы <literal>!=</"
"literal> и <literal>&lt;&gt;</literal> по-разному невозможно."

#: func.xml:251(para)
msgid ""
"Comparison operators are available for all relevant data types. All "
"comparison operators are binary operators that return values of type "
"<type>boolean</type>; expressions like <literal>1 &lt; 2 &lt; 3</literal> "
"are not valid (because there is no <literal>&lt;</literal> operator to "
"compare a Boolean value with <literal>3</literal>)."
msgstr ""
"Операторы сравнения определены для всех типов данных, для которых они имеют "
"смысл. Все операторы сравнения представляют собой бинарные операторы, "
"возвращающие значения типа <type>boolean</type>; при этом выражения вида "
"<literal>1 &lt; 2 &lt; 3</literal> недопустимы (так как не существует "
"оператора <literal>&lt;</literal>, который бы сравнивал булево значение с "
"<literal>3</literal>)."

#: func.xml:260(para)
msgid ""
"There are also some comparison predicates, as shown in <xref linkend="
"\"functions-comparison-pred-table\"/>. These behave much like operators, but "
"have special syntax mandated by the SQL standard."
msgstr ""
"Существует также несколько предикатов сравнения; они приведены в <xref remap="
"\"6\" linkend=\"functions-comparison-pred-table\"/>. Они работают подобно "
"операторам, но имеют особый синтаксис, установленный стандартом SQL."

#: func.xml:267(title)
msgid "Comparison Predicates"
msgstr "Предикаты сравнения"

#: func.xml:271(entry)
msgid "Predicate"
msgstr "Предикат"

#: func.xml:278(literal)
msgid "BETWEEN"
msgstr "BETWEEN"

#: func.xml:278(replaceable) func.xml:283(replaceable)
#: func.xml:288(replaceable) func.xml:293(replaceable)
#: func.xml:774(replaceable) func.xml:1172(replaceable)
#: func.xml:1177(replaceable) func.xml:1187(replaceable)
#: func.xml:1193(replaceable) func.xml:1203(replaceable)
#: func.xml:1209(replaceable) func.xml:1220(replaceable)
#: func.xml:1227(replaceable) func.xml:1238(replaceable)
#: func.xml:1244(replaceable) func.xml:1254(replaceable)
#: func.xml:1260(replaceable) func.xml:1270(replaceable)
#: func.xml:1276(replaceable) func.xml:1286(replaceable)
#: func.xml:1292(replaceable) func.xml:4556(replaceable)
msgctxt "replaceable"
msgid "x"
msgstr "x"

#: func.xml:278(replaceable) func.xml:283(replaceable)
#: func.xml:288(replaceable) func.xml:293(replaceable)
#: func.xml:1219(replaceable) func.xml:1226(replaceable)
msgctxt "replaceable"
msgid "y"
msgstr "y"

#: func.xml:279(entry)
msgid "between"
msgstr "между"

#: func.xml:283(literal)
msgid "NOT BETWEEN"
msgstr "NOT BETWEEN"

#: func.xml:284(entry)
msgid "not between"
msgstr "не между"

#: func.xml:288(literal)
msgid "BETWEEN SYMMETRIC"
msgstr "BETWEEN SYMMETRIC"

#: func.xml:289(entry)
msgid "between, after sorting the comparison values"
msgstr "между, после сортировки сравниваемых значений"

#: func.xml:293(literal)
msgid "NOT BETWEEN SYMMETRIC"
msgstr "NOT BETWEEN SYMMETRIC"

#: func.xml:294(entry)
msgid "not between, after sorting the comparison values"
msgstr "не между, после сортировки сравниваемых значений"

#: func.xml:298(literal)
msgid "IS DISTINCT FROM"
msgstr "IS DISTINCT FROM"

#: func.xml:299(entry)
msgid "not equal, treating null like an ordinary value"
msgstr "не равно, при этом NULL воспринимается как обычное значение"

#: func.xml:303(literal)
msgid "IS NOT DISTINCT FROM"
msgstr "IS NOT DISTINCT FROM"

#: func.xml:304(entry)
msgid "equal, treating null like an ordinary value"
msgstr "равно, при этом NULL воспринимается как обычное значение"

#: func.xml:308(replaceable) func.xml:313(replaceable)
#: func.xml:318(replaceable) func.xml:323(replaceable)
#: func.xml:12814(replaceable) func.xml:12828(replaceable)
#: func.xml:12850(replaceable) func.xml:12871(replaceable)
#: func.xml:12889(replaceable) func.xml:12907(replaceable)
#: func.xml:12924(replaceable) func.xml:12950(replaceable)
#: func.xml:12965(replaceable) func.xml:12982(replaceable)
#: func.xml:12999(replaceable) func.xml:13050(replaceable)
#: func.xml:13068(replaceable) func.xml:13087(replaceable)
#: func.xml:13106(replaceable) func.xml:13129(replaceable)
#: func.xml:13508(replaceable) func.xml:13532(replaceable)
#: func.xml:13556(replaceable) func.xml:14389(replaceable)
#: func.xml:14445(replaceable) func.xml:14501(replaceable)
#: func.xml:14502(replaceable) func.xml:14566(replaceable)
#: func.xml:14714(replaceable) func.xml:14745(replaceable)
#: func.xml:14786(replaceable) func.xml:14787(replaceable)
#: func.xml:14823(replaceable)
msgid "expression"
msgstr "выражение"

#: func.xml:308(literal)
msgid "IS NULL"
msgstr "IS NULL"

#: func.xml:309(entry)
msgid "is null"
msgstr "эквивалентно NULL"

#: func.xml:313(literal)
msgid "IS NOT NULL"
msgstr "IS NOT NULL"

#: func.xml:314(entry)
msgid "is not null"
msgstr "не эквивалентно NULL"

#: func.xml:318(literal)
msgid "ISNULL"
msgstr "ISNULL"

#: func.xml:319(entry)
msgid "is null (nonstandard syntax)"
msgstr "эквивалентно NULL (нестандартный синтаксис)"

#: func.xml:323(literal)
msgid "NOTNULL"
msgstr "NOTNULL"

#: func.xml:324(entry)
msgid "is not null (nonstandard syntax)"
msgstr "не эквивалентно NULL (нестандартный синтаксис)"

#: func.xml:328(replaceable) func.xml:333(replaceable)
#: func.xml:338(replaceable) func.xml:343(replaceable)
#: func.xml:348(replaceable) func.xml:353(replaceable)
msgid "boolean_expression"
msgstr "логическое_выражение"

#: func.xml:328(literal)
msgid "IS TRUE"
msgstr "IS TRUE"

#: func.xml:329(entry)
msgid "is true"
msgstr "истина"

#: func.xml:333(literal)
msgid "IS NOT TRUE"
msgstr "IS NOT TRUE"

#: func.xml:334(entry)
msgid "is false or unknown"
msgstr "ложь или неопределённость"

#: func.xml:338(literal)
msgid "IS FALSE"
msgstr "IS FALSE"

#: func.xml:339(entry)
msgid "is false"
msgstr "ложь"

#: func.xml:343(literal)
msgid "IS NOT FALSE"
msgstr "IS NOT FALSE"

#: func.xml:344(entry)
msgid "is true or unknown"
msgstr "истина или неопределённость"

#: func.xml:348(literal)
msgid "IS UNKNOWN"
msgstr "IS UNKNOWN"

#: func.xml:349(entry)
msgid "is unknown"
msgstr "неопределённость"

#: func.xml:353(literal)
msgid "IS NOT UNKNOWN"
msgstr "IS NOT UNKNOWN"

#: func.xml:354(entry)
msgid "is true or false"
msgstr "истина или ложь"

#: func.xml:361(indexterm)
msgid "<primary>BETWEEN</primary>"
msgstr "<primary>BETWEEN</primary>"

#: func.xml:382(indexterm)
msgid "<primary>BETWEEN SYMMETRIC</primary>"
msgstr "<primary>BETWEEN SYMMETRIC</primary>"

#: func.xml:360(para)
msgid ""
"<placeholder-1/> The <token>BETWEEN</token> predicate simplifies range "
"tests: <synopsis>\n"
"<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND "
"<replaceable>y</replaceable>\n"
"</synopsis> is equivalent to <synopsis>\n"
"<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND "
"<replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>\n"
"</synopsis> Notice that <token>BETWEEN</token> treats the endpoint values as "
"included in the range. <literal>NOT BETWEEN</literal> does the opposite "
"comparison: <synopsis>\n"
"<replaceable>a</replaceable> NOT BETWEEN <replaceable>x</replaceable> AND "
"<replaceable>y</replaceable>\n"
"</synopsis> is equivalent to <synopsis>\n"
"<replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR "
"<replaceable>a</replaceable> &gt; <replaceable>y</replaceable>\n"
"</synopsis> <placeholder-2/> <literal>BETWEEN SYMMETRIC</literal> is like "
"<literal>BETWEEN</literal> except there is no requirement that the argument "
"to the left of <literal>AND</literal> be less than or equal to the argument "
"on the right. If it is not, those two arguments are automatically swapped, "
"so that a nonempty range is always implied."
msgstr ""
"<placeholder-1/> Предикат <token>BETWEEN</token> упрощает проверки "
"интервала: <synopsis>\n"
"<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND "
"<replaceable>y</replaceable>\n"
"</synopsis> равнозначно выражению <synopsis>\n"
"<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND "
"<replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>\n"
"</synopsis> Заметьте, что <token>BETWEEN</token> считает, что границы "
"интервала также включаются в интервал. <literal>NOT BETWEEN</literal> "
"выполняет противоположное сравнение: <synopsis>\n"
"<replaceable>a</replaceable> NOT BETWEEN <replaceable>x</replaceable> AND "
"<replaceable>y</replaceable>\n"
"</synopsis> равнозначно выражению <synopsis>\n"
"<replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR "
"<replaceable>a</replaceable> &gt; <replaceable>y</replaceable>\n"
"</synopsis> <placeholder-2/> Предикат <literal>BETWEEN SYMMETRIC</literal> "
"аналогичен <literal>BETWEEN</literal>, за исключением того, что аргумент "
"слева от <literal>AND</literal> не обязательно должен быть меньше или равен "
"аргументу справа. Если это не так, аргументы автоматически меняются местами, "
"так что всегда подразумевается непустой интервал."

#: func.xml:393(indexterm) func.xml:14690(indexterm)
msgid "<primary>IS DISTINCT FROM</primary>"
msgstr "<primary>IS DISTINCT FROM</primary>"

#: func.xml:396(indexterm) func.xml:14694(indexterm)
msgid "<primary>IS NOT DISTINCT FROM</primary>"
msgstr "<primary>IS NOT DISTINCT FROM</primary>"

#: func.xml:392(para)
msgid ""
"<placeholder-1/> <placeholder-2/> Ordinary comparison operators yield null "
"(signifying <quote>unknown</quote>), not true or false, when either input is "
"null. For example, <literal>7 = NULL</literal> yields null, as does "
"<literal>7 &lt;&gt; NULL</literal>. When this behavior is not suitable, use "
"the <literal>IS <optional> NOT </optional> DISTINCT FROM</literal> "
"predicates: <synopsis>\n"
"<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>\n"
"<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</"
"replaceable>\n"
"</synopsis> For non-null inputs, <literal>IS DISTINCT FROM</literal> is the "
"same as the <literal>&lt;&gt;</literal> operator. However, if both inputs "
"are null it returns false, and if only one input is null it returns true. "
"Similarly, <literal>IS NOT DISTINCT FROM</literal> is identical to "
"<literal>=</literal> for non-null inputs, but it returns true when both "
"inputs are null, and false when only one input is null. Thus, these "
"predicates effectively act as though null were a normal data value, rather "
"than <quote>unknown</quote>."
msgstr ""
"<placeholder-1/> <placeholder-2/> Обычные операторы сравнения выдают NULL "
"(что означает <quote>неопределённость</quote>), а не true или false, когда "
"любое из сравниваемых значений NULL. Например, <literal>7 = NULL</literal> "
"выдаёт NULL, так же, как и <literal>7 &lt;&gt; NULL</literal>. Когда это "
"поведение нежелательно, можно использовать предикаты <literal>IS <optional> "
"NOT </optional> DISTINCT FROM</literal>: <synopsis>\n"
"<replaceable>a</replaceable> IS DISTINCT FROM <replaceable>b</replaceable>\n"
"<replaceable>a</replaceable> IS NOT DISTINCT FROM <replaceable>b</"
"replaceable>\n"
"</synopsis> Для значений не NULL условие <literal>IS DISTINCT FROM</literal> "
"работает так же, как оператор <literal>&lt;&gt;</literal>. Однако, если оба "
"сравниваемых значения NULL, результат будет false, и только если одно из "
"значений NULL, возвращается true. Аналогично, условие <literal>IS NOT "
"DISTINCT FROM</literal> равносильно <literal>=</literal> для значений не "
"NULL, но возвращает true, если оба сравниваемых значения NULL и false в "
"противном случае. Таким образом, эти предикаты по сути работают с NULL, как "
"с обычным значением, а не с <quote>неопределённостью</quote>."

#: func.xml:419(indexterm)
msgid "<primary>IS NULL</primary>"
msgstr "<primary>IS NULL</primary>"

#: func.xml:422(indexterm)
msgid "<primary>IS NOT NULL</primary>"
msgstr "<primary>IS NOT NULL</primary>"

#: func.xml:425(indexterm)
msgid "<primary>ISNULL</primary>"
msgstr "<primary>ISNULL</primary>"

#: func.xml:428(indexterm)
msgid "<primary>NOTNULL</primary>"
msgstr "<primary>NOTNULL</primary>"

#: func.xml:441(indexterm)
msgid "<primary>null value</primary><secondary>comparing</secondary>"
msgstr "<primary>NULL</primary> <secondary>сравнение</secondary>"

#: func.xml:418(para)
msgid ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> <placeholder-4/> To check "
"whether a value is or is not null, use the predicates: <synopsis>\n"
"<replaceable>expression</replaceable> IS NULL\n"
"<replaceable>expression</replaceable> IS NOT NULL\n"
"</synopsis> or the equivalent, but nonstandard, predicates: <synopsis>\n"
"<replaceable>expression</replaceable> ISNULL\n"
"<replaceable>expression</replaceable> NOTNULL\n"
"</synopsis> <placeholder-5/>"
msgstr ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> <placeholder-4/> Для "
"проверки, содержит ли значение NULL или нет, используются предикаты: "
"<synopsis>\n"
"<replaceable>выражение</replaceable> IS NULL\n"
"<replaceable>выражение</replaceable> IS NOT NULL\n"
"</synopsis> или равнозначные (но нестандартные) предикаты: <synopsis>\n"
"<replaceable>выражение</replaceable> ISNULL\n"
"<replaceable>выражение</replaceable> NOTNULL\n"
"</synopsis> <placeholder-5/>"

#: func.xml:444(para)
msgid ""
"Do <emphasis>not</emphasis> write <literal><replaceable>expression</"
"replaceable> = NULL</literal> because <literal>NULL</literal> is not "
"<quote>equal to</quote> <literal>NULL</literal>. (The null value represents "
"an unknown value, and it is not known whether two unknown values are equal.)"
msgstr ""
"Заметьте, что проверка <literal><replaceable>выражение</replaceable> = NULL</"
"literal> <emphasis>не</emphasis> будет работать, так как <literal>NULL</"
"literal> считается не <quote>равным</quote> <literal>NULL</literal>. "
"(Значение NULL представляет неопределённость и равны ли две "
"неопределённости, тоже не определено.)"

#: func.xml:453(para)
msgid ""
"Some applications might expect that <literal><replaceable>expression</"
"replaceable> = NULL</literal> returns true if <replaceable>expression</"
"replaceable> evaluates to the null value. It is highly recommended that "
"these applications be modified to comply with the SQL standard. However, if "
"that cannot be done the <xref linkend=\"guc-transform-null-equals\"/> "
"configuration variable is available. If it is enabled, "
"<productname>PostgreSQL</productname> will convert <literal>x = NULL</"
"literal> clauses to <literal>x IS NULL</literal>."
msgstr ""
"Некоторые приложения могут ожидать, что <literal><replaceable>выражение</"
"replaceable> = NULL</literal> вернёт true, если результатом "
"<replaceable>выражения</replaceable> является NULL. Такие приложения "
"настоятельно рекомендуется исправить и привести в соответствие со стандартом "
"SQL. Однако, в случаях, когда это невозможно, это поведение можно изменить с "
"помощью параметра конфигурации <xref linkend=\"guc-transform-null-equals\"/"
">. Когда этот параметр включён, <productname>PostgreSQL</productname> "
"преобразует условие <literal>x = NULL</literal> в <literal>x IS NULL</"
"literal>."

#: func.xml:466(para)
msgid ""
"If the <replaceable>expression</replaceable> is row-valued, then <literal>IS "
"NULL</literal> is true when the row expression itself is null or when all "
"the row's fields are null, while <literal>IS NOT NULL</literal> is true when "
"the row expression itself is non-null and all the row's fields are non-null. "
"Because of this behavior, <literal>IS NULL</literal> and <literal>IS NOT "
"NULL</literal> do not always return inverse results for row-valued "
"expressions; in particular, a row-valued expression that contains both null "
"and non-null fields will return false for both tests. In some cases, it may "
"be preferable to write <replaceable>row</replaceable> <literal>IS DISTINCT "
"FROM NULL</literal> or <replaceable>row</replaceable> <literal>IS NOT "
"DISTINCT FROM NULL</literal>, which will simply check whether the overall "
"row value is null without any additional tests on the row fields."
msgstr ""
"Если <replaceable>выражение</replaceable> возвращает табличную строку, тогда "
"<literal>IS NULL</literal> будет истинным, когда само выражение — NULL или "
"все поля строки — NULL, а <literal>IS NOT NULL</literal> будет истинным, "
"когда само выражение не NULL, и все поля строки так же не NULL. Вследствие "
"такого определения, <literal>IS NULL</literal> и <literal>IS NOT NULL</"
"literal> не всегда будут возвращать взаимодополняющие результаты для таких "
"выражений; в частности такие выражения со строками, одни поля которых NULL, "
"а другие не NULL, будут ложными одновременно. В некоторых случаях имеет "
"смысл написать <replaceable>строка</replaceable> <literal>IS DISTINCT FROM "
"NULL</literal> или <replaceable>строка</replaceable> <literal>IS NOT "
"DISTINCT FROM NULL</literal>, чтобы просто проверить, равно ли NULL всё "
"значение строки, без каких-либо дополнительных проверок полей строки."

#: func.xml:483(indexterm)
msgid "<primary>IS TRUE</primary>"
msgstr "<primary>IS TRUE</primary>"

#: func.xml:486(indexterm)
msgid "<primary>IS NOT TRUE</primary>"
msgstr "<primary>IS NOT TRUE</primary>"

#: func.xml:489(indexterm)
msgid "<primary>IS FALSE</primary>"
msgstr "<primary>IS FALSE</primary>"

#: func.xml:492(indexterm)
msgid "<primary>IS NOT FALSE</primary>"
msgstr "<primary>IS NOT FALSE</primary>"

#: func.xml:495(indexterm)
msgid "<primary>IS UNKNOWN</primary>"
msgstr "<primary>IS UNKNOWN</primary>"

#: func.xml:498(indexterm)
msgid "<primary>IS NOT UNKNOWN</primary>"
msgstr "<primary>IS NOT UNKNOWN</primary>"

#: func.xml:482(para)
msgid ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> <placeholder-4/> "
"<placeholder-5/> <placeholder-6/> Boolean values can also be tested using "
"the predicates <synopsis>\n"
"<replaceable>boolean_expression</replaceable> IS TRUE\n"
"<replaceable>boolean_expression</replaceable> IS NOT TRUE\n"
"<replaceable>boolean_expression</replaceable> IS FALSE\n"
"<replaceable>boolean_expression</replaceable> IS NOT FALSE\n"
"<replaceable>boolean_expression</replaceable> IS UNKNOWN\n"
"<replaceable>boolean_expression</replaceable> IS NOT UNKNOWN\n"
"</synopsis> These will always return true or false, never a null value, even "
"when the operand is null. A null input is treated as the logical value "
"<quote>unknown</quote>. Notice that <literal>IS UNKNOWN</literal> and "
"<literal>IS NOT UNKNOWN</literal> are effectively the same as <literal>IS "
"NULL</literal> and <literal>IS NOT NULL</literal>, respectively, except that "
"the input expression must be of Boolean type."
msgstr ""
"<placeholder-1/> <placeholder-2/> <placeholder-3/> <placeholder-4/> "
"<placeholder-5/> <placeholder-6/> Логические значения можно также проверить "
"с помощью предикатов <synopsis>\n"
"<replaceable>логическое_выражение</replaceable> IS TRUE\n"
"<replaceable>логическое_выражение</replaceable> IS NOT TRUE\n"
"<replaceable>логическое_выражение</replaceable> IS FALSE\n"
"<replaceable>логическое_выражение</replaceable> IS NOT FALSE\n"
"<replaceable>логическое_выражение</replaceable> IS UNKNOWN\n"
"<replaceable>логическое_выражение</replaceable> IS NOT UNKNOWN\n"
"</synopsis> Они всегда возвращают true или false и никогда NULL, даже если "
"какой-любо операнд — NULL. Они интерпретируют значение NULL как "
"<quote>неопределённость</quote>. Заметьте, что <literal>IS UNKNOWN</literal> "
"и <literal>IS NOT UNKNOWN</literal> по сути равнозначны <literal>IS NULL</"
"literal> и <literal>IS NOT NULL</literal>, соответственно, за исключением "
"того, что выражение может быть только булевого типа."

#. IS OF does not conform to the ISO SQL behavior, so it is undocumented here
#.    <para>
#.     <indexterm>
#.      <primary>IS OF</primary>
#.     </indexterm>
#.     <indexterm>
#.      <primary>IS NOT OF</primary>
#.     </indexterm>
#.     It is possible to check the data type of an expression using the
#.     predicates
#. <synopsis>
#. <replaceable>expression</replaceable> IS OF (typename, ...)
#. <replaceable>expression</replaceable> IS NOT OF (typename, ...)
#. </synopsis>
#.     They return a boolean value based on whether the expression's data
#.     type is one of the listed data types.
#.    </para>
#: func.xml:538(para)
msgid ""
"Some comparison-related functions are also available, as shown in <xref "
"linkend=\"functions-comparison-func-table\"/>."
msgstr ""
"Также имеется несколько связанных со сравнениями функций; они перечислены в "
"<xref remap=\"6\" linkend=\"functions-comparison-func-table\"/>."

#: func.xml:544(title)
msgid "Comparison Functions"
msgstr "Функции сравнения"

#: func.xml:548(entry) func.xml:760(entry) func.xml:1107(entry)
#: func.xml:1357(entry) func.xml:1589(entry) func.xml:3380(entry)
#: func.xml:3495(entry) func.xml:5686(entry) func.xml:6779(entry)
#: func.xml:8172(entry) func.xml:8493(entry) func.xml:8596(entry)
#: func.xml:8922(entry) func.xml:9122(entry) func.xml:9280(entry)
#: func.xml:9623(entry) func.xml:10844(entry) func.xml:11066(entry)
#: func.xml:11508(entry) func.xml:12171(entry) func.xml:12660(entry)
#: func.xml:12800(entry) func.xml:13247(entry) func.xml:13663(entry)
#: func.xml:13825(entry) func.xml:13948(entry) func.xml:14048(entry)
#: func.xml:15026(entry) func.xml:15136(entry) func.xml:18179(entry)
msgid "Function"
msgstr "Функция"

#: func.xml:550(entry) func.xml:606(entry) func.xml:763(entry)
#: func.xml:1360(entry) func.xml:1592(entry) func.xml:3383(entry)
#: func.xml:3498(entry) func.xml:3708(entry) func.xml:4139(entry)
#: func.xml:5689(entry) func.xml:6021(entry) func.xml:6426(entry)
#: func.xml:6651(entry) func.xml:6782(entry) func.xml:8174(entry)
#: func.xml:8279(entry) func.xml:8496(entry) func.xml:8599(entry)
#: func.xml:8815(entry) func.xml:8925(entry) func.xml:9125(entry)
#: func.xml:9188(entry) func.xml:9283(entry) func.xml:9626(entry)
#: func.xml:10626(entry) func.xml:10719(entry) func.xml:10846(entry)
#: func.xml:11069(entry) func.xml:11990(entry) func.xml:12174(entry)
#: func.xml:12465(entry) func.xml:12663(entry)
msgid "Example"
msgstr "Пример"

#: func.xml:551(entry) func.xml:8175(entry) func.xml:10627(entry)
#: func.xml:10847(entry) func.xml:11070(entry)
msgid "Example Result"
msgstr "Результат примера"

#: func.xml:557(indexterm)
msgid "<primary>num_nonnulls</primary>"
msgstr "<primary>num_nonnulls</primary>"

#: func.xml:560(literal)
msgid "num_nonnulls(VARIADIC \"any\")"
msgstr "num_nonnulls(VARIADIC \"any\")"

#: func.xml:562(entry)
msgid "returns the number of non-null arguments"
msgstr "возвращает число аргументов, отличных от NULL"

#: func.xml:563(literal)
msgid "num_nonnulls(1, NULL, 2)"
msgstr "num_nonnulls(1, NULL, 2)"

#: func.xml:564(literal) func.xml:637(literal) func.xml:728(literal)
#: func.xml:845(literal) func.xml:897(literal) func.xml:1003(literal)
#: func.xml:1090(literal) func.xml:2241(literal) func.xml:10658(literal)
#: func.xml:12210(literal) func.xml:12269(literal)
msgctxt "literal"
msgid "2"
msgstr "2"

#: func.xml:568(indexterm)
msgid "<primary>num_nulls</primary>"
msgstr "<primary>num_nulls</primary>"

#: func.xml:571(literal)
msgid "num_nulls(VARIADIC \"any\")"
msgstr "num_nulls(VARIADIC \"any\")"

#: func.xml:573(entry)
msgid "returns the number of null arguments"
msgstr "возвращает число аргументов NULL"

#: func.xml:574(literal)
msgid "num_nulls(1, NULL, 2)"
msgstr "num_nulls(1, NULL, 2)"

#: func.xml:575(literal) func.xml:644(literal) func.xml:920(literal)
#: func.xml:3571(literal)
msgctxt "literal"
msgid "1"
msgstr "1"

#: func.xml:584(title)
msgid "Mathematical Functions and Operators"
msgstr "Математические функции и операторы"

#: func.xml:586(para)
msgid ""
"Mathematical operators are provided for many <productname>PostgreSQL</"
"productname> types. For types without standard mathematical conventions (e."
"g., date/time types) we describe the actual behavior in subsequent sections."
msgstr ""
"Математические операторы определены для множества типов "
"<productname>PostgreSQL</productname>. Как работают эти операции с типами, "
"для которых нет стандартных соглашений о математических действиях (например, "
"с типами даты/времени), мы опишем в последующих разделах."

#: func.xml:594(para)
msgid ""
"<xref linkend=\"functions-math-op-table\"/> shows the available mathematical "
"operators."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-math-op-table\"/> перечислены все "
"доступные математические операторы."

#: func.xml:599(title)
msgid "Mathematical Operators"
msgstr "Математические операторы"

#: func.xml:607(entry) func.xml:764(entry) func.xml:1361(entry)
#: func.xml:1593(entry) func.xml:3384(entry) func.xml:3499(entry)
#: func.xml:3709(entry) func.xml:6460(entry) func.xml:6652(entry)
#: func.xml:6783(entry) func.xml:8926(entry) func.xml:9126(entry)
#: func.xml:9189(entry) func.xml:9284(entry) func.xml:9627(entry)
#: func.xml:11991(entry) func.xml:12175(entry) func.xml:12466(entry)
#: func.xml:12664(entry)
msgid "Result"
msgstr "Результат"

#: func.xml:613(literal) func.xml:4594(literal) func.xml:6658(literal)
#: func.xml:6664(literal) func.xml:6670(literal) func.xml:6676(literal)
#: func.xml:6682(literal) func.xml:6688(literal) func.xml:8284(literal)
#: func.xml:8890(literal) func.xml:12583(literal)
msgid "+"
msgstr "+"

#: func.xml:614(entry) func.xml:8891(entry)
msgid "addition"
msgstr "сложение"

#: func.xml:615(literal)
msgid "2 + 3"
msgstr "2 + 3"

#: func.xml:616(literal) func.xml:658(literal) func.xml:686(literal)
#: func.xml:3414(literal) func.xml:3610(literal) func.xml:9334(literal)
#: func.xml:11083(literal)
msgctxt "literal"
msgid "5"
msgstr "5"

#: func.xml:620(literal) func.xml:6694(literal) func.xml:6700(literal)
#: func.xml:6706(literal) func.xml:6712(literal) func.xml:6718(literal)
#: func.xml:6724(literal) func.xml:6730(literal) func.xml:6736(literal)
#: func.xml:6742(literal) func.xml:8289(literal) func.xml:8895(literal)
#: func.xml:8900(literal) func.xml:10765(literal) func.xml:10773(literal)
#: func.xml:12597(literal)
msgid "-"
msgstr "-"

#: func.xml:621(entry) func.xml:8896(entry) func.xml:8901(entry)
msgid "subtraction"
msgstr "вычитание"

#: func.xml:622(literal)
msgid "2 - 3"
msgstr "2 - 3"

#: func.xml:623(literal) func.xml:1016(literal)
msgid "-1"
msgstr "-1"

#: func.xml:627(literal) func.xml:4589(literal) func.xml:6748(literal)
#: func.xml:6754(literal) func.xml:6760(literal) func.xml:8294(literal)
#: func.xml:12590(literal)
msgid "*"
msgstr "*"

#: func.xml:628(entry)
msgid "multiplication"
msgstr "умножение"

#: func.xml:629(literal)
msgid "2 * 3"
msgstr "2 * 3"

#: func.xml:630(literal) func.xml:8972(literal)
msgid "6"
msgstr "6"

#: func.xml:634(literal) func.xml:6766(literal) func.xml:8299(literal)
msgid "/"
msgstr "/"

#: func.xml:635(entry)
msgid "division (integer division truncates the result)"
msgstr "деление (при целочисленном делении остаток отбрасывается)"

#: func.xml:636(literal)
msgid "4 / 2"
msgstr "4 / 2"

#: func.xml:641(literal)
msgid "%"
msgstr "%"

#: func.xml:642(entry)
msgid "modulo (remainder)"
msgstr "остаток от деления"

#: func.xml:643(literal)
msgid "5 % 4"
msgstr "5 % 4"

#: func.xml:648(literal) func.xml:4693(literal)
msgid "^"
msgstr "^"

#: func.xml:649(entry)
msgid "exponentiation (associates left to right)"
msgstr "возведение в степень (вычисляется слева направо)"

#: func.xml:650(literal)
msgid "2.0 ^ 3.0"
msgstr "2.0 ^ 3.0"

#: func.xml:651(literal)
msgid "8"
msgstr "8"

#: func.xml:655(literal)
msgid "|/"
msgstr "|/"

#: func.xml:656(entry) func.xml:1027(entry)
msgid "square root"
msgstr "квадратный корень"

#: func.xml:657(literal)
msgid "|/ 25.0"
msgstr "|/ 25.0"

#: func.xml:662(literal)
msgid "||/"
msgstr "||/"

#: func.xml:663(entry) func.xml:790(entry)
msgid "cube root"
msgstr "кубический корень"

#: func.xml:664(literal)
msgid "||/ 27.0"
msgstr "||/ 27.0"

#: func.xml:665(literal) func.xml:792(literal) func.xml:1066(literal)
#: func.xml:1078(literal) func.xml:1485(literal) func.xml:3442(literal)
#: func.xml:6892(literal) func.xml:6940(literal) func.xml:9322(literal)
#: func.xml:10651(literal) func.xml:10672(literal) func.xml:12245(literal)
msgctxt "literal"
msgid "3"
msgstr "3"

#: func.xml:669(literal)
msgid "!"
msgstr "!"

#: func.xml:670(entry)
msgid "factorial"
msgstr "факториал"

#: func.xml:671(literal)
msgid "5 !"
msgstr "5 !"

#: func.xml:672(literal) func.xml:679(literal) func.xml:1613(literal)
msgid "120"
msgstr "120"

#: func.xml:676(literal) func.xml:9229(literal)
msgid "!!"
msgstr "!!"

#: func.xml:677(entry)
msgid "factorial (prefix operator)"
msgstr "факториал (префиксная форма)"

#: func.xml:678(literal)
msgid "!! 5"
msgstr "!! 5"

#: func.xml:683(literal)
msgid "@"
msgstr "@"

#: func.xml:684(entry) func.xml:777(entry)
msgid "absolute value"
msgstr "модуль числа (абсолютное значение)"

#: func.xml:685(literal)
msgid "@ -5.0"
msgstr "@ -5.0"

#: func.xml:690(literal) func.xml:3722(literal) func.xml:8880(literal)
msgid "&amp;"
msgstr "&amp;"

#: func.xml:691(entry) func.xml:3723(entry) func.xml:8881(entry)
msgid "bitwise AND"
msgstr "битовый AND"

#: func.xml:692(literal)
msgid "91 &amp; 15"
msgstr "91 &amp; 15"

#: func.xml:693(literal)
msgid "11"
msgstr "11"

#: func.xml:697(literal) func.xml:3729(literal) func.xml:8885(literal)
msgid "|"
msgstr "|"

#: func.xml:698(entry) func.xml:3730(entry) func.xml:8886(entry)
msgid "bitwise OR"
msgstr "битовый OR"

#: func.xml:699(literal)
msgid "32 | 3"
msgstr "32 | 3"

#: func.xml:700(literal)
msgid "35"
msgstr "35"

#: func.xml:704(literal) func.xml:3736(literal) func.xml:8304(literal)
#: func.xml:8309(literal)
msgid "#"
msgstr "#"

#: func.xml:705(entry) func.xml:3737(entry)
msgid "bitwise XOR"
msgstr "битовый XOR"

#: func.xml:706(literal)
msgid "17 # 5"
msgstr "17 # 5"

#: func.xml:707(literal) func.xml:6882(literal) func.xml:6930(literal)
msgctxt "literal"
msgid "20"
msgstr "20"

#: func.xml:711(literal) func.xml:3743(literal) func.xml:4145(literal)
#: func.xml:8875(literal)
msgid "~"
msgstr "~"

#: func.xml:712(entry) func.xml:3744(entry) func.xml:8876(entry)
msgid "bitwise NOT"
msgstr "битовый NOT"

#: func.xml:713(literal)
msgid "~1"
msgstr "~1"

#: func.xml:714(literal)
msgid "-2"
msgstr "-2"

#: func.xml:718(literal) func.xml:3750(literal) func.xml:8339(literal)
#: func.xml:8850(literal) func.xml:12548(literal)
msgid "&lt;&lt;"
msgstr "&lt;&lt;"

#: func.xml:719(entry) func.xml:3751(entry)
msgid "bitwise shift left"
msgstr "битовый сдвиг влево"

#: func.xml:720(literal)
msgid "1 &lt;&lt; 4"
msgstr "1 &lt;&lt; 4"

#: func.xml:721(literal)
msgctxt "literal"
msgid "16"
msgstr "16"

#: func.xml:725(literal) func.xml:3757(literal) func.xml:8344(literal)
#: func.xml:8860(literal) func.xml:12555(literal)
msgid "&gt;&gt;"
msgstr "&gt;&gt;"

#: func.xml:726(entry) func.xml:3758(entry)
msgid "bitwise shift right"
msgstr "битовый сдвиг вправо"

#: func.xml:727(literal)
msgid "8 &gt;&gt; 2"
msgstr "8 &gt;&gt; 2"

#: func.xml:735(para)
msgid ""
"The bitwise operators work only on integral data types, whereas the others "
"are available for all numeric data types. The bitwise operators are also "
"available for the bit string types <type>bit</type> and <type>bit varying</"
"type>, as shown in <xref linkend=\"functions-bit-string-op-table\"/>."
msgstr ""
"Битовые операторы работают только с целостными типами данных, тогда как "
"другие и работают и с остальными числовыми типами. Битовые операции также "
"работают с битовыми строками <type>bit</type> и <type>bit varying</type>, "
"как показано в <xref remap=\"6\" linkend=\"functions-bit-string-op-table\"/>."

#: func.xml:743(para)
msgid ""
"<xref linkend=\"functions-math-func-table\"/> shows the available "
"mathematical functions. In the table, <literal>dp</literal> indicates "
"<type>double precision</type>. Many of these functions are provided in "
"multiple forms with different argument types. Except where noted, any given "
"form of a function returns the same data type as its argument. The functions "
"working with <type>double precision</type> data are mostly implemented on "
"top of the host system's C library; accuracy and behavior in boundary cases "
"can therefore vary depending on the host system."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-math-func-table\"/> перечислены все "
"существующие математические функции. Сокращение <literal>dp</literal> в ней "
"обозначает тип <type>double precision</type> (плавающее с двойной "
"точностью). Многие из этих функций имеют несколько форм с разными типами "
"аргументов. За исключением случаев, где это указано явно, любая форма "
"функции возвращает результат того же типа, что и аргумент. Функции, "
"работающие с данными <type>double precision</type>, в массе своей используют "
"реализации из системных библиотек сервера, поэтому точность и поведение в "
"граничных случаях может зависеть от системы сервера."

#: func.xml:756(title)
msgid "Mathematical Functions"
msgstr "Математические функции"

#: func.xml:761(entry) func.xml:1108(entry) func.xml:1358(entry)
#: func.xml:1590(entry) func.xml:3381(entry) func.xml:3496(entry)
#: func.xml:5687(entry) func.xml:6780(entry) func.xml:7872(entry)
#: func.xml:8494(entry) func.xml:8597(entry) func.xml:8923(entry)
#: func.xml:9123(entry) func.xml:9186(entry) func.xml:9281(entry)
#: func.xml:9624(entry) func.xml:11067(entry) func.xml:11508(entry)
#: func.xml:12172(entry) func.xml:12661(entry) func.xml:12802(entry)
#: func.xml:13249(entry) func.xml:13666(entry) func.xml:13828(entry)
#: func.xml:13949(entry) func.xml:14049(entry) func.xml:15028(entry)
#: func.xml:15137(entry) func.xml:15286(entry) func.xml:15667(entry)
#: func.xml:16095(entry) func.xml:16354(entry) func.xml:16727(entry)
#: func.xml:16836(entry) func.xml:16926(entry) func.xml:17042(entry)
#: func.xml:17082(entry) func.xml:17445(entry) func.xml:17563(entry)
#: func.xml:17698(entry) func.xml:17941(entry) func.xml:18021(entry)
#: func.xml:18112(entry) func.xml:18180(entry) func.xml:18598(entry)
#: func.xml:18848(entry) func.xml:18935(entry) func.xml:18997(entry)
#: func.xml:19121(entry) func.xml:19703(entry)
msgid "Return Type"
msgstr "Тип результата"

#: func.xml:771(indexterm)
msgid "<primary>abs</primary>"
msgstr "<primary>abs</primary>"

#: func.xml:774(function)
msgid "abs(<placeholder-1/>)"
msgstr "abs(<placeholder-1/>)"

#: func.xml:776(entry) func.xml:802(entry) func.xml:815(entry)
#: func.xml:855(entry) func.xml:868(entry) func.xml:881(entry)
#: func.xml:894(entry) func.xml:979(entry) func.xml:1013(entry)
#: func.xml:1026(entry) func.xml:1039(entry)
msgid "(same as input)"
msgstr "тип аргумента"

#: func.xml:778(literal)
msgid "abs(-17.4)"
msgstr "abs(-17.4)"

#: func.xml:779(literal)
msgid "17.4"
msgstr "17.4"

#: func.xml:784(indexterm)
msgid "<primary>cbrt</primary>"
msgstr "<primary>cbrt</primary>"

#: func.xml:787(type) func.xml:789(type) func.xml:800(type) func.xml:813(type)
#: func.xml:826(type) func.xml:828(type) func.xml:853(type) func.xml:866(type)
#: func.xml:879(type) func.xml:892(type) func.xml:930(type) func.xml:941(type)
#: func.xml:942(type) func.xml:944(type) func.xml:964(type) func.xml:966(type)
#: func.xml:977(type) func.xml:1011(type) func.xml:1024(type)
#: func.xml:1037(type) func.xml:1058(type) func.xml:1120(type)
#: func.xml:1129(type)
msgid "dp"
msgstr "dp"

#: func.xml:787(function)
msgid "cbrt(<placeholder-1/>)"
msgstr "cbrt(<placeholder-1/>)"

#: func.xml:791(literal)
msgid "cbrt(27.0)"
msgstr "cbrt(27.0)"

#: func.xml:797(indexterm)
msgid "<primary>ceil</primary>"
msgstr "<primary>ceil</primary>"

#: func.xml:800(type) func.xml:813(type) func.xml:839(type) func.xml:840(type)
#: func.xml:842(type) func.xml:853(type) func.xml:866(type) func.xml:879(type)
#: func.xml:892(type) func.xml:901(type) func.xml:902(type) func.xml:903(type)
#: func.xml:951(type) func.xml:952(type) func.xml:953(type) func.xml:977(type)
#: func.xml:986(type) func.xml:987(type) func.xml:998(type) func.xml:1000(type)
#: func.xml:1011(type) func.xml:1024(type) func.xml:1037(type)
#: func.xml:1046(type) func.xml:1047(type) func.xml:1070(type)
#: func.xml:5724(type) func.xml:5747(type) func.xml:17791(type)
#: func.xml:18672(type)
msgid "numeric"
msgstr "numeric"

#: func.xml:800(function)
msgid "ceil(<placeholder-1/> or <placeholder-2/>)"
msgstr "ceil(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:803(entry)
msgid "nearest integer greater than or equal to argument"
msgstr "ближайшее целое, большее или равное аргументу"

#: func.xml:804(literal)
msgid "ceil(-42.8)"
msgstr "ceil(-42.8)"

#: func.xml:805(literal)
msgid "-42"
msgstr "-42"

#: func.xml:810(indexterm)
msgid "<primary>ceiling</primary>"
msgstr "<primary>ceiling</primary>"

#: func.xml:813(function)
msgid "ceiling(<placeholder-1/> or <placeholder-2/>)"
msgstr "ceiling(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:816(entry)
msgid ""
"nearest integer greater than or equal to argument (same as <function>ceil</"
"function>)"
msgstr ""
"ближайшее целое, большее или равное аргументу (равнозначно <function>ceil</"
"function>)"

#: func.xml:817(literal)
msgid "ceiling(-95.3)"
msgstr "ceiling(-95.3)"

#: func.xml:818(literal)
msgid "-95"
msgstr "-95"

#: func.xml:823(indexterm)
msgid "<primary>degrees</primary>"
msgstr "<primary>degrees</primary>"

#: func.xml:826(function)
msgid "degrees(<placeholder-1/>)"
msgstr "degrees(<placeholder-1/>)"

#: func.xml:829(entry)
msgid "radians to degrees"
msgstr "преобразование радианов в градусы"

#: func.xml:830(literal)
msgid "degrees(0.5)"
msgstr "degrees(0.5)"

#: func.xml:831(literal)
msgid "28.6478897565412"
msgstr "28.6478897565&zwsp;412"

#: func.xml:836(indexterm)
msgid "<primary>div</primary>"
msgstr "<primary>div</primary>"

#: func.xml:839(parameter) func.xml:914(parameter)
msgctxt "parameter"
msgid "y"
msgstr "y"

#: func.xml:840(parameter) func.xml:902(parameter) func.xml:915(parameter)
msgctxt "parameter"
msgid "x"
msgstr "x"

#: func.xml:839(function)
msgid ""
"div(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"div(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:843(entry)
msgid "integer quotient of <parameter>y</parameter>/<parameter>x</parameter>"
msgstr ""
"целочисленный результат <parameter>y</parameter>/<parameter>x</parameter>"

#: func.xml:844(literal)
msgid "div(9,4)"
msgstr "div(9,4)"

#: func.xml:850(indexterm)
msgid "<primary>exp</primary>"
msgstr "<primary>exp</primary>"

#: func.xml:853(function)
msgid "exp(<placeholder-1/> or <placeholder-2/>)"
msgstr "exp(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:856(entry)
msgid "exponential"
msgstr "экспонента"

#: func.xml:857(literal)
msgid "exp(1.0)"
msgstr "exp(1.0)"

#: func.xml:858(literal)
msgid "2.71828182845905"
msgstr "2.7182818284&zwsp;5905"

#: func.xml:863(indexterm)
msgid "<primary>floor</primary>"
msgstr "<primary>floor</primary>"

#: func.xml:866(function)
msgid "floor(<placeholder-1/> or <placeholder-2/>)"
msgstr "floor(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:869(entry)
msgid "nearest integer less than or equal to argument"
msgstr "ближайшее целое, меньшее или равное аргументу"

#: func.xml:870(literal)
msgid "floor(-42.8)"
msgstr "floor(-42.8)"

#: func.xml:871(literal)
msgid "-43"
msgstr "-43"

#: func.xml:876(indexterm)
msgid "<primary>ln</primary>"
msgstr "<primary>ln</primary>"

#: func.xml:879(function)
msgid "ln(<placeholder-1/> or <placeholder-2/>)"
msgstr "ln(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:882(entry)
msgid "natural logarithm"
msgstr "натуральный логарифм"

#: func.xml:883(literal)
msgid "ln(2.0)"
msgstr "ln(2.0)"

#: func.xml:884(literal)
msgid "0.693147180559945"
msgstr "0.6931471805&zwsp;59945"

#: func.xml:889(indexterm)
msgid "<primary>log</primary>"
msgstr "<primary>log</primary>"

#: func.xml:892(function)
msgid "log(<placeholder-1/> or <placeholder-2/>)"
msgstr "log(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:895(entry)
msgid "base 10 logarithm"
msgstr "логарифм по основанию 10"

#: func.xml:896(literal)
msgid "log(100.0)"
msgstr "log(100.0)"

#: func.xml:901(parameter) func.xml:942(parameter) func.xml:952(parameter)
msgctxt "parameter"
msgid "b"
msgstr "b"

#: func.xml:901(function)
msgid ""
"log(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"log(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:904(entry)
msgid "logarithm to base <parameter>b</parameter>"
msgstr "логарифм по основанию <parameter>b</parameter>"

#: func.xml:905(literal)
msgid "log(2.0, 64.0)"
msgstr "log(2.0, 64.0)"

#: func.xml:906(literal)
msgid "6.0000000000"
msgstr "6.0000000000"

#: func.xml:911(indexterm)
msgid "<primary>mod</primary>"
msgstr "<primary>mod</primary>"

#: func.xml:914(function)
msgid "mod(<placeholder-1/>, <placeholder-2/>)"
msgstr "mod(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:917(entry)
msgid "(same as argument types)"
msgstr "зависит от типов аргументов"

#: func.xml:918(entry)
msgid "remainder of <parameter>y</parameter>/<parameter>x</parameter>"
msgstr "остаток от деления <parameter>y</parameter>/<parameter>x</parameter>"

#: func.xml:919(literal)
msgid "mod(9,4)"
msgstr "mod(9,4)"

#: func.xml:925(indexterm)
msgid "<primary>pi</primary>"
msgstr "<primary>pi</primary>"

#: func.xml:928(function)
msgctxt "function"
msgid "pi()"
msgstr "pi()"

#: func.xml:931(entry)
msgid "<quote>&pi;</quote> constant"
msgstr "константа <quote>&pi;</quote>"

#: func.xml:932(literal)
msgctxt "literal"
msgid "pi()"
msgstr "pi()"

#: func.xml:933(literal)
msgid "3.14159265358979"
msgstr "3.1415926535&zwsp;8979"

#: func.xml:938(indexterm)
msgid "<primary>power</primary>"
msgstr "<primary>power</primary>"

#: func.xml:941(parameter) func.xml:951(parameter)
msgctxt "parameter"
msgid "a"
msgstr "a"

#: func.xml:941(function) func.xml:951(function)
msgid ""
"power(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"power(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:945(entry) func.xml:954(entry)
msgid ""
"<parameter>a</parameter> raised to the power of <parameter>b</parameter>"
msgstr "<parameter>a</parameter> возводится в степень <parameter>b</parameter>"

#: func.xml:946(literal) func.xml:955(literal)
msgid "power(9.0, 3.0)"
msgstr "power(9.0, 3.0)"

#: func.xml:947(literal) func.xml:956(literal)
msgid "729"
msgstr "729"

#: func.xml:961(indexterm)
msgid "<primary>radians</primary>"
msgstr "<primary>radians</primary>"

#: func.xml:964(function)
msgid "radians(<placeholder-1/>)"
msgstr "radians(<placeholder-1/>)"

#: func.xml:967(entry)
msgid "degrees to radians"
msgstr "преобразование градусов в радианы"

#: func.xml:968(literal)
msgid "radians(45.0)"
msgstr "radians(45.0)"

#: func.xml:969(literal)
msgid "0.785398163397448"
msgstr "0.7853981633&zwsp;97448"

#: func.xml:974(indexterm)
msgid "<primary>round</primary>"
msgstr "<primary>round</primary>"

#: func.xml:977(function)
msgid "round(<placeholder-1/> or <placeholder-2/>)"
msgstr "round(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:980(entry)
msgid "round to nearest integer"
msgstr "округление до ближайшего целого"

#: func.xml:981(literal)
msgid "round(42.4)"
msgstr "round(42.4)"

#: func.xml:982(literal) func.xml:1042(literal)
msgid "42"
msgstr "42"

#: func.xml:986(parameter) func.xml:1046(parameter)
msgid "v"
msgstr "v"

#: func.xml:986(parameter) func.xml:1046(parameter)
msgctxt "parameter"
msgid "s"
msgstr "s"

#: func.xml:986(type) func.xml:1046(type) func.xml:1058(type)
#: func.xml:1059(type) func.xml:1070(type) func.xml:1071(type)
#: func.xml:1083(type) func.xml:1404(type) func.xml:1417(type)
#: func.xml:1454(type) func.xml:1465(type) func.xml:1482(type)
#: func.xml:1493(type) func.xml:1605(type) func.xml:1639(type)
#: func.xml:1824(type) func.xml:1842(type) func.xml:1853(type)
#: func.xml:1869(type) func.xml:2112(type) func.xml:2159(type)
#: func.xml:2176(type) func.xml:2216(type) func.xml:2233(type)
#: func.xml:2283(type) func.xml:3411(type) func.xml:3422(type)
#: func.xml:3439(type) func.xml:3450(type) func.xml:3566(type)
#: func.xml:3581(type) func.xml:3596(type) func.xml:5711(type)
#: func.xml:7048(type) func.xml:7049(type) func.xml:7050(type)
#: func.xml:7069(type) func.xml:7070(type) func.xml:7071(type)
#: func.xml:7072(type) func.xml:7073(type) func.xml:7074(type)
#: func.xml:7095(type) func.xml:7096(type) func.xml:7116(type)
#: func.xml:7117(type) func.xml:7118(type) func.xml:7119(type)
#: func.xml:7120(type) func.xml:7140(type) func.xml:7141(type)
#: func.xml:7142(type) func.xml:7143(type) func.xml:7144(type)
#: func.xml:8544(type) func.xml:8550(type) func.xml:8968(type)
#: func.xml:9005(type) func.xml:9039(type) func.xml:9047(type)
#: func.xml:10633(type) func.xml:10648(type) func.xml:11078(type)
#: func.xml:12207(type) func.xml:12239(type) func.xml:12242(type)
#: func.xml:12250(type) func.xml:12253(type) func.xml:12261(type)
#: func.xml:12264(type) func.xml:12333(type) func.xml:12336(type)
#: func.xml:12347(type) func.xml:15335(type) func.xml:15347(type)
#: func.xml:15354(type) func.xml:15361(type) func.xml:15404(type)
#: func.xml:17570(type) func.xml:17595(type) func.xml:18249(type)
#: func.xml:18274(type) func.xml:18292(type) func.xml:18309(type)
#: func.xml:18605(type) func.xml:19135(type) func.xml:19149(type)
#: func.xml:19163(type) func.xml:19184(type) func.xml:19198(type)
#: func.xml:19212(type) func.xml:19226(type) func.xml:19240(type)
#: func.xml:19254(type) func.xml:19268(type) func.xml:19721(type)
msgid "int"
msgstr "int"

#: func.xml:986(function)
msgid ""
"round(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"round(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:988(entry)
msgid "round to <parameter>s</parameter> decimal places"
msgstr ""
"округление <parameter>v</parameter> до <parameter>s</parameter> десятичных "
"знаков"

#: func.xml:989(literal)
msgid "round(42.4382, 2)"
msgstr "round(42.4382, 2)"

#: func.xml:990(literal)
msgid "42.44"
msgstr "42.44"

#: func.xml:995(indexterm)
msgid "<primary>scale</primary>"
msgstr "<primary>scale</primary>"

#: func.xml:998(function)
msgid "scale(<placeholder-1/>)"
msgstr "scale(<placeholder-1/>)"

#: func.xml:1001(entry)
msgid ""
"scale of the argument (the number of decimal digits in the fractional part)"
msgstr "масштаб аргумента (число десятичных цифр в дробной части)"

#: func.xml:1002(literal)
msgid "scale(8.41)"
msgstr "scale(8.41)"

#: func.xml:1008(indexterm)
msgid "<primary>sign</primary>"
msgstr "<primary>sign</primary>"

#: func.xml:1011(function)
msgid "sign(<placeholder-1/> or <placeholder-2/>)"
msgstr "sign(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:1014(entry)
msgid "sign of the argument (-1, 0, +1)"
msgstr "знак аргумента (-1, 0, +1)"

#: func.xml:1015(literal)
msgid "sign(-8.4)"
msgstr "sign(-8.4)"

#: func.xml:1021(indexterm)
msgid "<primary>sqrt</primary>"
msgstr "<primary>sqrt</primary>"

#: func.xml:1024(function)
msgid "sqrt(<placeholder-1/> or <placeholder-2/>)"
msgstr "sqrt(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:1028(literal)
msgid "sqrt(2.0)"
msgstr "sqrt(2.0)"

#: func.xml:1029(literal)
msgid "1.4142135623731"
msgstr "1.4142135623&zwsp;731"

#: func.xml:1034(indexterm) func.xml:9132(indexterm)
msgid "<primary>trunc</primary>"
msgstr "<primary>trunc</primary>"

#: func.xml:1037(function)
msgid "trunc(<placeholder-1/> or <placeholder-2/>)"
msgstr "trunc(<placeholder-1/> или <placeholder-2/>)"

#: func.xml:1040(entry)
msgid "truncate toward zero"
msgstr "округление к нулю"

#: func.xml:1041(literal)
msgid "trunc(42.8)"
msgstr "trunc(42.8)"

#: func.xml:1046(function)
msgid ""
"trunc(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"trunc(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:1048(entry)
msgid "truncate to <parameter>s</parameter> decimal places"
msgstr "округление к 0 до <parameter>s</parameter> десятичных знаков"

#: func.xml:1049(literal)
msgid "trunc(42.4382, 2)"
msgstr "trunc(42.4382, 2)"

#: func.xml:1050(literal)
msgid "42.43"
msgstr "42.43"

#: func.xml:1055(indexterm)
msgid "<primary>width_bucket</primary>"
msgstr "<primary>width_bucket</primary>"

#: func.xml:1058(parameter) func.xml:1070(parameter) func.xml:1082(parameter)
msgid "operand"
msgstr "operand"

#: func.xml:1058(parameter) func.xml:1070(parameter)
msgid "b1"
msgstr "b1"

#: func.xml:1058(parameter) func.xml:1070(parameter)
msgid "b2"
msgstr "b2"

#: func.xml:1058(parameter) func.xml:1070(parameter) func.xml:2249(parameter)
msgid "count"
msgstr "count"

#: func.xml:1058(function) func.xml:1070(function)
msgid ""
"width_bucket(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>)"
msgstr ""
"width_bucket(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>)"

#: func.xml:1060(entry) func.xml:1072(entry)
msgid ""
"return the bucket number to which <parameter>operand</parameter> would be "
"assigned in a histogram having <parameter>count</parameter> equal-width "
"buckets spanning the range <parameter>b1</parameter> to <parameter>b2</"
"parameter>; returns <literal>0</literal> or <literal><parameter>count</"
"parameter>+1</literal> for an input outside the range"
msgstr ""
"возвращает номер группы, в которую попадёт <parameter>operand</parameter> в "
"гистограмме с числом групп <parameter>count</parameter> равного размера, в "
"диапазоне от <parameter>b1</parameter> до <parameter>b2</parameter>; "
"возвращает <literal>0</literal> или <literal><parameter>count</parameter>+1</"
"literal>, если операнд лежит вне диапазона"

#: func.xml:1065(literal) func.xml:1077(literal)
msgid "width_bucket(5.35, 0.024, 10.06, 5)"
msgstr "width_bucket(5.35, 0.024, 10.06, 5)"

#: func.xml:1082(type) func.xml:1999(type) func.xml:2029(type)
#: func.xml:11172(type) func.xml:12182(type) func.xml:12226(type)
#: func.xml:12261(type) func.xml:12274(type) func.xml:12287(type)
#: func.xml:12298(type) func.xml:12310(type) func.xml:14140(type)
#: func.xml:14142(type) func.xml:14169(type) func.xml:14171(type)
msgid "anyelement"
msgstr "anyelement"

#: func.xml:1082(parameter)
msgid "thresholds"
msgstr "thresholds"

#: func.xml:1082(type) func.xml:12182(type) func.xml:12185(type)
#: func.xml:12193(type) func.xml:12196(type) func.xml:12204(type)
#: func.xml:12215(type) func.xml:12230(type) func.xml:12239(type)
#: func.xml:12250(type) func.xml:12261(type) func.xml:12274(type)
#: func.xml:12287(type) func.xml:12290(type) func.xml:12298(type)
#: func.xml:12301(type) func.xml:12310(type) func.xml:12313(type)
#: func.xml:12321(type) func.xml:12333(type) func.xml:12344(type)
#: func.xml:12367(type) func.xml:12379(type)
msgid "anyarray"
msgstr "anyarray"

#: func.xml:1082(function)
msgid ""
"width_bucket(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"width_bucket(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:1084(entry)
msgid ""
"return the bucket number to which <parameter>operand</parameter> would be "
"assigned given an array listing the lower bounds of the buckets; returns "
"<literal>0</literal> for an input less than the first lower bound; the "
"<parameter>thresholds</parameter> array <emphasis>must be sorted</emphasis>, "
"smallest first, or unexpected results will be obtained"
msgstr ""
"возвращает номер группы, в которую попадёт <parameter>operand</parameter> "
"(группы определяются нижними границами, передаваемыми в "
"<parameter>thresholds</parameter>); возвращает 0, если операнд оказывается "
"левее нижней границы; массив <parameter>thresholds</parameter> "
"<emphasis>должен быть отсортирован</emphasis> по возрастанию, иначе будут "
"получены неожиданные результаты"

#: func.xml:1089(literal)
msgid ""
"width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])"
msgstr ""
"width_bucket(now(), array['yesterday', 'today', 'tomorrow']::timestamptz[])"

#: func.xml:1096(para)
msgid ""
"<xref linkend=\"functions-math-random-table\"/> shows functions for "
"generating random numbers."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-math-random-table\"/> перечислены "
"все функции для генерации случайных чисел."

#: func.xml:1102(title)
msgid "Random Functions"
msgstr "Случайные функции"

#: func.xml:1115(indexterm)
msgid "<primary>random</primary>"
msgstr "<primary>random</primary>"

#: func.xml:1118(function)
msgid "random()"
msgstr "random()"

#: func.xml:1121(entry)
msgid "random value in the range 0.0 &lt;= x &lt; 1.0"
msgstr "случайное число в диапазоне 0.0 &lt;= x &lt; 1.0"

#: func.xml:1126(indexterm)
msgid "<primary>setseed</primary>"
msgstr "<primary>setseed</primary>"

#: func.xml:1129(function)
msgid "setseed(<placeholder-1/>)"
msgstr "setseed(<placeholder-1/>)"

#: func.xml:1131(type) func.xml:18038(type) func.xml:18046(type)
#: func.xml:18216(type) func.xml:19130(type) func.xml:19137(type)
#: func.xml:19144(type) func.xml:19151(type) func.xml:19172(type)
#: func.xml:19193(type) func.xml:19200(type) func.xml:19207(type)
#: func.xml:19214(type)
msgctxt "type"
msgid "void"
msgstr "void"

#: func.xml:1132(entry)
msgid ""
"set seed for subsequent <literal>random()</literal> calls (value between "
"-1.0 and 1.0, inclusive)"
msgstr ""
"задаёт отправную точку для последующих вызовов <literal>random()</literal> "
"(значение между -1.0 и 1.0, включая границы)"

#: func.xml:1139(para)
msgid ""
"The characteristics of the values returned by <literal><function>random()</"
"function></literal> depend on the system implementation. It is not suitable "
"for cryptographic applications; see <xref linkend=\"pgcrypto\"/> module for "
"an alternative."
msgstr ""
"Характеристики значений, возвращаемых функцией <literal><function>random()</"
"function></literal> зависят от системы. Для применения в криптографии они "
"непригодны; альтернативы описаны в <xref remap=\"6\" linkend=\"pgcrypto\"/>."

#: func.xml:1146(para)
msgid ""
"Finally, <xref linkend=\"functions-math-trig-table\"/> shows the available "
"trigonometric functions. All trigonometric functions take arguments and "
"return values of type <type>double precision</type>. Each of the "
"trigonometric functions comes in two variants, one that measures angles in "
"radians and one that measures angles in degrees."
msgstr ""
"Наконец, в <xref remap=\"6\" linkend=\"functions-math-trig-table\"/> "
"перечислены все имеющиеся тригонометрические функции. Все эти функции "
"принимают аргументы и возвращают значения типа <type>double precision</"
"type>. У каждой функции имеются две вариации — одна измеряет углы в "
"радианах, а вторая в градусах."

#: func.xml:1156(title)
msgid "Trigonometric Functions"
msgstr "Тригонометрические функции"

#: func.xml:1161(entry)
msgid "Function (radians)"
msgstr "Функции (в радианах)"

#: func.xml:1162(entry)
msgid "Function (degrees)"
msgstr "Функции (в градусах)"

#: func.xml:1170(indexterm)
msgid "<primary>acos</primary>"
msgstr "<primary>acos</primary>"

#: func.xml:1172(function)
msgid "acos(<placeholder-1/>)"
msgstr "acos(<placeholder-1/>)"

#: func.xml:1175(indexterm)
msgid "<primary>acosd</primary>"
msgstr "<primary>acosd</primary>"

#: func.xml:1177(function)
msgid "acosd(<placeholder-1/>)"
msgstr "acosd(<placeholder-1/>)"

#: func.xml:1179(entry)
msgid "inverse cosine"
msgstr "арккосинус"

#: func.xml:1184(indexterm)
msgid "<primary>asin</primary>"
msgstr "<primary>asin</primary>"

#: func.xml:1187(function)
msgid "asin(<placeholder-1/>)"
msgstr "asin(<placeholder-1/>)"

#: func.xml:1190(indexterm)
msgid "<primary>asind</primary>"
msgstr "<primary>asind</primary>"

#: func.xml:1193(function)
msgid "asind(<placeholder-1/>)"
msgstr "asind(<placeholder-1/>)"

#: func.xml:1195(entry)
msgid "inverse sine"
msgstr "арксинус"

#: func.xml:1200(indexterm)
msgid "<primary>atan</primary>"
msgstr "<primary>atan</primary>"

#: func.xml:1203(function)
msgid "atan(<placeholder-1/>)"
msgstr "atan(<placeholder-1/>)"

#: func.xml:1206(indexterm)
msgid "<primary>atand</primary>"
msgstr "<primary>atand</primary>"

#: func.xml:1209(function)
msgid "atand(<placeholder-1/>)"
msgstr "atand(<placeholder-1/>)"

#: func.xml:1211(entry)
msgid "inverse tangent"
msgstr "арктангенс"

#: func.xml:1216(indexterm)
msgid "<primary>atan2</primary>"
msgstr "<primary>atan2</primary>"

#: func.xml:1219(function)
msgid "atan2(<placeholder-1/>, <placeholder-2/>)"
msgstr "atan2(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:1223(indexterm)
msgid "<primary>atan2d</primary>"
msgstr "<primary>atan2d</primary>"

#: func.xml:1226(function)
msgid "atan2d(<placeholder-1/>, <placeholder-2/>)"
msgstr "atan2d(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:1229(entry)
msgid ""
"inverse tangent of <literal><replaceable>y</replaceable>/<replaceable>x</"
"replaceable></literal>"
msgstr ""
"арктангенс <literal><replaceable>y</replaceable>/<replaceable>x</"
"replaceable></literal>"

#: func.xml:1235(indexterm)
msgid "<primary>cos</primary>"
msgstr "<primary>cos</primary>"

#: func.xml:1238(function)
msgid "cos(<placeholder-1/>)"
msgstr "cos(<placeholder-1/>)"

#: func.xml:1241(indexterm)
msgid "<primary>cosd</primary>"
msgstr "<primary>cosd</primary>"

#: func.xml:1244(function)
msgid "cosd(<placeholder-1/>)"
msgstr "cosd(<placeholder-1/>)"

#: func.xml:1246(entry)
msgid "cosine"
msgstr "косинус"

#: func.xml:1251(indexterm)
msgid "<primary>cot</primary>"
msgstr "<primary>cot</primary>"

#: func.xml:1254(function)
msgid "cot(<placeholder-1/>)"
msgstr "cot(<placeholder-1/>)"

#: func.xml:1257(indexterm)
msgid "<primary>cotd</primary>"
msgstr "<primary>cotd</primary>"

#: func.xml:1260(function)
msgid "cotd(<placeholder-1/>)"
msgstr "cotd(<placeholder-1/>)"

#: func.xml:1262(entry)
msgid "cotangent"
msgstr "котангенс"

#: func.xml:1267(indexterm)
msgid "<primary>sin</primary>"
msgstr "<primary>sin</primary>"

#: func.xml:1270(function)
msgid "sin(<placeholder-1/>)"
msgstr "sin(<placeholder-1/>)"

#: func.xml:1273(indexterm)
msgid "<primary>sind</primary>"
msgstr "<primary>sind</primary>"

#: func.xml:1276(function)
msgid "sind(<placeholder-1/>)"
msgstr "sind(<placeholder-1/>)"

#: func.xml:1278(entry)
msgid "sine"
msgstr "синус"

#: func.xml:1283(indexterm)
msgid "<primary>tan</primary>"
msgstr "<primary>tan</primary>"

#: func.xml:1286(function)
msgid "tan(<placeholder-1/>)"
msgstr "tan(<placeholder-1/>)"

#: func.xml:1289(indexterm)
msgid "<primary>tand</primary>"
msgstr "<primary>tand</primary>"

#: func.xml:1292(function)
msgid "tand(<placeholder-1/>)"
msgstr "tand(<placeholder-1/>)"

#: func.xml:1294(entry)
msgid "tangent"
msgstr "тангенс"

#: func.xml:1301(para)
msgid ""
"Another way to work with angles measured in degrees is to use the unit "
"transformation functions <literal><function>radians()</function></literal> "
"and <literal><function>degrees()</function></literal> shown earlier. "
"However, using the degree-based trigonometric functions is preferred, as "
"that way avoids roundoff error for special cases such as <literal>sind(30)</"
"literal>."
msgstr ""
"Также можно работать с углами в градусах, применяя вышеупомянутые функции "
"преобразования единиц <literal><function>radians()</function></literal> и "
"<literal><function>degrees()</function></literal>. Однако предпочтительнее "
"использовать тригонометрические функции с градусами, так как это позволяет "
"избежать ошибок округления в особых случаях, например, при вычислении "
"<literal>sind(30)</literal>."

#: func.xml:1315(title)
msgid "String Functions and Operators"
msgstr "Строковые функции и операторы"

#: func.xml:1317(para)
msgid ""
"This section describes functions and operators for examining and "
"manipulating string values. Strings in this context include values of the "
"types <type>character</type>, <type>character varying</type>, and "
"<type>text</type>. Unless otherwise noted, all of the functions listed below "
"work on all of these types, but be wary of potential effects of automatic "
"space-padding when using the <type>character</type> type. Some functions "
"also exist natively for the bit-string types."
msgstr ""
"В этом разделе описаны функции и операторы для работы с текстовыми строками. "
"Под строками в данном контексте подразумеваются значения типов "
"<type>character</type>, <type>character varying</type> и <type>text</type>. "
"Если не отмечено обратное, все нижеперечисленные функции работают со всеми "
"этими типами, хотя с типом <type>character</type> следует учитывать "
"возможные эффекты автоматического дополнения строк пробелами. Некоторые из "
"этих функций также поддерживают битовые строки."

#: func.xml:1328(para)
msgid ""
"<acronym>SQL</acronym> defines some string functions that use key words, "
"rather than commas, to separate arguments. Details are in <xref linkend="
"\"functions-string-sql\"/>. <productname>PostgreSQL</productname> also "
"provides versions of these functions that use the regular function "
"invocation syntax (see <xref linkend=\"functions-string-other\"/>)."
msgstr ""
"В <acronym>SQL</acronym> определены несколько строковых функций, в которых "
"аргументы разделяются не запятыми, а ключевыми словами. Они перечислены в "
"<xref remap=\"6\" linkend=\"functions-string-sql\"/>. "
"<productname>PostgreSQL</productname> также предоставляет варианты этих "
"функций с синтаксисом, обычным для функций (см. <xref remap=\"4\" linkend="
"\"functions-string-other\"/>)."

#: func.xml:1339(para)
msgid ""
"Before <productname>PostgreSQL</productname> 8.3, these functions would "
"silently accept values of several non-string data types as well, due to the "
"presence of implicit coercions from those data types to <type>text</type>. "
"Those coercions have been removed because they frequently caused surprising "
"behaviors. However, the string concatenation operator (<literal>||</"
"literal>) still accepts non-string input, so long as at least one input is "
"of a string type, as shown in <xref linkend=\"functions-string-sql\"/>. For "
"other cases, insert an explicit coercion to <type>text</type> if you need to "
"duplicate the previous behavior."
msgstr ""
"До версии 8.3 в <productname>PostgreSQL</productname> эти функции также "
"прозрачно принимали значения некоторых не строковых типов, неявно приводя "
"эти значения к типу <type>text</type>. Сейчас такие приведения исключены, "
"так как они часто приводили к неожиданным результатам. Однако оператор "
"конкатенации строк (<literal>||</literal>) по-прежнему принимает не только "
"строковые данные, если хотя бы один аргумент имеет строковый тип, как "
"показано в <xref remap=\"6\" linkend=\"functions-string-sql\"/>. Во всех "
"остальных случаях для повторения предыдущего поведения потребуется добавить "
"явное преобразование в <type>text</type>."

#: func.xml:1353(title)
msgid "<acronym>SQL</acronym> String Functions and Operators"
msgstr "Строковые функции и операторы языка <acronym>SQL</acronym>"

#: func.xml:1367(parameter) func.xml:1368(parameter) func.xml:1402(parameter)
#: func.xml:1439(parameter) func.xml:1452(parameter) func.xml:1465(parameter)
#: func.xml:1480(parameter) func.xml:1493(parameter) func.xml:1504(parameter)
#: func.xml:1516(parameter) func.xml:1534(parameter) func.xml:1550(parameter)
#: func.xml:1567(parameter) func.xml:1603(parameter) func.xml:1621(parameter)
#: func.xml:1693(parameter) func.xml:1717(parameter) func.xml:1735(parameter)
#: func.xml:1751(parameter) func.xml:1806(parameter) func.xml:1840(parameter)
#: func.xml:1851(parameter) func.xml:1868(parameter) func.xml:1890(parameter)
#: func.xml:1908(parameter) func.xml:1962(parameter) func.xml:1982(parameter)
#: func.xml:2014(parameter) func.xml:2045(parameter) func.xml:2062(parameter)
#: func.xml:2078(parameter) func.xml:2095(parameter) func.xml:2112(parameter)
#: func.xml:2126(parameter) func.xml:2175(parameter) func.xml:2196(parameter)
#: func.xml:2214(parameter) func.xml:2231(parameter) func.xml:2249(parameter)
#: func.xml:2265(parameter) func.xml:2299(parameter) func.xml:3390(parameter)
#: func.xml:3391(parameter) func.xml:3409(parameter) func.xml:3422(parameter)
#: func.xml:3437(parameter) func.xml:3450(parameter) func.xml:3467(parameter)
#: func.xml:3509(parameter) func.xml:3527(parameter) func.xml:3564(parameter)
#: func.xml:3579(parameter) func.xml:3594(parameter) func.xml:3618(parameter)
#: func.xml:3634(parameter) func.xml:3650(parameter)
msgctxt "parameter"
msgid "string"
msgstr "string"

#: func.xml:1367(literal) func.xml:3390(literal) func.xml:3715(literal)
#: func.xml:9208(literal) func.xml:9222(literal) func.xml:10759(literal)
#: func.xml:12059(literal) func.xml:12066(literal) func.xml:12073(literal)
#: func.xml:12080(literal)
msgid "||"
msgstr "||"

#: func.xml:1369(type) func.xml:1389(type) func.xml:1441(type)
#: func.xml:1467(type) func.xml:1495(type) func.xml:1505(type)
#: func.xml:1517(type) func.xml:1536(type) func.xml:1554(type)
#: func.xml:1569(type) func.xml:1621(type) func.xml:1622(type)
#: func.xml:1624(type) func.xml:1641(type) func.xml:1661(type)
#: func.xml:1675(type) func.xml:1679(type) func.xml:1720(type)
#: func.xml:1735(type) func.xml:1751(type) func.xml:1752(type)
#: func.xml:1769(type) func.xml:1771(type) func.xml:1788(type)
#: func.xml:1791(type) func.xml:1808(type) func.xml:1823(type)
#: func.xml:1826(type) func.xml:1868(type) func.xml:1870(type)
#: func.xml:1872(type) func.xml:1890(type) func.xml:1891(type)
#: func.xml:1893(type) func.xml:1910(type) func.xml:1924(type)
#: func.xml:1962(type) func.xml:1964(type) func.xml:1982(type)
#: func.xml:1984(type) func.xml:2000(type) func.xml:2014(type)
#: func.xml:2016(type) func.xml:2030(type) func.xml:2045(type)
#: func.xml:2062(type) func.xml:2064(type) func.xml:2078(type)
#: func.xml:2095(type) func.xml:2112(type) func.xml:2114(type)
#: func.xml:2126(type) func.xml:2127(type) func.xml:2128(type)
#: func.xml:2130(type) func.xml:2145(type) func.xml:2158(type)
#: func.xml:2161(type) func.xml:2175(type) func.xml:2177(type)
#: func.xml:2179(type) func.xml:2196(type) func.xml:2197(type)
#: func.xml:2199(type) func.xml:2214(type) func.xml:2215(type)
#: func.xml:2218(type) func.xml:2251(type) func.xml:2265(type)
#: func.xml:2266(type) func.xml:2268(type) func.xml:2286(type)
#: func.xml:2299(type) func.xml:2300(type) func.xml:2301(type)
#: func.xml:2303(type) func.xml:3527(type) func.xml:3528(type)
#: func.xml:3545(type) func.xml:3547(type) func.xml:3620(type)
#: func.xml:5698(type) func.xml:5700(type) func.xml:5705(type)
#: func.xml:5706(type) func.xml:5711(type) func.xml:5712(type)
#: func.xml:5718(type) func.xml:5719(type) func.xml:5724(type)
#: func.xml:5725(type) func.xml:5734(type) func.xml:5745(type)
#: func.xml:5756(type) func.xml:6875(type) func.xml:6886(type)
#: func.xml:6900(type) func.xml:6910(type) func.xml:7146(type)
#: func.xml:7197(type) func.xml:8937(type) func.xml:8944(type)
#: func.xml:8981(type) func.xml:9060(type) func.xml:9341(type)
#: func.xml:9353(type) func.xml:9368(type) func.xml:9415(type)
#: func.xml:9427(type) func.xml:9439(type) func.xml:9473(type)
#: func.xml:9475(type) func.xml:9518(type) func.xml:9590(type)
#: func.xml:9636(type) func.xml:9648(type) func.xml:9660(type)
#: func.xml:9668(type) func.xml:9679(type) func.xml:9687(type)
#: func.xml:9698(type) func.xml:10641(type) func.xml:10655(type)
#: func.xml:10739(type) func.xml:10766(type) func.xml:11141(type)
#: func.xml:11251(type) func.xml:11374(type) func.xml:12218(type)
#: func.xml:12321(type) func.xml:12324(type) func.xml:12355(type)
#: func.xml:15304(type) func.xml:15423(type) func.xml:16360(type)
#: func.xml:16365(type) func.xml:16370(type) func.xml:16375(type)
#: func.xml:16381(type) func.xml:16387(type) func.xml:16392(type)
#: func.xml:16397(type) func.xml:16402(type) func.xml:16407(type)
#: func.xml:16412(type) func.xml:16424(type) func.xml:16429(type)
#: func.xml:16434(type) func.xml:16440(type) func.xml:16445(type)
#: func.xml:16455(type) func.xml:16460(type) func.xml:16465(type)
#: func.xml:16470(type) func.xml:16475(type) func.xml:16492(type)
#: func.xml:16502(type) func.xml:16733(type) func.xml:16747(type)
#: func.xml:16842(type) func.xml:16847(type) func.xml:16852(type)
#: func.xml:16857(type) func.xml:17168(type) func.xml:17188(type)
#: func.xml:17456(type) func.xml:17468(type) func.xml:17705(type)
#: func.xml:17733(type) func.xml:17777(type) func.xml:18121(type)
#: func.xml:18328(type) func.xml:18344(type) func.xml:18360(type)
#: func.xml:18376(type) func.xml:18478(type) func.xml:18497(type)
#: func.xml:18515(type) func.xml:18534(type) func.xml:18633(type)
#: func.xml:18653(type) func.xml:18664(type) func.xml:18674(type)
#: func.xml:18866(type) func.xml:19004(type) func.xml:19013(type)
#: func.xml:19015(type) func.xml:19022(type) func.xml:19031(type)
#: func.xml:19503(type) func.xml:19508(type) func.xml:19513(type)
#: func.xml:19521(type) func.xml:19610(type) func.xml:19615(type)
#: func.xml:19623(type) func.xml:19632(type)
msgctxt "type"
msgid "text"
msgstr "text"

#: func.xml:1372(indexterm)
msgid ""
"<primary>character string</primary> <secondary>concatenation</secondary>"
msgstr ""
"<primary>символьная строка</primary> <secondary>конкатенация</secondary>"

#: func.xml:1370(entry) func.xml:3393(entry)
msgid "String concatenation <placeholder-1/>"
msgstr "Конкатенация строк <placeholder-1/>"

#: func.xml:1377(literal)
msgid "'Post' || 'greSQL'"
msgstr "'Post' || 'greSQL'"

#: func.xml:1378(literal)
msgid "PostgreSQL"
msgstr "PostgreSQL"

#: func.xml:1382(entry)
msgid ""
"<literal><parameter>string</parameter> <literal>||</literal> <parameter>non-"
"string</parameter></literal> or <literal><parameter>non-string</parameter> "
"<literal>||</literal> <parameter>string</parameter></literal>"
msgstr ""
"<literal><parameter>string</parameter> <literal>||</literal> <parameter>не "
"string</parameter></literal> или <literal><parameter>не string</parameter> "
"<literal>||</literal> <parameter>string</parameter></literal>"

#: func.xml:1390(entry)
msgid "String concatenation with one non-string input"
msgstr "Конкатенация строк с одним не строковым операндом"

#: func.xml:1393(literal)
msgid "'Value: ' || 42"
msgstr "'Value: ' || 42"

#: func.xml:1394(literal)
msgid "Value: 42"
msgstr "Value: 42"

#: func.xml:1399(indexterm)
msgid "<primary>bit_length</primary>"
msgstr "<primary>bit_length</primary>"

#: func.xml:1402(function)
msgid "bit_length(<placeholder-1/>)"
msgstr "bit_length(<placeholder-1/>)"

#: func.xml:1405(entry)
msgid "Number of bits in string"
msgstr "Число бит в строке"

#: func.xml:1406(literal)
msgid "bit_length('jose')"
msgstr "bit_length('jose')"

#: func.xml:1407(literal)
msgid "32"
msgstr "32"

#: func.xml:1412(indexterm)
msgid "<primary>char_length</primary>"
msgstr "<primary>char_length</primary>"

#: func.xml:1411(entry)
msgid ""
"<placeholder-1/> <literal><function>char_length(<parameter>string</"
"parameter>)</function></literal> or "
"<literal><function>character_length(<parameter>string</parameter>)</"
"function></literal>"
msgstr ""
"<placeholder-1/> <literal><function>char_length(<parameter>string</"
"parameter>)</function></literal> или "
"<literal><function>character_length(<parameter>string</parameter>)</"
"function></literal>"

#: func.xml:1420(indexterm)
msgid "<primary>character string</primary> <secondary>length</secondary>"
msgstr "<primary>строка символов</primary> <secondary>длина</secondary>"

#: func.xml:1424(indexterm)
msgid ""
"<primary>length</primary> <secondary sortas=\"character string\">of a "
"character string</secondary> <see>character string, length</see>"
msgstr ""
"<primary>длина</primary> <secondary sortas=\"символьная строка\">строки "
"символов</secondary> <see>строка символов, длина</see>"

#: func.xml:1418(entry)
msgid "Number of characters in string <placeholder-1/> <placeholder-2/>"
msgstr "Число символов в строке <placeholder-1/> <placeholder-2/>"

#: func.xml:1430(literal)
msgid "char_length('jose')"
msgstr "char_length('jose')"

#: func.xml:1431(literal) func.xml:1457(literal) func.xml:1847(literal)
#: func.xml:1860(literal) func.xml:12339(literal) func.xml:12350(literal)
msgctxt "literal"
msgid "4"
msgstr "4"

#: func.xml:1436(indexterm) func.xml:12633(indexterm)
msgid "<primary>lower</primary>"
msgstr "<primary>lower</primary>"

#: func.xml:1439(function)
msgid "lower(<placeholder-1/>)"
msgstr "lower(<placeholder-1/>)"

#: func.xml:1442(entry)
msgid "Convert string to lower case"
msgstr "Переводит символы строки в нижний регистр"

#: func.xml:1443(literal)
msgid "lower('TOM')"
msgstr "lower('TOM')"

#: func.xml:1444(literal)
msgid "tom"
msgstr "tom"

#: func.xml:1449(indexterm) func.xml:3406(indexterm)
msgid "<primary>octet_length</primary>"
msgstr "<primary>octet_length</primary>"

#: func.xml:1452(function) func.xml:3409(function)
msgid "octet_length(<placeholder-1/>)"
msgstr "octet_length(<placeholder-1/>)"

#: func.xml:1455(entry)
msgid "Number of bytes in string"
msgstr "Число байт в строке"

#: func.xml:1456(literal)
msgid "octet_length('jose')"
msgstr "octet_length('jose')"

#: func.xml:1462(indexterm) func.xml:3419(indexterm)
msgid "<primary>overlay</primary>"
msgstr "<primary>overlay</primary>"

#: func.xml:1465(optional) func.xml:1493(optional) func.xml:3422(optional)
#: func.xml:3450(optional)
msgid "for <placeholder-1/>"
msgstr "for <placeholder-1/>"

#: func.xml:1465(function) func.xml:3422(function)
msgid ""
"overlay(<placeholder-1/> placing <placeholder-2/> from <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"overlay(<placeholder-1/> placing <placeholder-2/> from <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:1468(entry) func.xml:3425(entry)
msgid "Replace substring"
msgstr "Заменяет подстроку"

#: func.xml:1471(literal)
msgid "overlay('Txxxxas' placing 'hom' from 2 for 4)"
msgstr "overlay('Txxxxas' placing 'hom' from 2 for 4)"

#: func.xml:1472(literal)
msgid "Thomas"
msgstr "Thomas"

#: func.xml:1477(indexterm) func.xml:3434(indexterm)
msgid "<primary>position</primary>"
msgstr "<primary>position</primary>"

#: func.xml:1480(parameter) func.xml:2231(parameter) func.xml:3437(parameter)
msgid "substring"
msgstr "substring"

#: func.xml:1480(function) func.xml:3437(function)
msgid "position(<placeholder-1/> in <placeholder-2/>)"
msgstr "position(<placeholder-1/> in <placeholder-2/>)"

#: func.xml:1483(entry) func.xml:3440(entry)
msgid "Location of specified substring"
msgstr "Положение указанной подстроки"

#: func.xml:1484(literal)
msgid "position('om' in 'Thomas')"
msgstr "position('om' in 'Thomas')"

#: func.xml:1490(indexterm) func.xml:3447(indexterm) func.xml:3964(indexterm)
#: func.xml:4110(indexterm)
msgid "<primary>substring</primary>"
msgstr "<primary>substring</primary>"

#: func.xml:1493(optional) func.xml:3450(optional)
msgid "from <placeholder-1/>"
msgstr "from <placeholder-1/>"

#: func.xml:1493(function) func.xml:3450(function)
msgid "substring(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "substring(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:1496(entry) func.xml:3453(entry)
msgid "Extract substring"
msgstr "Извлекает подстроку"

#: func.xml:1499(literal)
msgid "substring('Thomas' from 2 for 3)"
msgstr "substring('Thomas' from 2 for 3)"

#: func.xml:1500(literal)
msgid "hom"
msgstr "hom"

#: func.xml:1504(replaceable) func.xml:1516(replaceable)
#: func.xml:3868(replaceable) func.xml:3869(replaceable)
#: func.xml:3969(replaceable) func.xml:3970(replaceable)
msgctxt "replaceable"
msgid "pattern"
msgstr "шаблон"

#: func.xml:1504(function)
msgid "substring(<placeholder-1/> from <placeholder-2/>)"
msgstr "substring(<placeholder-1/> from <placeholder-2/>)"

#: func.xml:1506(entry)
msgid ""
"Extract substring matching POSIX regular expression. See <xref linkend="
"\"functions-matching\"/> for more information on pattern matching."
msgstr ""
"Извлекает подстроку, соответствующую регулярному выражению в стиле POSIX. "
"Подробно шаблоны описаны в <xref remap=\"6\" linkend=\"functions-matching\"/"
">."

#: func.xml:1511(literal)
msgid "substring('Thomas' from '...$')"
msgstr "substring('Thomas' from '...$')"

#: func.xml:1512(literal)
msgid "mas"
msgstr "mas"

#: func.xml:1516(replaceable)
msgid "escape"
msgstr "спецсимвол"

#: func.xml:1516(function)
msgid "substring(<placeholder-1/> from <placeholder-2/> for <placeholder-3/>)"
msgstr "substring(<placeholder-1/> from <placeholder-2/> for <placeholder-3/>)"

#: func.xml:1518(entry)
msgid ""
"Extract substring matching <acronym>SQL</acronym> regular expression. See "
"<xref linkend=\"functions-matching\"/> for more information on pattern "
"matching."
msgstr ""
"Извлекает подстроку, соответствующую регулярному выражению в стиле "
"<acronym>SQL</acronym>. Подробно шаблоны описаны в <xref remap=\"6\" linkend="
"\"functions-matching\"/>."

#: func.xml:1523(literal)
msgid "substring('Thomas' from '%#\"o_a#\"_' for '#')"
msgstr "substring('Thomas' from '%#\"o_a#\"_' for '#')"

#: func.xml:1524(literal)
msgid "oma"
msgstr "oma"

#: func.xml:1529(indexterm) func.xml:3462(indexterm)
msgid "<primary>trim</primary>"
msgstr "<primary>trim</primary>"

#: func.xml:1532(optional) func.xml:1548(optional)
msgid "leading | trailing | both"
msgstr "leading | trailing | both"

#: func.xml:1533(parameter) func.xml:1622(parameter) func.xml:1891(parameter)
#: func.xml:2197(parameter)
msgid "characters"
msgstr "characters"

#: func.xml:1532(function)
msgid ""
"trim(<placeholder-1/> <optional><placeholder-2/></optional> from "
"<placeholder-3/>)"
msgstr ""
"trim(<placeholder-1/> <optional><placeholder-2/></optional> from "
"<placeholder-3/>)"

#: func.xml:1537(entry)
msgid ""
"Remove the longest string containing only the <parameter>characters</"
"parameter> (a space by default) from the start/end/both ends of the "
"<parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, содержащую только символы "
"<parameter>characters</parameter> (по умолчанию пробелы), с начала, с конца "
"или с обеих сторон строки <parameter>string</parameter>"

#: func.xml:1542(literal)
msgid "trim(both 'x' from 'xTomxx')"
msgstr "trim(both 'x' from 'xTomxx')"

#: func.xml:1543(literal) func.xml:1559(literal) func.xml:3476(literal)
msgid "Tom"
msgstr "Tom"

#: func.xml:1549(optional)
msgctxt "optional"
msgid "from"
msgstr "from"

#: func.xml:1551(parameter)
msgid ", characters"
msgstr ", characters"

#: func.xml:1548(function)
msgid ""
"trim(<placeholder-1/> <placeholder-2/> <placeholder-3/> "
"<optional><placeholder-4/></optional> )"
msgstr ""
"trim(<placeholder-1/> <placeholder-2/> <placeholder-3/> "
"<optional><placeholder-4/></optional> )"

#: func.xml:1555(entry)
msgid "Non-standard version of <function>trim()</function>"
msgstr "Нестандартная версия <function>trim()</function>"

#: func.xml:1558(literal)
msgid "trim(both from 'xTomxx', 'x')"
msgstr "trim(both from 'xTomxx', 'x')"

#: func.xml:1564(indexterm) func.xml:12636(indexterm)
msgid "<primary>upper</primary>"
msgstr "<primary>upper</primary>"

#: func.xml:1567(function)
msgid "upper(<placeholder-1/>)"
msgstr "upper(<placeholder-1/>)"

#: func.xml:1570(entry)
msgid "Convert string to upper case"
msgstr "Переводит символы строки в верхний регистр"

#: func.xml:1571(literal)
msgid "upper('tom')"
msgstr "upper('tom')"

#: func.xml:1572(literal)
msgid "TOM"
msgstr "TOM"

#: func.xml:1578(para)
msgid ""
"Additional string manipulation functions are available and are listed in "
"<xref linkend=\"functions-string-other\"/>. Some of them are used internally "
"to implement the <acronym>SQL</acronym>-standard string functions listed in "
"<xref linkend=\"functions-string-sql\"/>."
msgstr ""
"Кроме этого, в <productname>PostgreSQL</productname> есть и другие функции "
"для работы со строками, перечисленные в <xref remap=\"6\" linkend="
"\"functions-string-other\"/>. Некоторые из них используются в качестве "
"внутренней реализации стандартных строковых функций <acronym>SQL</acronym>, "
"приведённых в <xref remap=\"6\" linkend=\"functions-string-sql\"/>."

#: func.xml:1585(title)
msgid "Other String Functions"
msgstr "Другие строковые функции"

#: func.xml:1600(indexterm)
msgid "<primary>ascii</primary>"
msgstr "<primary>ascii</primary>"

#: func.xml:1603(function)
msgid "ascii(<placeholder-1/>)"
msgstr "ascii(<placeholder-1/>)"

#: func.xml:1606(entry)
msgid ""
"<acronym>ASCII</acronym> code of the first character of the argument. For "
"<acronym>UTF8</acronym> returns the Unicode code point of the character. For "
"other multibyte encodings, the argument must be an <acronym>ASCII</acronym> "
"character."
msgstr ""
"Возвращает <acronym>ASCII</acronym>-код первого символа аргумента. Для "
"<acronym>UTF8</acronym> возвращает код символа в Unicode. Для других "
"многобайтных кодировок аргумент должен быть <acronym>ASCII</acronym>-"
"символом."

#: func.xml:1612(literal)
msgid "ascii('x')"
msgstr "ascii('x')"

#: func.xml:1618(indexterm) func.xml:3506(indexterm)
msgid "<primary>btrim</primary>"
msgstr "<primary>btrim</primary>"

#: func.xml:1622(optional) func.xml:1870(optional) func.xml:1891(optional)
#: func.xml:2177(optional) func.xml:2197(optional) func.xml:2266(optional)
#: func.xml:9473(optional) func.xml:9485(optional) func.xml:9497(optional)
#: func.xml:11316(optional) func.xml:17733(optional) func.xml:18190(optional)
msgid ", <placeholder-1/> <placeholder-2/>"
msgstr ", <placeholder-1/> <placeholder-2/>"

#: func.xml:1621(function)
msgid "btrim(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "btrim(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:1625(entry)
msgid ""
"Remove the longest string consisting only of characters in "
"<parameter>characters</parameter> (a space by default) from the start and "
"end of <parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, состоящую только из символов "
"<parameter>characters</parameter> (по умолчанию пробелов), с начала и с "
"конца строки <parameter>string</parameter>"

#: func.xml:1630(literal)
msgid "btrim('xyxtrimyyx', 'xy')"
msgstr "btrim('xyxtrimyyx', 'xy')"

#: func.xml:1631(literal) func.xml:1900(literal) func.xml:2206(literal)
#: func.xml:3519(literal)
msgid "trim"
msgstr "trim"

#: func.xml:1636(indexterm)
msgid "<primary>chr</primary>"
msgstr "<primary>chr</primary>"

#: func.xml:1639(function)
msgid "chr(<placeholder-1/>)"
msgstr "chr(<placeholder-1/>)"

#: func.xml:1642(entry)
msgid ""
"Character with the given code. For <acronym>UTF8</acronym> the argument is "
"treated as a Unicode code point. For other multibyte encodings the argument "
"must designate an <acronym>ASCII</acronym> character. The NULL (0) character "
"is not allowed because text data types cannot store such bytes."
msgstr ""
"Возвращает символ с данным кодом. Для <acronym>UTF8</acronym> аргумент "
"воспринимается как код символа Unicode, а для других кодировок он должен "
"указывать на <acronym>ASCII</acronym>-символ. Код 0 (NULL) не допускается, "
"так как байты с нулевым кодом в текстовых строках сохранить нельзя."

#: func.xml:1649(literal)
msgid "chr(65)"
msgstr "chr(65)"

#: func.xml:1650(literal)
msgid "A"
msgstr "A"

#: func.xml:1655(indexterm)
msgid "<primary>concat</primary>"
msgstr "<primary>concat</primary>"

#: func.xml:1658(parameter) func.xml:1659(parameter) func.xml:1676(parameter)
#: func.xml:1677(parameter) func.xml:1823(parameter) func.xml:2143(parameter)
#: func.xml:2158(parameter)
msgid "str"
msgstr "str"

#: func.xml:1658(type) func.xml:1659(type) func.xml:1676(type)
#: func.xml:1677(type) func.xml:1789(type) func.xml:13845(type)
#: func.xml:13848(type) func.xml:13868(type) func.xml:13871(type)
#: func.xml:13891(type) func.xml:13894(type) func.xml:13914(type)
#: func.xml:13917(type)
msgid "\"any\""
msgstr "\"any\""

#: func.xml:1658(function)
msgid ""
"concat(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/"
"> [, ...] ])"
msgstr ""
"concat(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/"
"> [, ...] ])"

#: func.xml:1662(entry)
msgid ""
"Concatenate the text representations of all the arguments. NULL arguments "
"are ignored."
msgstr "Соединяет текстовые представления всех аргументов, игнорируя NULL."

#: func.xml:1666(literal)
msgid "concat('abcde', 2, NULL, 22)"
msgstr "concat('abcde', 2, NULL, 22)"

#: func.xml:1667(literal)
msgid "abcde222"
msgstr "abcde222"

#: func.xml:1672(indexterm)
msgid "<primary>concat_ws</primary>"
msgstr "<primary>concat_ws</primary>"

#: func.xml:1675(parameter)
msgid "sep"
msgstr "sep"

#: func.xml:1675(function)
msgid ""
"concat_ws(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
"> [, <placeholder-5/> <placeholder-6/> [, ...] ])"
msgstr ""
"concat_ws(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
"> [, <placeholder-5/> <placeholder-6/> [, ...] ])"

#: func.xml:1680(entry)
msgid ""
"Concatenate all but the first argument with separators. The first argument "
"is used as the separator string. NULL arguments are ignored."
msgstr ""
"Соединяет все аргументы, кроме первого, через разделитель, игнорируя "
"аргументы NULL. Разделитель указывается в первом аргументе."

#: func.xml:1684(literal)
msgid "concat_ws(',', 'abcde', 2, NULL, 22)"
msgstr "concat_ws(',', 'abcde', 2, NULL, 22)"

#: func.xml:1685(literal)
msgid "abcde,2,22"
msgstr "abcde,2,22"

#: func.xml:1690(indexterm)
msgid "<primary>convert</primary>"
msgstr "<primary>convert</primary>"

#: func.xml:1693(type) func.xml:1697(type) func.xml:1717(type)
#: func.xml:1738(type) func.xml:1754(type) func.xml:1768(type)
#: func.xml:1851(type) func.xml:3392(type) func.xml:3424(type)
#: func.xml:3452(type) func.xml:3469(type) func.xml:3510(type)
#: func.xml:3512(type) func.xml:3530(type) func.xml:3544(type)
#: func.xml:3637(type) func.xml:3653(type) func.xml:18534(type)
#: func.xml:19024(type)
msgid "bytea"
msgstr "bytea"

#: func.xml:1694(parameter) func.xml:1718(parameter)
msgid "src_encoding"
msgstr "src_encoding"

#: func.xml:1694(type) func.xml:1695(type) func.xml:1718(type)
#: func.xml:1736(type) func.xml:1852(type) func.xml:1949(type)
#: func.xml:15292(type) func.xml:15298(type) func.xml:15311(type)
#: func.xml:15323(type) func.xml:15411(type) func.xml:15417(type)
#: func.xml:16450(type) func.xml:18190(type) func.xml:18213(type)
#: func.xml:18230(type) func.xml:18249(type) func.xml:18274(type)
#: func.xml:18292(type) func.xml:18309(type) func.xml:18617(type)
#: func.xml:18699(type)
msgctxt "type"
msgid "name"
msgstr "name"

#: func.xml:1695(parameter) func.xml:1736(parameter)
msgid "dest_encoding"
msgstr "dest_encoding"

#: func.xml:1693(function)
msgid ""
"convert(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"convert(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#: func.xml:1698(entry)
msgid ""
"Convert string to <parameter>dest_encoding</parameter>. The original "
"encoding is specified by <parameter>src_encoding</parameter>. The "
"<parameter>string</parameter> must be valid in this encoding. Conversions "
"can be defined by <command>CREATE CONVERSION</command>. Also there are some "
"predefined conversions. See <xref linkend=\"conversion-names\"/> for "
"available conversions."
msgstr ""
"Преобразует строку <parameter>string</parameter> из кодировки "
"<parameter>src_encoding</parameter> в <parameter>dest_encoding</parameter>. "
"Переданная строка должна быть допустимой для исходной кодировки. "
"Преобразования могут быть определены с помощью <command>CREATE CONVERSION</"
"command>. Все встроенные преобразования перечислены в <xref remap=\"6\" "
"linkend=\"conversion-names\"/>."

#: func.xml:1707(literal)
msgid "convert('text_in_utf8', 'UTF8', 'LATIN1')"
msgstr "convert('text_in_utf8'&zwsp;, 'UTF8', 'LATIN1')"

#: func.xml:1708(entry)
msgid ""
"<literal>text_in_utf8</literal> represented in Latin-1 encoding (ISO 8859-1)"
msgstr ""
"строка <literal>text_in_utf8</literal>, представленная в кодировке Latin-1 "
"(ISO 8859-1)"

#: func.xml:1714(indexterm)
msgid "<primary>convert_from</primary>"
msgstr "<primary>convert_from</primary>"

#: func.xml:1717(function)
msgid ""
"convert_from(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"convert_from(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:1721(entry)
msgid ""
"Convert string to the database encoding. The original encoding is specified "
"by <parameter>src_encoding</parameter>. The <parameter>string</parameter> "
"must be valid in this encoding."
msgstr ""
"Преобразует строку <parameter>string</parameter> из кодировки "
"<parameter>src_encoding</parameter> в кодировку базы данных. Переданная "
"строка должна быть допустимой для исходной кодировки."

#: func.xml:1726(literal)
msgid "convert_from('text_in_utf8', 'UTF8')"
msgstr "convert_from('text_in_utf8'&zwsp;, 'UTF8')"

#: func.xml:1727(entry)
msgid ""
"<literal>text_in_utf8</literal> represented in the current database encoding"
msgstr ""
"строка <literal>text_in_utf8</literal>, представленная в кодировке текущей "
"базы данных"

#: func.xml:1732(indexterm)
msgid "<primary>convert_to</primary>"
msgstr "<primary>convert_to</primary>"

#: func.xml:1735(function)
msgid ""
"convert_to(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"convert_to(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:1739(entry)
msgid "Convert string to <parameter>dest_encoding</parameter>."
msgstr "Преобразует строку в кодировку <parameter>dest_encoding</parameter>."

#: func.xml:1742(literal)
msgid "convert_to('some text', 'UTF8')"
msgstr "convert_to('некоторый текст', 'UTF8')"

#: func.xml:1743(entry)
msgid "<literal>some text</literal> represented in the UTF8 encoding"
msgstr "<literal>некоторый текст</literal>, представленный в кодировке UTF8"

#: func.xml:1748(indexterm) func.xml:3524(indexterm)
msgid "<primary>decode</primary>"
msgstr "<primary>decode</primary>"

#: func.xml:1752(parameter) func.xml:1769(parameter) func.xml:3528(parameter)
#: func.xml:3545(parameter)
msgctxt "parameter"
msgid "format"
msgstr "format"

#: func.xml:1751(function) func.xml:3527(function)
msgid ""
"decode(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"decode(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:1755(entry) func.xml:3531(entry)
msgid ""
"Decode binary data from textual representation in <parameter>string</"
"parameter>. Options for <parameter>format</parameter> are same as in "
"<function>encode</function>."
msgstr ""
"Получает двоичные данные из текстового представления в <parameter>string</"
"parameter>. Значения параметра <parameter>format</parameter> те же, что и "
"для функции <function>encode</function>."

#: func.xml:1759(literal)
msgid "decode('MTIzAAE=', 'base64')"
msgstr "decode('MTIzAAE=', 'base64')"

#: func.xml:1760(literal)
msgid "\\x3132330001"
msgstr "\\x3132330001"

#: func.xml:1765(indexterm) func.xml:3541(indexterm)
msgid "<primary>encode</primary>"
msgstr "<primary>encode</primary>"

#: func.xml:1768(parameter) func.xml:3544(parameter)
msgid "data"
msgstr "data"

#: func.xml:1768(function) func.xml:3544(function)
msgid ""
"encode(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"encode(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:1772(entry) func.xml:3548(entry)
msgid ""
"Encode binary data into a textual representation. Supported formats are: "
"<literal>base64</literal>, <literal>hex</literal>, <literal>escape</"
"literal>. <literal>escape</literal> converts zero bytes and high-bit-set "
"bytes to octal sequences (<literal>\\</literal><replaceable>nnn</"
"replaceable>) and doubles backslashes."
msgstr ""
"Переводит двоичные данные в текстовое представление в одном из форматов: "
"<literal>base64</literal>, <literal>hex</literal>, <literal>escape</"
"literal>. Формат <literal>escape</literal> преобразует нулевые байты и байты "
"с 1 в старшем бите в восьмеричные последовательности <literal>\\nnn</"
"literal> и дублирует обратную косую черту."

#: func.xml:1779(literal)
msgid "encode(E'123\\\\000\\\\001', 'base64')"
msgstr "encode(E'123&zwsp;\\\\000&zwsp;\\\\001', 'base64')"

#: func.xml:1780(literal)
msgid "MTIzAAE="
msgstr "MTIzAAE="

#: func.xml:1785(indexterm) func.xml:3135(indexterm)
msgid "<primary>format</primary>"
msgstr "<primary>format</primary>"

#: func.xml:1788(function) func.xml:3133(function)
msgctxt "function"
msgid "format"
msgstr "format"

#: func.xml:1788(parameter)
msgid "formatstr"
msgstr "formatstr"

#: func.xml:1789(parameter)
msgid "formatarg"
msgstr "formatarg"

#: func.xml:1788(literal)
msgid ""
"<placeholder-1/>(<placeholder-2/> <placeholder-3/> [, <placeholder-4/> "
"<placeholder-5/> [, ...] ])"
msgstr ""
"<placeholder-1/>(<placeholder-2/> <placeholder-3/> [, <placeholder-4/> "
"<placeholder-5/> [, ...] ])"

#: func.xml:1792(entry)
msgid ""
"Format arguments according to a format string. This function is similar to "
"the C function <function>sprintf</function>. See <xref linkend=\"functions-"
"string-format\"/>."
msgstr ""
"Форматирует аргумент в соответствии со строкой формата. Эта функция работает "
"подобно <function>sprintf</function> в языке C. См. <xref remap=\"4\" "
"linkend=\"functions-string-format\"/>."

#: func.xml:1797(literal)
msgid "format('Hello %s, %1$s', 'World')"
msgstr "format('Hello %s, %1$s', 'World')"

#: func.xml:1798(literal)
msgid "Hello World, World"
msgstr "Hello World, World"

#: func.xml:1803(indexterm)
msgid "<primary>initcap</primary>"
msgstr "<primary>initcap</primary>"

#: func.xml:1806(function)
msgid "initcap(<placeholder-1/>)"
msgstr "initcap(<placeholder-1/>)"

#: func.xml:1809(entry)
msgid ""
"Convert the first letter of each word to upper case and the rest to lower "
"case. Words are sequences of alphanumeric characters separated by non-"
"alphanumeric characters."
msgstr ""
"Переводит первую букву каждого слова в строке в верхний регистр, а остальные "
"&mdash; в нижний. Словами считаются последовательности алфавитно-цифровых "
"символов, разделённые любыми другими символами."

#: func.xml:1814(literal)
msgid "initcap('hi THOMAS')"
msgstr "initcap('hi THOMAS')"

#: func.xml:1815(literal)
msgid "Hi Thomas"
msgstr "Hi Thomas"

#: func.xml:1820(indexterm)
msgid "<primary>left</primary>"
msgstr "<primary>left</primary>"

#: func.xml:1824(parameter) func.xml:2159(parameter)
msgctxt "parameter"
msgid "n"
msgstr "n"

#: func.xml:1823(function)
msgid ""
"left(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"left(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:1827(entry)
msgid ""
"Return first <replaceable>n</replaceable> characters in the string. When "
"<replaceable>n</replaceable> is negative, return all but last |"
"<replaceable>n</replaceable>| characters."
msgstr ""
"Возвращает первые <replaceable>n</replaceable> символов в строке. Когда "
"<replaceable>n</replaceable> меньше нуля, возвращаются все символы слева, "
"кроме последних |<replaceable>n</replaceable>|."

#: func.xml:1831(literal)
msgid "left('abcde', 2)"
msgstr "left('abcde', 2)"

#: func.xml:1832(literal)
msgid "ab"
msgstr "ab"

#: func.xml:1837(indexterm) func.xml:3591(indexterm) func.xml:8469(indexterm)
#: func.xml:9314(indexterm)
msgid "<primary>length</primary>"
msgstr "<primary>length</primary>"

#: func.xml:1840(function) func.xml:3594(function) func.xml:8537(function)
#: func.xml:9317(function)
msgid "length(<placeholder-1/>)"
msgstr "length(<placeholder-1/>)"

#: func.xml:1843(entry)
msgid "Number of characters in <parameter>string</parameter>"
msgstr "Число символов в строке <parameter>string</parameter>"

#: func.xml:1846(literal)
msgid "length('jose')"
msgstr "length('jose')"

#: func.xml:1852(parameter) func.xml:2266(parameter)
msgid "encoding"
msgstr "encoding"

#: func.xml:1851(function)
msgid ""
"length(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> )"
msgstr ""
"length(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> )"

#: func.xml:1854(entry)
msgid ""
"Number of characters in <parameter>string</parameter> in the given "
"<parameter>encoding</parameter>. The <parameter>string</parameter> must be "
"valid in this encoding."
msgstr ""
"Число символов, которые содержит строка <parameter>string</parameter> в "
"заданной кодировке <parameter>encoding</parameter>. Переданная строка должна "
"быть допустимой в этой кодировке."

#: func.xml:1859(literal)
msgid "length('jose', 'UTF8')"
msgstr "length('jose', 'UTF8')"

#: func.xml:1865(indexterm)
msgid "<primary>lpad</primary>"
msgstr "<primary>lpad</primary>"

#: func.xml:1869(parameter) func.xml:2176(parameter) func.xml:19013(parameter)
#: func.xml:19022(parameter)
msgctxt "parameter"
msgid "length"
msgstr "length"

#: func.xml:1870(parameter) func.xml:2177(parameter)
msgid "fill"
msgstr "fill"

#: func.xml:1868(function)
msgid ""
"lpad(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> "
"<placeholder-5/>)"
msgstr ""
"lpad(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> "
"<placeholder-5/>)"

#: func.xml:1873(entry)
msgid ""
"Fill up the <parameter>string</parameter> to length <parameter>length</"
"parameter> by prepending the characters <parameter>fill</parameter> (a space "
"by default). If the <parameter>string</parameter> is already longer than "
"<parameter>length</parameter> then it is truncated (on the right)."
msgstr ""
"Дополняет строку <parameter>string</parameter> слева до длины "
"<parameter>length</parameter> символами <parameter>fill</parameter> (по "
"умолчанию пробелами). Если длина строки уже больше заданной, она обрезается "
"справа."

#: func.xml:1881(literal)
msgid "lpad('hi', 5, 'xy')"
msgstr "lpad('hi', 5, 'xy')"

#: func.xml:1882(literal)
msgid "xyxhi"
msgstr "xyxhi"

#: func.xml:1887(indexterm)
msgid "<primary>ltrim</primary>"
msgstr "<primary>ltrim</primary>"

#: func.xml:1890(function)
msgid "ltrim(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "ltrim(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:1894(entry)
msgid ""
"Remove the longest string containing only characters from "
"<parameter>characters</parameter> (a space by default) from the start of "
"<parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, содержащую только символы "
"<parameter>characters</parameter> (по умолчанию пробелы), с начала строки "
"<parameter>string</parameter>"

#: func.xml:1899(literal)
msgid "ltrim('zzzytrim', 'xyz')"
msgstr "ltrim('zzzytrim', 'xyz')"

#: func.xml:1905(indexterm) func.xml:3615(indexterm)
msgid "<primary>md5</primary>"
msgstr "<primary>md5</primary>"

#: func.xml:1908(function) func.xml:3618(function)
msgid "md5(<placeholder-1/>)"
msgstr "md5(<placeholder-1/>)"

#: func.xml:1911(entry) func.xml:3621(entry)
msgid ""
"Calculates the MD5 hash of <parameter>string</parameter>, returning the "
"result in hexadecimal"
msgstr ""
"Вычисляет MD5-хеш строки <parameter>string</parameter> и возвращает "
"результат в 16-ричном виде"

#: func.xml:1915(literal)
msgid "md5('abc')"
msgstr "md5('abc')"

#: func.xml:1916(literal)
msgid "900150983cd24fb0 d6963f7d28e17f72"
msgstr "90015098&zwsp;3cd24fb0 d6963f7d&zwsp;28e17f72"

#: func.xml:1921(indexterm)
msgid "<primary>parse_ident</primary>"
msgstr "<primary>parse_ident</primary>"

#: func.xml:1924(parameter)
msgid "qualified_identifier"
msgstr "qualified_identifier"

#: func.xml:1925(parameter)
msgid "strictmode"
msgstr "strictmode"

#: func.xml:1925(type) func.xml:6950(type) func.xml:6958(type)
#: func.xml:6966(type) func.xml:8526(type) func.xml:8532(type)
#: func.xml:9072(type) func.xml:9195(type) func.xml:9202(type)
#: func.xml:9244(type) func.xml:9251(type) func.xml:11316(type)
#: func.xml:11341(type) func.xml:11535(type) func.xml:12696(type)
#: func.xml:12707(type) func.xml:12718(type) func.xml:12729(type)
#: func.xml:12740(type) func.xml:15316(type) func.xml:15380(type)
#: func.xml:15676(type) func.xml:15683(type) func.xml:15692(type)
#: func.xml:15700(type) func.xml:15708(type) func.xml:15715(type)
#: func.xml:15723(type) func.xml:15730(type) func.xml:15738(type)
#: func.xml:15745(type) func.xml:15753(type) func.xml:15760(type)
#: func.xml:15768(type) func.xml:15775(type) func.xml:15783(type)
#: func.xml:15790(type) func.xml:15798(type) func.xml:15805(type)
#: func.xml:15813(type) func.xml:15820(type) func.xml:15828(type)
#: func.xml:15835(type) func.xml:15843(type) func.xml:15850(type)
#: func.xml:15856(type) func.xml:16102(type) func.xml:16108(type)
#: func.xml:16114(type) func.xml:16120(type) func.xml:16126(type)
#: func.xml:16132(type) func.xml:16138(type) func.xml:16144(type)
#: func.xml:16150(type) func.xml:16156(type) func.xml:16162(type)
#: func.xml:16168(type) func.xml:16957(type) func.xml:17183(type)
#: func.xml:17355(type) func.xml:17360(type) func.xml:17365(type)
#: func.xml:17416(type) func.xml:17572(type) func.xml:17583(type)
#: func.xml:17590(type) func.xml:17597(type) func.xml:17733(type)
#: func.xml:17747(type) func.xml:18190(type) func.xml:19004(type)
#: func.xml:19013(type) func.xml:19022(type) func.xml:19031(type)
#: func.xml:19158(type) func.xml:19165(type) func.xml:19179(type)
#: func.xml:19186(type) func.xml:19221(type) func.xml:19228(type)
#: func.xml:19235(type) func.xml:19242(type) func.xml:19249(type)
#: func.xml:19256(type) func.xml:19263(type) func.xml:19270(type)
msgid "boolean"
msgstr "boolean"

#: func.xml:1924(function)
msgid ""
"parse_ident(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/> DEFAULT true ] )"
msgstr ""
"parse_ident(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/> DEFAULT true ] )"

#: func.xml:1927(type) func.xml:2080(type) func.xml:9293(type)
#: func.xml:9391(type) func.xml:9449(type) func.xml:9555(type)
#: func.xml:9636(type) func.xml:9650(type) func.xml:10662(type)
#: func.xml:10669(type) func.xml:10746(type) func.xml:10753(type)
#: func.xml:10782(type) func.xml:12358(type) func.xml:16747(type)
#: func.xml:18249(type) func.xml:18274(type) func.xml:18292(type)
#: func.xml:18309(type) func.xml:19640(type) func.xml:19651(type)
msgid "text[]"
msgstr "text[]"

#: func.xml:1928(entry)
msgid ""
"Split <parameter>qualified_identifier</parameter> into an array of "
"identifiers, removing any quoting of individual identifiers. By default, "
"extra characters after the last identifier are considered an error; but if "
"the second parameter is <literal>false</literal>, then such extra characters "
"are ignored. (This behavior is useful for parsing names for objects like "
"functions.) Note that this function does not truncate over-length "
"identifiers. If you want truncation you can cast the result to <type>name[]</"
"type>."
msgstr ""
"Раскладывает полный идентификатор, задаваемый параметром "
"<parameter>qualified_identifier</parameter>, на массив идентификаторов, "
"удаляя кавычки, обрамляющие отдельные идентификаторы. По умолчанию лишние "
"символы после последнего идентификатора вызывают ошибку, но если отключить "
"строгий режим (передать во втором параметре <literal>false</literal>), такие "
"символы игнорируются. (Это поведение полезно для разбора имён таких "
"объектов, как функции.) Заметьте, что эта функция не усекает чрезмерно "
"длинные идентификаторы. Если вы хотите получить усечённые имена, можно "
"привести результат к <type>name[]</type>."

#: func.xml:1938(literal)
msgid "parse_ident('\"SomeSchema\".someTable')"
msgstr "parse_ident('\"SomeSchema\".someTable')"

#: func.xml:1939(literal)
msgid "{SomeSchema,sometable}"
msgstr "{SomeSchema,sometable}"

#: func.xml:1944(indexterm)
msgid "<primary>pg_client_encoding</primary>"
msgstr "<primary>pg_client_encoding</primary>"

#: func.xml:1947(function)
msgctxt "function"
msgid "pg_client_encoding()"
msgstr "pg_client_encoding()"

#: func.xml:1950(entry)
msgid "Current client encoding name"
msgstr "Возвращает имя текущей клиентской кодировки"

#: func.xml:1953(literal)
msgctxt "literal"
msgid "pg_client_encoding()"
msgstr "pg_client_encoding()"

#: func.xml:1954(literal) func.xml:2362(literal) func.xml:2368(literal)
#: func.xml:2645(literal) func.xml:2771(literal)
msgid "SQL_ASCII"
msgstr "SQL_ASCII"

#: func.xml:1959(indexterm)
msgid "<primary>quote_ident</primary>"
msgstr "<primary>quote_ident</primary>"

#: func.xml:1962(function)
msgid "quote_ident(<placeholder-1/> <placeholder-2/>)"
msgstr "quote_ident(<placeholder-1/> <placeholder-2/>)"

#: func.xml:1965(entry)
msgid ""
"Return the given string suitably quoted to be used as an identifier in an "
"<acronym>SQL</acronym> statement string. Quotes are added only if necessary "
"(i.e., if the string contains non-identifier characters or would be case-"
"folded). Embedded quotes are properly doubled. See also <xref linkend="
"\"plpgsql-quote-literal-example\"/>."
msgstr ""
"Переданная строка оформляется для использования в качестве идентификатора в "
"<acronym>SQL</acronym> -операторе. При необходимости идентификатор "
"заключается в кавычки (например, если он содержит символы, недопустимые в "
"открытом виде, или буквы в разном регистре). Если переданная строка содержит "
"кавычки, они дублируются. См. также <xref remap=\"4\" linkend=\"plpgsql-"
"quote-literal-example\"/>."

#: func.xml:1973(literal)
msgid "quote_ident('Foo bar')"
msgstr "quote_ident('Foo bar')"

#: func.xml:1974(literal)
msgid "\"Foo bar\""
msgstr "\"Foo bar\""

#: func.xml:1979(indexterm)
msgid "<primary>quote_literal</primary>"
msgstr "<primary>quote_literal</primary>"

#: func.xml:1982(function) func.xml:1999(function)
msgid "quote_literal(<placeholder-1/> <placeholder-2/>)"
msgstr "quote_literal(<placeholder-1/> <placeholder-2/>)"

#: func.xml:1985(entry)
msgid ""
"Return the given string suitably quoted to be used as a string literal in an "
"<acronym>SQL</acronym> statement string. Embedded single-quotes and "
"backslashes are properly doubled. Note that <function>quote_literal</"
"function> returns null on null input; if the argument might be null, "
"<function>quote_nullable</function> is often more suitable. See also <xref "
"linkend=\"plpgsql-quote-literal-example\"/>."
msgstr ""
"Переданная строка оформляется для использования в качестве текстовой строки "
"в <acronym>SQL</acronym>-операторе. Включённые символы апостроф и обратная "
"косая черта при этом дублируются. Заметьте, что <function>quote_literal</"
"function> возвращает NULL, когда на вход ей передаётся строка NULL; если же "
"нужно получить представление и такого аргумента, лучше использовать "
"<function>quote_nullable</function>. См. также <xref remap=\"4\" linkend="
"\"plpgsql-quote-literal-example\"/>."

#: func.xml:1994(literal)
msgid "quote_literal(E'O\\'Reilly')"
msgstr "quote_literal(E'O\\'Reilly')"

#: func.xml:1995(literal)
msgid "'O''Reilly'"
msgstr "'O''Reilly'"

#: func.xml:1999(parameter) func.xml:2029(parameter)
msgctxt "parameter"
msgid "value"
msgstr "value"

#: func.xml:2001(entry)
msgid ""
"Coerce the given value to text and then quote it as a literal. Embedded "
"single-quotes and backslashes are properly doubled."
msgstr ""
"Переводит данное значение в текстовый вид и заключает в апострофы как "
"текстовую строку. Символы апостроф и обратная косая черта при этом "
"дублируются."

#: func.xml:2005(literal)
msgid "quote_literal(42.5)"
msgstr "quote_literal(42.5)"

#: func.xml:2006(literal) func.xml:2037(literal)
msgid "'42.5'"
msgstr "'42.5'"

#: func.xml:2011(indexterm)
msgid "<primary>quote_nullable</primary>"
msgstr "<primary>quote_nullable</primary>"

#: func.xml:2014(function) func.xml:2029(function)
msgid "quote_nullable(<placeholder-1/> <placeholder-2/>)"
msgstr "quote_nullable(<placeholder-1/> <placeholder-2/>)"

#: func.xml:2017(entry)
msgid ""
"Return the given string suitably quoted to be used as a string literal in an "
"<acronym>SQL</acronym> statement string; or, if the argument is null, return "
"<literal>NULL</literal>. Embedded single-quotes and backslashes are properly "
"doubled. See also <xref linkend=\"plpgsql-quote-literal-example\"/>."
msgstr ""
"Переданная строка оформляется для использования в качестве текстовой строки "
"в <acronym>SQL</acronym>-операторе; при этом для аргумента NULL возвращается "
"строка <literal>NULL</literal>. Символы апостроф и обратная косая черта "
"дублируются должным образом. См. также <xref remap=\"4\" linkend=\"plpgsql-"
"quote-literal-example\"/>."

#: func.xml:2024(literal)
msgid "quote_nullable(NULL)"
msgstr "quote_nullable(NULL)"

#: func.xml:2025(literal)
msgctxt "literal"
msgid "NULL"
msgstr "NULL"

#: func.xml:2031(entry)
msgid ""
"Coerce the given value to text and then quote it as a literal; or, if the "
"argument is null, return <literal>NULL</literal>. Embedded single-quotes and "
"backslashes are properly doubled."
msgstr ""
"Переводит данное значение в текстовый вид и заключает в апострофы как "
"текстовую строку, при этом для аргумента NULL возвращается строка "
"<literal>NULL</literal>. Символы апостроф и обратная косая черта дублируются "
"должным образом."

#: func.xml:2036(literal)
msgid "quote_nullable(42.5)"
msgstr "quote_nullable(42.5)"

#: func.xml:2042(indexterm) func.xml:4116(indexterm)
msgid "<primary>regexp_matches</primary>"
msgstr "<primary>regexp_matches</primary>"

#: func.xml:2045(parameter) func.xml:2062(parameter) func.xml:2078(parameter)
#: func.xml:2095(parameter)
msgctxt "parameter"
msgid "pattern"
msgstr "pattern"

#: func.xml:2045(parameter) func.xml:2062(parameter) func.xml:2078(parameter)
#: func.xml:2095(parameter)
msgid "flags"
msgstr "flags"

#: func.xml:2045(function)
msgid ""
"regexp_matches(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"
msgstr ""
"regexp_matches&zwsp;(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"

#: func.xml:2047(type)
msgid "setof text[]"
msgstr "setof text[]"

#: func.xml:2048(entry)
msgid ""
"Return all captured substrings resulting from matching a POSIX regular "
"expression against the <parameter>string</parameter>. See <xref linkend="
"\"functions-posix-regexp\"/> for more information."
msgstr ""
"Возвращает все подходящие подстроки, полученные в результате применения "
"регулярного выражения в стиле POSIX к <parameter>string</parameter>. "
"Подробности описаны в <xref remap=\"6\" linkend=\"functions-posix-regexp\"/>."

#: func.xml:2053(literal)
msgid "regexp_matches('foobarbequebaz', '(bar)(beque)')"
msgstr "regexp_matches&zwsp;('foobar&zwsp;bequebaz', '(bar)(beque)')"

#: func.xml:2054(literal)
msgid "{bar,beque}"
msgstr "{bar,beque}"

#: func.xml:2059(indexterm) func.xml:4113(indexterm)
msgid "<primary>regexp_replace</primary>"
msgstr "<primary>regexp_replace</primary>"

#: func.xml:2062(parameter)
msgid "replacement"
msgstr "replacement"

#: func.xml:2062(function)
msgid ""
"regexp_replace(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>])"
msgstr ""
"regexp_replace&zwsp;(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>])"

#: func.xml:2065(entry)
msgid ""
"Replace substring(s) matching a POSIX regular expression. See <xref linkend="
"\"functions-posix-regexp\"/> for more information."
msgstr ""
"Заменяет подстроки, соответствующие заданному регулярному выражению в стиле "
"POSIX. Подробности описаны в <xref remap=\"6\" linkend=\"functions-posix-"
"regexp\"/>."

#: func.xml:2069(literal)
msgid "regexp_replace('Thomas', '.[mN]a.', 'M')"
msgstr "regexp_replace('Thomas', '.[mN]a.', 'M')"

#: func.xml:2070(literal)
msgid "ThM"
msgstr "ThM"

#: func.xml:2075(indexterm) func.xml:4122(indexterm)
msgid "<primary>regexp_split_to_array</primary>"
msgstr "<primary>regexp_split_to_array</primary>"

#: func.xml:2078(function)
msgid ""
"regexp_split_to_array(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/> ])"
msgstr ""
"regexp_split_to_array(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/> ])"

#: func.xml:2081(entry) func.xml:2098(entry)
msgid ""
"Split <parameter>string</parameter> using a POSIX regular expression as the "
"delimiter. See <xref linkend=\"functions-posix-regexp\"/> for more "
"information."
msgstr ""
"Разделяет содержимое <parameter>string</parameter> на элементы, используя в "
"качестве разделителя регулярное выражение POSIX. Подробности описаны в <xref "
"remap=\"6\" linkend=\"functions-posix-regexp\"/>."

#: func.xml:2086(literal)
msgid "regexp_split_to_array('hello world', E'\\\\s+')"
msgstr "regexp_split_to_array('hello world', E'\\\\s+')"

#: func.xml:2087(literal)
msgid "{hello,world}"
msgstr "{hello,world}"

#: func.xml:2092(indexterm) func.xml:4119(indexterm)
msgid "<primary>regexp_split_to_table</primary>"
msgstr "<primary>regexp_split&zwsp;_to_table</primary>"

#: func.xml:2095(function)
msgid ""
"regexp_split_to_table(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"
msgstr ""
"regexp_split_to_table(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/> [, <placeholder-5/> <placeholder-6/>])"

#: func.xml:2097(type) func.xml:11154(type) func.xml:11233(type)
#: func.xml:15386(type) func.xml:19006(type)
msgid "setof text"
msgstr "setof text"

#: func.xml:2103(literal)
msgid "regexp_split_to_table('hello world', E'\\\\s+')"
msgstr "regexp_split_to_table('hello world', E'\\\\s+')"

#: func.xml:2104(literal)
msgid "world"
msgstr "world"

#: func.xml:2104(entry)
msgid "<literal>hello</literal><placeholder-1/> (2 rows)"
msgstr "<literal>hello</literal> <placeholder-1/> (2 строки)"

#: func.xml:2109(indexterm)
msgid "<primary>repeat</primary>"
msgstr "<primary>repeat</primary>"

#: func.xml:2112(parameter) func.xml:2283(parameter)
msgctxt "parameter"
msgid "number"
msgstr "number"

#: func.xml:2112(function)
msgid ""
"repeat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"repeat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:2115(entry)
msgid ""
"Repeat <parameter>string</parameter> the specified <parameter>number</"
"parameter> of times"
msgstr ""
"Повторяет содержимое <parameter>string</parameter> указанное число "
"(<parameter>number</parameter>) раз"

#: func.xml:2117(literal)
msgid "repeat('Pg', 4)"
msgstr "repeat('Pg', 4)"

#: func.xml:2118(literal)
msgid "PgPgPgPg"
msgstr "PgPgPgPg"

#: func.xml:2123(indexterm)
msgid "<primary>replace</primary>"
msgstr "<primary>replace</primary>"

#: func.xml:2127(parameter) func.xml:2249(parameter) func.xml:2300(parameter)
msgctxt "parameter"
msgid "from"
msgstr "from"

#: func.xml:2128(parameter) func.xml:2301(parameter)
msgid "to"
msgstr "to"

#: func.xml:2126(function)
msgid ""
"replace(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"replace(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#: func.xml:2131(entry)
msgid ""
"Replace all occurrences in <parameter>string</parameter> of substring "
"<parameter>from</parameter> with substring <parameter>to</parameter>"
msgstr ""
"Заменяет все вхождения в <parameter>string</parameter> подстроки "
"<parameter>from</parameter> подстрокой <parameter>to</parameter>"

#: func.xml:2134(literal)
msgid "replace('abcdefabcdef', 'cd', 'XX')"
msgstr "replace('abcdefabcdef', 'cd', 'XX')"

#: func.xml:2135(literal)
msgid "abXXefabXXef"
msgstr "abXXefabXXef"

#: func.xml:2140(indexterm)
msgid "<primary>reverse</primary>"
msgstr "<primary>reverse</primary>"

#: func.xml:2143(function)
msgid "reverse(<placeholder-1/>)"
msgstr "reverse(<placeholder-1/>)"

#: func.xml:2146(entry)
msgid "Return reversed string."
msgstr "Возвращает перевёрнутую строку"

#: func.xml:2149(literal)
msgid "reverse('abcde')"
msgstr "reverse('abcde')"

#: func.xml:2150(literal)
msgid "edcba"
msgstr "edcba"

#: func.xml:2155(indexterm)
msgid "<primary>right</primary>"
msgstr "<primary>right</primary>"

#: func.xml:2158(function)
msgid ""
"right(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"right(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:2162(entry)
msgid ""
"Return last <replaceable>n</replaceable> characters in the string. When "
"<replaceable>n</replaceable> is negative, return all but first |"
"<replaceable>n</replaceable>| characters."
msgstr ""
"Возвращает последние <replaceable>n</replaceable> символов в строке. Когда "
"<replaceable>n</replaceable> меньше нуля, возвращаются все символы справа, "
"кроме первых |<replaceable>n</replaceable>|."

#: func.xml:2166(literal)
msgid "right('abcde', 2)"
msgstr "right('abcde', 2)"

#: func.xml:2167(literal)
msgid "de"
msgstr "de"

#: func.xml:2172(indexterm)
msgid "<primary>rpad</primary>"
msgstr "<primary>rpad</primary>"

#: func.xml:2175(function)
msgid ""
"rpad(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> "
"<placeholder-5/>)"
msgstr ""
"rpad(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/> "
"<placeholder-5/>)"

#: func.xml:2180(entry)
msgid ""
"Fill up the <parameter>string</parameter> to length <parameter>length</"
"parameter> by appending the characters <parameter>fill</parameter> (a space "
"by default). If the <parameter>string</parameter> is already longer than "
"<parameter>length</parameter> then it is truncated."
msgstr ""
"Дополняет строку <parameter>string</parameter> справа до длины "
"<parameter>length</parameter> символами <parameter>fill</parameter> (по "
"умолчанию пробелами). Если длина строки уже больше заданной, она обрезается."

#: func.xml:2187(literal)
msgid "rpad('hi', 5, 'xy')"
msgstr "rpad('hi', 5, 'xy')"

#: func.xml:2188(literal)
msgid "hixyx"
msgstr "hixyx"

#: func.xml:2193(indexterm)
msgid "<primary>rtrim</primary>"
msgstr "<primary>rtrim</primary>"

#: func.xml:2196(function)
msgid "rtrim(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "rtrim(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:2200(entry)
msgid ""
"Remove the longest string containing only characters from "
"<parameter>characters</parameter> (a space by default) from the end of "
"<parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, содержащую только символы "
"<parameter>characters</parameter> (по умолчанию пробелы), с конца строки "
"<parameter>string</parameter>"

#: func.xml:2205(literal)
msgid "rtrim('trimxxxx', 'x')"
msgstr "rtrim('trimxxxx', 'x')"

#: func.xml:2211(indexterm)
msgid "<primary>split_part</primary>"
msgstr "<primary>split_part</primary>"

#: func.xml:2215(parameter)
msgctxt "parameter"
msgid "delimiter"
msgstr "delimiter"

#: func.xml:2216(parameter) func.xml:6923(parameter) func.xml:6934(parameter)
msgctxt "parameter"
msgid "field"
msgstr "field"

#: func.xml:2214(function)
msgid ""
"split_part(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"split_part(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:2219(entry)
msgid ""
"Split <parameter>string</parameter> on <parameter>delimiter</parameter> and "
"return the given field (counting from one)"
msgstr ""
"Разделяет строку <parameter>string</parameter> по символу "
"<parameter>delimiter</parameter> и возвращает элемент по заданному номеру "
"(считая с 1)"

#: func.xml:2222(literal)
msgid "split_part('abc~@~def~@~ghi', '~@~', 2)"
msgstr "split_part('abc~@~def&zwsp;~@~ghi', '~@~', 2)"

#: func.xml:2223(literal)
msgid "def"
msgstr "def"

#: func.xml:2228(indexterm)
msgid "<primary>strpos</primary>"
msgstr "<primary>strpos</primary>"

#: func.xml:2231(function)
msgid "strpos(<placeholder-1/>, <placeholder-2/>)"
msgstr "strpos(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:2234(entry)
msgid ""
"Location of specified substring (same as "
"<literal>position(<parameter>substring</parameter> in <parameter>string</"
"parameter>)</literal>, but note the reversed argument order)"
msgstr ""
"Возвращает положение указанной подстроки (подобно "
"<literal>position(<parameter>substring</parameter> in <parameter>string</"
"parameter>)</literal>, но с другим порядком аргументов)"

#: func.xml:2240(literal)
msgid "strpos('high', 'ig')"
msgstr "strpos('high', 'ig')"

#: func.xml:2246(indexterm)
msgid "<primary>substr</primary>"
msgstr "<primary>substr</primary>"

#: func.xml:2249(optional) func.xml:9987(optional) func.xml:10266(optional)
#: func.xml:10327(optional) func.xml:12227(optional) func.xml:12261(optional)
#: func.xml:12321(optional) func.xml:12355(optional)
msgid ", <placeholder-1/>"
msgstr ", <placeholder-1/>"

#: func.xml:2249(function)
msgid "substr(<placeholder-1/>, <placeholder-2/> <placeholder-3/>)"
msgstr "substr(<placeholder-1/>, <placeholder-2/> <placeholder-3/>)"

#: func.xml:2252(entry)
msgid ""
"Extract substring (same as <literal>substring(<parameter>string</parameter> "
"from <parameter>from</parameter> for <parameter>count</parameter>)</literal>)"
msgstr ""
"Извлекает подстроку (подобно <literal>substring(<parameter>string</"
"parameter> from <parameter>from</parameter> for <parameter>count</"
"parameter>)</literal>)"

#: func.xml:2256(literal)
msgid "substr('alphabet', 3, 2)"
msgstr "substr('alphabet', 3, 2)"

#: func.xml:2257(literal)
msgid "ph"
msgstr "ph"

#: func.xml:2262(indexterm)
msgid "<primary>to_ascii</primary>"
msgstr "<primary>to_ascii</primary>"

#: func.xml:2265(function)
msgid "to_ascii(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "to_ascii(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:2269(entry)
msgid ""
"Convert <parameter>string</parameter> to <acronym>ASCII</acronym> from "
"another encoding (only supports conversion from <literal>LATIN1</literal>, "
"<literal>LATIN2</literal>, <literal>LATIN9</literal>, and <literal>WIN1250</"
"literal> encodings)"
msgstr ""
"Преобразует <parameter>string</parameter> в <acronym>ASCII</acronym> из "
"кодировки <parameter>encoding</parameter> (поддерживаются только "
"<literal>LATIN1</literal>, <literal>LATIN2</literal>, <literal>LATIN9</"
"literal> и <literal>WIN1250</literal>)"

#: func.xml:2274(literal)
msgid "to_ascii('Karel')"
msgstr "to_ascii('Karel')"

#: func.xml:2275(literal)
msgid "Karel"
msgstr "Karel"

#: func.xml:2280(indexterm)
msgid "<primary>to_hex</primary>"
msgstr "<primary>to_hex</primary>"

#: func.xml:2284(type) func.xml:11514(type) func.xml:11520(type)
#: func.xml:11526(type) func.xml:11530(type) func.xml:11531(type)
#: func.xml:11535(type) func.xml:11536(type) func.xml:12944(type)
#: func.xml:12952(type) func.xml:13366(type) func.xml:13851(type)
#: func.xml:13874(type) func.xml:14063(type) func.xml:14076(type)
#: func.xml:14089(type) func.xml:16932(type) func.xml:16947(type)
#: func.xml:16952(type) func.xml:17279(type) func.xml:18612(type)
#: func.xml:18619(type) func.xml:18626(type) func.xml:18635(type)
#: func.xml:18646(type) func.xml:18655(type) func.xml:18662(type)
#: func.xml:18684(type) func.xml:18694(type) func.xml:18701(type)
#: func.xml:18708(type) func.xml:18950(type) func.xml:19013(type)
#: func.xml:19022(type) func.xml:19128(type) func.xml:19142(type)
#: func.xml:19156(type) func.xml:19177(type) func.xml:19191(type)
#: func.xml:19205(type) func.xml:19219(type) func.xml:19233(type)
#: func.xml:19247(type) func.xml:19261(type)
msgctxt "type"
msgid "bigint"
msgstr "bigint"

#: func.xml:2283(function)
msgid "to_hex(<placeholder-1/> <placeholder-2/> or <placeholder-3/>)"
msgstr "to_hex(<placeholder-1/> <placeholder-2/> или <placeholder-3/>)"

#: func.xml:2287(entry)
msgid ""
"Convert <parameter>number</parameter> to its equivalent hexadecimal "
"representation"
msgstr "Преобразует число <parameter>number</parameter> в 16-ричный вид"

#: func.xml:2290(literal)
msgid "to_hex(2147483647)"
msgstr "to_hex(2147483647)"

#: func.xml:2291(literal)
msgid "7fffffff"
msgstr "7fffffff"

#: func.xml:2296(indexterm)
msgid "<primary>translate</primary>"
msgstr "<primary>translate</primary>"

#: func.xml:2299(function)
msgid ""
"translate(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"translate(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#: func.xml:2304(entry)
msgid ""
"Any character in <parameter>string</parameter> that matches a character in "
"the <parameter>from</parameter> set is replaced by the corresponding "
"character in the <parameter>to</parameter> set. If <parameter>from</"
"parameter> is longer than <parameter>to</parameter>, occurrences of the "
"extra characters in <parameter>from</parameter> are removed."
msgstr ""
"Заменяет символы в <parameter>string</parameter>, найденные в наборе "
"<parameter>from</parameter>, на соответствующие символы в множестве "
"<parameter>to</parameter>. Если строка <parameter>from</parameter> длиннее "
"<parameter>to</parameter>, найденные в исходной строке лишние символы "
"<parameter>from</parameter> удаляются."

#: func.xml:2312(literal)
msgid "translate('12345', '143', 'ax')"
msgstr "translate('12345', '143', 'ax')"

#: func.xml:2313(literal)
msgid "a2x5"
msgstr "a2x5"

#: func.xml:2320(para)
msgid ""
"The <function>concat</function>, <function>concat_ws</function> and "
"<function>format</function> functions are variadic, so it is possible to "
"pass the values to be concatenated or formatted as an array marked with the "
"<literal>VARIADIC</literal> keyword (see <xref linkend=\"xfunc-sql-variadic-"
"functions\"/>). The array's elements are treated as if they were separate "
"ordinary arguments to the function. If the variadic array argument is NULL, "
"<function>concat</function> and <function>concat_ws</function> return NULL, "
"but <function>format</function> treats a NULL as a zero-element array."
msgstr ""
"Функции <function>concat</function>, <function>concat_ws</function> и "
"<function>format</function> принимают переменное число аргументов, так что "
"им для объединения или форматирования можно передавать значения в виде "
"массива, помеченного ключевым словом <literal>VARIADIC</literal> (см. <xref "
"remap=\"4\" linkend=\"xfunc-sql-variadic-functions\"/>). Элементы такого "
"массива обрабатываются, как если бы они были обычными аргументами функции. "
"Если вместо массива в соответствующем аргументе передаётся NULL, функции "
"<function>concat</function> и <function>concat_ws</function> возвращают "
"NULL, а <function>format</function> воспринимает NULL как массив нулевого "
"размера."

#: func.xml:2332(para)
msgid ""
"See also the aggregate function <function>string_agg</function> in <xref "
"linkend=\"functions-aggregate\"/>."
msgstr ""
"См. также агрегатную функцию <function>string_agg</function> в <xref remap="
"\"6\" linkend=\"functions-aggregate\"/>."

#: func.xml:2338(title)
msgid "Built-in Conversions"
msgstr "Встроенные преобразования"

#: func.xml:2344(para)
msgid ""
"The conversion names follow a standard naming scheme: The official name of "
"the source encoding with all non-alphanumeric characters replaced by "
"underscores, followed by <literal>_to_</literal>, followed by the similarly "
"processed destination encoding name. Therefore, the names might deviate from "
"the customary encoding names."
msgstr ""
"Имена преобразований следуют стандартной схеме именования. К официальному "
"названию исходной кодировки, в котором все не алфавитно-цифровые символы "
"заменяются подчёркиваниями, добавляется <literal>_to_</literal>, а за ним "
"аналогично подготовленное имя целевой кодировки. Таким образом, имена "
"кодировок могут не совпадать буквально с общепринятыми названиями."

#: func.xml:2342(entry)
msgid "Conversion Name <placeholder-1/>"
msgstr "Имя преобразования <placeholder-1/>"

#: func.xml:2354(entry)
msgid "Source Encoding"
msgstr "Исходная кодировка"

#: func.xml:2355(entry)
msgid "Destination Encoding"
msgstr "Целевая кодировка"

#: func.xml:2361(literal)
msgid "ascii_to_mic"
msgstr "ascii_to_mic"

#: func.xml:2363(literal) func.xml:2381(literal) func.xml:2393(literal)
#: func.xml:2405(literal) func.xml:2423(literal) func.xml:2441(literal)
#: func.xml:2495(literal) func.xml:2507(literal) func.xml:2525(literal)
#: func.xml:2537(literal) func.xml:2555(literal) func.xml:2615(literal)
#: func.xml:2644(literal) func.xml:2650(literal) func.xml:2656(literal)
#: func.xml:2662(literal) func.xml:2668(literal) func.xml:2674(literal)
#: func.xml:2680(literal) func.xml:2686(literal) func.xml:2692(literal)
#: func.xml:2698(literal) func.xml:2704(literal) func.xml:2710(literal)
#: func.xml:2716(literal) func.xml:2722(literal) func.xml:2728(literal)
#: func.xml:2734(literal) func.xml:2747(literal) func.xml:3005(literal)
#: func.xml:3029(literal) func.xml:3071(literal)
msgid "MULE_INTERNAL"
msgstr "MULE_INTERNAL"

#: func.xml:2367(literal)
msgid "ascii_to_utf8"
msgstr "ascii_to_utf8"

#: func.xml:2369(literal) func.xml:2387(literal) func.xml:2399(literal)
#: func.xml:2417(literal) func.xml:2429(literal) func.xml:2447(literal)
#: func.xml:2453(literal) func.xml:2459(literal) func.xml:2465(literal)
#: func.xml:2471(literal) func.xml:2477(literal) func.xml:2483(literal)
#: func.xml:2489(literal) func.xml:2501(literal) func.xml:2513(literal)
#: func.xml:2531(literal) func.xml:2543(literal) func.xml:2561(literal)
#: func.xml:2579(literal) func.xml:2585(literal) func.xml:2591(literal)
#: func.xml:2597(literal) func.xml:2603(literal) func.xml:2621(literal)
#: func.xml:2639(literal) func.xml:2753(literal) func.xml:2759(literal)
#: func.xml:2765(literal) func.xml:2770(literal) func.xml:2776(literal)
#: func.xml:2782(literal) func.xml:2788(literal) func.xml:2794(literal)
#: func.xml:2800(literal) func.xml:2806(literal) func.xml:2812(literal)
#: func.xml:2818(literal) func.xml:2824(literal) func.xml:2830(literal)
#: func.xml:2836(literal) func.xml:2842(literal) func.xml:2848(literal)
#: func.xml:2854(literal) func.xml:2860(literal) func.xml:2866(literal)
#: func.xml:2872(literal) func.xml:2878(literal) func.xml:2884(literal)
#: func.xml:2890(literal) func.xml:2896(literal) func.xml:2902(literal)
#: func.xml:2908(literal) func.xml:2914(literal) func.xml:2920(literal)
#: func.xml:2926(literal) func.xml:2932(literal) func.xml:2938(literal)
#: func.xml:2944(literal) func.xml:2950(literal) func.xml:2956(literal)
#: func.xml:2962(literal) func.xml:2968(literal) func.xml:2974(literal)
#: func.xml:2980(literal) func.xml:2986(literal) func.xml:2992(literal)
#: func.xml:3011(literal) func.xml:3035(literal) func.xml:3047(literal)
#: func.xml:3053(literal) func.xml:3077(literal) func.xml:3089(literal)
#: func.xml:3095(literal) func.xml:3100(literal) func.xml:3107(literal)
#: func.xml:3112(literal)
msgid "UTF8"
msgstr "UTF8"

#: func.xml:2373(literal)
msgid "big5_to_euc_tw"
msgstr "big5_to_euc_tw"

#: func.xml:2374(literal) func.xml:2380(literal) func.xml:2386(literal)
#: func.xml:2435(literal) func.xml:2651(literal) func.xml:2777(literal)
msgid "BIG5"
msgstr "BIG5"

#: func.xml:2375(literal) func.xml:2434(literal) func.xml:2440(literal)
#: func.xml:2446(literal) func.xml:2675(literal) func.xml:2801(literal)
msgid "EUC_TW"
msgstr "EUC_TW"

#: func.xml:2379(literal)
msgid "big5_to_mic"
msgstr "big5_to_mic"

#: func.xml:2385(literal)
msgid "big5_to_utf8"
msgstr "big5_to_utf8"

#: func.xml:2391(literal)
msgid "euc_cn_to_mic"
msgstr "euc_cn_to_mic"

#: func.xml:2392(literal) func.xml:2398(literal) func.xml:2657(literal)
#: func.xml:2783(literal)
msgid "EUC_CN"
msgstr "EUC_CN"

#: func.xml:2397(literal)
msgid "euc_cn_to_utf8"
msgstr "euc_cn_to_utf8"

#: func.xml:2403(literal)
msgid "euc_jp_to_mic"
msgstr "euc_jp_to_mic"

#: func.xml:2404(literal) func.xml:2410(literal) func.xml:2416(literal)
#: func.xml:2663(literal) func.xml:2741(literal) func.xml:2789(literal)
msgid "EUC_JP"
msgstr "EUC_JP"

#: func.xml:2409(literal)
msgid "euc_jp_to_sjis"
msgstr "euc_jp_to_sjis"

#: func.xml:2411(literal) func.xml:2717(literal) func.xml:2740(literal)
#: func.xml:2746(literal) func.xml:2752(literal) func.xml:2921(literal)
msgid "SJIS"
msgstr "SJIS"

#: func.xml:2415(literal)
msgid "euc_jp_to_utf8"
msgstr "euc_jp_to_utf8"

#: func.xml:2421(literal)
msgid "euc_kr_to_mic"
msgstr "euc_kr_to_mic"

#: func.xml:2422(literal) func.xml:2428(literal) func.xml:2669(literal)
#: func.xml:2795(literal)
msgid "EUC_KR"
msgstr "EUC_KR"

#: func.xml:2427(literal)
msgid "euc_kr_to_utf8"
msgstr "euc_kr_to_utf8"

#: func.xml:2433(literal)
msgid "euc_tw_to_big5"
msgstr "euc_tw_to_big5"

#: func.xml:2439(literal)
msgid "euc_tw_to_mic"
msgstr "euc_tw_to_mic"

#: func.xml:2445(literal)
msgid "euc_tw_to_utf8"
msgstr "euc_tw_to_utf8"

#: func.xml:2451(literal)
msgid "gb18030_to_utf8"
msgstr "gb18030_to_utf8"

#: func.xml:2452(literal) func.xml:2807(literal)
msgid "GB18030"
msgstr "GB18030"

#: func.xml:2457(literal)
msgid "gbk_to_utf8"
msgstr "gbk_to_utf8"

#: func.xml:2458(literal) func.xml:2813(literal)
msgid "GBK"
msgstr "GBK"

#: func.xml:2463(literal)
msgid "iso_8859_10_to_utf8"
msgstr "iso_8859_10_to_utf8"

#: func.xml:2464(literal) func.xml:2825(literal)
msgid "LATIN6"
msgstr "LATIN6"

#: func.xml:2469(literal)
msgid "iso_8859_13_to_utf8"
msgstr "iso_8859_13_to_utf8"

#: func.xml:2470(literal) func.xml:2831(literal)
msgid "LATIN7"
msgstr "LATIN7"

#: func.xml:2475(literal)
msgid "iso_8859_14_to_utf8"
msgstr "iso_8859_14_to_utf8"

#: func.xml:2476(literal) func.xml:2837(literal)
msgid "LATIN8"
msgstr "LATIN8"

#: func.xml:2481(literal)
msgid "iso_8859_15_to_utf8"
msgstr "iso_8859_15_to_utf8"

#: func.xml:2482(literal) func.xml:2843(literal)
msgid "LATIN9"
msgstr "LATIN9"

#: func.xml:2487(literal)
msgid "iso_8859_16_to_utf8"
msgstr "iso_8859_16_to_utf8"

#: func.xml:2488(literal) func.xml:2849(literal)
msgid "LATIN10"
msgstr "LATIN10"

#: func.xml:2493(literal)
msgid "iso_8859_1_to_mic"
msgstr "iso_8859_1_to_mic"

#: func.xml:2494(literal) func.xml:2500(literal) func.xml:2681(literal)
#: func.xml:2819(literal)
msgid "LATIN1"
msgstr "LATIN1"

#: func.xml:2499(literal)
msgid "iso_8859_1_to_utf8"
msgstr "iso_8859_1_to_utf8"

#: func.xml:2505(literal)
msgid "iso_8859_2_to_mic"
msgstr "iso_8859_2_to_mic"

#: func.xml:2506(literal) func.xml:2512(literal) func.xml:2518(literal)
#: func.xml:2687(literal) func.xml:2855(literal) func.xml:2999(literal)
msgid "LATIN2"
msgstr "LATIN2"

#: func.xml:2511(literal)
msgid "iso_8859_2_to_utf8"
msgstr "iso_8859_2_to_utf8"

#: func.xml:2517(literal)
msgid "iso_8859_2_to_windows_1250"
msgstr "iso_8859_2_to_windows_1250"

#: func.xml:2519(literal) func.xml:2723(literal) func.xml:2939(literal)
#: func.xml:2998(literal) func.xml:3004(literal) func.xml:3010(literal)
msgid "WIN1250"
msgstr "WIN1250"

#: func.xml:2523(literal)
msgid "iso_8859_3_to_mic"
msgstr "iso_8859_3_to_mic"

#: func.xml:2524(literal) func.xml:2530(literal) func.xml:2693(literal)
#: func.xml:2861(literal)
msgid "LATIN3"
msgstr "LATIN3"

#: func.xml:2529(literal)
msgid "iso_8859_3_to_utf8"
msgstr "iso_8859_3_to_utf8"

#: func.xml:2535(literal)
msgid "iso_8859_4_to_mic"
msgstr "iso_8859_4_to_mic"

#: func.xml:2536(literal) func.xml:2542(literal) func.xml:2699(literal)
#: func.xml:2867(literal)
msgid "LATIN4"
msgstr "LATIN4"

#: func.xml:2541(literal)
msgid "iso_8859_4_to_utf8"
msgstr "iso_8859_4_to_utf8"

#: func.xml:2547(literal)
msgid "iso_8859_5_to_koi8_r"
msgstr "iso_8859_5_to_koi8_r"

#: func.xml:2548(literal) func.xml:2554(literal) func.xml:2560(literal)
#: func.xml:2566(literal) func.xml:2572(literal) func.xml:2609(literal)
#: func.xml:2705(literal) func.xml:2873(literal) func.xml:3017(literal)
#: func.xml:3059(literal)
msgid "ISO_8859_5"
msgstr "ISO_8859_5"

#: func.xml:2549(literal) func.xml:2608(literal) func.xml:2614(literal)
#: func.xml:2620(literal) func.xml:2626(literal) func.xml:2632(literal)
#: func.xml:2711(literal) func.xml:2909(literal) func.xml:3023(literal)
#: func.xml:3065(literal)
msgid "KOI8R"
msgstr "KOI8R"

#: func.xml:2553(literal)
msgid "iso_8859_5_to_mic"
msgstr "iso_8859_5_to_mic"

#: func.xml:2559(literal)
msgid "iso_8859_5_to_utf8"
msgstr "iso_8859_5_to_utf8"

#: func.xml:2565(literal)
msgid "iso_8859_5_to_windows_1251"
msgstr "iso_8859_5_to_windows_1251"

#: func.xml:2567(literal) func.xml:2627(literal) func.xml:2729(literal)
#: func.xml:2945(literal) func.xml:3016(literal) func.xml:3022(literal)
#: func.xml:3028(literal) func.xml:3034(literal) func.xml:3040(literal)
msgid "WIN1251"
msgstr "WIN1251"

#: func.xml:2571(literal)
msgid "iso_8859_5_to_windows_866"
msgstr "iso_8859_5_to_windows_866"

#: func.xml:2573(literal) func.xml:2633(literal) func.xml:2735(literal)
#: func.xml:2987(literal) func.xml:3041(literal) func.xml:3058(literal)
#: func.xml:3064(literal) func.xml:3070(literal) func.xml:3076(literal)
#: func.xml:3082(literal)
msgid "WIN866"
msgstr "WIN866"

#: func.xml:2577(literal)
msgid "iso_8859_6_to_utf8"
msgstr "iso_8859_6_to_utf8"

#: func.xml:2578(literal) func.xml:2879(literal)
msgid "ISO_8859_6"
msgstr "ISO_8859_6"

#: func.xml:2583(literal)
msgid "iso_8859_7_to_utf8"
msgstr "iso_8859_7_to_utf8"

#: func.xml:2584(literal) func.xml:2885(literal)
msgid "ISO_8859_7"
msgstr "ISO_8859_7"

#: func.xml:2589(literal)
msgid "iso_8859_8_to_utf8"
msgstr "iso_8859_8_to_utf8"

#: func.xml:2590(literal) func.xml:2891(literal)
msgid "ISO_8859_8"
msgstr "ISO_8859_8"

#: func.xml:2595(literal)
msgid "iso_8859_9_to_utf8"
msgstr "iso_8859_9_to_utf8"

#: func.xml:2596(literal) func.xml:2897(literal)
msgid "LATIN5"
msgstr "LATIN5"

#: func.xml:2601(literal)
msgid "johab_to_utf8"
msgstr "johab_to_utf8"

#: func.xml:2602(literal) func.xml:2903(literal)
msgid "JOHAB"
msgstr "JOHAB"

#: func.xml:2607(literal)
msgid "koi8_r_to_iso_8859_5"
msgstr "koi8_r_to_iso_8859_5"

#: func.xml:2613(literal)
msgid "koi8_r_to_mic"
msgstr "koi8_r_to_mic"

#: func.xml:2619(literal)
msgid "koi8_r_to_utf8"
msgstr "koi8_r_to_utf8"

#: func.xml:2625(literal)
msgid "koi8_r_to_windows_1251"
msgstr "koi8_r_to_windows_1251"

#: func.xml:2631(literal)
msgid "koi8_r_to_windows_866"
msgstr "koi8_r_to_windows_866"

#: func.xml:2637(literal)
msgid "koi8_u_to_utf8"
msgstr "koi8_u_to_utf8"

#: func.xml:2638(literal) func.xml:2915(literal)
msgid "KOI8U"
msgstr "KOI8U"

#: func.xml:2643(literal)
msgid "mic_to_ascii"
msgstr "mic_to_ascii"

#: func.xml:2649(literal)
msgid "mic_to_big5"
msgstr "mic_to_big5"

#: func.xml:2655(literal)
msgid "mic_to_euc_cn"
msgstr "mic_to_euc_cn"

#: func.xml:2661(literal)
msgid "mic_to_euc_jp"
msgstr "mic_to_euc_jp"

#: func.xml:2667(literal)
msgid "mic_to_euc_kr"
msgstr "mic_to_euc_kr"

#: func.xml:2673(literal)
msgid "mic_to_euc_tw"
msgstr "mic_to_euc_tw"

#: func.xml:2679(literal)
msgid "mic_to_iso_8859_1"
msgstr "mic_to_iso_8859_1"

#: func.xml:2685(literal)
msgid "mic_to_iso_8859_2"
msgstr "mic_to_iso_8859_2"

#: func.xml:2691(literal)
msgid "mic_to_iso_8859_3"
msgstr "mic_to_iso_8859_3"

#: func.xml:2697(literal)
msgid "mic_to_iso_8859_4"
msgstr "mic_to_iso_8859_4"

#: func.xml:2703(literal)
msgid "mic_to_iso_8859_5"
msgstr "mic_to_iso_8859_5"

#: func.xml:2709(literal)
msgid "mic_to_koi8_r"
msgstr "mic_to_koi8_r"

#: func.xml:2715(literal)
msgid "mic_to_sjis"
msgstr "mic_to_sjis"

#: func.xml:2721(literal)
msgid "mic_to_windows_1250"
msgstr "mic_to_windows_1250"

#: func.xml:2727(literal)
msgid "mic_to_windows_1251"
msgstr "mic_to_windows_1251"

#: func.xml:2733(literal)
msgid "mic_to_windows_866"
msgstr "mic_to_windows_866"

#: func.xml:2739(literal)
msgid "sjis_to_euc_jp"
msgstr "sjis_to_euc_jp"

#: func.xml:2745(literal)
msgid "sjis_to_mic"
msgstr "sjis_to_mic"

#: func.xml:2751(literal)
msgid "sjis_to_utf8"
msgstr "sjis_to_utf8"

#: func.xml:2757(literal)
msgid "tcvn_to_utf8"
msgstr "tcvn_to_utf8"

#: func.xml:2758(literal) func.xml:2927(literal)
msgid "WIN1258"
msgstr "WIN1258"

#: func.xml:2763(literal)
msgid "uhc_to_utf8"
msgstr "uhc_to_utf8"

#: func.xml:2764(literal) func.xml:2933(literal)
msgid "UHC"
msgstr "UHC"

#: func.xml:2769(literal)
msgid "utf8_to_ascii"
msgstr "utf8_to_ascii"

#: func.xml:2775(literal)
msgid "utf8_to_big5"
msgstr "utf8_to_big5"

#: func.xml:2781(literal)
msgid "utf8_to_euc_cn"
msgstr "utf8_to_euc_cn"

#: func.xml:2787(literal)
msgid "utf8_to_euc_jp"
msgstr "utf8_to_euc_jp"

#: func.xml:2793(literal)
msgid "utf8_to_euc_kr"
msgstr "utf8_to_euc_kr"

#: func.xml:2799(literal)
msgid "utf8_to_euc_tw"
msgstr "utf8_to_euc_tw"

#: func.xml:2805(literal)
msgid "utf8_to_gb18030"
msgstr "utf8_to_gb18030"

#: func.xml:2811(literal)
msgid "utf8_to_gbk"
msgstr "utf8_to_gbk"

#: func.xml:2817(literal)
msgid "utf8_to_iso_8859_1"
msgstr "utf8_to_iso_8859_1"

#: func.xml:2823(literal)
msgid "utf8_to_iso_8859_10"
msgstr "utf8_to_iso_8859_10"

#: func.xml:2829(literal)
msgid "utf8_to_iso_8859_13"
msgstr "utf8_to_iso_8859_13"

#: func.xml:2835(literal)
msgid "utf8_to_iso_8859_14"
msgstr "utf8_to_iso_8859_14"

#: func.xml:2841(literal)
msgid "utf8_to_iso_8859_15"
msgstr "utf8_to_iso_8859_15"

#: func.xml:2847(literal)
msgid "utf8_to_iso_8859_16"
msgstr "utf8_to_iso_8859_16"

#: func.xml:2853(literal)
msgid "utf8_to_iso_8859_2"
msgstr "utf8_to_iso_8859_2"

#: func.xml:2859(literal)
msgid "utf8_to_iso_8859_3"
msgstr "utf8_to_iso_8859_3"

#: func.xml:2865(literal)
msgid "utf8_to_iso_8859_4"
msgstr "utf8_to_iso_8859_4"

#: func.xml:2871(literal)
msgid "utf8_to_iso_8859_5"
msgstr "utf8_to_iso_8859_5"

#: func.xml:2877(literal)
msgid "utf8_to_iso_8859_6"
msgstr "utf8_to_iso_8859_6"

#: func.xml:2883(literal)
msgid "utf8_to_iso_8859_7"
msgstr "utf8_to_iso_8859_7"

#: func.xml:2889(literal)
msgid "utf8_to_iso_8859_8"
msgstr "utf8_to_iso_8859_8"

#: func.xml:2895(literal)
msgid "utf8_to_iso_8859_9"
msgstr "utf8_to_iso_8859_9"

#: func.xml:2901(literal)
msgid "utf8_to_johab"
msgstr "utf8_to_johab"

#: func.xml:2907(literal)
msgid "utf8_to_koi8_r"
msgstr "utf8_to_koi8_r"

#: func.xml:2913(literal)
msgid "utf8_to_koi8_u"
msgstr "utf8_to_koi8_u"

#: func.xml:2919(literal)
msgid "utf8_to_sjis"
msgstr "utf8_to_sjis"

#: func.xml:2925(literal)
msgid "utf8_to_tcvn"
msgstr "utf8_to_tcvn"

#: func.xml:2931(literal)
msgid "utf8_to_uhc"
msgstr "utf8_to_uhc"

#: func.xml:2937(literal)
msgid "utf8_to_windows_1250"
msgstr "utf8_to_windows_1250"

#: func.xml:2943(literal)
msgid "utf8_to_windows_1251"
msgstr "utf8_to_windows_1251"

#: func.xml:2949(literal)
msgid "utf8_to_windows_1252"
msgstr "utf8_to_windows_1252"

#: func.xml:2951(literal) func.xml:3046(literal)
msgid "WIN1252"
msgstr "WIN1252"

#: func.xml:2955(literal)
msgid "utf8_to_windows_1253"
msgstr "utf8_to_windows_1253"

#: func.xml:2957(literal)
msgid "WIN1253"
msgstr "WIN1253"

#: func.xml:2961(literal)
msgid "utf8_to_windows_1254"
msgstr "utf8_to_windows_1254"

#: func.xml:2963(literal)
msgid "WIN1254"
msgstr "WIN1254"

#: func.xml:2967(literal)
msgid "utf8_to_windows_1255"
msgstr "utf8_to_windows_1255"

#: func.xml:2969(literal)
msgid "WIN1255"
msgstr "WIN1255"

#: func.xml:2973(literal)
msgid "utf8_to_windows_1256"
msgstr "utf8_to_windows_1256"

#: func.xml:2975(literal) func.xml:3052(literal)
msgid "WIN1256"
msgstr "WIN1256"

#: func.xml:2979(literal)
msgid "utf8_to_windows_1257"
msgstr "utf8_to_windows_1257"

#: func.xml:2981(literal)
msgid "WIN1257"
msgstr "WIN1257"

#: func.xml:2985(literal)
msgid "utf8_to_windows_866"
msgstr "utf8_to_windows_866"

#: func.xml:2991(literal)
msgid "utf8_to_windows_874"
msgstr "utf8_to_windows_874"

#: func.xml:2993(literal) func.xml:3088(literal)
msgid "WIN874"
msgstr "WIN874"

#: func.xml:2997(literal)
msgid "windows_1250_to_iso_8859_2"
msgstr "windows_1250_to_iso_8859_2"

#: func.xml:3003(literal)
msgid "windows_1250_to_mic"
msgstr "windows_1250_to_mic"

#: func.xml:3009(literal)
msgid "windows_1250_to_utf8"
msgstr "windows_1250_to_utf8"

#: func.xml:3015(literal)
msgid "windows_1251_to_iso_8859_5"
msgstr "windows_1251_to_iso_8859_5"

#: func.xml:3021(literal)
msgid "windows_1251_to_koi8_r"
msgstr "windows_1251_to_koi8_r"

#: func.xml:3027(literal)
msgid "windows_1251_to_mic"
msgstr "windows_1251_to_mic"

#: func.xml:3033(literal)
msgid "windows_1251_to_utf8"
msgstr "windows_1251_to_utf8"

#: func.xml:3039(literal)
msgid "windows_1251_to_windows_866"
msgstr "windows_1251_to_windows_866"

#: func.xml:3045(literal)
msgid "windows_1252_to_utf8"
msgstr "windows_1252_to_utf8"

#: func.xml:3051(literal)
msgid "windows_1256_to_utf8"
msgstr "windows_1256_to_utf8"

#: func.xml:3057(literal)
msgid "windows_866_to_iso_8859_5"
msgstr "windows_866_to_iso_8859_5"

#: func.xml:3063(literal)
msgid "windows_866_to_koi8_r"
msgstr "windows_866_to_koi8_r"

#: func.xml:3069(literal)
msgid "windows_866_to_mic"
msgstr "windows_866_to_mic"

#: func.xml:3075(literal)
msgid "windows_866_to_utf8"
msgstr "windows_866_to_utf8"

#: func.xml:3081(literal)
msgid "windows_866_to_windows_1251"
msgstr "windows_866_to_windows_1251"

#: func.xml:3083(literal)
msgid "WIN"
msgstr "WIN"

#: func.xml:3087(literal)
msgid "windows_874_to_utf8"
msgstr "windows_874_to_utf8"

#: func.xml:3093(literal)
msgid "euc_jis_2004_to_utf8"
msgstr "euc_jis_2004_to_utf8"

#: func.xml:3094(literal) func.xml:3101(literal) func.xml:3118(literal)
#: func.xml:3125(literal)
msgid "EUC_JIS_2004"
msgstr "EUC_JIS_2004"

#: func.xml:3099(literal)
msgid "utf8_to_euc_jis_2004"
msgstr "utf8_to_euc_jis_2004"

#: func.xml:3105(literal)
msgid "shift_jis_2004_to_utf8"
msgstr "shift_jis_2004_to_utf8"

#: func.xml:3106(literal) func.xml:3113(literal) func.xml:3119(literal)
#: func.xml:3124(literal)
msgid "SHIFT_JIS_2004"
msgstr "SHIFT_JIS_2004"

#: func.xml:3111(literal)
msgid "utf8_to_shift_jis_2004"
msgstr "utf8_to_shift_jis_2004"

#: func.xml:3117(literal)
msgid "euc_jis_2004_to_shift_jis_2004"
msgstr "euc_jis_2004_to_shift_jis_2004"

#: func.xml:3123(literal)
msgid "shift_jis_2004_to_euc_jis_2004"
msgstr "shift_jis_2004_to_euc_jis_2004"

#: func.xml:3139(para)
msgid ""
"The function <function>format</function> produces output formatted according "
"to a format string, in a style similar to the C function <function>sprintf</"
"function>."
msgstr ""
"Функция <function>format</function> выдаёт текст, отформатированный в "
"соответствии со строкой формата, подобно функции <function>sprintf</"
"function> в C."

#: func.xml:3145(para)
msgid ""
"<synopsis>\n"
"<function>format</function>(<parameter>formatstr</parameter> <type>text</"
"type> [, <parameter>formatarg</parameter> <type>\"any\"</type> [, ...] ])\n"
"</synopsis> <replaceable>formatstr</replaceable> is a format string that "
"specifies how the result should be formatted. Text in the format string is "
"copied directly to the result, except where <firstterm>format specifiers</"
"firstterm> are used. Format specifiers act as placeholders in the string, "
"defining how subsequent function arguments should be formatted and inserted "
"into the result. Each <replaceable>formatarg</replaceable> argument is "
"converted to text according to the usual output rules for its data type, and "
"then formatted and inserted into the result string according to the format "
"specifier(s)."
msgstr ""
"<synopsis>\n"
"<function>format</function>(<parameter>formatstr</parameter> <type>text</"
"type> [, <parameter>formatarg</parameter> <type>\"any\"</type> [, ...] ])\n"
"</synopsis> <replaceable>formatstr</replaceable> &mdash; строка, "
"определяющая, как будет форматироваться результат. Обычный текст в строке "
"формата непосредственно копируется в результат, за исключением "
"<firstterm>спецификаторов формата</firstterm>. Спецификаторы формата "
"представляют собой местозаполнители, определяющие, как должны "
"форматироваться и выводиться в результате аргументы функции. Каждый аргумент "
"<replaceable>formatarg</replaceable> преобразуется в текст по правилам "
"выводам своего типа данных, а затем форматируется и вставляется в "
"результирующую строку согласно спецификаторам формата."

#: func.xml:3169(term)
msgid "<replaceable>position</replaceable> (optional)"
msgstr "<replaceable>позиция</replaceable> (необязателен)"

#: func.xml:3171(para)
msgid ""
"A string of the form <literal><replaceable>n</replaceable>$</literal> where "
"<replaceable>n</replaceable> is the index of the argument to print. Index 1 "
"means the first argument after <replaceable>formatstr</replaceable>. If the "
"<replaceable>position</replaceable> is omitted, the default is to use the "
"next argument in sequence."
msgstr ""
"Строка вида <literal><replaceable>n</replaceable>$</literal>, где "
"<replaceable>n</replaceable> &mdash; индекс выводимого аргумента. Индекс, "
"равный 1, выбирает первый аргумент после <replaceable>formatstr</"
"replaceable>. Если <replaceable>позиция</replaceable> опускается, по "
"умолчанию используется следующий аргумент по порядку."

#: func.xml:3182(term)
msgid "<replaceable>flags</replaceable> (optional)"
msgstr "<replaceable>флаги</replaceable> (необязателен)"

#: func.xml:3184(para)
msgid ""
"Additional options controlling how the format specifier's output is "
"formatted. Currently the only supported flag is a minus sign (<literal>-</"
"literal>) which will cause the format specifier's output to be left-"
"justified. This has no effect unless the <replaceable>width</replaceable> "
"field is also specified."
msgstr ""
"Дополнительные параметры, управляющие форматированием данного спецификатора. "
"В настоящее время поддерживается только знак минус (<literal>-</literal>), "
"который выравнивает результата спецификатора по левому краю. Он работает, "
"только если также определена <replaceable>ширина</replaceable>."

#: func.xml:3195(term)
msgid "<replaceable>width</replaceable> (optional)"
msgstr "<replaceable>ширина</replaceable> (необязателен)"

#: func.xml:3197(para)
msgid ""
"Specifies the <emphasis>minimum</emphasis> number of characters to use to "
"display the format specifier's output. The output is padded on the left or "
"right (depending on the <literal>-</literal> flag) with spaces as needed to "
"fill the width. A too-small width does not cause truncation of the output, "
"but is simply ignored. The width may be specified using any of the "
"following: a positive integer; an asterisk (<literal>*</literal>) to use the "
"next function argument as the width; or a string of the form "
"<literal>*<replaceable>n</replaceable>$</literal> to use the <replaceable>n</"
"replaceable>th function argument as the width."
msgstr ""
"Задаёт <emphasis>минимальное</emphasis> число символов, которое будет "
"занимать результат данного спецификатора. Выводимое значение выравнивается "
"по правой или левой стороне (в зависимости от флага <literal>-</literal>) с "
"дополнением необходимым числом пробелов. Если ширина слишком мала, она "
"просто игнорируется, т. е. результат не усекается. Ширину можно обозначить "
"положительным целым, звёздочкой (<literal>*</literal>), тогда ширина будет "
"получена из следующего аргумента функции, или строкой вида "
"<literal>*<replaceable>n</replaceable>$</literal>, тогда ширина будет "
"задаваться в <replaceable>n</replaceable>-ом аргументе функции."

#: func.xml:3209(para)
msgid ""
"If the width comes from a function argument, that argument is consumed "
"before the argument that is used for the format specifier's value. If the "
"width argument is negative, the result is left aligned (as if the <literal>-"
"</literal> flag had been specified) within a field of length <function>abs</"
"function>(<replaceable>width</replaceable>)."
msgstr ""
"Если ширина передаётся в аргументе функции, этот аргумент выбирается до "
"аргумента, используемого для спецификатора. Если аргумент ширины "
"отрицательный, результат выравнивается по левой стороне (как если бы был "
"указан флаг <literal>-</literal>) в рамках поля длины <function>abs</"
"function>(<replaceable>ширина</replaceable>)."

#: func.xml:3220(term)
msgid "<replaceable>type</replaceable> (required)"
msgstr "<replaceable>тип</replaceable> (обязателен)"

#: func.xml:3227(para)
msgid ""
"<literal>s</literal> formats the argument value as a simple string. A null "
"value is treated as an empty string."
msgstr ""
"<literal>s</literal> форматирует значение аргумента как простую строку. "
"Значение NULL представляется пустой строкой."

#: func.xml:3233(para)
msgid ""
"<literal>I</literal> treats the argument value as an SQL identifier, double-"
"quoting it if necessary. It is an error for the value to be null (equivalent "
"to <function>quote_ident</function>)."
msgstr ""
"<literal>I</literal> обрабатывает значение аргумента как SQL-идентификатор, "
"при необходимости заключая его в кавычки. Значение NULL для такого "
"преобразования считается ошибочным (так же, как и для <function>quote_ident</"
"function>)."

#: func.xml:3241(para)
msgid ""
"<literal>L</literal> quotes the argument value as an SQL literal. A null "
"value is displayed as the string <literal>NULL</literal>, without quotes "
"(equivalent to <function>quote_nullable</function>)."
msgstr ""
"<literal>L</literal> заключает значение аргумента в апострофы, как строку "
"SQL. Значение NULL выводится буквально, как <literal>NULL</literal>, без "
"кавычек (так же, как и с <function>quote_nullable</function>)."

#: func.xml:3222(para)
msgid ""
"The type of format conversion to use to produce the format specifier's "
"output. The following types are supported: <placeholder-1/>"
msgstr ""
"Тип спецификатора определяет преобразование соответствующего выводимого "
"значения. Поддерживаются следующие типы: <placeholder-1/>"

#: func.xml:3159(para)
msgid ""
"Format specifiers are introduced by a <literal>%</literal> character and "
"have the form <synopsis>\n"
"%[<replaceable>position</replaceable>][<replaceable>flags</replaceable>]"
"[<replaceable>width</replaceable>]<replaceable>type</replaceable>\n"
"</synopsis> where the component fields are: <placeholder-1/>"
msgstr ""
"Спецификаторы формата предваряются символом <literal>%</literal> и имеют "
"форму <synopsis>\n"
"%[<replaceable>позиция</replaceable>][<replaceable>флаги</replaceable>]"
"[<replaceable>ширина</replaceable>]<replaceable>тип</replaceable>\n"
"</synopsis> Здесь: <placeholder-1/>"

#: func.xml:3254(para)
msgid ""
"In addition to the format specifiers described above, the special sequence "
"<literal>%%</literal> may be used to output a literal <literal>%</literal> "
"character."
msgstr ""
"В дополнение к спецификаторам, описанным выше, можно использовать "
"спецпоследовательность <literal>%%</literal>, которая просто выведет символ "
"<literal>%</literal>."

#: func.xml:3259(para)
msgid ""
"Here are some examples of the basic format conversions: <screen>\n"
"SELECT format('Hello %s', 'World');\n"
"<lineannotation>Result: </lineannotation><computeroutput>Hello World</"
"computeroutput>\n"
"\n"
"SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');\n"
"<lineannotation>Result: </lineannotation><computeroutput>Testing one, two, "
"three, %</computeroutput>\n"
"\n"
"SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\\'Reilly');\n"
"<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO \"Foo "
"bar\" VALUES('O''Reilly')</computeroutput>\n"
"\n"
"SELECT format('INSERT INTO %I VALUES(%L)', 'locations', E'C:\\\\Program "
"Files');\n"
"<lineannotation>Result: </lineannotation><computeroutput>INSERT INTO "
"locations VALUES(E'C:\\\\Program Files')</computeroutput>\n"
"</screen>"
msgstr ""
"Несколько пример простых преобразований формата: <screen>\n"
"SELECT format('Hello %s', 'World');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>Hello World</"
"computeroutput>\n"
"\n"
"SELECT format('Testing %s, %s, %s, %%', 'one', 'two', 'three');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>Testing one, "
"two, three, %</computeroutput>\n"
"\n"
"SELECT format('INSERT INTO %I VALUES(%L)', 'Foo bar', E'O\\'Reilly');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>INSERT INTO "
"\"Foo bar\" VALUES('O''Reilly')</computeroutput>\n"
"\n"
"SELECT format('INSERT INTO %I VALUES(%L)', 'locations', E'C:\\\\Program "
"Files');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>INSERT INTO "
"locations VALUES(E'C:\\\\Program Files')</computeroutput>\n"
"</screen>"

#: func.xml:3277(para)
msgid ""
"Here are examples using <replaceable>width</replaceable> fields and the "
"<literal>-</literal> flag: <screen>\n"
"SELECT format('|%10s|', 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"\n"
"SELECT format('|%-10s|', 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%*s|', 10, 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"\n"
"SELECT format('|%*s|', -10, 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%-*s|', 10, 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%-*s|', -10, 'foo');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"</screen>"
msgstr ""
"Следующие примеры иллюстрируют использование поля <replaceable>ширина</"
"replaceable> и флага <literal>-</literal>: <screen>\n"
"SELECT format('|%10s|', 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"\n"
"SELECT format('|%-10s|', 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%*s|', 10, 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"\n"
"SELECT format('|%*s|', -10, 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%-*s|', 10, 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"\n"
"SELECT format('|%-*s|', -10, 'foo');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|foo       |</"
"computeroutput>\n"
"</screen>"

#: func.xml:3302(para)
msgid ""
"These examples show use of <replaceable>position</replaceable> fields: "
"<screen>\n"
"SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');\n"
"<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, "
"one</computeroutput>\n"
"\n"
"SELECT format('|%*2$s|', 'foo', 10, 'bar');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|       bar|</"
"computeroutput>\n"
"\n"
"SELECT format('|%1$*2$s|', 'foo', 10, 'bar');\n"
"<lineannotation>Result: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"</screen>"
msgstr ""
"Эти примеры показывают применение полей <replaceable>позиция</replaceable>: "
"<screen>\n"
"SELECT format('Testing %3$s, %2$s, %1$s', 'one', 'two', 'three');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>Testing three, "
"two, one</computeroutput>\n"
"\n"
"SELECT format('|%*2$s|', 'foo', 10, 'bar');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|       bar|</"
"computeroutput>\n"
"\n"
"SELECT format('|%1$*2$s|', 'foo', 10, 'bar');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>|       foo|</"
"computeroutput>\n"
"</screen>"

#: func.xml:3317(para)
msgid ""
"Unlike the standard C function <function>sprintf</function>, "
"<productname>PostgreSQL</productname>'s <function>format</function> function "
"allows format specifiers with and without <replaceable>position</"
"replaceable> fields to be mixed in the same format string. A format "
"specifier without a <replaceable>position</replaceable> field always uses "
"the next argument after the last argument consumed. In addition, the "
"<function>format</function> function does not require all function arguments "
"to be used in the format string. For example: <screen>\n"
"SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');\n"
"<lineannotation>Result: </lineannotation><computeroutput>Testing three, two, "
"three</computeroutput>\n"
"</screen>"
msgstr ""
"В отличие от стандартной функции C <function>sprintf</function>, функция "
"<function>format</function> в <productname>PostgreSQL</productname> "
"позволяет комбинировать в одной строке спецификаторы с полями "
"<replaceable>позиция</replaceable> и без них. Спецификатор формата без поля "
"<replaceable>позиция</replaceable> всегда использует следующий аргумент "
"после последнего выбранного. Кроме того, функция <function>format</function> "
"не требует, чтобы в строке формата использовались все аргументы функции. "
"Пример этого поведения: <screen>\n"
"SELECT format('Testing %3$s, %2$s, %s', 'one', 'two', 'three');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>Testing three, "
"two, three</computeroutput>\n"
"</screen>"

#: func.xml:3334(para)
msgid ""
"The <literal>%I</literal> and <literal>%L</literal> format specifiers are "
"particularly useful for safely constructing dynamic SQL statements. See "
"<xref linkend=\"plpgsql-quote-literal-example\"/>."
msgstr ""
"Спецификаторы формата <literal>%I</literal> и <literal>%L</literal> особенно "
"полезны для безопасного составления динамических операторов SQL. См. <xref "
"remap=\"4\" linkend=\"plpgsql-quote-literal-example\"/>."

#: func.xml:3345(title)
msgid "Binary String Functions and Operators"
msgstr "Функции и операторы двоичных строк"

#: func.xml:3347(indexterm)
msgid "<primary>binary data</primary> <secondary>functions</secondary>"
msgstr "<primary>двоичные данные</primary> <secondary>функции</secondary>"

#: func.xml:3352(para)
msgid ""
"This section describes functions and operators for examining and "
"manipulating values of type <type>bytea</type>."
msgstr ""
"В этом разделе описываются функции и операторы для работы с данными типа "
"<type>bytea</type>."

#: func.xml:3357(para)
msgid ""
"<acronym>SQL</acronym> defines some string functions that use key words, "
"rather than commas, to separate arguments. Details are in <xref linkend="
"\"functions-binarystring-sql\"/>. <productname>PostgreSQL</productname> also "
"provides versions of these functions that use the regular function "
"invocation syntax (see <xref linkend=\"functions-binarystring-other\"/>)."
msgstr ""
"В <acronym>SQL</acronym> определены несколько строковых функций, в которых "
"аргументы разделяются не запятыми, а ключевыми словами. Подробнее это "
"описано в <xref remap=\"6\" linkend=\"functions-binarystring-sql\"/>. "
"<productname>PostgreSQL</productname> также предоставляет варианты этих "
"функций с синтаксисом, обычным для функций (см. <xref remap=\"4\" linkend="
"\"functions-binarystring-other\"/>)."

#: func.xml:3368(para)
msgid ""
"The sample results shown on this page assume that the server parameter <link "
"linkend=\"guc-bytea-output\"><varname>bytea_output</varname></link> is set "
"to <literal>escape</literal> (the traditional PostgreSQL format)."
msgstr ""
"В примерах, приведённых на этой странице, подразумевается, что параметр "
"сервера <link linkend=\"guc-bytea-output\"><varname>bytea_output</varname></"
"link> равен <literal>escape</literal> (выбран традиционный формат "
"PostgreSQL)."

#: func.xml:3376(title)
msgid "<acronym>SQL</acronym> Binary String Functions and Operators"
msgstr ""
"<acronym>SQL</acronym>-функции и операторы для работы с двоичными строками"

#: func.xml:3395(indexterm)
msgid "<primary>binary string</primary> <secondary>concatenation</secondary>"
msgstr "<primary>двоичные строки</primary> <secondary>конкатенация</secondary>"

#: func.xml:3400(literal)
msgid "E'\\\\\\\\Post'::bytea || E'\\\\047gres\\\\000'::bytea"
msgstr "E'\\\\\\\\Post'::bytea || E'\\\\047gres&zwsp;\\\\000'::bytea"

#: func.xml:3401(literal)
msgid "\\\\Post'gres\\000"
msgstr "\\\\Post'gres&zwsp;\\000"

#: func.xml:3412(entry)
msgid "Number of bytes in binary string"
msgstr "Число байт в двоичной строке"

#: func.xml:3413(literal)
msgid "octet_length(E'jo\\\\000se'::bytea)"
msgstr "octet_length(E'jo\\\\000se'::bytea)"

#: func.xml:3428(literal)
msgid ""
"overlay(E'Th\\\\000omas'::bytea placing E'\\\\002\\\\003'::bytea from 2 for "
"3)"
msgstr ""
"overlay(E'Th\\\\000&zwsp;omas'::bytea placing E'\\\\002\\\\003'::bytea from "
"2 for 3)"

#: func.xml:3429(literal)
msgid "T\\\\002\\\\003mas"
msgstr "T\\\\002&zwsp;\\\\003&zwsp;mas"

#: func.xml:3441(literal)
msgid "position(E'\\\\000om'::bytea in E'Th\\\\000omas'::bytea)"
msgstr "position(E'\\\\000om'::bytea in E'Th\\\\000&zwsp;omas'::bytea)"

#: func.xml:3456(literal)
msgid "substring(E'Th\\\\000omas'::bytea from 2 for 3)"
msgstr "substring(E'Th\\\\000&zwsp;omas'::bytea from 2 for 3)"

#: func.xml:3457(literal)
msgid "h\\000o"
msgstr "h\\000o"

#: func.xml:3465(optional)
msgid "both"
msgstr "both"

#: func.xml:3466(parameter) func.xml:3510(parameter)
msgid "bytes"
msgstr "bytes"

#: func.xml:3465(function)
msgid "trim(<placeholder-1/> <placeholder-2/> from <placeholder-3/>)"
msgstr "trim(<placeholder-1/> <placeholder-2/> from <placeholder-3/>)"

#: func.xml:3470(entry)
msgid ""
"Remove the longest string containing only the bytes in <parameter>bytes</"
"parameter> from the start and end of <parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, содержащую только байты <parameter>bytes</"
"parameter>, с начала и с конца строки <parameter>string</parameter>"

#: func.xml:3475(literal)
msgid "trim(E'\\\\000'::bytea from E'\\\\000Tom\\\\000'::bytea)"
msgstr "trim(E'\\\\000'::bytea from E'\\\\000Tom&zwsp;\\\\000'::bytea)"

#: func.xml:3482(para)
msgid ""
"Additional binary string manipulation functions are available and are listed "
"in <xref linkend=\"functions-binarystring-other\"/>. Some of them are used "
"internally to implement the <acronym>SQL</acronym>-standard string functions "
"listed in <xref linkend=\"functions-binarystring-sql\"/>."
msgstr ""
"В <productname>PostgreSQL</productname> есть и другие функции для работы с "
"двоичными строками, перечисленные в <xref remap=\"6\" linkend=\"functions-"
"binarystring-other\"/>. Некоторые из них используются в качестве внутренней "
"реализации стандартных функций <acronym>SQL</acronym>, приведённых в <xref "
"remap=\"6\" linkend=\"functions-binarystring-sql\"/>."

#: func.xml:3491(title)
msgid "Other Binary String Functions"
msgstr "Другие функции для работы с двоичными строками"

#: func.xml:3509(function)
msgid ""
"btrim(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr ""
"btrim(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:3513(entry)
msgid ""
"Remove the longest string consisting only of bytes in <parameter>bytes</"
"parameter> from the start and end of <parameter>string</parameter>"
msgstr ""
"Удаляет наибольшую подстроку, состоящую только из байт <parameter>bytes</"
"parameter>, с начала и с конца строки <parameter>string</parameter>"

#: func.xml:3518(literal)
msgid "btrim(E'\\\\000trim\\\\000'::bytea, E'\\\\000'::bytea)"
msgstr "btrim(E'\\\\000trim&zwsp;\\\\000'::bytea, E'\\\\000'::bytea)"

#: func.xml:3535(literal)
msgid "decode(E'123\\\\000456', 'escape')"
msgstr "decode(E'123&zwsp;\\\\000456', 'escape')"

#: func.xml:3536(literal) func.xml:3556(literal)
msgid "123\\000456"
msgstr "123\\000456"

#: func.xml:3555(literal)
msgid "encode(E'123\\\\000456'::bytea, 'escape')"
msgstr "encode(E'123&zwsp;\\\\000456'::bytea, 'escape')"

#: func.xml:3561(indexterm)
msgid "<primary>get_bit</primary>"
msgstr "<primary>get_bit</primary>"

#: func.xml:3564(parameter) func.xml:3579(parameter) func.xml:3635(parameter)
#: func.xml:3651(parameter) func.xml:19013(parameter) func.xml:19022(parameter)
msgctxt "parameter"
msgid "offset"
msgstr "offset"

#: func.xml:3564(function)
msgid "get_bit(<placeholder-1/>, <placeholder-2/>)"
msgstr "get_bit(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:3567(entry)
msgid "Extract bit from string"
msgstr "Извлекает бит из строки"

#: func.xml:3570(literal)
msgid "get_bit(E'Th\\\\000omas'::bytea, 45)"
msgstr "get_bit(E'Th\\\\000&zwsp;omas'::bytea, 45)"

#: func.xml:3576(indexterm)
msgid "<primary>get_byte</primary>"
msgstr "<primary>get_byte</primary>"

#: func.xml:3579(function)
msgid "get_byte(<placeholder-1/>, <placeholder-2/>)"
msgstr "get_byte(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:3582(entry)
msgid "Extract byte from string"
msgstr "Извлекает байт из строки"

#: func.xml:3585(literal)
msgid "get_byte(E'Th\\\\000omas'::bytea, 4)"
msgstr "get_byte(E'Th\\\\000&zwsp;omas'::bytea, 4)"

#: func.xml:3586(literal)
msgid "109"
msgstr "109"

#: func.xml:3599(indexterm)
msgid "<primary>binary string</primary> <secondary>length</secondary>"
msgstr "<primary>двоичная строка</primary> <secondary>длина</secondary>"

#: func.xml:3603(indexterm)
msgid ""
"<primary>length</primary> <secondary sortas=\"binary string\">of a binary "
"string</secondary> <see>binary strings, length</see>"
msgstr ""
"<primary>длина</primary> <secondary sortas=\"двоичная строка\">двоичной "
"строки</secondary> <see>двоичные строки, длина</see>"

#: func.xml:3597(entry)
msgid "Length of binary string <placeholder-1/> <placeholder-2/>"
msgstr "Длина двоичной строки <placeholder-1/> <placeholder-2/>"

#: func.xml:3609(literal)
msgid "length(E'jo\\\\000se'::bytea)"
msgstr "length(E'jo\\\\000se'::bytea)"

#: func.xml:3625(literal)
msgid "md5(E'Th\\\\000omas'::bytea)"
msgstr "md5(E'Th\\\\000&zwsp;omas'::bytea)"

#: func.xml:3626(literal)
msgid "8ab2d3c9689aaf18 b4958c334c82d8b1"
msgstr "8ab2d3c9&zwsp;689aaf18 b4958c33&zwsp;4c82d8b1"

#: func.xml:3631(indexterm)
msgid "<primary>set_bit</primary>"
msgstr "<primary>set_bit</primary>"

#: func.xml:3635(parameter) func.xml:3651(parameter)
msgid "newvalue"
msgstr "newvalue"

#: func.xml:3634(function)
msgid "set_bit(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "set_bit(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:3638(entry)
msgid "Set bit in string"
msgstr "Устанавливает значение бита в строке"

#: func.xml:3641(literal)
msgid "set_bit(E'Th\\\\000omas'::bytea, 45, 0)"
msgstr "set_bit(E'Th\\\\000&zwsp;omas'::bytea, 45, 0)"

#: func.xml:3642(literal)
msgid "Th\\000omAs"
msgstr "Th\\000omAs"

#: func.xml:3647(indexterm)
msgid "<primary>set_byte</primary>"
msgstr "<primary>set_byte</primary>"

#: func.xml:3650(function)
msgid "set_byte(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "set_byte(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:3654(entry)
msgid "Set byte in string"
msgstr "Устанавливает значение байта в строке"

#: func.xml:3657(literal)
msgid "set_byte(E'Th\\\\000omas'::bytea, 4, 64)"
msgstr "set_byte(E'Th\\\\000&zwsp;omas'::bytea, 4, 64)"

#: func.xml:3658(literal)
msgid "Th\\000o@as"
msgstr "Th\\000o@as"

#: func.xml:3664(para)
msgid ""
"<function>get_byte</function> and <function>set_byte</function> number the "
"first byte of a binary string as byte 0. <function>get_bit</function> and "
"<function>set_bit</function> number bits from the right within each byte; "
"for example bit 0 is the least significant bit of the first byte, and bit 15 "
"is the most significant bit of the second byte."
msgstr ""
"Для функций <function>get_byte</function> и <function>set_byte</function> "
"байты нумеруется с 0. Функции <function>get_bit</function> и "
"<function>set_bit</function> нумеруют биты справа налево; например, бит 0 "
"будет меньшим значащим битом первого байта, а бит 15 &mdash; большим "
"значащим битом второго байта."

#: func.xml:3672(para)
msgid ""
"See also the aggregate function <function>string_agg</function> in <xref "
"linkend=\"functions-aggregate\"/> and the large object functions in <xref "
"linkend=\"lo-funcs\"/>."
msgstr ""
"См. также агрегатную функцию <function>string_agg</function> в <xref remap="
"\"6\" linkend=\"functions-aggregate\"/> и функции для работы с большими "
"объектами в <xref remap=\"6\" linkend=\"lo-funcs\"/>."

#: func.xml:3681(title)
msgid "Bit String Functions and Operators"
msgstr "Функции и операторы для работы с битовыми строками"

#: func.xml:3683(indexterm)
msgid "<primary>bit strings</primary> <secondary>functions</secondary>"
msgstr "<primary>битовые строки</primary> <secondary>функции</secondary>"

#: func.xml:3688(para)
msgid ""
"This section describes functions and operators for examining and "
"manipulating bit strings, that is values of the types <type>bit</type> and "
"<type>bit varying</type>. Aside from the usual comparison operators, the "
"operators shown in <xref linkend=\"functions-bit-string-op-table\"/> can be "
"used. Bit string operands of <literal>&amp;</literal>, <literal>|</literal>, "
"and <literal>#</literal> must be of equal length. When bit shifting, the "
"original length of the string is preserved, as shown in the examples."
msgstr ""
"В этом разделе описываются функции и операторы, предназначенные для работы с "
"битовыми строками, то есть с данными типов <type>bit</type> и <type>bit "
"varying</type>. Помимо обычных операторов сравнения, с такими данными можно "
"использовать операторы, перечисленные в <xref remap=\"6\" linkend="
"\"functions-bit-string-op-table\"/>. Заметьте, что операторы <literal>&amp;</"
"literal>, <literal>|</literal> и <literal>#</literal> работают только с "
"двоичными строками одинаковой длины. Операторы побитового сдвига сохраняют "
"длины исходных строк, как показано в примерах."

#: func.xml:3701(title)
msgid "Bit String Operators"
msgstr "Операторы для работы с битовыми строками"

#: func.xml:3716(entry)
msgid "concatenation"
msgstr "конкатенация"

#: func.xml:3717(literal)
msgid "B'10001' || B'011'"
msgstr "B'10001' || B'011'"

#: func.xml:3718(literal)
msgid "10001011"
msgstr "10001011"

#: func.xml:3724(literal)
msgid "B'10001' &amp; B'01101'"
msgstr "B'10001' &amp; B'01101'"

#: func.xml:3725(literal)
msgid "00001"
msgstr "00001"

#: func.xml:3731(literal)
msgid "B'10001' | B'01101'"
msgstr "B'10001' | B'01101'"

#: func.xml:3732(literal)
msgid "11101"
msgstr "11101"

#: func.xml:3738(literal)
msgid "B'10001' # B'01101'"
msgstr "B'10001' # B'01101'"

#: func.xml:3739(literal)
msgid "11100"
msgstr "11100"

#: func.xml:3745(literal)
msgid "~ B'10001'"
msgstr "~ B'10001'"

#: func.xml:3746(literal)
msgid "01110"
msgstr "01110"

#: func.xml:3752(literal)
msgid "B'10001' &lt;&lt; 3"
msgstr "B'10001' &lt;&lt; 3"

#: func.xml:3753(literal)
msgid "01000"
msgstr "01000"

#: func.xml:3759(literal)
msgid "B'10001' &gt;&gt; 2"
msgstr "B'10001' &gt;&gt; 2"

#: func.xml:3760(literal)
msgid "00100"
msgstr "00100"

#: func.xml:3766(para)
msgid ""
"The following <acronym>SQL</acronym>-standard functions work on bit strings "
"as well as character strings: <literal><function>length</function></"
"literal>, <literal><function>bit_length</function></literal>, "
"<literal><function>octet_length</function></literal>, "
"<literal><function>position</function></literal>, "
"<literal><function>substring</function></literal>, "
"<literal><function>overlay</function></literal>."
msgstr ""
"Следующие функции языка <acronym>SQL</acronym> работают как с символьными, "
"так и с битовыми строками: <literal><function>length</function></literal>, "
"<literal><function>bit_length</function></literal>, "
"<literal><function>octet_length</function></literal>, "
"<literal><function>position</function></literal>, "
"<literal><function>substring</function></literal>, "
"<literal><function>overlay</function></literal>."

#: func.xml:3777(para)
msgid ""
"The following functions work on bit strings as well as binary strings: "
"<literal><function>get_bit</function></literal>, <literal><function>set_bit</"
"function></literal>. When working with a bit string, these functions number "
"the first (leftmost) bit of the string as bit 0."
msgstr ""
"С битовыми и двоичными строками работают функции <literal><function>get_bit</"
"function></literal> и <literal><function>set_bit</function></literal>. При "
"работе с битовыми строками эти функции нумеруют биты слева направо и самый "
"левый бит считается нулевым."

#: func.xml:3790(programlisting)
#, no-wrap
msgid ""
"44::bit(10)                    <lineannotation>0000101100</lineannotation>\n"
"44::bit(3)                     <lineannotation>100</lineannotation>\n"
"cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>\n"
"'1110'::bit(4)::integer        <lineannotation>14</lineannotation>"
msgstr ""
"44::bit(10)                    <lineannotation>0000101100</lineannotation>\n"
"44::bit(3)                     <lineannotation>100</lineannotation>\n"
"cast(-44 as bit(12))           <lineannotation>111111010100</lineannotation>\n"
"'1110'::bit(4)::integer        <lineannotation>14</lineannotation>"

#: func.xml:3786(para)
msgid ""
"In addition, it is possible to cast integral values to and from type "
"<type>bit</type>. Some examples: <placeholder-1/> Note that casting to just "
"<quote>bit</quote> means casting to <literal>bit(1)</literal>, and so will "
"deliver only the least significant bit of the integer."
msgstr ""
"Кроме того, целые значения можно преобразовать в тип <type>bit</type> и "
"обратно. Например: <placeholder-1/> Заметьте, что приведение к типу "
"<quote>bit</quote> без длины будет означать приведение к <literal>bit(1)</"
"literal>, и в результате будет получен только один менее значащий бит числа."

#: func.xml:3802(para)
msgid ""
"Casting an integer to <type>bit(n)</type> copies the rightmost <literal>n</"
"literal> bits. Casting an integer to a bit string width wider than the "
"integer itself will sign-extend on the left."
msgstr ""
"Приведение целого числа к типу <type>bit(n)</type> копирует правые "
"<literal>n</literal> бит числа. Если же целое преобразуется в битовую строку "
"большей длины, чем требуется для этого числа, она дополняется слева битами "
"знака числа."

#: func.xml:3813(title)
msgid "Pattern Matching"
msgstr "Поиск по шаблону"

#: func.xml:3815(indexterm)
msgid "<primary>pattern matching</primary>"
msgstr "<primary>поиск по шаблону</primary>"

#: func.xml:3819(para)
msgid ""
"There are three separate approaches to pattern matching provided by "
"<productname>PostgreSQL</productname>: the traditional <acronym>SQL</"
"acronym> <function>LIKE</function> operator, the more recent "
"<function>SIMILAR TO</function> operator (added in SQL:1999), and "
"<acronym>POSIX</acronym>-style regular expressions. Aside from the basic "
"<quote>does this string match this pattern?</quote> operators, functions are "
"available to extract or replace matching substrings and to split a string at "
"matching locations."
msgstr ""
"<productname>PostgreSQL</productname> предлагает три разных способа поиска "
"текста по шаблону: традиционный оператор <function>LIKE</function> языка "
"<acronym>SQL</acronym>, более современный <function>SIMILAR TO</function> "
"(добавленный в SQL:1999) и регулярные выражения в стиле <acronym>POSIX</"
"acronym>. Помимо простых операторов, отвечающих на вопрос "
"<quote>соответствует ли строка этому шаблону?</quote>, в "
"<productname>PostgreSQL</productname> есть функции для извлечения или замены "
"соответствующих подстрок и для разделения строки по заданному шаблону."

#: func.xml:3832(para)
msgid ""
"If you have pattern matching needs that go beyond this, consider writing a "
"user-defined function in Perl or Tcl."
msgstr ""
"Если этих встроенных возможностей оказывается недостаточно, вы можете "
"написать собственные функции на языке Perl или Tcl."

#: func.xml:3839(para)
msgid ""
"While most regular-expression searches can be executed very quickly, regular "
"expressions can be contrived that take arbitrary amounts of time and memory "
"to process. Be wary of accepting regular-expression search patterns from "
"hostile sources. If you must do so, it is advisable to impose a statement "
"timeout."
msgstr ""
"Хотя чаще всего поиск по регулярному выражению бывает очень быстрым, "
"регулярные выражения бывают и настолько сложными, что их обработка может "
"занять приличное время и объём памяти. Поэтому опасайтесь шаблонов "
"регулярных выражений, поступающих из недоверенных источников. Если у вас нет "
"другого выхода, рекомендуется ввести таймаут для операторов."

#: func.xml:3847(para)
msgid ""
"Searches using <function>SIMILAR TO</function> patterns have the same "
"security hazards, since <function>SIMILAR TO</function> provides many of the "
"same capabilities as <acronym>POSIX</acronym>-style regular expressions."
msgstr ""
"Поиск с шаблонами <function>SIMILAR TO</function> несёт те же риски "
"безопасности, так как конструкция <function>SIMILAR TO</function> "
"предоставляет во многом те же возможности, что и регулярные выражения в "
"стиле <acronym>POSIX</acronym>."

#: func.xml:3854(para)
msgid ""
"<function>LIKE</function> searches, being much simpler than the other two "
"options, are safer to use with possibly-hostile pattern sources."
msgstr ""
"Поиск с <function>LIKE</function> гораздо проще, чем два другие варианта, "
"поэтому его безопаснее использовать с недоверенными источниками шаблонов "
"поиска."

#: func.xml:3861(function)
msgid "LIKE"
msgstr "LIKE"

#: func.xml:3863(indexterm)
msgid "<primary>LIKE</primary>"
msgstr "<primary>LIKE</primary>"

#: func.xml:3868(replaceable) func.xml:3869(replaceable)
#: func.xml:3969(replaceable) func.xml:3970(replaceable)
msgctxt "replaceable"
msgid "string"
msgstr "строка"

#: func.xml:3868(replaceable) func.xml:3869(replaceable)
#: func.xml:3969(replaceable) func.xml:3970(replaceable)
msgid "escape-character"
msgstr "спецсимвол"

#: func.xml:3868(optional) func.xml:3869(optional) func.xml:3969(optional)
#: func.xml:3970(optional)
msgid "ESCAPE <placeholder-1/>"
msgstr "ESCAPE <placeholder-1/>"

#: func.xml:3867(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> LIKE <placeholder-2/> <placeholder-3/>\n"
"<placeholder-4/> NOT LIKE <placeholder-5/> <placeholder-6/>"
msgstr ""
"<placeholder-1/> LIKE <placeholder-2/> <placeholder-3/>\n"
"<placeholder-4/> NOT LIKE <placeholder-5/> <placeholder-6/>"

#: func.xml:3872(para)
msgid ""
"The <function>LIKE</function> expression returns true if the "
"<replaceable>string</replaceable> matches the supplied <replaceable>pattern</"
"replaceable>. (As expected, the <function>NOT LIKE</function> expression "
"returns false if <function>LIKE</function> returns true, and vice versa. An "
"equivalent expression is <literal>NOT (<replaceable>string</replaceable> "
"LIKE <replaceable>pattern</replaceable>)</literal>.)"
msgstr ""
"Выражение <function>LIKE</function> возвращает true, если "
"<replaceable>строка</replaceable> соответствует заданному "
"<replaceable>шаблону</replaceable>. (Как можно было ожидать, выражение "
"<function>NOT LIKE</function> возвращает false, когда <function>LIKE</"
"function> возвращает true, и наоборот. Этому выражению равносильно выражение "
"<literal>NOT (<replaceable>строка</replaceable> LIKE <replaceable>шаблон</"
"replaceable>)</literal>.)"

#: func.xml:3883(para)
msgid ""
"If <replaceable>pattern</replaceable> does not contain percent signs or "
"underscores, then the pattern only represents the string itself; in that "
"case <function>LIKE</function> acts like the equals operator. An underscore "
"(<literal>_</literal>) in <replaceable>pattern</replaceable> stands for "
"(matches) any single character; a percent sign (<literal>%</literal>) "
"matches any sequence of zero or more characters."
msgstr ""
"Если <replaceable>шаблон</replaceable> не содержит знаков процента и "
"подчёркиваний, тогда шаблон представляет в точности строку и <function>LIKE</"
"function> работает как оператор сравнения. Подчёркивание (<literal>_</"
"literal>) в <replaceable>шаблоне</replaceable> подменяет (вместо него "
"подходит) любой символ; а знак процента (<literal>%</literal>) подменяет "
"любую (в том числе и пустую) последовательность символов."

#: func.xml:3895(programlisting)
#, no-wrap
msgid ""
"'abc' LIKE 'abc'    <lineannotation>true</lineannotation>\n"
"'abc' LIKE 'a%'     <lineannotation>true</lineannotation>\n"
"'abc' LIKE '_b_'    <lineannotation>true</lineannotation>\n"
"'abc' LIKE 'c'      <lineannotation>false</lineannotation>"
msgstr ""
"'abc' LIKE 'abc'    <lineannotation>true</lineannotation>\n"
"'abc' LIKE 'a%'     <lineannotation>true</lineannotation>\n"
"'abc' LIKE '_b_'    <lineannotation>true</lineannotation>\n"
"'abc' LIKE 'c'      <lineannotation>false</lineannotation>"

#: func.xml:3893(para) func.xml:4068(para) func.xml:4195(para)
#: func.xml:4227(para) func.xml:4263(para) func.xml:4301(para)
#: func.xml:4360(para)
msgid "Some examples: <placeholder-1/>"
msgstr "Несколько примеров: <placeholder-1/>"

#: func.xml:3903(para)
msgid ""
"<function>LIKE</function> pattern matching always covers the entire string. "
"Therefore, if it's desired to match a sequence anywhere within a string, the "
"pattern must start and end with a percent sign."
msgstr ""
"При проверке по шаблону <function>LIKE</function> всегда рассматривается вся "
"строка. Поэтому, если нужно найти последовательность символов где-то в "
"середине строки, шаблон должен начинаться и заканчиваться знаками процента."

#: func.xml:3909(para)
msgid ""
"To match a literal underscore or percent sign without matching other "
"characters, the respective character in <replaceable>pattern</replaceable> "
"must be preceded by the escape character. The default escape character is "
"the backslash but a different one can be selected by using the "
"<literal>ESCAPE</literal> clause. To match the escape character itself, "
"write two escape characters."
msgstr ""
"Чтобы найти в строке буквальное вхождение знака процента или подчёркивания, "
"перед соответствующим символом в <replaceable>шаблоне</replaceable> нужно "
"добавить спецсимвол. По умолчанию в качестве спецсимвола выбрана обратная "
"косая черта, но с помощью предложения <literal>ESCAPE</literal> можно "
"выбрать и другой. Чтобы включить спецсимвол в шаблон поиска, продублируйте "
"его."

#: func.xml:3920(para) func.xml:4569(para)
msgid ""
"If you have <xref linkend=\"guc-standard-conforming-strings\"/> turned off, "
"any backslashes you write in literal string constants will need to be "
"doubled. See <xref linkend=\"sql-syntax-strings\"/> for more information."
msgstr ""
"Если параметр <xref linkend=\"guc-standard-conforming-strings\"/> выключен, "
"каждый символ обратной косой черты, записываемый в текстовой константе, "
"нужно дублировать. Подробнее это описано в <xref remap=\"6\" linkend=\"sql-"
"syntax-strings\"/>."

#: func.xml:3927(para)
msgid ""
"It's also possible to select no escape character by writing <literal>ESCAPE "
"''</literal>. This effectively disables the escape mechanism, which makes it "
"impossible to turn off the special meaning of underscore and percent signs "
"in the pattern."
msgstr ""
"Также можно отказаться от спецсимвола, написав <literal>ESCAPE ''</literal>. "
"При этом механизм спецпоследовательностей фактически отключается и "
"использовать знаки процента и подчёркивания буквально в шаблоне нельзя."

#: func.xml:3934(para)
msgid ""
"The key word <token>ILIKE</token> can be used instead of <token>LIKE</token> "
"to make the match case-insensitive according to the active locale. This is "
"not in the <acronym>SQL</acronym> standard but is a <productname>PostgreSQL</"
"productname> extension."
msgstr ""
"Вместо <token>LIKE</token> можно использовать ключевое слово <token>ILIKE</"
"token>, чтобы поиск был регистр-независимым с учётом текущей языковой среды. "
"Этот оператор не описан в стандарте <acronym>SQL</acronym>; это расширение "
"<productname>PostgreSQL</productname>."

#: func.xml:3941(para)
msgid ""
"The operator <literal>~~</literal> is equivalent to <function>LIKE</"
"function>, and <literal>~~*</literal> corresponds to <function>ILIKE</"
"function>. There are also <literal>!~~</literal> and <literal>!~~*</literal> "
"operators that represent <function>NOT LIKE</function> and <function>NOT "
"ILIKE</function>, respectively. All of these operators are "
"<productname>PostgreSQL</productname>-specific."
msgstr ""
"Кроме того, в <productname>PostgreSQL</productname> есть оператор "
"<literal>~~</literal>, равнозначный <function>LIKE</function>, и "
"<literal>~~*</literal>, соответствующий <function>ILIKE</function>. Есть "
"также два оператора <literal>!~~</literal> и <literal>!~~*</literal>, "
"представляющие <function>NOT LIKE</function> и <function>NOT ILIKE</"
"function>, соответственно. Все эти операторы можно отнести к особенностям "
"<productname>PostgreSQL</productname>."

#: func.xml:3954(title)
msgid "<function>SIMILAR TO</function> Regular Expressions"
msgstr "Регулярные выражения <function>SIMILAR TO</function>"

#: func.xml:3956(indexterm)
msgid "<primary>regular expression</primary>"
msgstr "<primary>регулярное выражение</primary>"

#: func.xml:3961(indexterm)
msgid "<primary>SIMILAR TO</primary>"
msgstr "<primary>SIMILAR TO</primary>"

#: func.xml:3968(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> SIMILAR TO <placeholder-2/> <placeholder-3/>\n"
"<placeholder-4/> NOT SIMILAR TO <placeholder-5/> <placeholder-6/>"
msgstr ""
"<placeholder-1/> SIMILAR TO <placeholder-2/> <placeholder-3/>\n"
"<placeholder-4/> NOT SIMILAR TO <placeholder-5/> <placeholder-6/>"

#: func.xml:3973(para)
msgid ""
"The <function>SIMILAR TO</function> operator returns true or false depending "
"on whether its pattern matches the given string. It is similar to "
"<function>LIKE</function>, except that it interprets the pattern using the "
"SQL standard's definition of a regular expression. SQL regular expressions "
"are a curious cross between <function>LIKE</function> notation and common "
"regular expression notation."
msgstr ""
"Оператор <function>SIMILAR TO</function> возвращает true или false в "
"зависимости от того, соответствует ли данная строка шаблону или нет. Он "
"работает подобно оператору <function>LIKE</function>, только его шаблоны "
"соответствуют определению регулярных выражений в стандарте SQL. Регулярные "
"выражения SQL представляют собой любопытный гибрид синтаксиса "
"<function>LIKE</function> с синтаксисом обычных регулярных выражений."

#: func.xml:3983(para)
msgid ""
"Like <function>LIKE</function>, the <function>SIMILAR TO</function> operator "
"succeeds only if its pattern matches the entire string; this is unlike "
"common regular expression behavior where the pattern can match any part of "
"the string. Also like <function>LIKE</function>, <function>SIMILAR TO</"
"function> uses <literal>_</literal> and <literal>%</literal> as wildcard "
"characters denoting any single character and any string, respectively (these "
"are comparable to <literal>.</literal> and <literal>.*</literal> in POSIX "
"regular expressions)."
msgstr ""
"Как и <function>LIKE</function>, условие <function>SIMILAR TO</function> "
"истинно, только если шаблон соответствует всей строке; это отличается от "
"условий с регулярными выражениями, в которых шаблон может соответствовать "
"любой части строки. Также подобно <function>LIKE</function>, "
"<function>SIMILAR TO</function> воспринимает символы <literal>_</literal> и "
"<literal>%</literal> как знаки подстановки, подменяющие любой один символ "
"или любую подстроку, соответственно (в регулярных выражениях POSIX им "
"аналогичны символы <literal>.</literal> и <literal>.*</literal>)."

#: func.xml:4003(para)
msgid "<literal>|</literal> denotes alternation (either of two alternatives)."
msgstr "<literal>|</literal> означает выбор (одного из двух вариантов)."

#: func.xml:4008(para)
msgid ""
"<literal>*</literal> denotes repetition of the previous item zero or more "
"times."
msgstr ""
"<literal>*</literal> означает повторение предыдущего элемента 0 и более раз."

#: func.xml:4014(para)
msgid ""
"<literal>+</literal> denotes repetition of the previous item one or more "
"times."
msgstr ""
"<literal>+</literal> означает повторение предыдущего элемента 1 и более раз."

#: func.xml:4020(para)
msgid ""
"<literal>?</literal> denotes repetition of the previous item zero or one "
"time."
msgstr ""
"<literal>?</literal> означает вхождение предыдущего элемента 0 или 1 раз."

#: func.xml:4026(para)
msgid ""
"<literal>{</literal><replaceable>m</replaceable><literal>}</literal> denotes "
"repetition of the previous item exactly <replaceable>m</replaceable> times."
msgstr ""
"<literal>{</literal><replaceable>m</replaceable><literal>}</literal> "
"означает повторяет предыдущего элемента ровно <replaceable>m</replaceable> "
"раз."

#: func.xml:4032(para)
msgid ""
"<literal>{</literal><replaceable>m</replaceable><literal>,}</literal> "
"denotes repetition of the previous item <replaceable>m</replaceable> or more "
"times."
msgstr ""
"<literal>{</literal><replaceable>m</replaceable><literal>,}</literal> "
"означает повторение предыдущего элемента <replaceable>m</replaceable> или "
"более раз."

#: func.xml:4038(para)
msgid ""
"<literal>{</literal><replaceable>m</replaceable><literal>,</"
"literal><replaceable>n</replaceable><literal>}</literal> denotes repetition "
"of the previous item at least <replaceable>m</replaceable> and not more than "
"<replaceable>n</replaceable> times."
msgstr ""
"<literal>{</literal><replaceable>m</replaceable><literal>,</"
"literal><replaceable>n</replaceable><literal>}</literal> означает повторение "
"предыдущего элемента не менее чем <replaceable>m</replaceable> и не более "
"чем <replaceable>n</replaceable> раз."

#: func.xml:4045(para)
msgid ""
"Parentheses <literal>()</literal> can be used to group items into a single "
"logical item."
msgstr ""
"Скобки <literal>()</literal> объединяют несколько элементов в одну "
"логическую группу."

#: func.xml:4051(para)
msgid ""
"A bracket expression <literal>[...]</literal> specifies a character class, "
"just as in POSIX regular expressions."
msgstr ""
"Квадратные скобки <literal>[...]</literal> обозначают класс символов так же, "
"как и в регулярных выражениях POSIX."

#: func.xml:3996(para)
msgid ""
"In addition to these facilities borrowed from <function>LIKE</function>, "
"<function>SIMILAR TO</function> supports these pattern-matching "
"metacharacters borrowed from POSIX regular expressions: <placeholder-1/> "
"Notice that the period (<literal>.</literal>) is not a metacharacter for "
"<function>SIMILAR TO</function>."
msgstr ""
"Помимо средств описания шаблонов, позаимствованных от <function>LIKE</"
"function>, <function>SIMILAR TO</function> поддерживает следующие "
"метасимволы, унаследованные от регулярных выражений POSIX: <placeholder-1/> "
"Обратите внимание, точка (<literal>.</literal>) не является метасимволом для "
"оператора <function>SIMILAR TO</function>."

#: func.xml:4062(para)
msgid ""
"As with <function>LIKE</function>, a backslash disables the special meaning "
"of any of these metacharacters; or a different escape character can be "
"specified with <literal>ESCAPE</literal>."
msgstr ""
"Как и с <function>LIKE</function>, обратная косая черта отменяет специальное "
"значение любого из этих метасимволов, а предложение <literal>ESCAPE</"
"literal> позволяет выбрать другой спецсимвол."

#: func.xml:4070(programlisting)
#, no-wrap
msgid ""
"'abc' SIMILAR TO 'abc'      <lineannotation>true</lineannotation>\n"
"'abc' SIMILAR TO 'a'        <lineannotation>false</lineannotation>\n"
"'abc' SIMILAR TO '%(b|d)%'  <lineannotation>true</lineannotation>\n"
"'abc' SIMILAR TO '(b|c)%'   <lineannotation>false</lineannotation>"
msgstr ""
"'abc' SIMILAR TO 'abc'      <lineannotation>true</lineannotation>\n"
"'abc' SIMILAR TO 'a'        <lineannotation>false</lineannotation>\n"
"'abc' SIMILAR TO '%(b|d)%'  <lineannotation>true</lineannotation>\n"
"'abc' SIMILAR TO '(b|c)%'   <lineannotation>false</lineannotation>"

#: func.xml:4078(para)
msgid ""
"The <function>substring</function> function with three parameters, "
"<function>substring(<replaceable>string</replaceable> from "
"<replaceable>pattern</replaceable> for <replaceable>escape-character</"
"replaceable>)</function>, provides extraction of a substring that matches an "
"SQL regular expression pattern. As with <literal>SIMILAR TO</literal>, the "
"specified pattern must match the entire data string, or else the function "
"fails and returns null. To indicate the part of the pattern that should be "
"returned on success, the pattern must contain two occurrences of the escape "
"character followed by a double quote (<literal>\"</literal>). The text "
"matching the portion of the pattern between these markers is returned."
msgstr ""
"Функция <function>substring</function> с тремя параметрами, "
"<function>substring(<replaceable>строка</replaceable> from "
"<replaceable>шаблон</replaceable> for <replaceable>спецсимвол</"
"replaceable>)</function> извлекает подстроку, соответствующую шаблону "
"регулярного выражения SQL. Как и с <literal>SIMILAR TO</literal>, указанному "
"шаблону должна соответствовать вся строка, в противном случае функция не "
"найдёт ничего и вернёт NULL. Для обозначения части шаблона, которая должна "
"быть возвращена в случае успеха, шаблон должен содержать два спецсимвола и "
"кавычки (<literal>\"</literal>) после каждого. Эта функция возвращает часть "
"шаблона между двумя такими маркерами."

#: func.xml:4096(programlisting)
#, no-wrap
msgid ""
"substring('foobar' from '%#\"o_b#\"%' for '#')   <lineannotation>oob</lineannotation>\n"
"substring('foobar' from '#\"o_b#\"%' for '#')    <lineannotation>NULL</lineannotation>"
msgstr ""
"substring('foobar' from '%#\"o_b#\"%' for '#')   <lineannotation>oob</lineannotation>\n"
"substring('foobar' from '#\"o_b#\"%' for '#')    <lineannotation>NULL</lineannotation>"

#: func.xml:4094(para)
msgid ""
"Some examples, with <literal>#\"</literal> delimiting the return string: "
"<placeholder-1/>"
msgstr ""
"Несколько примеров с маркерами <literal>#\"</literal>, выделяющими "
"возвращаемую строку: <placeholder-1/>"

#: func.xml:4104(title)
msgid "<acronym>POSIX</acronym> Regular Expressions"
msgstr "Регулярные выражения <acronym>POSIX</acronym>"

#: func.xml:4106(indexterm)
msgid ""
"<primary>regular expression</primary> <seealso>pattern matching</seealso>"
msgstr ""
"<primary>регулярное выражение</primary> <seealso>поиск по шаблону</seealso>"

#: func.xml:4126(para)
msgid ""
"<xref linkend=\"functions-posix-table\"/> lists the available operators for "
"pattern matching using POSIX regular expressions."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-posix-table\"/> перечислены все "
"существующие операторы для проверки строк регулярными выражениями POSIX."

#: func.xml:4132(title)
msgid "Regular Expression Match Operators"
msgstr "Операторы регулярных выражений"

#: func.xml:4146(entry)
msgid "Matches regular expression, case sensitive"
msgstr "Проверяет соответствие регулярному выражению с учётом регистра"

#: func.xml:4147(literal)
msgid "'thomas' ~ '.*thomas.*'"
msgstr "'thomas' ~ '.*thomas.*'"

#: func.xml:4151(literal)
msgid "~*"
msgstr "~*"

#: func.xml:4152(entry)
msgid "Matches regular expression, case insensitive"
msgstr "Проверяет соответствие регулярному выражению без учёта регистра"

#: func.xml:4153(literal)
msgid "'thomas' ~* '.*Thomas.*'"
msgstr "'thomas' ~* '.*Thomas.*'"

#: func.xml:4157(literal)
msgid "!~"
msgstr "!~"

#: func.xml:4158(entry)
msgid "Does not match regular expression, case sensitive"
msgstr "Проверяет несоответствие регулярному выражению с учётом регистра"

#: func.xml:4159(literal)
msgid "'thomas' !~ '.*Thomas.*'"
msgstr "'thomas' !~ '.*Thomas.*'"

#: func.xml:4163(literal)
msgid "!~*"
msgstr "!~*"

#: func.xml:4164(entry)
msgid "Does not match regular expression, case insensitive"
msgstr "Проверяет несоответствие регулярному выражению без учёта регистра"

#: func.xml:4165(literal)
msgid "'thomas' !~* '.*vadim.*'"
msgstr "'thomas' !~* '.*vadim.*'"

#: func.xml:4171(para)
msgid ""
"<acronym>POSIX</acronym> regular expressions provide a more powerful means "
"for pattern matching than the <function>LIKE</function> and "
"<function>SIMILAR TO</function> operators. Many Unix tools such as "
"<command>egrep</command>, <command>sed</command>, or <command>awk</command> "
"use a pattern matching language that is similar to the one described here."
msgstr ""
"Регулярные выражения <acronym>POSIX</acronym> предоставляют более мощные "
"средства поиска по шаблонам, чем операторы <function>LIKE</function> и "
"<function>SIMILAR TO</function>. Во многих командах Unix, таких как "
"<command>egrep</command>, <command>sed</command> и <command>awk</command> "
"используется язык шаблонов, похожий на описанный здесь."

#: func.xml:4180(para)
msgid ""
"A regular expression is a character sequence that is an abbreviated "
"definition of a set of strings (a <firstterm>regular set</firstterm>). A "
"string is said to match a regular expression if it is a member of the "
"regular set described by the regular expression. As with <function>LIKE</"
"function>, pattern characters match string characters exactly unless they "
"are special characters in the regular expression language &mdash; but "
"regular expressions use different special characters than <function>LIKE</"
"function> does. Unlike <function>LIKE</function> patterns, a regular "
"expression is allowed to match anywhere within a string, unless the regular "
"expression is explicitly anchored to the beginning or end of the string."
msgstr ""
"Регулярное выражение &mdash; это последовательность символов, представляющая "
"собой краткое определение набора строк (<firstterm>регулярное множество</"
"firstterm>). Строка считается соответствующей регулярному выражению, если "
"она является членом регулярного множества, описываемого регулярным "
"выражением. Как и для <function>LIKE</function>, символы шаблона "
"непосредственно соответствуют символам строки, за исключением специальных "
"символов языка регулярных выражений. При этом спецсимволы регулярных "
"выражений отличается от спецсимволов <function>LIKE</function>. В отличие от "
"шаблонов <function>LIKE</function>, регулярное выражение может совпадать с "
"любой частью строки, если только оно не привязано явно к началу и/или концу "
"строки."

#: func.xml:4197(programlisting)
#, no-wrap
msgid ""
"'abc' ~ 'abc'    <lineannotation>true</lineannotation>\n"
"'abc' ~ '^a'     <lineannotation>true</lineannotation>\n"
"'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>\n"
"'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>"
msgstr ""
"'abc' ~ 'abc'    <lineannotation>true</lineannotation>\n"
"'abc' ~ '^a'     <lineannotation>true</lineannotation>\n"
"'abc' ~ '(b|d)'  <lineannotation>true</lineannotation>\n"
"'abc' ~ '^(b|c)' <lineannotation>false</lineannotation>"

#: func.xml:4205(para)
msgid ""
"The <acronym>POSIX</acronym> pattern language is described in much greater "
"detail below."
msgstr ""
"Более подробно язык шаблонов в стиле <acronym>POSIX</acronym> описан ниже."

#: func.xml:4210(para)
msgid ""
"The <function>substring</function> function with two parameters, "
"<function>substring(<replaceable>string</replaceable> from "
"<replaceable>pattern</replaceable>)</function>, provides extraction of a "
"substring that matches a POSIX regular expression pattern. It returns null "
"if there is no match, otherwise the portion of the text that matched the "
"pattern. But if the pattern contains any parentheses, the portion of the "
"text that matched the first parenthesized subexpression (the one whose left "
"parenthesis comes first) is returned. You can put parentheses around the "
"whole expression if you want to use parentheses within it without triggering "
"this exception. If you need parentheses in the pattern before the "
"subexpression you want to extract, see the non-capturing parentheses "
"described below."
msgstr ""
"Функция <function>substring</function> с двумя параметрами, "
"<function>substring(<replaceable>строка</replaceable> from "
"<replaceable>шаблон</replaceable>)</function>, извлекает подстроку, "
"соответствующую шаблону регулярного выражения POSIX. Она возвращает фрагмент "
"текста, подходящий шаблону, если таковой находится в строке, либо NULL в "
"противном случае. Но если шаблон содержит скобки, она возвращает первое "
"подвыражение, заключённое в скобки (то, которое начинается с самой первой "
"открывающей скобки). Если вы хотите использовать скобки, но не в таком "
"особом режиме, можно просто заключить в них всё выражение. Если же вам нужно "
"включить скобки в шаблон до подвыражения, которое вы хотите извлечь, это "
"можно сделать, используя группы без захвата, которые будут описаны ниже."

#: func.xml:4229(programlisting)
#, no-wrap
msgid ""
"substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>\n"
"substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>"
msgstr ""
"substring('foobar' from 'o.b')     <lineannotation>oob</lineannotation>\n"
"substring('foobar' from 'o(.)b')   <lineannotation>o</lineannotation>"

#: func.xml:4235(para)
msgid ""
"The <function>regexp_replace</function> function provides substitution of "
"new text for substrings that match POSIX regular expression patterns. It has "
"the syntax <function>regexp_replace</function>(<replaceable>source</"
"replaceable>, <replaceable>pattern</replaceable>, <replaceable>replacement</"
"replaceable> <optional>, <replaceable>flags</replaceable></optional>). The "
"<replaceable>source</replaceable> string is returned unchanged if there is "
"no match to the <replaceable>pattern</replaceable>. If there is a match, the "
"<replaceable>source</replaceable> string is returned with the "
"<replaceable>replacement</replaceable> string substituted for the matching "
"substring. The <replaceable>replacement</replaceable> string can contain "
"<literal>\\</literal><replaceable>n</replaceable>, where <replaceable>n</"
"replaceable> is 1 through 9, to indicate that the source substring matching "
"the <replaceable>n</replaceable>'th parenthesized subexpression of the "
"pattern should be inserted, and it can contain <literal>\\&amp;</literal> to "
"indicate that the substring matching the entire pattern should be inserted. "
"Write <literal>\\\\</literal> if you need to put a literal backslash in the "
"replacement text. The <replaceable>flags</replaceable> parameter is an "
"optional text string containing zero or more single-letter flags that change "
"the function's behavior. Flag <literal>i</literal> specifies case-"
"insensitive matching, while flag <literal>g</literal> specifies replacement "
"of each matching substring rather than only the first one. Supported flags "
"(though not <literal>g</literal>) are described in <xref linkend=\"posix-"
"embedded-options-table\"/>."
msgstr ""
"Функция <function>regexp_replace</function> подставляет другой текст вместо "
"подстрок, соответствующих шаблонам регулярных выражений POSIX. Она имеет "
"синтаксис <function>regexp_replace</function>(<replaceable>исходная_строка</"
"replaceable>, <replaceable>шаблон</replaceable>, <replaceable>замена</"
"replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Если "
"<replaceable>исходная_строка</replaceable> не содержит фрагмента, "
"подходящего под <replaceable>шаблон</replaceable>, она возвращается "
"неизменной. Если же соответствие находится, возвращается "
"<replaceable>исходная_строка</replaceable>, в которой вместо "
"соответствующего фрагмента подставляется <replaceable>замена</replaceable>. "
"Строка <replaceable>замена</replaceable> может содержать <literal>\\</"
"literal><replaceable>n</replaceable>, где <replaceable>n</replaceable> "
"&mdash; число от 1 до 9, указывающее на исходный фрагмент, соответствующий "
"<replaceable>n</replaceable>-ому подвыражению в скобках, и может содержать "
"обозначение <literal>\\&amp;</literal>, указывающее, что будет вставлен "
"фрагмент, соответствующий всему шаблону. Если же в текст замены нужно "
"включить обратную косую черту буквально, следует написать <literal>\\\\</"
"literal>. В необязательном параметре <replaceable>флаги</replaceable> "
"передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, "
"меняющих поведение функции. Флаг <literal>i</literal> включает поиск без "
"учёта регистра, а флаг <literal>g</literal> указывает, что заменяться должны "
"все подходящие подстроки, а не только первая из них. Допустимые флаги (кроме "
"<literal>g</literal>) описаны в <xref remap=\"6\" linkend=\"posix-embedded-"
"options-table\"/>."

#: func.xml:4265(programlisting)
#, no-wrap
msgid ""
"regexp_replace('foobarbaz', 'b..', 'X')\n"
"                                   <lineannotation>fooXbaz</lineannotation>\n"
"regexp_replace('foobarbaz', 'b..', 'X', 'g')\n"
"                                   <lineannotation>fooXX</lineannotation>\n"
"regexp_replace('foobarbaz', 'b(..)', E'X\\\\1Y', 'g')\n"
"                                   <lineannotation>fooXarYXazY</lineannotation>"
msgstr ""
"regexp_replace('foobarbaz', 'b..', 'X')\n"
"                                   <lineannotation>fooXbaz</lineannotation>\n"
"regexp_replace('foobarbaz', 'b..', 'X', 'g')\n"
"                                   <lineannotation>fooXX</lineannotation>\n"
"regexp_replace('foobarbaz', 'b(..)', E'X\\\\1Y', 'g')\n"
"                                   <lineannotation>fooXarYXazY</lineannotation>"

#: func.xml:4275(para)
msgid ""
"The <function>regexp_matches</function> function returns a text array of all "
"of the captured substrings resulting from matching a POSIX regular "
"expression pattern. It has the syntax <function>regexp_matches</"
"function>(<replaceable>string</replaceable>, <replaceable>pattern</"
"replaceable> <optional>, <replaceable>flags</replaceable></optional>). The "
"function can return no rows, one row, or multiple rows (see the <literal>g</"
"literal> flag below). If the <replaceable>pattern</replaceable> does not "
"match, the function returns no rows. If the pattern contains no "
"parenthesized subexpressions, then each row returned is a single-element "
"text array containing the substring matching the whole pattern. If the "
"pattern contains parenthesized subexpressions, the function returns a text "
"array whose <replaceable>n</replaceable>'th element is the substring "
"matching the <replaceable>n</replaceable>'th parenthesized subexpression of "
"the pattern (not counting <quote>non-capturing</quote> parentheses; see "
"below for details). The <replaceable>flags</replaceable> parameter is an "
"optional text string containing zero or more single-letter flags that change "
"the function's behavior. Flag <literal>g</literal> causes the function to "
"find each match in the string, not only the first one, and return a row for "
"each such match. Supported flags (though not <literal>g</literal>) are "
"described in <xref linkend=\"posix-embedded-options-table\"/>."
msgstr ""
"Функция <function>regexp_matches</function> возвращает текстовый массив из "
"всех подходящих подстрок, полученных в результате применения регулярного "
"выражения POSIX. Она имеет синтаксис <function>regexp_matches</"
"function>(<replaceable>строка</replaceable>, <replaceable>шаблон</"
"replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Эта "
"функция может вовсе не вернуть строк или вернуть одну или несколько строк "
"(см. описание флага <literal>g</literal> ниже). Если <replaceable>шаблон</"
"replaceable> не находится в строке, функция не возвращает строк. Если шаблон "
"не содержит подвыражений в скобках, тогда для каждой строки возвращается "
"массив с одним элементом, содержащим подстроку, соответствующую всему "
"шаблону. Если же шаблон содержит подвыражения в скобках, функция возвращает "
"массив элементов, в котором <replaceable>n</replaceable>-эй элемент "
"соответствует <replaceable>n</replaceable>-ому подвыражению в скобках (не "
"считая скобки <quote>без захвата</quote>; подробнее об этом ниже). В "
"необязательном параметре <replaceable>флаги</replaceable> передаётся "
"текстовая строка, содержащая ноль или более однобуквенных флагов, меняющих "
"поведение функции. Флаг <literal>g</literal> указывает, что функция должна "
"находить в строке не только первое, а все соответствия шаблону, и возвращать "
"строку для каждого соответствия. Допустимые флаги (кроме <literal>g</"
"literal>) описаны в <xref remap=\"6\" linkend=\"posix-embedded-options-table"
"\"/>."

#: func.xml:4303(programlisting)
#, no-wrap
msgid ""
"SELECT regexp_matches('foobarbequebaz', '(bar)(beque)');\n"
" regexp_matches \n"
"----------------\n"
" {bar,beque}\n"
"(1 row)\n"
"\n"
"SELECT regexp_matches('foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');\n"
" regexp_matches \n"
"----------------\n"
" {bar,beque}\n"
" {bazil,barf}\n"
"(2 rows)\n"
"\n"
"SELECT regexp_matches('foobarbequebaz', 'barbeque');\n"
" regexp_matches \n"
"----------------\n"
" {barbeque}\n"
"(1 row)"
msgstr ""
"SELECT regexp_matches('foobarbequebaz', '(bar)(beque)');\n"
" regexp_matches \n"
"----------------\n"
" {bar,beque}\n"
"(1 row)\n"
"\n"
"SELECT regexp_matches(\n"
" 'foobarbequebazilbarfbonk', '(b[^b]+)(b[^b]+)', 'g');\n"
" regexp_matches \n"
"----------------\n"
" {bar,beque}\n"
" {bazil,barf}\n"
"(2 rows)\n"
"\n"
"SELECT regexp_matches('foobarbequebaz', 'barbeque');\n"
" regexp_matches \n"
"----------------\n"
" {barbeque}\n"
"(1 row)"

#: func.xml:4330(programlisting)
#, no-wrap
msgid "SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;"
msgstr "SELECT col1, (SELECT regexp_matches(col2, '(bar)(beque)')) FROM tab;"

#: func.xml:4325(para)
msgid ""
"It is possible to force <function>regexp_matches()</function> to always "
"return one row by using a sub-select; this is particularly useful in a "
"<literal>SELECT</literal> target list when you want all rows returned, even "
"non-matching ones: <placeholder-1/>"
msgstr ""
"Добиться, чтобы функция <function>regexp_matches()</function> всегда "
"возвращала одну строку, можно с помощью вложенного подзапроса; это особенно "
"полезно в списке выборки <literal>SELECT</literal>, когда нужно получить все "
"строки, в том числе и не соответствующие шаблону: <placeholder-1/>"

#: func.xml:4335(para)
msgid ""
"The <function>regexp_split_to_table</function> function splits a string "
"using a POSIX regular expression pattern as a delimiter. It has the syntax "
"<function>regexp_split_to_table</function>(<replaceable>string</"
"replaceable>, <replaceable>pattern</replaceable> <optional>, "
"<replaceable>flags</replaceable></optional>). If there is no match to the "
"<replaceable>pattern</replaceable>, the function returns the "
"<replaceable>string</replaceable>. If there is at least one match, for each "
"match it returns the text from the end of the last match (or the beginning "
"of the string) to the beginning of the match. When there are no more "
"matches, it returns the text from the end of the last match to the end of "
"the string. The <replaceable>flags</replaceable> parameter is an optional "
"text string containing zero or more single-letter flags that change the "
"function's behavior. <function>regexp_split_to_table</function> supports the "
"flags described in <xref linkend=\"posix-embedded-options-table\"/>."
msgstr ""
"Функция <function>regexp_split_to_table</function> разделяет строку, "
"используя в качестве разделителя шаблон регулярного выражения POSIX. Она "
"имеет синтаксис <function>regexp_split_to_table</"
"function>(<replaceable>строка</replaceable>, <replaceable>шаблон</"
"replaceable> <optional>, <replaceable>флаги</replaceable></optional>). Если "
"<replaceable>шаблон</replaceable> не находится в переданной строке, "
"возвращается вся <replaceable>строка</replaceable> целиком. Если находится "
"минимум одно вхождение, для каждого такого вхождения возвращается текст от "
"конца предыдущего вхождения (или начала строки) до начала вхождения. После "
"последнего найденного вхождения возвращается фрагмент от его конца до конца "
"строки. В необязательном параметре <replaceable>флаги</replaceable> "
"передаётся текстовая строка, содержащая ноль или более однобуквенных флагов, "
"меняющих поведение функции. Флаги, которые поддерживает "
"<function>regexp_split_to_table</function>, описаны в <xref remap=\"6\" "
"linkend=\"posix-embedded-options-table\"/>."

#: func.xml:4351(para)
msgid ""
"The <function>regexp_split_to_array</function> function behaves the same as "
"<function>regexp_split_to_table</function>, except that "
"<function>regexp_split_to_array</function> returns its result as an array of "
"<type>text</type>. It has the syntax <function>regexp_split_to_array</"
"function>(<replaceable>string</replaceable>, <replaceable>pattern</"
"replaceable> <optional>, <replaceable>flags</replaceable></optional>). The "
"parameters are the same as for <function>regexp_split_to_table</function>."
msgstr ""
"Функция <function>regexp_split_to_array</function> ведёт себя подобно "
"<function>regexp_split_to_table</function>, за исключением того, что "
"<function>regexp_split_to_array</function> возвращает результат в массиве "
"элементов типа <type>text</type>. Она имеет синтаксис "
"<function>regexp_split_to_array</function>(<replaceable>строка</"
"replaceable>, <replaceable>шаблон</replaceable> <optional>, "
"<replaceable>флаги</replaceable></optional>). Параметры у этой функции те "
"же, что и у <function>regexp_split_to_table</function>."

#: func.xml:4362(programlisting)
#, no-wrap
msgid ""
"SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', E'\\\\s+') AS foo;\n"
"  foo   \n"
"-------\n"
" the    \n"
" quick  \n"
" brown  \n"
" fox    \n"
" jumps \n"
" over   \n"
" the    \n"
" lazy   \n"
" dog    \n"
"(9 rows)\n"
"\n"
"SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', E'\\\\s+');\n"
"              regexp_split_to_array             \n"
"-----------------------------------------------\n"
" {the,quick,brown,fox,jumps,over,the,lazy,dog}\n"
"(1 row)\n"
"\n"
"SELECT foo FROM regexp_split_to_table('the quick brown fox', E'\\\\s*') AS foo;\n"
" foo \n"
"-----\n"
" t         \n"
" h         \n"
" e         \n"
" q         \n"
" u         \n"
" i         \n"
" c         \n"
" k         \n"
" b         \n"
" r         \n"
" o         \n"
" w         \n"
" n         \n"
" f         \n"
" o         \n"
" x         \n"
"(16 rows)"
msgstr ""
"SELECT foo FROM regexp_split_to_table('the quick brown fox jumps over the lazy dog', E'\\\\s+') AS foo;\n"
"  foo   \n"
"-------\n"
" the    \n"
" quick  \n"
" brown  \n"
" fox    \n"
" jumps \n"
" over   \n"
" the    \n"
" lazy   \n"
" dog    \n"
"(9 rows)\n"
"\n"
"SELECT regexp_split_to_array('the quick brown fox jumps over the lazy dog', E'\\\\s+');\n"
"              regexp_split_to_array             \n"
"-----------------------------------------------\n"
" {the,quick,brown,fox,jumps,over,the,lazy,dog}\n"
"(1 row)\n"
"\n"
"SELECT foo FROM regexp_split_to_table('the quick brown fox', E'\\\\s*') AS foo;\n"
" foo \n"
"-----\n"
" t         \n"
" h         \n"
" e         \n"
" q         \n"
" u         \n"
" i         \n"
" c         \n"
" k         \n"
" b         \n"
" r         \n"
" o         \n"
" w         \n"
" n         \n"
" f         \n"
" o         \n"
" x         \n"
"(16 rows)"

#: func.xml:4407(para)
msgid ""
"As the last example demonstrates, the regexp split functions ignore zero-"
"length matches that occur at the start or end of the string or immediately "
"after a previous match. This is contrary to the strict definition of regexp "
"matching that is implemented by <function>regexp_matches</function>, but is "
"usually the most convenient behavior in practice. Other software systems "
"such as Perl use similar definitions."
msgstr ""
"Как показывает последний пример, функции разделения по регулярным выражениям "
"игнорируют вхождения нулевой длины, идущие в начале и в конце строки, а "
"также непосредственно за предыдущим вхождением. Это поведение противоречит "
"строгому определению поиска по регулярным выражениям, который реализует "
"<function>regexp_matches</function>, но обычно более удобно на практике. "
"Подобное поведение наблюдается и в других программных средах, например в "
"Perl."

#: func.xml:4419(title)
msgid "Regular Expression Details"
msgstr "Подробное описание регулярных выражений"

#: func.xml:4421(para)
msgid ""
"<productname>PostgreSQL</productname>'s regular expressions are implemented "
"using a software package written by Henry Spencer. Much of the description "
"of regular expressions below is copied verbatim from his manual."
msgstr ""
"Регулярные выражения в <productname>PostgreSQL</productname> реализованы с "
"использованием программного пакета, который разработал Генри Спенсер (Henry "
"Spencer). Практически всё следующее описание регулярных выражений дословно "
"скопировано из его руководства."

#: func.xml:4428(para)
msgid ""
"Regular expressions (<acronym>RE</acronym>s), as defined in <acronym>POSIX</"
"acronym> 1003.2, come in two forms: <firstterm>extended</firstterm> "
"<acronym>RE</acronym>s or <acronym>ERE</acronym>s (roughly those of "
"<command>egrep</command>), and <firstterm>basic</firstterm> <acronym>RE</"
"acronym>s or <acronym>BRE</acronym>s (roughly those of <command>ed</"
"command>). <productname>PostgreSQL</productname> supports both forms, and "
"also implements some extensions that are not in the POSIX standard, but have "
"become widely used due to their availability in programming languages such "
"as Perl and Tcl. <acronym>RE</acronym>s using these non-POSIX extensions are "
"called <firstterm>advanced</firstterm> <acronym>RE</acronym>s or "
"<acronym>ARE</acronym>s in this documentation. AREs are almost an exact "
"superset of EREs, but BREs have several notational incompatibilities (as "
"well as being much more limited). We first describe the ARE and ERE forms, "
"noting features that apply only to AREs, and then describe how BREs differ."
msgstr ""
"Регулярное выражение (Regular expression, <acronym>RE</acronym>), согласно "
"определению в <acronym>POSIX</acronym> 1003.2, может иметь две формы: "
"<firstterm>расширенное</firstterm> <acronym>RE</acronym> или <acronym>ERE</"
"acronym> (грубо говоря, это выражения которые понимает <command>egrep</"
"command>) и <firstterm>простое</firstterm> <acronym>RE</acronym> или "
"<acronym>BRE</acronym> (грубо говоря, это выражения для <command>ed</"
"command>). <productname>PostgreSQL</productname> поддерживает обе формы, а "
"кроме того реализует некоторые расширения, не предусмотренные стандартом "
"POSIX, но широко используемые вследствие их доступности в некоторых языках "
"программирования, например в Perl и Tcl. Регулярные выражения, использующие "
"эти несовместимые с POSIX расширения, здесь называются "
"<firstterm>усовершенствованными</firstterm> <acronym>RE</acronym> или "
"<acronym>ARE</acronym>. ARE практически представляют собой надмножество ERE, "
"тогда как BRE отличаются некоторой несовместимостью в записи (помимо того, "
"что они гораздо более ограничены). Сначала мы опишем формы ARE и ERE, "
"отметив особенности, присущие только ARE, а затем расскажем, чем от них "
"отличаются BRE."

#: func.xml:4449(para)
msgid ""
"<productname>PostgreSQL</productname> always initially presumes that a "
"regular expression follows the ARE rules. However, the more limited ERE or "
"BRE rules can be chosen by prepending an <firstterm>embedded option</"
"firstterm> to the RE pattern, as described in <xref linkend=\"posix-"
"metasyntax\"/>. This can be useful for compatibility with applications that "
"expect exactly the <acronym>POSIX</acronym> 1003.2 rules."
msgstr ""
"<productname>PostgreSQL</productname> изначально всегда предполагает, что "
"регулярное выражение следует правилам ARE. Однако можно переключиться на "
"более ограниченные правила ERE или BRE, добавив в шаблон RE "
"<firstterm>встроенный параметр</firstterm>, как описано в <xref remap=\"6\" "
"linkend=\"posix-metasyntax\"/>. Это может быть полезно для совместимости с "
"приложениями, ожидающими от СУБД строгого следования правилам "
"<acronym>POSIX</acronym> 1003.2."

#: func.xml:4459(para)
msgid ""
"A regular expression is defined as one or more <firstterm>branches</"
"firstterm>, separated by <literal>|</literal>. It matches anything that "
"matches one of the branches."
msgstr ""
"Регулярное выражение определяется как одна или более <firstterm>ветвей</"
"firstterm>, разделённых символами <literal>|</literal>. Оно считается "
"соответствующим всему, что соответствует одной из этих ветвей."

#: func.xml:4466(para)
msgid ""
"A branch is zero or more <firstterm>quantified atoms</firstterm> or "
"<firstterm>constraints</firstterm>, concatenated. It matches a match for the "
"first, followed by a match for the second, etc; an empty branch matches the "
"empty string."
msgstr ""
"Ветвь &mdash; это ноль или несколько <firstterm>количественных атомов</"
"firstterm> или <firstterm>ограничений</firstterm>, соединённых вместе. "
"Соответствие ветви в целом образуется из соответствия первой части, за "
"которым следует соответствие второй части и т. д.; пустой ветви "
"соответствует пустая строка."

#: func.xml:4473(para)
msgid ""
"A quantified atom is an <firstterm>atom</firstterm> possibly followed by a "
"single <firstterm>quantifier</firstterm>. Without a quantifier, it matches a "
"match for the atom. With a quantifier, it can match some number of matches "
"of the atom. An <firstterm>atom</firstterm> can be any of the possibilities "
"shown in <xref linkend=\"posix-atoms-table\"/>. The possible quantifiers and "
"their meanings are shown in <xref linkend=\"posix-quantifiers-table\"/>."
msgstr ""
"Количественный атом &mdash; это <firstterm>атом</firstterm>, за которым "
"может следовать <firstterm>определитель количества</firstterm>. Без этого "
"определителя ему соответствует одно вхождение атома. С определителем "
"количества ему может соответствовать некоторое число вхождений этого атома. "
"Все возможные <firstterm>атомы</firstterm> перечислены в <xref remap=\"6\" "
"linkend=\"posix-atoms-table\"/>. Варианты определителей количества и их "
"значения перечислены в <xref remap=\"6\" linkend=\"posix-quantifiers-table\"/"
">."

#: func.xml:4484(para)
msgid ""
"A <firstterm>constraint</firstterm> matches an empty string, but matches "
"only when specific conditions are met. A constraint can be used where an "
"atom could be used, except it cannot be followed by a quantifier. The simple "
"constraints are shown in <xref linkend=\"posix-constraints-table\"/>; some "
"more constraints are described later."
msgstr ""
"<firstterm>Ограничению</firstterm> соответствует пустая строка, но это "
"соответствие возможно только при выполнении определённых условий. "
"Ограничения могут использоваться там же, где и атомы, за исключением того, "
"что их нельзя дополнять определителями количества. Простые ограничения "
"показаны в <xref remap=\"6\" linkend=\"posix-constraints-table\"/>; "
"некоторые дополнительные ограничения описаны ниже."

#: func.xml:4495(title)
msgid "Regular Expression Atoms"
msgstr "Атомы регулярных выражений"

#: func.xml:4500(entry)
msgid "Atom"
msgstr "Атом"

#: func.xml:4507(literal)
msgid "("
msgstr "("

#: func.xml:4507(replaceable) func.xml:4514(replaceable)
#: func.xml:4703(replaceable) func.xml:4710(replaceable)
#: func.xml:4717(replaceable) func.xml:4724(replaceable)
msgid "re"
msgstr "re"

#: func.xml:4507(literal) func.xml:4514(literal) func.xml:4703(literal)
#: func.xml:4710(literal) func.xml:4717(literal) func.xml:4724(literal)
msgid ")"
msgstr ")"

#: func.xml:4508(entry)
msgid ""
"(where <replaceable>re</replaceable> is any regular expression) matches a "
"match for <replaceable>re</replaceable>, with the match noted for possible "
"reporting"
msgstr ""
"(где <replaceable>re</replaceable> &mdash; любое регулярное выражение) "
"описывает соответствие <replaceable>re</replaceable>, при этом данное "
"соответствие захватывается для последующей обработки"

#: func.xml:4514(literal)
msgid "(?:"
msgstr "(?:"

#: func.xml:4515(entry)
msgid ""
"as above, but the match is not noted for reporting (a <quote>non-capturing</"
"quote> set of parentheses) (AREs only)"
msgstr ""
"подобно предыдущему, но соответствие не захватывается (т. е. это набор "
"скобок <quote>без захвата</quote>) (применимо только к ARE)"

#: func.xml:4521(literal)
msgid "."
msgstr "."

#: func.xml:4522(entry)
msgid "matches any single character"
msgstr "соответствует любому символу"

#: func.xml:4526(literal)
msgid "["
msgstr "["

#: func.xml:4526(replaceable)
msgid "chars"
msgstr "символы"

#: func.xml:4526(literal)
msgid "]"
msgstr "]"

#: func.xml:4527(entry)
msgid ""
"a <firstterm>bracket expression</firstterm>, matching any one of the "
"<replaceable>chars</replaceable> (see <xref linkend=\"posix-bracket-"
"expressions\"/> for more detail)"
msgstr ""
"<firstterm>выражение в квадратных скобках</firstterm>, соответствует любому "
"из <replaceable>символов</replaceable> (подробнее это описано в <xref remap="
"\"6\" linkend=\"posix-bracket-expressions\"/>)"

#: func.xml:4533(literal) func.xml:4540(literal) func.xml:4994(literal)
#: func.xml:5002(literal) func.xml:5161(literal) func.xml:5167(literal)
msgid "\\"
msgstr "\\"

#: func.xml:4533(replaceable)
msgid "k"
msgstr "k"

#: func.xml:4534(entry)
msgid ""
"(where <replaceable>k</replaceable> is a non-alphanumeric character) matches "
"that character taken as an ordinary character, e.g., <literal>\\\\</literal> "
"matches a backslash character"
msgstr ""
"(где <replaceable>k</replaceable> &mdash; не алфавитно-цифровой символ) "
"соответствует обычному символу буквально, т. е. <literal>\\\\</literal> "
"соответствует обратной косой черте"

#: func.xml:4540(replaceable)
msgctxt "replaceable"
msgid "c"
msgstr "c"

#: func.xml:4541(entry)
msgid ""
"where <replaceable>c</replaceable> is alphanumeric (possibly followed by "
"other characters) is an <firstterm>escape</firstterm>, see <xref linkend="
"\"posix-escape-sequences\"/> (AREs only; in EREs and BREs, this matches "
"<replaceable>c</replaceable>)"
msgstr ""
"где <replaceable>c</replaceable> &mdash; алфавитно-цифровой символ (за "
"которым могут следовать другие символы), это <firstterm>спецсимвол</"
"firstterm>, см. <xref remap=\"4\" linkend=\"posix-escape-sequences\"/> "
"(применим только к ARE; в ERE и BRE этому атому соответствует "
"<replaceable>c</replaceable>)"

#: func.xml:4548(literal) func.xml:4604(literal) func.xml:4609(literal)
#: func.xml:4615(literal) func.xml:4637(literal) func.xml:4642(literal)
#: func.xml:4648(literal)
msgid "{"
msgstr "{"

#: func.xml:4549(entry)
msgid ""
"when followed by a character other than a digit, matches the left-brace "
"character <literal>{</literal>; when followed by a digit, it is the "
"beginning of a <replaceable>bound</replaceable> (see below)"
msgstr ""
"когда за этим символом следует любой символ, кроме цифры, этот атом "
"соответствует левой фигурной скобке (<literal>{</literal>), если же за ним "
"следует цифра, это обозначает начало <replaceable>границы</replaceable> (см. "
"ниже)"

#: func.xml:4557(entry)
msgid ""
"where <replaceable>x</replaceable> is a single character with no other "
"significance, matches that character"
msgstr ""
"(где <replaceable>x</replaceable> &mdash; один символ, не имеющий "
"специального значения) соответствует этому символу"

#: func.xml:4564(para)
msgid "An RE cannot end with a backslash (<literal>\\</literal>)."
msgstr ""
"Выражение RE не может заканчиваться обратной косой чертой (<literal>\\</"
"literal>)."

#: func.xml:4577(title)
msgid "Regular Expression Quantifiers"
msgstr "Определители количества в регулярных выражениях"

#: func.xml:4582(entry)
msgid "Quantifier"
msgstr "Определитель"

#: func.xml:4583(entry)
msgid "Matches"
msgstr "Соответствует"

#: func.xml:4590(entry)
msgid "a sequence of 0 or more matches of the atom"
msgstr "0 или более вхождений атома"

#: func.xml:4595(entry)
msgid "a sequence of 1 or more matches of the atom"
msgstr "1 или более вхождений атома"

#: func.xml:4599(literal) func.xml:10738(literal)
msgid "?"
msgstr "?"

#: func.xml:4600(entry)
msgid "a sequence of 0 or 1 matches of the atom"
msgstr "0 или 1 вхождение атома"

#: func.xml:4604(replaceable) func.xml:4609(replaceable)
#: func.xml:4615(replaceable) func.xml:4637(replaceable)
#: func.xml:4642(replaceable) func.xml:4648(replaceable)
#: func.xml:5161(replaceable)
msgctxt "replaceable"
msgid "m"
msgstr "m"

#: func.xml:4604(literal) func.xml:4615(literal)
msgid "}"
msgstr "}"

#: func.xml:4605(entry)
msgid "a sequence of exactly <replaceable>m</replaceable> matches of the atom"
msgstr "ровно <replaceable>m</replaceable> вхождений атома"

#: func.xml:4609(literal)
msgid ",}"
msgstr ",}"

#: func.xml:4610(entry)
msgid "a sequence of <replaceable>m</replaceable> or more matches of the atom"
msgstr "<replaceable>m</replaceable> или более вхождений атома"

#: func.xml:4615(literal) func.xml:4648(literal)
msgid ","
msgstr ","

#: func.xml:4615(replaceable) func.xml:4648(replaceable)
msgctxt "replaceable"
msgid "n"
msgstr "n"

#: func.xml:4616(entry)
msgid ""
"a sequence of <replaceable>m</replaceable> through <replaceable>n</"
"replaceable> (inclusive) matches of the atom; <replaceable>m</replaceable> "
"cannot exceed <replaceable>n</replaceable>"
msgstr ""
"от <replaceable>m</replaceable> до <replaceable>n</replaceable> (включая "
"границы) вхождений атома; <replaceable>m</replaceable> не может быть больше "
"<replaceable>n</replaceable>"

#: func.xml:4622(literal)
msgid "*?"
msgstr "*?"

#: func.xml:4623(entry)
msgid "non-greedy version of <literal>*</literal>"
msgstr "не жадная версия <literal>*</literal>"

#: func.xml:4627(literal)
msgid "+?"
msgstr "+?"

#: func.xml:4628(entry)
msgid "non-greedy version of <literal>+</literal>"
msgstr "не жадная версия <literal>+</literal>"

#: func.xml:4632(literal)
msgid "??"
msgstr "??"

#: func.xml:4633(entry)
msgid "non-greedy version of <literal>?</literal>"
msgstr "не жадная версия <literal>?</literal>"

#: func.xml:4637(literal) func.xml:4648(literal)
msgid "}?"
msgstr "}?"

#: func.xml:4638(entry)
msgid ""
"non-greedy version of <literal>{</literal><replaceable>m</"
"replaceable><literal>}</literal>"
msgstr ""
"не жадная версия <literal>{</literal><replaceable>m</replaceable><literal>}</"
"literal>"

#: func.xml:4642(literal)
msgid ",}?"
msgstr ",}?"

#: func.xml:4643(entry)
msgid ""
"non-greedy version of <literal>{</literal><replaceable>m</"
"replaceable><literal>,}</literal>"
msgstr ""
"не жадная версия <literal>{</literal><replaceable>m</replaceable><literal>,}"
"</literal>"

#: func.xml:4649(entry)
msgid ""
"non-greedy version of <literal>{</literal><replaceable>m</"
"replaceable><literal>,</literal><replaceable>n</replaceable><literal>}</"
"literal>"
msgstr ""
"не жадная версия <literal>{</literal><replaceable>m</replaceable><literal>,</"
"literal><replaceable>n</replaceable><literal>}</literal>"

#: func.xml:4655(para)
msgid ""
"The forms using <literal>{</literal><replaceable>...</replaceable><literal>}"
"</literal> are known as <firstterm>bounds</firstterm>. The numbers "
"<replaceable>m</replaceable> and <replaceable>n</replaceable> within a bound "
"are unsigned decimal integers with permissible values from 0 to 255 "
"inclusive."
msgstr ""
"В формах с <literal>{</literal><replaceable>...</replaceable><literal>}</"
"literal> числа <replaceable>m</replaceable> и <replaceable>n</replaceable> "
"определяют так называемые <firstterm>границы</firstterm> количества. Эти "
"числа должны быть беззнаковыми десятичными целыми в диапазоне от 0 до 255 "
"включительно."

#: func.xml:4662(para)
msgid ""
"<firstterm>Non-greedy</firstterm> quantifiers (available in AREs only) match "
"the same possibilities as their corresponding normal (<firstterm>greedy</"
"firstterm>) counterparts, but prefer the smallest number rather than the "
"largest number of matches. See <xref linkend=\"posix-matching-rules\"/> for "
"more detail."
msgstr ""
"<firstterm>Не жадные</firstterm> определители (допустимые только в ARE) "
"описывают те же возможные соответствия, что и аналогичные им обычные (&laquo;"
"<firstterm>жадные</firstterm>&raquo;), но предпочитают выбирать наименьшее, "
"а не наибольшее количество вхождений. Подробнее это описано в <xref remap="
"\"6\" linkend=\"posix-matching-rules\"/>."

#: func.xml:4671(para)
msgid ""
"A quantifier cannot immediately follow another quantifier, e.g., "
"<literal>**</literal> is invalid. A quantifier cannot begin an expression or "
"subexpression or follow <literal>^</literal> or <literal>|</literal>."
msgstr ""
"Определители количества не могут следовать один за другим, например запись "
"<literal>**</literal> будет ошибочной. Кроме того, определители не могут "
"стоять в начале выражения или подвыражения и идти сразу после <literal>^</"
"literal> или <literal>|</literal>."

#: func.xml:4681(title)
msgid "Regular Expression Constraints"
msgstr "Ограничения в регулярных выражениях"

# #-#-#-#-#  -  #-#-#-#-#
# refragment
#: func.xml:4686(entry)
msgid "Constraint"
msgstr "Ограничение"

#: func.xml:4694(entry)
msgid "matches at the beginning of the string"
msgstr "соответствует началу строки"

#: func.xml:4698(literal)
msgid "$"
msgstr "$"

#: func.xml:4699(entry)
msgid "matches at the end of the string"
msgstr "соответствует концу строки"

#: func.xml:4703(literal)
msgid "(?="
msgstr "(?="

#: func.xml:4704(entry)
msgid ""
"<firstterm>positive lookahead</firstterm> matches at any point where a "
"substring matching <replaceable>re</replaceable> begins (AREs only)"
msgstr ""
"<firstterm>позитивный просмотр вперёд</firstterm> находит соответствие там, "
"где начинается подстрока, соответствующая <replaceable>re</replaceable> "
"(только для ARE)"

#: func.xml:4710(literal)
msgid "(?!"
msgstr "(?!"

#: func.xml:4711(entry)
msgid ""
"<firstterm>negative lookahead</firstterm> matches at any point where no "
"substring matching <replaceable>re</replaceable> begins (AREs only)"
msgstr ""
"<firstterm>негативный просмотр вперёд</firstterm> находит соответствие там, "
"где не начинается подстрока, соответствующая <replaceable>re</replaceable> "
"(только для ARE)"

#: func.xml:4717(literal)
msgid "(?&lt;="
msgstr "(?&lt;="

#: func.xml:4718(entry)
msgid ""
"<firstterm>positive lookbehind</firstterm> matches at any point where a "
"substring matching <replaceable>re</replaceable> ends (AREs only)"
msgstr ""
"<firstterm>позитивный просмотр назад</firstterm> находит соответствие там, "
"где заканчивается подстрока, соответствующая <replaceable>re</replaceable> "
"(только для ARE)"

#: func.xml:4724(literal)
msgid "(?&lt;!"
msgstr "(?&lt;!"

#: func.xml:4725(entry)
msgid ""
"<firstterm>negative lookbehind</firstterm> matches at any point where no "
"substring matching <replaceable>re</replaceable> ends (AREs only)"
msgstr ""
"<firstterm>негативный просмотр назад</firstterm> находит соответствие там, "
"где не заканчивается подстрока, соответствующая <replaceable>re</"
"replaceable> (только для ARE)"

#: func.xml:4733(para)
msgid ""
"Lookahead and lookbehind constraints cannot contain <firstterm>back "
"references</firstterm> (see <xref linkend=\"posix-escape-sequences\"/>), and "
"all parentheses within them are considered non-capturing."
msgstr ""
"Ограничения просмотра вперёд и назад не могут содержать <firstterm>ссылки "
"назад</firstterm> (см. <xref remap=\"4\" linkend=\"posix-escape-sequences\"/"
">), и все скобки в них считаются &laquo;скобками без захвата&raquo;."

#: func.xml:4741(title)
msgid "Bracket Expressions"
msgstr "Выражения в квадратных скобках"

#: func.xml:4743(para)
msgid ""
"A <firstterm>bracket expression</firstterm> is a list of characters enclosed "
"in <literal>[]</literal>. It normally matches any single character from the "
"list (but see below). If the list begins with <literal>^</literal>, it "
"matches any single character <emphasis>not</emphasis> from the rest of the "
"list. If two characters in the list are separated by <literal>-</literal>, "
"this is shorthand for the full range of characters between those two "
"(inclusive) in the collating sequence, e.g., <literal>[0-9]</literal> in "
"<acronym>ASCII</acronym> matches any decimal digit. It is illegal for two "
"ranges to share an endpoint, e.g., <literal>a-c-e</literal>. Ranges are very "
"collating-sequence-dependent, so portable programs should avoid relying on "
"them."
msgstr ""
"<firstterm>Выражение в квадратных скобках</firstterm> содержит список "
"символов, заключённый в <literal>[]</literal>. Обычно ему соответствует "
"любой символ из списка (об исключении написано ниже). Если список начинается "
"с <literal>^</literal>, ему соответствует любой символ, который "
"<emphasis>не</emphasis> перечисляется далее в этом списке. Если два символа "
"в списке разделяются знаком <literal>-</literal>, это воспринимается как "
"краткая запись полного интервала символов между двумя заданными (и включая "
"их) в порядке сортировки; например выражению <literal>[0-9]</literal> в "
"<acronym>ASCII</acronym> соответствует любая десятичная цифра. Два интервала "
"не могут разделять одну границу, т. е. выражение <literal>a-c-e</literal> "
"недопустимо. Интервалы зависят от порядка сортировки, который может "
"меняться, поэтому в переносимых программах их лучше не использовать."

#: func.xml:4760(para)
msgid ""
"To include a literal <literal>]</literal> in the list, make it the first "
"character (after <literal>^</literal>, if that is used). To include a "
"literal <literal>-</literal>, make it the first or last character, or the "
"second endpoint of a range. To use a literal <literal>-</literal> as the "
"first endpoint of a range, enclose it in <literal>[.</literal> and "
"<literal>.]</literal> to make it a collating element (see below). With the "
"exception of these characters, some combinations using <literal>[</literal> "
"(see next paragraphs), and escapes (AREs only), all other special characters "
"lose their special significance within a bracket expression. In particular, "
"<literal>\\</literal> is not special when following ERE or BRE rules, though "
"it is special (as introducing an escape) in AREs."
msgstr ""
"Чтобы включить в список <literal>]</literal>, этот символ нужно написать "
"первым (сразу за <literal>^</literal>, если он присутствует). Чтобы включить "
"в список символ <literal>-</literal>, его нужно написать первым или "
"последним, либо как вторую границу интервала. Указать <literal>-</literal> в "
"качестве первой границы интервал можно, заключив его между <literal>[.</"
"literal> и <literal>.]</literal>, чтобы он стал элементом сортировки (см. "
"ниже). За исключением этих символов, некоторых комбинаций с <literal>[</"
"literal> (см. следующие абзацы) и спецсимволов (в ARE), все остальные "
"специальные символы в квадратных скобках теряют своё особое значение. В "
"частности, символ <literal>\\</literal> по правилам ERE или BRE "
"воспринимается как обычный, хотя в ARE он экранирует символ, следующий за "
"ним."

#: func.xml:4776(para)
msgid ""
"Within a bracket expression, a collating element (a character, a multiple-"
"character sequence that collates as if it were a single character, or a "
"collating-sequence name for either) enclosed in <literal>[.</literal> and "
"<literal>.]</literal> stands for the sequence of characters of that "
"collating element. The sequence is treated as a single element of the "
"bracket expression's list. This allows a bracket expression containing a "
"multiple-character collating element to match more than one character, e.g., "
"if the collating sequence includes a <literal>ch</literal> collating "
"element, then the RE <literal>[[.ch.]]*c</literal> matches the first five "
"characters of <literal>chchcc</literal>."
msgstr ""
"Выражения в квадратных скобках могут содержать элемент сортировки (символ "
"или последовательность символов или имя такой последовательности), "
"определение которого заключается между <literal>[.</literal> и <literal>.]</"
"literal>. Определяющая его последовательность воспринимается в выражении в "
"скобках как один элемент. Это позволяет включать в такие выражения элементы, "
"соответствующие последовательности нескольких символов. Например, с "
"элементом сортировки <literal>ch</literal> в квадратных скобках регулярному "
"выражению <literal>[[.ch.]]*c</literal> будут соответствовать первые пять "
"символов строки <literal>chchcc</literal>."

#: func.xml:4792(para)
msgid ""
"<productname>PostgreSQL</productname> currently does not support multi-"
"character collating elements. This information describes possible future "
"behavior."
msgstr ""
"В настоящее время <productname>PostgreSQL</productname> не поддерживает "
"элементы сортировки, состоящие из нескольких символов. Эта информация "
"относится к возможному в будущем поведению."

#: func.xml:4798(para)
msgid ""
"Within a bracket expression, a collating element enclosed in <literal>[=</"
"literal> and <literal>=]</literal> is an <firstterm>equivalence class</"
"firstterm>, standing for the sequences of characters of all collating "
"elements equivalent to that one, including itself. (If there are no other "
"equivalent collating elements, the treatment is as if the enclosing "
"delimiters were <literal>[.</literal> and <literal>.]</literal>.) For "
"example, if <literal>o</literal> and <literal>^</literal> are the members of "
"an equivalence class, then <literal>[[=o=]]</literal>, <literal>[[=^=]]</"
"literal>, and <literal>[o^]</literal> are all synonymous. An equivalence "
"class cannot be an endpoint of a range."
msgstr ""
"В квадратных скобках могут содержаться элементы сортировки, заключённые "
"между <literal>[=</literal> и <literal>=]</literal>, обозначающие "
"<firstterm>классы эквивалентности</firstterm>, т. е. последовательности "
"символов из всех элементов сортировки, эквивалентных указанному, включая его "
"самого. (Если для этого символа нет эквивалентных, он обрабатывается, как "
"заключённый между <literal>[.</literal> и <literal>.]</literal>.) Например, "
"если <literal>е</literal> и <literal>ё</literal> &mdash; члены одного класса "
"эквивалентности, выражения <literal>[[=е=]]</literal>, <literal>[[=ё=]]</"
"literal> и <literal>[её]</literal> будут равнозначными. Класс "
"эквивалентности нельзя указать в качестве границы интервала."

#: func.xml:4812(para)
msgid ""
"Within a bracket expression, the name of a character class enclosed in "
"<literal>[:</literal> and <literal>:]</literal> stands for the list of all "
"characters belonging to that class. Standard character class names are: "
"<literal>alnum</literal>, <literal>alpha</literal>, <literal>blank</"
"literal>, <literal>cntrl</literal>, <literal>digit</literal>, "
"<literal>graph</literal>, <literal>lower</literal>, <literal>print</"
"literal>, <literal>punct</literal>, <literal>space</literal>, "
"<literal>upper</literal>, <literal>xdigit</literal>. These stand for the "
"character classes defined in <citerefentry><refentrytitle>ctype</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>. A locale can provide "
"others. A character class cannot be used as an endpoint of a range."
msgstr ""
"В квадратных скобках может также содержаться имя класса символов, "
"заключённое между <literal>[:</literal> и <literal>:]</literal>, и "
"заменяющее список всех символов этого класса. Стандартные имена классов: "
"<literal>alnum</literal>, <literal>alpha</literal>, <literal>blank</"
"literal>, <literal>cntrl</literal>, <literal>digit</literal>, "
"<literal>graph</literal>, <literal>lower</literal>, <literal>print</"
"literal>, <literal>punct</literal>, <literal>space</literal>, "
"<literal>upper</literal> и <literal>xdigit</literal>. Весь этот набор "
"классов определён в <citerefentry><refentrytitle>ctype</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> и он может меняться в "
"зависимости от локали (языковой среды). Класс символов также нельзя "
"использовать в качестве границы интервала."

#: func.xml:4829(para)
msgid ""
"There are two special cases of bracket expressions: the bracket expressions "
"<literal>[[:&lt;:]]</literal> and <literal>[[:&gt;:]]</literal> are "
"constraints, matching empty strings at the beginning and end of a word "
"respectively. A word is defined as a sequence of word characters that is "
"neither preceded nor followed by word characters. A word character is an "
"<literal>alnum</literal> character (as defined by "
"<citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>) or an underscore. This is an extension, compatible with but "
"not specified by <acronym>POSIX</acronym> 1003.2, and should be used with "
"caution in software intended to be portable to other systems. The constraint "
"escapes described below are usually preferable; they are no more standard, "
"but are easier to type."
msgstr ""
"Есть два особых вида выражений в квадратных скобках: выражения <literal>[[:"
"&lt;:]]</literal> и <literal>[[:&gt;:]]</literal>, представляющие собой "
"ограничения, соответствующие пустым строкам в начале и конце слова. Слово в "
"данном контексте определяется как последовательность словосоставляющих "
"символов, перед или после которой нет словосоставляющих символов. "
"Словосоставляющий символ &mdash; это символ класса <literal>alnum</literal> "
"(определённого в <citerefentry><refentrytitle>ctype</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>) или подчёркивание. "
"Это расширение совместимо со стандартом <acronym>POSIX</acronym> 1003.2, но "
"не описано в нём, и поэтому его следует использовать с осторожностью там, "
"где важна совместимость с другими системами. Обычно лучше использовать "
"ограничивающие спецсимволы, описанные ниже; они также не совсем стандартны, "
"но набрать их легче."

#: func.xml:4848(title)
msgid "Regular Expression Escapes"
msgstr "Спецсимволы регулярных выражений"

#: func.xml:4850(para)
msgid ""
"<firstterm>Escapes</firstterm> are special sequences beginning with <literal>"
"\\</literal> followed by an alphanumeric character. Escapes come in several "
"varieties: character entry, class shorthands, constraint escapes, and back "
"references. A <literal>\\</literal> followed by an alphanumeric character "
"but not constituting a valid escape is illegal in AREs. In EREs, there are "
"no escapes: outside a bracket expression, a <literal>\\</literal> followed "
"by an alphanumeric character merely stands for that character as an ordinary "
"character, and inside a bracket expression, <literal>\\</literal> is an "
"ordinary character. (The latter is the one actual incompatibility between "
"EREs and AREs.)"
msgstr ""
"<firstterm>Спецсимволы</firstterm> &mdash; это специальные команды, "
"состоящие из <literal>\\</literal> и последующего алфавитно-цифрового "
"символа. Можно выделить следующие категории спецсимволов: обозначения "
"символов, коды классов, ограничения и ссылки назад. Символ <literal>\\</"
"literal>, за которым идёт алфавитно-цифровой символ, не образующий "
"допустимый спецсимвол, считается ошибочным в ARE. В ERE спецсимволов нет: "
"вне квадратных скобок пара из <literal>\\</literal> и последующего алфавитно-"
"цифрового символа, воспринимается просто как данный символ, а в квадратных "
"скобках и сам символ <literal>\\</literal> воспринимается просто как "
"обратная косая черта. (Последнее на самом деле нарушает совместимость между "
"ERE и ARE.)"

#: func.xml:4863(para)
msgid ""
"<firstterm>Character-entry escapes</firstterm> exist to make it easier to "
"specify non-printing and other inconvenient characters in REs. They are "
"shown in <xref linkend=\"posix-character-entry-escapes-table\"/>."
msgstr ""
"<firstterm>Спецобозначения символов</firstterm> введены для того, чтобы "
"облегчить ввод в RE непечатаемых и других неудобных символов. Они приведены "
"в <xref remap=\"6\" linkend=\"posix-character-entry-escapes-table\"/>."

#: func.xml:4869(para)
msgid ""
"<firstterm>Class-shorthand escapes</firstterm> provide shorthands for "
"certain commonly-used character classes. They are shown in <xref linkend="
"\"posix-class-shorthand-escapes-table\"/>."
msgstr ""
"<firstterm>Коды классов</firstterm> представляют собой краткий способ записи "
"имён некоторых распространённых классов символов. Они перечислены в <xref "
"remap=\"6\" linkend=\"posix-class-shorthand-escapes-table\"/>."

#: func.xml:4875(para)
msgid ""
"A <firstterm>constraint escape</firstterm> is a constraint, matching the "
"empty string if specific conditions are met, written as an escape. They are "
"shown in <xref linkend=\"posix-constraint-escapes-table\"/>."
msgstr ""
"<firstterm>Спецсимволы ограничений</firstterm> обозначают ограничения, "
"которым при совпадении определённых условий соответствует пустая строка. Они "
"перечислены в <xref remap=\"6\" linkend=\"posix-constraint-escapes-table\"/>."

#: func.xml:4882(para)
msgid ""
"A <firstterm>back reference</firstterm> (<literal>\\</"
"literal><replaceable>n</replaceable>) matches the same string matched by the "
"previous parenthesized subexpression specified by the number <replaceable>n</"
"replaceable> (see <xref linkend=\"posix-constraint-backref-table\"/>). For "
"example, <literal>([bc])\\1</literal> matches <literal>bb</literal> or "
"<literal>cc</literal> but not <literal>bc</literal> or <literal>cb</"
"literal>. The subexpression must entirely precede the back reference in the "
"RE. Subexpressions are numbered in the order of their leading parentheses. "
"Non-capturing parentheses do not define subexpressions."
msgstr ""
"<firstterm>Ссылка назад</firstterm> (<literal>\\</literal><replaceable>n</"
"replaceable>) соответствует той же строке, какой соответствовало предыдущее "
"подвыражение в скобках под номером <replaceable>n</replaceable> (см. <xref "
"remap=\"4\" linkend=\"posix-constraint-backref-table\"/>). Например, "
"<literal>([bc])\\1</literal> соответствует <literal>bb</literal> или "
"<literal>cc</literal>, но не <literal>bc</literal> или <literal>cb</"
"literal>. Это подвыражение должно полностью предшествовать ссылке назад в "
"RE. Нумеруются подвыражения в порядке следования их открывающих скобок. При "
"этом скобки без захвата исключаются из рассмотрения."

#: func.xml:4895(title)
msgid "Regular Expression Character-entry Escapes"
msgstr "Спецобозначения символов в регулярных выражениях"

#: func.xml:4900(entry) func.xml:5041(entry) func.xml:5098(entry)
#: func.xml:5154(entry)
msgid "Escape"
msgstr "Спецсимвол"

#: func.xml:4907(literal)
msgid "\\a"
msgstr "\\a"

#: func.xml:4908(entry)
msgid "alert (bell) character, as in C"
msgstr "символ звонка, как в C"

#: func.xml:4912(literal)
msgid "\\b"
msgstr "\\b"

#: func.xml:4913(entry)
msgid "backspace, as in C"
msgstr "символ &laquo;забой&raquo;, как в C"

#: func.xml:4917(literal)
msgid "\\B"
msgstr "\\B"

#: func.xml:4918(entry)
msgid ""
"synonym for backslash (<literal>\\</literal>) to help reduce the need for "
"backslash doubling"
msgstr ""
"синоним для обратной косой черты (<literal>\\</literal>), сокращающий "
"потребность в дублировании этого символа"

#: func.xml:4923(literal)
msgid "\\c"
msgstr "\\c"

#: func.xml:4923(replaceable) func.xml:13265(replaceable)
#: func.xml:13286(replaceable) func.xml:13307(replaceable)
#: func.xml:13324(replaceable) func.xml:13342(replaceable)
#: func.xml:13360(replaceable) func.xml:13380(replaceable)
#: func.xml:13400(replaceable) func.xml:13420(replaceable)
#: func.xml:13439(replaceable) func.xml:13460(replaceable)
#: func.xml:13484(replaceable)
msgid "X"
msgstr "X"

#: func.xml:4924(entry)
msgid ""
"(where <replaceable>X</replaceable> is any character) the character whose "
"low-order 5 bits are the same as those of <replaceable>X</replaceable>, and "
"whose other bits are all zero"
msgstr ""
"(где <replaceable>X</replaceable> &mdash; любой символ) символ, младшие 5 "
"бит которого те же, что и у <replaceable>X</replaceable>, а остальные равны 0"

#: func.xml:4930(literal)
msgid "\\e"
msgstr "\\e"

#: func.xml:4931(entry)
msgid ""
"the character whose collating-sequence name is <literal>ESC</literal>, or "
"failing that, the character with octal value <literal>033</literal>"
msgstr ""
"символ, определённый в последовательности сортировки с именем <literal>ESC</"
"literal>, либо, если таковой не определён, символ с восьмеричным значением "
"<literal>033</literal>"

#: func.xml:4937(literal)
msgid "\\f"
msgstr "\\f"

#: func.xml:4938(entry)
msgid "form feed, as in C"
msgstr "подача формы, как в C"

#: func.xml:4942(literal)
msgid "\\n"
msgstr "\\n"

#: func.xml:4943(entry)
msgid "newline, as in C"
msgstr "новая строка, как в C"

#: func.xml:4947(literal)
msgid "\\r"
msgstr "\\r"

#: func.xml:4948(entry)
msgid "carriage return, as in C"
msgstr "возврат каретки, как в C"

#: func.xml:4952(literal)
msgid "\\t"
msgstr "\\t"

#: func.xml:4953(entry)
msgid "horizontal tab, as in C"
msgstr "горизонтальная табуляция, как в C"

#: func.xml:4957(literal)
msgid "\\u"
msgstr "\\u"

#: func.xml:4957(replaceable)
msgid "wxyz"
msgstr "wxyz"

#: func.xml:4958(entry)
msgid ""
"(where <replaceable>wxyz</replaceable> is exactly four hexadecimal digits) "
"the character whose hexadecimal value is <literal>0x</"
"literal><replaceable>wxyz</replaceable>"
msgstr ""
"(где <replaceable>wxyz</replaceable> ровно четыре шестнадцатеричные цифры) "
"символ с шестнадцатеричным кодом <literal>0x</literal><replaceable>wxyz</"
"replaceable>"

#: func.xml:4965(literal)
msgid "\\U"
msgstr "\\U"

#: func.xml:4965(replaceable)
msgid "stuvwxyz"
msgstr "stuvwxyz"

#: func.xml:4966(entry)
msgid ""
"(where <replaceable>stuvwxyz</replaceable> is exactly eight hexadecimal "
"digits) the character whose hexadecimal value is <literal>0x</"
"literal><replaceable>stuvwxyz</replaceable>"
msgstr ""
"(где <replaceable>stuvwxyz</replaceable> ровно восемь шестнадцатеричных "
"цифр) символ с шестнадцатеричным кодом <literal>0x</"
"literal><replaceable>stuvwxyz</replaceable>"

#: func.xml:4974(literal)
msgid "\\v"
msgstr "\\v"

#: func.xml:4975(entry)
msgid "vertical tab, as in C"
msgstr "вертикальная табуляция, как в C"

#: func.xml:4979(literal)
msgid "\\x"
msgstr "\\x"

#: func.xml:4979(replaceable)
msgid "hhh"
msgstr "hhh"

#: func.xml:4980(entry)
msgid ""
"(where <replaceable>hhh</replaceable> is any sequence of hexadecimal digits) "
"the character whose hexadecimal value is <literal>0x</"
"literal><replaceable>hhh</replaceable> (a single character no matter how "
"many hexadecimal digits are used)"
msgstr ""
"(где <replaceable>hhh</replaceable> &mdash; несколько шестнадцатеричных "
"цифр) символ с шестнадцатеричным кодом <literal>0x</"
"literal><replaceable>hhh</replaceable> (символ всегда один вне зависимости "
"от числа шестнадцатеричных цифр)"

#: func.xml:4989(literal)
msgid "\\0"
msgstr "\\0"

#: func.xml:4990(entry)
msgid "the character whose value is <literal>0</literal> (the null byte)"
msgstr "символ с кодом <literal>0</literal> (нулевой байт)"

#: func.xml:4994(replaceable)
msgid "xy"
msgstr "xy"

#: func.xml:4995(entry)
msgid ""
"(where <replaceable>xy</replaceable> is exactly two octal digits, and is not "
"a <firstterm>back reference</firstterm>) the character whose octal value is "
"<literal>0</literal><replaceable>xy</replaceable>"
msgstr ""
"(где <replaceable>xy</replaceable> &mdash; ровно две восьмеричных цифры, не "
"<firstterm>ссылка назад</firstterm>) символ с восьмеричным кодом <literal>0</"
"literal><replaceable>xy</replaceable>"

#: func.xml:5002(replaceable)
msgid "xyz"
msgstr "xyz"

#: func.xml:5003(entry)
msgid ""
"(where <replaceable>xyz</replaceable> is exactly three octal digits, and is "
"not a <firstterm>back reference</firstterm>) the character whose octal value "
"is <literal>0</literal><replaceable>xyz</replaceable>"
msgstr ""
"(где <replaceable>xyz</replaceable> &mdash; ровно три восьмеричных цифры, не "
"<firstterm>ссылка назад</firstterm>) символ с восьмеричным кодом <literal>0</"
"literal><replaceable>xyz</replaceable>"

#: func.xml:5012(para)
msgid ""
"Hexadecimal digits are <literal>0</literal>-<literal>9</literal>, "
"<literal>a</literal>-<literal>f</literal>, and <literal>A</literal>-"
"<literal>F</literal>. Octal digits are <literal>0</literal>-<literal>7</"
"literal>."
msgstr ""
"Шестнадцатеричные цифры записываются символами <literal>0</literal>-"
"<literal>9</literal> и <literal>a</literal>-<literal>f</literal> или "
"<literal>A</literal>-<literal>F</literal>. Восьмеричные цифры &mdash; цифры "
"от <literal>0</literal> до <literal>7</literal>."

#: func.xml:5018(para)
msgid ""
"Numeric character-entry escapes specifying values outside the ASCII range "
"(0-127) have meanings dependent on the database encoding. When the encoding "
"is UTF-8, escape values are equivalent to Unicode code points, for example "
"<literal>\\u1234</literal> means the character <literal>U+1234</literal>. "
"For other multibyte encodings, character-entry escapes usually just specify "
"the concatenation of the byte values for the character. If the escape value "
"does not correspond to any legal character in the database encoding, no "
"error will be raised, but it will never match any data."
msgstr ""
"Спецпоследовательности с числовыми кодами, задающими значения вне диапазона "
"ASCII (0-127), воспринимаются по-разному в зависимости от кодировки базы "
"данных. Когда база данных имеет кодировку UTF-8, спецкод равнозначен позиции "
"символа в Unicode, например, <literal>\\u1234</literal> обозначает символ "
"<literal>U+1234</literal>. Для других многобайтных кодировок "
"спецпоследовательности обычно просто задают серию байт, определяющих символ. "
"Если в кодировке базы данных отсутствует символ, заданный "
"спецпоследовательностью, ошибки не будет, но и никакие данные не будут ей "
"соответствовать."

#: func.xml:5029(para)
msgid ""
"The character-entry escapes are always taken as ordinary characters. For "
"example, <literal>\\135</literal> is <literal>]</literal> in ASCII, but "
"<literal>\\135</literal> does not terminate a bracket expression."
msgstr ""
"Символы, переданные спецобозначением, всегда воспринимаются как обычные "
"символы. Например, <literal>\\135</literal> кодирует <literal>]</literal> в "
"ASCII, но спецпоследовательность <literal>\\135</literal> не будет закрывать "
"выражение в квадратных скобках."

#: func.xml:5036(title)
msgid "Regular Expression Class-shorthand Escapes"
msgstr "Спецкоды классов в регулярных выражениях"

#: func.xml:5048(literal)
msgid "\\d"
msgstr "\\d"

#: func.xml:5049(literal)
msgid "[[:digit:]]"
msgstr "[[:digit:]]"

#: func.xml:5053(literal)
msgid "\\s"
msgstr "\\s"

#: func.xml:5054(literal)
msgid "[[:space:]]"
msgstr "[[:space:]]"

#: func.xml:5058(literal)
msgid "\\w"
msgstr "\\w"

#: func.xml:5059(entry)
msgid "<literal>[[:alnum:]_]</literal> (note underscore is included)"
msgstr "<literal>[[:alnum:]_]</literal> (подчёркивание также включается)"

#: func.xml:5064(literal)
msgid "\\D"
msgstr "\\D"

#: func.xml:5065(literal)
msgid "[^[:digit:]]"
msgstr "[^[:digit:]]"

#: func.xml:5069(literal)
msgid "\\S"
msgstr "\\S"

#: func.xml:5070(literal)
msgid "[^[:space:]]"
msgstr "[^[:space:]]"

#: func.xml:5074(literal)
msgid "\\W"
msgstr "\\W"

#: func.xml:5075(entry)
msgid "<literal>[^[:alnum:]_]</literal> (note underscore is included)"
msgstr "<literal>[^[:alnum:]_]</literal> (подчёркивание также включается)"

#: func.xml:5082(para)
msgid ""
"Within bracket expressions, <literal>\\d</literal>, <literal>\\s</literal>, "
"and <literal>\\w</literal> lose their outer brackets, and <literal>\\D</"
"literal>, <literal>\\S</literal>, and <literal>\\W</literal> are illegal. "
"(So, for example, <literal>[a-c\\d]</literal> is equivalent to <literal>[a-"
"c[:digit:]]</literal>. Also, <literal>[a-c\\D]</literal>, which is "
"equivalent to <literal>[a-c^[:digit:]]</literal>, is illegal.)"
msgstr ""
"В выражениях в квадратных скобках спецсимволы <literal>\\d</literal>, "
"<literal>\\s</literal> и <literal>\\w</literal> теряют свои внешние "
"квадратные скобки, а <literal>\\D</literal>, <literal>\\S</literal> и "
"<literal>\\W</literal> &mdash; недопустимы. (Так что, например запись "
"<literal>[a-c\\d]</literal> равнозначна <literal>[a-c[:digit:]]</literal>. А "
"запись <literal>[a-c\\D]</literal>, которая была бы равнозначна <literal>[a-"
"c^[:digit:]]</literal>, &mdash; недопустима.)"

#: func.xml:5093(title)
msgid "Regular Expression Constraint Escapes"
msgstr "Спецсимволы ограничений в регулярных выражений"

#: func.xml:5105(literal)
msgid "\\A"
msgstr "\\A"

#: func.xml:5106(entry)
msgid ""
"matches only at the beginning of the string (see <xref linkend=\"posix-"
"matching-rules\"/> for how this differs from <literal>^</literal>)"
msgstr ""
"соответствует только началу строки (чем это отличается от <literal>^</"
"literal>, описано в <xref remap=\"6\" linkend=\"posix-matching-rules\"/>)"

#: func.xml:5112(literal)
msgid "\\m"
msgstr "\\m"

#: func.xml:5113(entry)
msgid "matches only at the beginning of a word"
msgstr "соответствует только началу слова"

#: func.xml:5117(literal)
msgid "\\M"
msgstr "\\M"

#: func.xml:5118(entry)
msgid "matches only at the end of a word"
msgstr "соответствует только концу слова"

#: func.xml:5122(literal)
msgid "\\y"
msgstr "\\y"

#: func.xml:5123(entry)
msgid "matches only at the beginning or end of a word"
msgstr "соответствует только началу или концу слова"

#: func.xml:5127(literal)
msgid "\\Y"
msgstr "\\Y"

#: func.xml:5128(entry)
msgid "matches only at a point that is not the beginning or end of a word"
msgstr "соответствует только положению не в начале и не в конце слова"

#: func.xml:5133(literal)
msgid "\\Z"
msgstr "\\Z"

#: func.xml:5134(entry)
msgid ""
"matches only at the end of the string (see <xref linkend=\"posix-matching-"
"rules\"/> for how this differs from <literal>$</literal>)"
msgstr ""
"соответствует только концу строки (чем это отличается от <literal>$</"
"literal>, описано в <xref remap=\"6\" linkend=\"posix-matching-rules\"/>)"

#: func.xml:5142(para)
msgid ""
"A word is defined as in the specification of <literal>[[:&lt;:]]</literal> "
"and <literal>[[:&gt;:]]</literal> above. Constraint escapes are illegal "
"within bracket expressions."
msgstr ""
"Определением слова здесь служит то же, что было приведено выше в описании "
"<literal>[[:&lt;:]]</literal> и <literal>[[:&gt;:]]</literal>. В квадратных "
"скобках спецсимволы ограничений не допускаются."

#: func.xml:5149(title)
msgid "Regular Expression Back References"
msgstr "Ссылки назад в регулярных выражениях"

#: func.xml:5162(entry)
msgid ""
"(where <replaceable>m</replaceable> is a nonzero digit) a back reference to "
"the <replaceable>m</replaceable>'th subexpression"
msgstr ""
"(где <replaceable>m</replaceable> &mdash; цифра, отличная от 0) &mdash; "
"ссылка назад на подвыражение под номером <replaceable>m</replaceable>"

#: func.xml:5167(replaceable)
msgid "mnn"
msgstr "mnn"

#: func.xml:5168(entry)
msgid ""
"(where <replaceable>m</replaceable> is a nonzero digit, and <replaceable>nn</"
"replaceable> is some more digits, and the decimal value <replaceable>mnn</"
"replaceable> is not greater than the number of closing capturing parentheses "
"seen so far) a back reference to the <replaceable>mnn</replaceable>'th "
"subexpression"
msgstr ""
"(где <replaceable>m</replaceable> &mdash; цифра, отличная от 0, а "
"<replaceable>nn</replaceable> &mdash; ещё несколько цифр с десятичным "
"значением <replaceable>mnn</replaceable>, не превышающим число закрытых до "
"этого скобок с захватом) ссылка назад на подвыражение под номером "
"<replaceable>mnn</replaceable>"

#: func.xml:5179(para)
msgid ""
"There is an inherent ambiguity between octal character-entry escapes and "
"back references, which is resolved by the following heuristics, as hinted at "
"above. A leading zero always indicates an octal escape. A single non-zero "
"digit, not followed by another digit, is always taken as a back reference. A "
"multi-digit sequence not starting with a zero is taken as a back reference "
"if it comes after a suitable subexpression (i.e., the number is in the legal "
"range for a back reference), and otherwise is taken as octal."
msgstr ""
"Регулярным выражениям присуща неоднозначность между восьмеричными кодами "
"символов и ссылками назад, которая разрешается следующим образом (это "
"упоминалось выше). Ведущий ноль всегда считается признаком восьмеричной "
"последовательности. Единственная цифра, отличная от 0, за которой не следует "
"ещё одна цифра, всегда воспринимается как ссылка назад. Последовательность "
"из нескольких цифр, которая начинается не с 0, воспринимается как ссылка "
"назад, если она идёт за подходящим подвыражением (т. е. число оказывается в "
"диапазоне, допустимом для ссылки назад), в противном случае она "
"воспринимается как восьмеричное число."

#: func.xml:5195(title)
msgid "Regular Expression Metasyntax"
msgstr "Метасинтаксис регулярных выражений"

#: func.xml:5197(para)
msgid ""
"In addition to the main syntax described above, there are some special forms "
"and miscellaneous syntactic facilities available."
msgstr ""
"В дополнение к основному синтаксису, описанному выше, можно использовать "
"также несколько особых форм и разнообразные синтаксические удобства."

#: func.xml:5202(para)
msgid ""
"An RE can begin with one of two special <firstterm>director</firstterm> "
"prefixes. If an RE begins with <literal>***:</literal>, the rest of the RE "
"is taken as an ARE. (This normally has no effect in <productname>PostgreSQL</"
"productname>, since REs are assumed to be AREs; but it does have an effect "
"if ERE or BRE mode had been specified by the <replaceable>flags</"
"replaceable> parameter to a regex function.) If an RE begins with "
"<literal>***=</literal>, the rest of the RE is taken to be a literal string, "
"with all characters considered ordinary characters."
msgstr ""
"Регулярное выражение может начинаться с одного из двух специальных префиксов "
"режима. Если RE начинается с <literal>***:</literal>, его продолжение "
"рассматривается как ARE. (В <productname>PostgreSQL</productname> это обычно "
"не имеет значения, так как регулярные выражения воспринимаются как ARE по "
"умолчанию; но это может быть полезно, когда параметр <replaceable>флаги</"
"replaceable> функций regex включает режим ERE или BRE.) Если RE начинается с "
"<literal>***=</literal>, его продолжение воспринимается как обычная "
"текстовая строка, все его символы воспринимаются буквально."

#: func.xml:5214(para)
msgid ""
"An ARE can begin with <firstterm>embedded options</firstterm>: a sequence "
"<literal>(?</literal><replaceable>xyz</replaceable><literal>)</literal> "
"(where <replaceable>xyz</replaceable> is one or more alphabetic characters) "
"specifies options affecting the rest of the RE. These options override any "
"previously determined options &mdash; in particular, they can override the "
"case-sensitivity behavior implied by a regex operator, or the "
"<replaceable>flags</replaceable> parameter to a regex function. The "
"available option letters are shown in <xref linkend=\"posix-embedded-options-"
"table\"/>. Note that these same option letters are used in the "
"<replaceable>flags</replaceable> parameters of regex functions."
msgstr ""
"ARE может начинаться со <firstterm>встроенных параметров</firstterm>: "
"последовательности <literal>(?</literal><replaceable>xyz</"
"replaceable><literal>)</literal> (где <replaceable>xyz</replaceable> &mdash; "
"один или несколько алфавитно-цифровых символов), определяющих параметры "
"остального регулярного выражения. Эти параметры переопределяют любые ранее "
"определённые параметры, в частности они могут переопределить режим "
"чувствительности к регистру, подразумеваемый для оператора regex, или "
"параметр <replaceable>флаги</replaceable> функции regex. Допустимые буквы "
"параметров показаны в <xref remap=\"6\" linkend=\"posix-embedded-options-"
"table\"/>. Заметьте, что те же буквы используются в параметре "
"<replaceable>флаги</replaceable> функций regex."

#: func.xml:5230(title)
msgid "ARE Embedded-option Letters"
msgstr "Буквы встроенных параметров ARE"

#: func.xml:5235(entry)
msgid "Option"
msgstr "Параметр"

#: func.xml:5242(literal)
msgctxt "literal"
msgid "b"
msgstr "b"

#: func.xml:5243(entry)
msgid "rest of RE is a BRE"
msgstr "продолжение регулярного выражения &mdash; BRE"

#: func.xml:5247(literal)
msgctxt "literal"
msgid "c"
msgstr "c"

#: func.xml:5248(entry)
msgid "case-sensitive matching (overrides operator type)"
msgstr "поиск соответствий с учётом регистра (переопределяет тип оператора)"

#: func.xml:5252(literal)
msgid "e"
msgstr "e"

#: func.xml:5253(entry)
msgid "rest of RE is an ERE"
msgstr "продолжение RE &mdash; ERE"

#: func.xml:5257(literal)
msgid "i"
msgstr "i"

#: func.xml:5258(entry)
msgid ""
"case-insensitive matching (see <xref linkend=\"posix-matching-rules\"/>) "
"(overrides operator type)"
msgstr ""
"поиск соответствий без учёта регистра (см. <xref remap=\"4\" linkend=\"posix-"
"matching-rules\"/>) (переопределяет тип оператора)"

#: func.xml:5263(literal)
msgctxt "literal"
msgid "m"
msgstr "m"

#: func.xml:5264(entry)
msgid "historical synonym for <literal>n</literal>"
msgstr "исторически сложившийся синоним <literal>n</literal>"

#: func.xml:5268(literal)
msgctxt "literal"
msgid "n"
msgstr "n"

#: func.xml:5269(entry)
msgid ""
"newline-sensitive matching (see <xref linkend=\"posix-matching-rules\"/>)"
msgstr ""
"поиск соответствий с учётом перевода строк (см. <xref remap=\"4\" linkend="
"\"posix-matching-rules\"/>)"

#: func.xml:5274(literal)
msgid "p"
msgstr "p"

#: func.xml:5275(entry)
msgid ""
"partial newline-sensitive matching (see <xref linkend=\"posix-matching-rules"
"\"/>)"
msgstr ""
"переводы строк учитываются частично (см. <xref remap=\"4\" linkend=\"posix-"
"matching-rules\"/>)"

#: func.xml:5280(literal)
msgid "q"
msgstr "q"

#: func.xml:5281(entry)
msgid ""
"rest of RE is a literal (<quote>quoted</quote>) string, all ordinary "
"characters"
msgstr ""
"продолжение регулярного выражения &mdash; обычная строка (<quote>в кавычках</"
"quote>), содержимое которой воспринимается буквально"

#: func.xml:5286(literal)
msgctxt "literal"
msgid "s"
msgstr "s"

#: func.xml:5287(entry)
msgid "non-newline-sensitive matching (default)"
msgstr "поиск соответствий без учёта перевода строк (по умолчанию)"

#: func.xml:5291(literal) func.xml:9198(literal) func.xml:9205(literal)
#: func.xml:9254(literal) func.xml:11999(literal) func.xml:12006(literal)
#: func.xml:12013(literal) func.xml:12020(literal) func.xml:12027(literal)
#: func.xml:12034(literal) func.xml:12041(literal) func.xml:12048(literal)
#: func.xml:12055(literal) func.xml:12474(literal) func.xml:12481(literal)
#: func.xml:12488(literal) func.xml:12495(literal) func.xml:12502(literal)
#: func.xml:12509(literal) func.xml:12516(literal) func.xml:12523(literal)
#: func.xml:12530(literal) func.xml:12544(literal) func.xml:12551(literal)
#: func.xml:12558(literal) func.xml:12565(literal) func.xml:12572(literal)
#: func.xml:12579(literal)
msgid "t"
msgstr "t"

#: func.xml:5292(entry)
msgid "tight syntax (default; see below)"
msgstr "компактный синтаксис (по умолчанию; см. ниже)"

#: func.xml:5296(literal)
msgid "w"
msgstr "w"

#: func.xml:5297(entry)
msgid ""
"inverse partial newline-sensitive (<quote>weird</quote>) matching (see <xref "
"linkend=\"posix-matching-rules\"/>)"
msgstr ""
"переводы строк учитываются частично, но в другом, <quote>странном</quote> "
"режиме (см. <xref remap=\"4\" linkend=\"posix-matching-rules\"/>)"

#: func.xml:5302(literal)
msgctxt "literal"
msgid "x"
msgstr "x"

#: func.xml:5303(entry)
msgid "expanded syntax (see below)"
msgstr "развёрнутый синтаксис (см. ниже)"

#: func.xml:5309(para)
msgid ""
"Embedded options take effect at the <literal>)</literal> terminating the "
"sequence. They can appear only at the start of an ARE (after the "
"<literal>***:</literal> director if any)."
msgstr ""
"Внедрённые параметры начинают действовать сразу после скобки <literal>)</"
"literal>, завершающей их последовательность. Они могут находиться только в "
"начале ARE (после указания <literal>***:</literal>, если оно присутствует)."

#: func.xml:5328(para)
msgid ""
"a white-space character or <literal>#</literal> preceded by <literal>\\</"
"literal> is retained"
msgstr ""
"пробельный символ или <literal>#</literal>, за которым следует <literal>\\</"
"literal>, сохраняется"

#: func.xml:5334(para)
msgid ""
"white space or <literal>#</literal> within a bracket expression is retained"
msgstr ""
"пробельный символ или <literal>#</literal> внутри выражения в квадратных "
"скобках сохраняется"

#: func.xml:5339(para)
msgid ""
"white space and comments cannot appear within multi-character symbols, such "
"as <literal>(?:</literal>"
msgstr ""
"пробельные символы и комментарии не могут присутствовать в составных "
"символах, например, в <literal>(?:</literal>"

#: func.xml:5315(para)
msgid ""
"In addition to the usual (<firstterm>tight</firstterm>) RE syntax, in which "
"all characters are significant, there is an <firstterm>expanded</firstterm> "
"syntax, available by specifying the embedded <literal>x</literal> option. In "
"the expanded syntax, white-space characters in the RE are ignored, as are "
"all characters between a <literal>#</literal> and the following newline (or "
"the end of the RE). This permits paragraphing and commenting a complex RE. "
"There are three exceptions to that basic rule: <placeholder-1/> For this "
"purpose, white-space characters are blank, tab, newline, and any character "
"that belongs to the <replaceable>space</replaceable> character class."
msgstr ""
"Помимо обычного (<firstterm>компактного</firstterm>) синтаксиса RE, в "
"котором имеют значение все символы, поддерживается также "
"<firstterm>развёрнутый</firstterm> синтаксис, включить который можно с "
"помощью встроенного параметра <literal>x</literal>. В развёрнутом синтаксисе "
"игнорируются пробельные символы, а также все символы от <literal>#</literal> "
"до конца строки (или конца RE). Это позволяет разделять RE на строки и "
"добавлять в него комментарии. Но есть три исключения: <placeholder-1/> В "
"данном контексте пробельными символами считаются пробел, табуляция, перевод "
"строки и любой другой символ, относящийся к классу символов "
"<replaceable>space</replaceable>."

#: func.xml:5350(para)
msgid ""
"Finally, in an ARE, outside bracket expressions, the sequence <literal>(?#</"
"literal><replaceable>ttt</replaceable><literal>)</literal> (where "
"<replaceable>ttt</replaceable> is any text not containing a <literal>)</"
"literal>) is a comment, completely ignored. Again, this is not allowed "
"between the characters of multi-character symbols, like <literal>(?:</"
"literal>. Such comments are more a historical artifact than a useful "
"facility, and their use is deprecated; use the expanded syntax instead."
msgstr ""
"И наконец, в ARE последовательность <literal>(?#</literal><replaceable>ttt</"
"replaceable><literal>)</literal> (где <replaceable>ttt</replaceable> &mdash; "
"любой текст, не содержащий <literal>)</literal>) вне квадратных скобок также "
"считается комментарием и полностью игнорируется. При этом она так же не "
"может находиться внутри составных символов, таких как <literal>(?:</"
"literal>. Эти комментарии в большей степени историческое наследие, чем "
"полезное средство; они считаются устаревшими, а вместо них рекомендуется "
"использовать развёрнутый синтаксис."

#: func.xml:5361(para)
msgid ""
"<emphasis>None</emphasis> of these metasyntax extensions is available if an "
"initial <literal>***=</literal> director has specified that the user's input "
"be treated as a literal string rather than as an RE."
msgstr ""
"<emphasis>Ни одно</emphasis> из этих расширений метасинтаксиса не будет "
"работать, если выражение начинается с префикса <literal>***=</literal>, "
"после которого строка воспринимается буквально, а не как RE."

#: func.xml:5370(title)
msgid "Regular Expression Matching Rules"
msgstr "Правила соответствия регулярным выражениям"

#: func.xml:5372(para)
msgid ""
"In the event that an RE could match more than one substring of a given "
"string, the RE matches the one starting earliest in the string. If the RE "
"could match more than one substring starting at that point, either the "
"longest possible match or the shortest possible match will be taken, "
"depending on whether the RE is <firstterm>greedy</firstterm> or "
"<firstterm>non-greedy</firstterm>."
msgstr ""
"В случае, когда RE может соответствовать более чем одной подстроке в "
"заданной строке, соответствующей RE считается подстрока, которая начинается "
"в ней первой. Если к данной позиции подобных соответствующих подстрок "
"оказывается несколько, из них выбирается либо самая длинная, либо самая "
"короткая из возможных, в зависимости от того, какой режим выбран в RE: "
"<firstterm>жадный</firstterm> или <firstterm>не жадный</firstterm>."

#: func.xml:5385(para)
msgid ""
"Most atoms, and all constraints, have no greediness attribute (because they "
"cannot match variable amounts of text anyway)."
msgstr ""
"Большинство атомов и все ограничения не имеют признака жадности (так как они "
"всё равно не могут соответствовать подстрокам разного состава)."

#: func.xml:5391(para)
msgid "Adding parentheses around an RE does not change its greediness."
msgstr "Скобки, окружающие RE, не влияют на его &laquo;жадность&raquo;."

#: func.xml:5396(para)
msgid ""
"A quantified atom with a fixed-repetition quantifier (<literal>{</"
"literal><replaceable>m</replaceable><literal>}</literal> or <literal>{</"
"literal><replaceable>m</replaceable><literal>}?</literal>) has the same "
"greediness (possibly none) as the atom itself."
msgstr ""
"Атом с определителем фиксированного количества (<literal>{</"
"literal><replaceable>m</replaceable><literal>}</literal> или <literal>{</"
"literal><replaceable>m</replaceable><literal>}?</literal>) имеет ту же "
"характеристику жадности (или может не иметь её), как и сам атом."

#: func.xml:5405(para)
msgid ""
"A quantified atom with other normal quantifiers (including <literal>{</"
"literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</"
"replaceable><literal>}</literal> with <replaceable>m</replaceable> equal to "
"<replaceable>n</replaceable>) is greedy (prefers longest match)."
msgstr ""
"Атом с другими обычными определителями количества (включая <literal>{</"
"literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</"
"replaceable><literal>}</literal>, где <replaceable>m</replaceable> равняется "
"<replaceable>n</replaceable>) считается жадным (предпочитает соответствие "
"максимальной длины)."

#: func.xml:5413(para)
msgid ""
"A quantified atom with a non-greedy quantifier (including <literal>{</"
"literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</"
"replaceable><literal>}?</literal> with <replaceable>m</replaceable> equal to "
"<replaceable>n</replaceable>) is non-greedy (prefers shortest match)."
msgstr ""
"Атом с не жадным определителем количества (включая <literal>{</"
"literal><replaceable>m</replaceable><literal>,</literal><replaceable>n</"
"replaceable><literal>}?</literal>, где <replaceable>m</replaceable> равно "
"<replaceable>n</replaceable>) считается не жадным (предпочитает соответствие "
"минимальной длины)."

#: func.xml:5421(para)
msgid ""
"A branch &mdash; that is, an RE that has no top-level <literal>|</literal> "
"operator &mdash; has the same greediness as the first quantified atom in it "
"that has a greediness attribute."
msgstr ""
"Ветвь (RE без оператора <literal>|</literal> на верхнем уровне) имеет ту же "
"характеристику жадности, что и первый количественный атом в нём, имеющий "
"атрибут жадности."

#: func.xml:5428(para)
msgid ""
"An RE consisting of two or more branches connected by the <literal>|</"
"literal> operator is always greedy."
msgstr ""
"RE, образованное из двух или более ветвей, соединённых оператором <literal>|"
"</literal>, всегда считается жадным."

#: func.xml:5381(para)
msgid ""
"Whether an RE is greedy or not is determined by the following rules: "
"<placeholder-1/>"
msgstr ""
"Где жадный или не жадный характер RE определяется по следующим правилам: "
"<placeholder-1/>"

#: func.xml:5436(para)
msgid ""
"The above rules associate greediness attributes not only with individual "
"quantified atoms, but with branches and entire REs that contain quantified "
"atoms. What that means is that the matching is done in such a way that the "
"branch, or whole RE, matches the longest or shortest possible substring "
"<emphasis>as a whole</emphasis>. Once the length of the entire match is "
"determined, the part of it that matches any particular subexpression is "
"determined on the basis of the greediness attribute of that subexpression, "
"with subexpressions starting earlier in the RE taking priority over ones "
"starting later."
msgstr ""
"Эти правила связывают характеристики жадности не только с отдельными "
"количественными атомами, но и с ветвями и целыми RE, содержащими "
"количественные атомы. Это означает, что при сопоставлении ветвь или целое RE "
"может соответствовать максимально длинной или короткой подстроке <emphasis>в "
"целом</emphasis>. Когда определена длина всего соответствия, часть его, "
"соответствующая конкретному подвыражению, определяется с учётом "
"характеристики жадности для этого подвыражения, при этом подвыражения, "
"начинающиеся в RE раньше, имеют больший приоритет, чем следующие за ними."

#: func.xml:5448(para)
msgid ""
"An example of what this means: <screen>\n"
"SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');\n"
"<lineannotation>Result: </lineannotation><computeroutput>123</"
"computeroutput>\n"
"SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');\n"
"<lineannotation>Result: </lineannotation><computeroutput>1</computeroutput>\n"
"</screen> In the first case, the RE as a whole is greedy because "
"<literal>Y*</literal> is greedy. It can match beginning at the <literal>Y</"
"literal>, and it matches the longest possible string starting there, i.e., "
"<literal>Y123</literal>. The output is the parenthesized part of that, or "
"<literal>123</literal>. In the second case, the RE as a whole is non-greedy "
"because <literal>Y*?</literal> is non-greedy. It can match beginning at the "
"<literal>Y</literal>, and it matches the shortest possible string starting "
"there, i.e., <literal>Y1</literal>. The subexpression <literal>[0-9]{1,3}</"
"literal> is greedy but it cannot change the decision as to the overall match "
"length; so it is forced to match just <literal>1</literal>."
msgstr ""
"Это иллюстрирует следующий пример: <screen>\n"
"SELECT SUBSTRING('XY1234Z', 'Y*([0-9]{1,3})');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>123</"
"computeroutput>\n"
"SELECT SUBSTRING('XY1234Z', 'Y*?([0-9]{1,3})');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>1</"
"computeroutput>\n"
"</screen> В первом случае, RE в целом жадное, так как жадным является атом "
"<literal>Y*</literal>. Соответствие ему начинается с буквы <literal>Y</"
"literal> и оно включает подстроку максимальной длины с этого места, т. е. "
"подстроку <literal>Y123</literal>. Результат выражения &mdash; её часть, "
"соответствующая подвыражению в скобках, т. е. <literal>123</literal>. Во "
"втором случае, RE в целом наследует не жадный характер от атома <literal>Y*?"
"</literal>. Соответствие ему так же начинается с <literal>Y</literal>, но "
"включает оно подстроку минимальной длины с этого места, т. е. <literal>Y1</"
"literal>. И хотя подвыражение <literal>[0-9]{1,3}</literal> имеет жадный "
"характер, оно не может повлиять на выбор длины соответствия в целом, поэтому "
"ему остаётся только подстрока <literal>1</literal>."

#: func.xml:5468(para)
msgid ""
"In short, when an RE contains both greedy and non-greedy subexpressions, the "
"total match length is either as long as possible or as short as possible, "
"according to the attribute assigned to the whole RE. The attributes assigned "
"to the subexpressions only affect how much of that match they are allowed to "
"<quote>eat</quote> relative to each other."
msgstr ""
"Другими словами, когда RE содержит и жадные, и не жадные подвыражения, всё "
"соответствие будет максимально длинным или коротким в зависимости от "
"характеристики всего RE. Характеристики, связанные с подвыражениями, влияют "
"только на то, какую часть подстроки может <quote>поглотить</quote> одно "
"подвыражение относительно другого."

#: func.xml:5476(para)
msgid ""
"The quantifiers <literal>{1,1}</literal> and <literal>{1,1}?</literal> can "
"be used to force greediness or non-greediness, respectively, on a "
"subexpression or a whole RE. This is useful when you need the whole RE to "
"have a greediness attribute different from what's deduced from its elements. "
"As an example, suppose that we are trying to separate a string containing "
"some digits into the digits and the parts before and after them. We might "
"try to do that like this: <screen>\n"
"SELECT regexp_matches('abc01234xyz', '(.*)(\\d+)(.*)');\n"
"<lineannotation>Result: </lineannotation><computeroutput>{abc0123,4,xyz}</"
"computeroutput>\n"
"</screen> That didn't work: the first <literal>.*</literal> is greedy so it "
"<quote>eats</quote> as much as it can, leaving the <literal>\\d+</literal> "
"to match at the last possible place, the last digit. We might try to fix "
"that by making it non-greedy: <screen>\n"
"SELECT regexp_matches('abc01234xyz', '(.*?)(\\d+)(.*)');\n"
"<lineannotation>Result: </lineannotation><computeroutput>{abc,0,\"\"}</"
"computeroutput>\n"
"</screen> That didn't work either, because now the RE as a whole is non-"
"greedy and so it ends the overall match as soon as possible. We can get what "
"we want by forcing the RE as a whole to be greedy: <screen>\n"
"SELECT regexp_matches('abc01234xyz', '(?:(.*?)(\\d+)(.*)){1,1}');\n"
"<lineannotation>Result: </lineannotation><computeroutput>{abc,01234,xyz}</"
"computeroutput>\n"
"</screen> Controlling the RE's overall greediness separately from its "
"components' greediness allows great flexibility in handling variable-length "
"patterns."
msgstr ""
"Чтобы явно придать характеристику «жадности» или «нежадности» подвыражению "
"или всему RE, можно использовать определители <literal>{1,1}</literal> и "
"<literal>{1,1}?</literal>, соответственно. Это полезно, когда вам нужно, "
"чтобы общая характеристика жадности RE отличалась от той, что вытекает из "
"его элементов. Например, предположим, что вы пытаетесь выделить из строки, "
"содержащей несколько цифр, эти цифры и части до и после них. Можно "
"попытаться сделать это так: <screen>\n"
"SELECT regexp_matches('abc01234xyz', '(.*)(\\d+)(.*)');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>{abc0123,4,xyz}</"
"computeroutput>\n"
"</screen> Но это не будет работать: первая группа <literal>.*</literal> — "
"&laquo;жадная&raquo;, она <quote>съест</quote> всё, что сможет, оставляя для "
"соответствия <literal>\\d+</literal> только последнюю возможность, то есть "
"последнюю цифру. Можно попытаться сделать запрос &laquo;нежадным&raquo;: "
"<screen>\n"
"SELECT regexp_matches('abc01234xyz', '(.*?)(\\d+)(.*)');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>{abc,0,\"\"}</"
"computeroutput>\n"
"</screen> И это не будет работать, так теперь весь RE в целом стал нежадным, "
"и все соответствия завершаются как можно раньше. Но мы можем получить нужный "
"результат, явно сделав жадным всё RE: <screen>\n"
"SELECT regexp_matches('abc01234xyz', '(?:(.*?)(\\d+)(.*)){1,1}');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>{abc,01234,xyz}</"
"computeroutput>\n"
"</screen> Управление общей характеристикой &laquo;жадности&raquo; RE "
"независимо от &laquo;жадности&raquo; его компонентов даёт большую гибкость в "
"описании шаблонов переменной длины."

#: func.xml:5508(para)
msgid ""
"When deciding what is a longer or shorter match, match lengths are measured "
"in characters, not collating elements. An empty string is considered longer "
"than no match at all. For example: <literal>bb*</literal> matches the three "
"middle characters of <literal>abbbc</literal>; <literal>(week|wee)(night|"
"knights)</literal> matches all ten characters of <literal>weeknights</"
"literal>; when <literal>(.*).*</literal> is matched against <literal>abc</"
"literal> the parenthesized subexpression matches all three characters; and "
"when <literal>(a*)*</literal> is matched against <literal>bc</literal> both "
"the whole RE and the parenthesized subexpression match an empty string."
msgstr ""
"При определении более длинного или более короткого соответствия длины "
"соответствий определяются в символах, а не в элементах сортировки. Пустая "
"строка считается длиннее, чем отсутствие соответствия. Например, выражению "
"<literal>bb*</literal> соответствуют три символа в середине строки "
"<literal>abbbc</literal>, выражению <literal>(week|wee)(night|knights)</"
"literal> &mdash; все десять символов <literal>weeknights</literal>; когда "
"выражение <literal>(.*).*</literal> сопоставляется со строкой <literal>abc</"
"literal>, подвыражению в скобках соответствуют все три символа; а когда "
"<literal>(a*)*</literal> сопоставляется со строкой <literal>bc</literal>, то "
"и RE в целом, и подстроке в скобках соответствует пустая строка."

#: func.xml:5525(para)
msgid ""
"If case-independent matching is specified, the effect is much as if all case "
"distinctions had vanished from the alphabet. When an alphabetic that exists "
"in multiple cases appears as an ordinary character outside a bracket "
"expression, it is effectively transformed into a bracket expression "
"containing both cases, e.g., <literal>x</literal> becomes <literal>[xX]</"
"literal>. When it appears inside a bracket expression, all case counterparts "
"of it are added to the bracket expression, e.g., <literal>[x]</literal> "
"becomes <literal>[xX]</literal> and <literal>[^x]</literal> becomes "
"<literal>[^xX]</literal>."
msgstr ""
"Игнорирование регистра символов даёт практически тот же эффект, как если бы "
"в алфавите исчезли различия прописных и строчных букв. Если буква, "
"существующая и в верхнем, и в нижнем регистре, фигурирует вне квадратных "
"скобок как обычный символ, она по сути преобразуется в выражение в "
"квадратных скобках, содержащее оба варианта, например <literal>x</literal> "
"становится <literal>[xX]</literal>. Если же она фигурирует в выражении в "
"квадратных скобках, в это выражение добавляются все её варианты, например "
"<literal>[x]</literal> становится <literal>[xX]</literal>, а <literal>[^x]</"
"literal> &mdash; <literal>[^xX]</literal>."

#: func.xml:5539(para)
msgid ""
"If newline-sensitive matching is specified, <literal>.</literal> and bracket "
"expressions using <literal>^</literal> will never match the newline "
"character (so that matches will never cross newlines unless the RE "
"explicitly arranges it) and <literal>^</literal> and <literal>$</literal> "
"will match the empty string after and before a newline respectively, in "
"addition to matching at beginning and end of string respectively. But the "
"ARE escapes <literal>\\A</literal> and <literal>\\Z</literal> continue to "
"match beginning or end of string <emphasis>only</emphasis>."
msgstr ""
"Когда включён режим учёта перевода строк, атом <literal>.</literal> и "
"выражения в квадратных скобках с <literal>^</literal> никогда не будут "
"соответствовать символам конца строки (так что соответствия никогда не будут "
"пересекать границы строк, если в RE нет явных указаний на эти символы), а "
"<literal>^</literal> и <literal>$</literal> будут соответствовать пустой "
"подстроке не только в начале и конце всего текста, но и в начале и конце "
"каждой отдельной его строки. Однако спецсимволы ARE <literal>\\A</literal> и "
"<literal>\\Z</literal> по-прежнему будут соответствовать <emphasis>только</"
"emphasis> началу и концу всего текста."

#: func.xml:5553(para)
msgid ""
"If partial newline-sensitive matching is specified, this affects <literal>.</"
"literal> and bracket expressions as with newline-sensitive matching, but not "
"<literal>^</literal> and <literal>$</literal>."
msgstr ""
"В режиме, когда переводы строк учитываются частично, особый смысл перевод "
"строк имеет для атома <literal>.</literal> и выражений в квадратных скобках, "
"но не для <literal>^</literal> и <literal>$</literal>."

#: func.xml:5560(para)
msgid ""
"If inverse partial newline-sensitive matching is specified, this affects "
"<literal>^</literal> and <literal>$</literal> as with newline-sensitive "
"matching, but not <literal>.</literal> and bracket expressions. This isn't "
"very useful but is provided for symmetry."
msgstr ""
"В обратном частичном режиме, перевод строк имеет особый смысл для "
"<literal>^</literal> и <literal>$</literal>, как и в режиме с учётом "
"перевода строк, но не для <literal>.</literal> и выражений в квадратных "
"скобках. Данный режим не очень полезен, но существует для симметрии."

#: func.xml:5570(title)
msgid "Limits and Compatibility"
msgstr "Пределы и совместимость"

#: func.xml:5572(para)
msgid ""
"No particular limit is imposed on the length of REs in this implementation. "
"However, programs intended to be highly portable should not employ REs "
"longer than 256 bytes, as a POSIX-compliant implementation can refuse to "
"accept such REs."
msgstr ""
"В текущей реализации отсутствует какой-либо явно заданный предел длины RE. "
"Однако, разрабатывая программы высокой степени переносимости, не следует "
"применять RE длиннее 256 байт, так как другая POSIX-совместимая реализация "
"может отказаться обрабатывать такие регулярные выражения."

#: func.xml:5580(para)
msgid ""
"The only feature of AREs that is actually incompatible with POSIX EREs is "
"that <literal>\\</literal> does not lose its special significance inside "
"bracket expressions. All other ARE features use syntax which is illegal or "
"has undefined or unspecified effects in POSIX EREs; the <literal>***</"
"literal> syntax of directors likewise is outside the POSIX syntax for both "
"BREs and EREs."
msgstr ""
"Единственная особенность ARE, действительно несовместимая с ERE стандарта "
"POSIX проявляется в том, что в ARE знак <literal>\\</literal> не теряет своё "
"специальное значение в квадратных скобках. Все другие расширения ARE "
"используют синтаксические возможности, которые не определены, не допустимы "
"или не поддерживаются в ERE; синтаксис переключения режимов (<literal>***</"
"literal>) также выходит за рамки синтаксиса POSIX как для BRE, так и для ERE."

#: func.xml:5590(para)
msgid ""
"Many of the ARE extensions are borrowed from Perl, but some have been "
"changed to clean them up, and a few Perl extensions are not present. "
"Incompatibilities of note include <literal>\\b</literal>, <literal>\\B</"
"literal>, the lack of special treatment for a trailing newline, the addition "
"of complemented bracket expressions to the things affected by newline-"
"sensitive matching, the restrictions on parentheses and back references in "
"lookahead/lookbehind constraints, and the longest/shortest-match (rather "
"than first-match) matching semantics."
msgstr ""
"Многие расширения ARE заимствованы из языка Perl, но некоторые были "
"изменены, оптимизированы, а несколько расширений Perl были исключены. В "
"результате имеют место следующие несовместимости: атомы <literal>\\b</"
"literal> и <literal>\\B</literal>, отсутствие специальной обработки "
"завершающего перевода строки, добавление исключений в квадратных скобках в "
"число случаев, когда учитывается перевод строк, особые условия для скобок и "
"ссылок назад в ограничениях просмотра вперёд/назад и семантика "
"<quote>наиболее длинное/короткое соответствие</quote> (вместо <quote>первое "
"соответствие</quote>)."

#: func.xml:5608(para)
msgid ""
"In AREs, <literal>\\</literal> followed by an alphanumeric character is "
"either an escape or an error, while in previous releases, it was just "
"another way of writing the alphanumeric. This should not be much of a "
"problem because there was no reason to write such a sequence in earlier "
"releases."
msgstr ""
"В ARE <literal>\\</literal> с последующим алфавитно-цифровым символом "
"представляет либо спецсимвол, либо ошибочную последовательность, тогда как в "
"предыдущих версиях так можно было записывать алфавитно-цифровые символы. Это "
"не должно быть большой проблемой, так как раньше не было причин использовать "
"такие последовательности."

#: func.xml:5617(para)
msgid ""
"In AREs, <literal>\\</literal> remains a special character within "
"<literal>[]</literal>, so a literal <literal>\\</literal> within a bracket "
"expression must be written <literal>\\\\</literal>."
msgstr ""
"В ARE знак <literal>\\</literal> сохраняет своё специальное значение в "
"<literal>[]</literal>, поэтому, чтобы передать <literal>\\</literal> в "
"квадратных скобках буквально, его нужно записать как <literal>\\\\</literal>."

#: func.xml:5602(para)
msgid ""
"Two significant incompatibilities exist between AREs and the ERE syntax "
"recognized by pre-7.4 releases of <productname>PostgreSQL</productname>: "
"<placeholder-1/>"
msgstr ""
"Важно отметить две несовместимости синтаксиса ARE и регулярных выражений "
"ERE, которые воспринимал <productname>PostgreSQL</productname> до версии "
"7.4: <placeholder-1/>"

#: func.xml:5628(title)
msgid "Basic Regular Expressions"
msgstr "Простые регулярные выражения"

#: func.xml:5630(para)
msgid ""
"BREs differ from EREs in several respects. In BREs, <literal>|</literal>, "
"<literal>+</literal>, and <literal>?</literal> are ordinary characters and "
"there is no equivalent for their functionality. The delimiters for bounds "
"are <literal>\\{</literal> and <literal>\\}</literal>, with <literal>{</"
"literal> and <literal>}</literal> by themselves ordinary characters. The "
"parentheses for nested subexpressions are <literal>\\(</literal> and "
"<literal>\\)</literal>, with <literal>(</literal> and <literal>)</literal> "
"by themselves ordinary characters. <literal>^</literal> is an ordinary "
"character except at the beginning of the RE or the beginning of a "
"parenthesized subexpression, <literal>$</literal> is an ordinary character "
"except at the end of the RE or the end of a parenthesized subexpression, and "
"<literal>*</literal> is an ordinary character if it appears at the beginning "
"of the RE or the beginning of a parenthesized subexpression (after a "
"possible leading <literal>^</literal>). Finally, single-digit back "
"references are available, and <literal>\\&lt;</literal> and <literal>\\&gt;</"
"literal> are synonyms for <literal>[[:&lt;:]]</literal> and <literal>[[:"
"&gt;:]]</literal> respectively; no other escapes are available in BREs."
msgstr ""
"BRE имеют ряд отличий от ERE. В BRE знаки <literal>|</literal>, <literal>+</"
"literal> и <literal>?</literal> теряют специальное значение, а замены им "
"нет. Границы количества окружаются символами <literal>\\{</literal> и "
"<literal>\\}</literal>, тогда как <literal>{</literal> и <literal>}</"
"literal> рассматриваются как обычные символы. Вложенные подвыражения "
"помещаются между <literal>\\(</literal> и <literal>\\)</literal>, а "
"<literal>(</literal> и <literal>)</literal> представляют обычные символы. "
"Символ <literal>^</literal> воспринимается как обычный, если только он не "
"находится в начале RE или подвыражения в скобках, <literal>$</literal> "
"&mdash; тоже обычный символ, если он находится не в конце RE или в конце "
"подвыражения в скобках, и <literal>*</literal> &mdash; обычный символ, когда "
"он находится в начале RE или подвыражения в скобках (возможно, после "
"начального <literal>^</literal>). И, наконец, в BRE работают ссылки назад с "
"одной цифрой, <literal>\\&lt;</literal> и <literal>\\&gt;</literal> &mdash; "
"синонимы для <literal>[[:&lt;:]]</literal> и <literal>[[:&gt;:]]</literal>, "
"соответственно; никакие другие спецсимволы в BRE не поддерживаются."

#: func.xml:5664(title)
msgid "Data Type Formatting Functions"
msgstr "Функции форматирования данных"

#: func.xml:5666(indexterm)
msgid "<primary>formatting</primary>"
msgstr "<primary>форматирование</primary>"

#: func.xml:5670(para)
msgid ""
"The <productname>PostgreSQL</productname> formatting functions provide a "
"powerful set of tools for converting various data types (date/time, integer, "
"floating point, numeric) to formatted strings and for converting from "
"formatted strings to specific data types. <xref linkend=\"functions-"
"formatting-table\"/> lists them. These functions all follow a common calling "
"convention: the first argument is the value to be formatted and the second "
"argument is a template that defines the output or input format."
msgstr ""
"Функции форматирования в <productname>PostgreSQL</productname> предоставляют "
"богатый набор инструментов для преобразования самых разных типов данных "
"(дата/время, целое, числа с плавающей и фиксированной точкой) в "
"форматированные строки и обратно. Все они перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-table\"/>. Все эти функции следует одному "
"соглашению: в первом аргументе передаётся значение, которое нужно "
"отформатировать, а во втором &mdash; шаблон, определяющий формат ввода или "
"вывода."

#: func.xml:5682(title)
msgid "Formatting Functions"
msgstr "Функции форматирования"

#: func.xml:5695(indexterm)
msgid "<primary>to_char</primary>"
msgstr "<primary>to_char</primary>"

#: func.xml:5698(type) func.xml:6793(type) func.xml:6803(type)
#: func.xml:6875(type) func.xml:6900(type) func.xml:6902(type)
#: func.xml:6924(type) func.xml:6957(type) func.xml:7033(type)
#: func.xml:7125(type)
msgid "timestamp"
msgstr "timestamp"

#: func.xml:5698(function) func.xml:5705(function) func.xml:5711(function)
#: func.xml:5724(function)
msgid "to_char(<placeholder-1/>, <placeholder-2/>)"
msgstr "to_char(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:5701(entry)
msgid "convert time stamp to string"
msgstr "преобразует время в текст"

#: func.xml:5702(literal)
msgid "to_char(current_timestamp, 'HH12:MI:SS')"
msgstr "to_char(current_timestamp, 'HH12:MI:SS')"

#: func.xml:5705(type) func.xml:6795(type) func.xml:6804(type)
#: func.xml:6886(type) func.xml:6910(type) func.xml:6911(type)
#: func.xml:6935(type) func.xml:6965(type) func.xml:6977(type)
#: func.xml:6979(type) func.xml:6990(type) func.xml:6992(type)
#: func.xml:7003(type) func.xml:7005(type) func.xml:7079(type)
#: func.xml:15055(type)
msgid "interval"
msgstr "interval"

#: func.xml:5707(entry)
msgid "convert interval to string"
msgstr "преобразует интервал в текст"

#: func.xml:5708(literal)
msgid "to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')"
msgstr "to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')"

#: func.xml:5713(entry)
msgid "convert integer to string"
msgstr "преобразует целое в текст"

#: func.xml:5714(literal)
msgid "to_char(125, '999')"
msgstr "to_char(125, '999')"

#: func.xml:5717(function)
msgid "to_char"
msgstr "to_char"

#: func.xml:5717(type) func.xml:6877(type) func.xml:6887(type)
#: func.xml:6926(type) func.xml:6936(type) func.xml:7075(type)
#: func.xml:7097(type) func.xml:7121(type) func.xml:7145(type)
#: func.xml:7225(type) func.xml:8502(type) func.xml:8514(type)
#: func.xml:8520(type) func.xml:8538(type) func.xml:8577(type)
#: func.xml:8583(type) func.xml:8650(type) func.xml:8700(type)
#: func.xml:8701(type) func.xml:13268(type) func.xml:13271(type)
#: func.xml:13289(type) func.xml:13292(type) func.xml:13310(type)
#: func.xml:13313(type) func.xml:13327(type) func.xml:13330(type)
#: func.xml:13345(type) func.xml:13348(type) func.xml:13363(type)
#: func.xml:13383(type) func.xml:13386(type) func.xml:13403(type)
#: func.xml:13406(type) func.xml:13423(type) func.xml:13426(type)
#: func.xml:13442(type) func.xml:13445(type) func.xml:13463(type)
#: func.xml:13466(type) func.xml:13487(type) func.xml:13490(type)
#: func.xml:13709(type) func.xml:13755(type) func.xml:13897(type)
#: func.xml:13920(type) func.xml:14102(type) func.xml:14115(type)
msgid "double precision"
msgstr "double precision"

#: func.xml:5717(literal) func.xml:8700(literal) func.xml:12181(literal)
#: func.xml:12192(literal) func.xml:12238(literal) func.xml:12249(literal)
#: func.xml:12273(literal) func.xml:12286(literal) func.xml:12297(literal)
#: func.xml:12332(literal) func.xml:12747(literal) func.xml:15680(literal)
#: func.xml:15712(literal) func.xml:15727(literal) func.xml:15742(literal)
#: func.xml:15757(literal) func.xml:15772(literal) func.xml:15787(literal)
#: func.xml:15802(literal) func.xml:15817(literal) func.xml:15832(literal)
#: func.xml:15847(literal)
msgctxt "literal"
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>)"

#: func.xml:5720(entry)
msgid "convert real/double precision to string"
msgstr "преобразует плавающее одинарной/двойной точности в текст"

#: func.xml:5721(literal)
msgid "to_char(125.8::real, '999D9')"
msgstr "to_char(125.8::real, '999D9')"

#: func.xml:5726(entry)
msgid "convert numeric to string"
msgstr "преобразует числовое значение в текст"

#: func.xml:5727(literal)
msgid "to_char(-125.8, '999D99S')"
msgstr "to_char(-125.8, '999D99S')"

#: func.xml:5731(indexterm)
msgid "<primary>to_date</primary>"
msgstr "<primary>to_date</primary>"

#: func.xml:5734(function)
msgid "to_date(<placeholder-1/>, <placeholder-2/>)"
msgstr "to_date(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:5736(type) func.xml:6832(type) func.xml:6948(type)
#: func.xml:7054(type)
msgid "date"
msgstr "date"

#: func.xml:5737(entry)
msgid "convert string to date"
msgstr "преобразует текст в дату"

#: func.xml:5738(literal)
msgid "to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')"
msgstr "to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')"

#: func.xml:5742(indexterm)
msgid "<primary>to_number</primary>"
msgstr "<primary>to_number</primary>"

#: func.xml:5745(function)
msgid "to_number(<placeholder-1/>, <placeholder-2/>)"
msgstr "to_number(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:5748(entry)
msgid "convert string to numeric"
msgstr "преобразует текст в число"

#: func.xml:5749(literal)
msgid "to_number('12,454.8-', '99G999D9S')"
msgstr "to_number('12,454.8-', '99G999D9S')"

#: func.xml:5753(indexterm) func.xml:7222(indexterm)
msgid "<primary>to_timestamp</primary>"
msgstr "<primary>to_timestamp</primary>"

#: func.xml:5756(function)
msgid "to_timestamp(<placeholder-1/>, <placeholder-2/>)"
msgstr "to_timestamp(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:5758(type) func.xml:6817(type) func.xml:6862(type)
#: func.xml:7150(type) func.xml:7167(type) func.xml:7182(type)
#: func.xml:7213(type) func.xml:7227(type) func.xml:7882(type)
#: func.xml:7888(type) func.xml:15368(type) func.xml:15398(type)
#: func.xml:17051(type) func.xml:17243(type) func.xml:17284(type)
#: func.xml:17763(type) func.xml:17985(type)
msgid "timestamp with time zone"
msgstr "timestamp with time zone"

#: func.xml:5759(entry)
msgid "convert string to time stamp"
msgstr "преобразует строку во время"

#: func.xml:5760(literal)
msgid "to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')"
msgstr "to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')"

#: func.xml:5767(para)
msgid ""
"There is also a single-argument <function>to_timestamp</function> function; "
"see <xref linkend=\"functions-datetime-table\"/>."
msgstr ""
"Также имеется функция <function>to_timestamp</function> с одним аргументом; "
"см. <xref remap=\"4\" linkend=\"functions-datetime-table\"/>."

#: func.xml:5773(para)
msgid ""
"In a <function>to_char</function> output template string, there are certain "
"patterns that are recognized and replaced with appropriately-formatted data "
"based on the given value. Any text that is not a template pattern is simply "
"copied verbatim. Similarly, in an input template string (for the other "
"functions), template patterns identify the values to be supplied by the "
"input data string."
msgstr ""
"Шаблон вывода <function>to_char</function> может содержать ряд кодов, "
"которые распознаются при форматировании и заменяются соответствующими "
"данными. Любой текст, который не является кодом, копируется в результат в "
"неизменном виде. Подобным образом, в строке шаблона ввода (для других "
"функций) коды шаблона определяют, какие значения содержит передаваемая "
"текстовая строка."

#: func.xml:5782(para)
msgid ""
"<xref linkend=\"functions-formatting-datetime-table\"/> shows the template "
"patterns available for formatting date and time values."
msgstr ""
"Все коды форматирования даты и времени перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-datetime-table\"/>."

#: func.xml:5788(title)
msgid "Template Patterns for Date/Time Formatting"
msgstr "Коды форматирования даты/времени"

#: func.xml:5792(entry) func.xml:6270(entry)
msgid "Pattern"
msgstr "Код"

#: func.xml:5798(literal)
msgid "HH"
msgstr "HH"

#: func.xml:5799(entry) func.xml:5803(entry)
msgid "hour of day (01-12)"
msgstr "час (01-12)"

#: func.xml:5802(literal)
msgid "HH12"
msgstr "HH12"

#: func.xml:5806(literal)
msgid "HH24"
msgstr "HH24"

#: func.xml:5807(entry)
msgid "hour of day (00-23)"
msgstr "час (00-23)"

#: func.xml:5810(literal) func.xml:6312(literal)
msgid "MI"
msgstr "MI"

#: func.xml:5811(entry)
msgid "minute (00-59)"
msgstr "минута (00-59)"

#: func.xml:5814(literal)
msgid "SS"
msgstr "SS"

#: func.xml:5815(entry)
msgid "second (00-59)"
msgstr "секунда (00-59)"

#: func.xml:5818(literal)
msgid "MS"
msgstr "MS"

#: func.xml:5819(entry)
msgid "millisecond (000-999)"
msgstr "миллисекунда (000-999)"

#: func.xml:5822(literal)
msgid "US"
msgstr "US"

#: func.xml:5823(entry)
msgid "microsecond (000000-999999)"
msgstr "микросекунда (000000-999999)"

#: func.xml:5826(literal)
msgid "SSSS"
msgstr "SSSS"

#: func.xml:5827(entry)
msgid "seconds past midnight (0-86399)"
msgstr "число секунд с начала суток (0-86399)"

#: func.xml:5830(entry)
msgid ""
"<literal>AM</literal>, <literal>am</literal>, <literal>PM</literal> or "
"<literal>pm</literal>"
msgstr ""
"<literal>AM</literal>, <literal>am</literal>, <literal>PM</literal> или "
"<literal>pm</literal>"

#: func.xml:5832(entry)
msgid "meridiem indicator (without periods)"
msgstr "обозначение времени до/после полудня (без точек)"

#: func.xml:5835(entry)
msgid ""
"<literal>A.M.</literal>, <literal>a.m.</literal>, <literal>P.M.</literal> or "
"<literal>p.m.</literal>"
msgstr ""
"<literal>A.M.</literal>, <literal>a.m.</literal>, <literal>P.M.</literal> "
"или <literal>p.m.</literal>"

#: func.xml:5837(entry)
msgid "meridiem indicator (with periods)"
msgstr "обозначение времени до/после полудня (с точками)"

#: func.xml:5840(literal)
msgid "Y,YYY"
msgstr "Y,YYY"

#: func.xml:5841(entry)
msgid "year (4 or more digits) with comma"
msgstr "год (4 или более цифр) с разделителем"

#: func.xml:5844(literal)
msgid "YYYY"
msgstr "YYYY"

#: func.xml:5845(entry)
msgid "year (4 or more digits)"
msgstr "год (4 или более цифр)"

#: func.xml:5848(literal)
msgid "YYY"
msgstr "YYY"

#: func.xml:5849(entry)
msgid "last 3 digits of year"
msgstr "последние 3 цифры года"

#: func.xml:5852(literal)
msgid "YY"
msgstr "YY"

#: func.xml:5853(entry)
msgid "last 2 digits of year"
msgstr "последние 2 цифры года"

#: func.xml:5856(literal)
msgctxt "literal"
msgid "Y"
msgstr "Y"

#: func.xml:5857(entry)
msgid "last digit of year"
msgstr "последняя цифра года"

#: func.xml:5860(literal)
msgid "IYYY"
msgstr "IYYY"

#: func.xml:5861(entry)
msgid "ISO 8601 week-numbering year (4 or more digits)"
msgstr "недельный год по ISO 8601 (4 или более цифр)"

#: func.xml:5864(literal)
msgid "IYY"
msgstr "IYY"

#: func.xml:5865(entry)
msgid "last 3 digits of ISO 8601 week-numbering year"
msgstr "последние 3 цифры недельного года по ISO 8601"

#: func.xml:5868(literal)
msgid "IY"
msgstr "IY"

#: func.xml:5869(entry)
msgid "last 2 digits of ISO 8601 week-numbering year"
msgstr "последние 2 цифры недельного года по ISO 8601"

#: func.xml:5872(literal)
msgid "I"
msgstr "I"

#: func.xml:5873(entry)
msgid "last digit of ISO 8601 week-numbering year"
msgstr "последняя цифра недельного года по ISO 8601"

#: func.xml:5876(entry)
msgid ""
"<literal>BC</literal>, <literal>bc</literal>, <literal>AD</literal> or "
"<literal>ad</literal>"
msgstr ""
"<literal>BC</literal>, <literal>bc</literal>, <literal>AD</literal> или "
"<literal>ad</literal>"

#: func.xml:5878(entry)
msgid "era indicator (without periods)"
msgstr "обозначение эры (без точек)"

#: func.xml:5881(entry)
msgid ""
"<literal>B.C.</literal>, <literal>b.c.</literal>, <literal>A.D.</literal> or "
"<literal>a.d.</literal>"
msgstr ""
"<literal>B.C.</literal>, <literal>b.c.</literal>, <literal>A.D.</literal> "
"или <literal>a.d.</literal>"

#: func.xml:5883(entry)
msgid "era indicator (with periods)"
msgstr "обозначение эры (с точками)"

#: func.xml:5886(literal)
msgid "MONTH"
msgstr "MONTH"

#: func.xml:5887(entry)
msgid "full upper case month name (blank-padded to 9 chars)"
msgstr ""
"полное название месяца в верхнем регистре (дополненное пробелами до 9 "
"символов)"

#: func.xml:5890(literal)
msgid "Month"
msgstr "Month"

#: func.xml:5891(entry)
msgid "full capitalized month name (blank-padded to 9 chars)"
msgstr ""
"полное название месяца с большой буквы (дополненное пробелами до 9 символов)"

#: func.xml:5894(literal) func.xml:7619(literal) func.xml:7826(literal)
msgctxt "literal"
msgid "month"
msgstr "month"

#: func.xml:5895(entry)
msgid "full lower case month name (blank-padded to 9 chars)"
msgstr ""
"полное название месяца в нижнем регистре (дополненное пробелами до 9 "
"символов)"

#: func.xml:5898(literal)
msgid "MON"
msgstr "MON"

#: func.xml:5899(entry)
msgid ""
"abbreviated upper case month name (3 chars in English, localized lengths "
"vary)"
msgstr ""
"сокращённое название месяца в верхнем регистре (3 буквы в английском; в "
"других языках длина может меняться)"

#: func.xml:5902(literal)
msgid "Mon"
msgstr "Mon"

#: func.xml:5903(entry)
msgid ""
"abbreviated capitalized month name (3 chars in English, localized lengths "
"vary)"
msgstr ""
"сокращённое название месяца с большой буквы (3 буквы в английском; в других "
"языках длина может меняться)"

#: func.xml:5906(literal)
msgid "mon"
msgstr "mon"

#: func.xml:5907(entry)
msgid ""
"abbreviated lower case month name (3 chars in English, localized lengths "
"vary)"
msgstr ""
"сокращённое название месяца в нижнем регистре (3 буквы в английском; в "
"других языках длина может меняться)"

#: func.xml:5910(literal)
msgid "MM"
msgstr "MM"

#: func.xml:5911(entry)
msgid "month number (01-12)"
msgstr "номер месяца (01-12)"

#: func.xml:5914(literal)
msgid "DAY"
msgstr "DAY"

#: func.xml:5915(entry)
msgid "full upper case day name (blank-padded to 9 chars)"
msgstr ""
"полное название дня недели в верхнем регистре (дополненное пробелами до 9 "
"символов)"

#: func.xml:5918(literal)
msgid "Day"
msgstr "Day"

#: func.xml:5919(entry)
msgid "full capitalized day name (blank-padded to 9 chars)"
msgstr ""
"полное название дня недели с большой буквы (дополненное пробелами до 9 "
"символов)"

#: func.xml:5922(literal) func.xml:7393(literal) func.xml:7824(literal)
msgctxt "literal"
msgid "day"
msgstr "day"

#: func.xml:5923(entry)
msgid "full lower case day name (blank-padded to 9 chars)"
msgstr ""
"полное название дня недели в нижнем регистре (дополненное пробелами до 9 "
"символов)"

#: func.xml:5926(literal)
msgid "DY"
msgstr "DY"

#: func.xml:5927(entry)
msgid ""
"abbreviated upper case day name (3 chars in English, localized lengths vary)"
msgstr ""
"сокращённое название дня недели в верхнем регистре (3 буквы в английском; в "
"других языках может меняться)"

#: func.xml:5930(literal)
msgid "Dy"
msgstr "Dy"

#: func.xml:5931(entry)
msgid ""
"abbreviated capitalized day name (3 chars in English, localized lengths vary)"
msgstr ""
"сокращённое название дня недели с большой буквы (3 буквы в английском; в "
"других языках длина может меняться)"

#: func.xml:5934(literal)
msgid "dy"
msgstr "dy"

#: func.xml:5935(entry)
msgid ""
"abbreviated lower case day name (3 chars in English, localized lengths vary)"
msgstr ""
"сокращённое название дня недели в нижнем регистре (3 буквы в английском; в "
"других языках длина может меняться)"

#: func.xml:5938(literal)
msgid "DDD"
msgstr "DDD"

#: func.xml:5939(entry)
msgid "day of year (001-366)"
msgstr "номер дня в году (001-366)"

#: func.xml:5942(literal)
msgid "IDDD"
msgstr "IDDD"

#: func.xml:5943(entry)
msgid ""
"day of ISO 8601 week-numbering year (001-371; day 1 of the year is Monday of "
"the first ISO week)"
msgstr ""
"номер дня в году по ISO 8601 (001-371; 1 день &mdash; понедельник первой "
"недели по ISO)"

#: func.xml:5946(literal)
msgid "DD"
msgstr "DD"

#: func.xml:5947(entry)
msgid "day of month (01-31)"
msgstr "день месяца (01-31)"

#: func.xml:5950(literal) func.xml:6304(literal)
msgid "D"
msgstr "D"

#: func.xml:5951(entry)
msgid ""
"day of the week, Sunday (<literal>1</literal>) to Saturday (<literal>7</"
"literal>)"
msgstr ""
"номер дня недели, считая с воскресенья (<literal>1</literal>) до субботы "
"(<literal>7</literal>)"

#: func.xml:5954(literal)
msgid "ID"
msgstr "ID"

#: func.xml:5955(entry)
msgid ""
"ISO 8601 day of the week, Monday (<literal>1</literal>) to Sunday "
"(<literal>7</literal>)"
msgstr ""
"номер дня недели по ISO 8601, считая с понедельника (<literal>1</literal>) "
"до воскресенья (<literal>7</literal>)"

#: func.xml:5958(literal)
msgid "W"
msgstr "W"

#: func.xml:5959(entry)
msgid ""
"week of month (1-5) (the first week starts on the first day of the month)"
msgstr "неделя месяца (1-5) (первая неделя начинается в первое число месяца)"

#: func.xml:5962(literal)
msgid "WW"
msgstr "WW"

#: func.xml:5963(entry)
msgid ""
"week number of year (1-53) (the first week starts on the first day of the "
"year)"
msgstr ""
"номер недели в году (1-53) (первая неделя начинается в первый день года)"

#: func.xml:5966(literal)
msgid "IW"
msgstr "IW"

#: func.xml:5967(entry)
msgid ""
"week number of ISO 8601 week-numbering year (01-53; the first Thursday of "
"the year is in week 1)"
msgstr ""
"номер недели в году по ISO 8601 (01-53; первый четверг года относится к "
"неделе 1)"

#: func.xml:5970(literal)
msgid "CC"
msgstr "CC"

#: func.xml:5971(entry)
msgid "century (2 digits) (the twenty-first century starts on 2001-01-01)"
msgstr "век (2 цифры) (двадцать первый век начался 2001-01-01)"

#: func.xml:5974(literal)
msgid "J"
msgstr "J"

#: func.xml:5975(entry)
msgid "Julian Day (integer days since November 24, 4714 BC at midnight UTC)"
msgstr "День по юлианскому календарю (номер дня с 24 ноября 4714 г. до н. э.)"

#: func.xml:5978(literal)
msgid "Q"
msgstr "Q"

#: func.xml:5979(entry)
msgid ""
"quarter (ignored by <function>to_date</function> and <function>to_timestamp</"
"function>)"
msgstr ""
"квартал (игнорируется функциями <function>to_date</function> и "
"<function>to_timestamp</function>)"

#: func.xml:5982(literal)
msgid "RM"
msgstr "RM"

#: func.xml:5983(entry)
msgid "month in upper case Roman numerals (I-XII; I=January)"
msgstr "номер месяца римскими цифрами в верхнем регистре (I-XII; I=январь)"

#: func.xml:5986(literal)
msgid "rm"
msgstr "rm"

#: func.xml:5987(entry)
msgid "month in lower case Roman numerals (i-xii; i=January)"
msgstr "номер месяца римскими цифрами в нижнем регистре (i-xii; i=январь)"

#: func.xml:5990(literal)
msgid "TZ"
msgstr "TZ"

#: func.xml:5991(entry)
msgid "upper case time-zone name"
msgstr "название часового пояса в верхнем регистре"

#: func.xml:5994(literal)
msgid "tz"
msgstr "tz"

#: func.xml:5995(entry)
msgid "lower case time-zone name"
msgstr "название часового пояса в нижнем регистре"

#: func.xml:5998(literal)
msgid "OF"
msgstr "OF"

#: func.xml:5999(entry)
msgid "time-zone offset"
msgstr "смещение часового пояса"

#: func.xml:6005(para)
msgid ""
"Modifiers can be applied to any template pattern to alter its behavior. For "
"example, <literal>FMMonth</literal> is the <literal>Month</literal> pattern "
"with the <literal>FM</literal> modifier. <xref linkend=\"functions-"
"formatting-datetimemod-table\"/> shows the modifier patterns for date/time "
"formatting."
msgstr ""
"К любым кодам форматирования можно добавить модификаторы, изменяющие их "
"поведение. Например, шаблон форматирования <literal>FMMonth</literal> "
"включает код <literal>Month</literal> с модификатором <literal>FM</literal>. "
"Модификаторы, предназначенные для форматирования даты/времени, перечислены в "
"<xref remap=\"6\" linkend=\"functions-formatting-datetimemod-table\"/>."

#: func.xml:6015(title)
msgid "Template Pattern Modifiers for Date/Time Formatting"
msgstr "Модификаторы кодов для форматирования даты/времени"

#: func.xml:6019(entry) func.xml:6424(entry)
msgid "Modifier"
msgstr "Модификатор"

#: func.xml:6026(entry) func.xml:6431(entry)
msgid "<literal>FM</literal> prefix"
msgstr "Приставка <literal>FM</literal>"

#: func.xml:6027(entry) func.xml:6432(entry)
msgid "fill mode (suppress leading zeroes and padding blanks)"
msgstr "режим заполнения (подавляет ведущие нули и дополнение пробелами)"

#: func.xml:6028(literal)
msgid "FMMonth"
msgstr "FMMonth"

#: func.xml:6031(entry) func.xml:6436(entry)
msgid "<literal>TH</literal> suffix"
msgstr "Окончание <literal>TH</literal>"

#: func.xml:6032(entry) func.xml:6437(entry)
msgid "upper case ordinal number suffix"
msgstr "окончание порядкового числительного в верхнем регистре"

#: func.xml:6033(entry)
msgid "<literal>DDTH</literal>, e.g., <literal>12TH</literal>"
msgstr "<literal>DDTH</literal>, например <literal>12TH</literal>"

#: func.xml:6036(entry) func.xml:6441(entry)
msgid "<literal>th</literal> suffix"
msgstr "Окончание <literal>th</literal>"

#: func.xml:6037(entry) func.xml:6442(entry)
msgid "lower case ordinal number suffix"
msgstr "окончание порядкового числительного в нижнем регистре"

#: func.xml:6038(entry)
msgid "<literal>DDth</literal>, e.g., <literal>12th</literal>"
msgstr "<literal>DDth</literal>, например <literal>12th</literal>"

#: func.xml:6041(entry)
msgid "<literal>FX</literal> prefix"
msgstr "Приставка <literal>FX</literal>"

#: func.xml:6042(entry)
msgid "fixed format global option (see usage notes)"
msgstr "глобальный параметр фиксированного формата (см. замечания)"

#: func.xml:6043(literal)
msgid "FX&nbsp;Month&nbsp;DD&nbsp;Day"
msgstr "FX&nbsp;Month&nbsp;DD&nbsp;Day"

#: func.xml:6046(entry)
msgid "<literal>TM</literal> prefix"
msgstr "Приставка <literal>TM</literal>"

#: func.xml:6047(entry)
msgid ""
"translation mode (print localized day and month names based on <xref linkend="
"\"guc-lc-time\"/>)"
msgstr ""
"режим перевода (выводятся локализованные названия дней и месяцев, исходя из "
"<xref linkend=\"guc-lc-time\"/>)"

#: func.xml:6049(literal)
msgid "TMMonth"
msgstr "TMMonth"

#: func.xml:6052(entry)
msgid "<literal>SP</literal> suffix"
msgstr "Окончание <literal>SP</literal>"

#: func.xml:6053(entry)
msgid "spell mode (not implemented)"
msgstr "режим числа прописью (не реализован)"

#: func.xml:6054(literal)
msgid "DDSP"
msgstr "DDSP"

#: func.xml:6065(para)
msgid ""
"<literal>FM</literal> suppresses leading zeroes and trailing blanks that "
"would otherwise be added to make the output of a pattern be fixed-width. In "
"<productname>PostgreSQL</productname>, <literal>FM</literal> modifies only "
"the next specification, while in Oracle <literal>FM</literal> affects all "
"subsequent specifications, and repeated <literal>FM</literal> modifiers "
"toggle fill mode on and off."
msgstr ""
"<literal>FM</literal> подавляет дополняющие пробелы и нули справа, которые в "
"противном случае будут добавлены, чтобы результат имел фиксированную ширину. "
"В <productname>PostgreSQL</productname> модификатор <literal>FM</literal> "
"действует только на следующий код, тогда как в Oracle <literal>FM</literal> "
"её действие распространяется на все последующие коды, пока не будет "
"отключено последующим модификатором <literal>FM</literal>."

#: func.xml:6077(para)
msgid ""
"<literal>TM</literal> does not include trailing blanks. "
"<function>to_timestamp</function> and <function>to_date</function> ignore "
"the <literal>TM</literal> modifier."
msgstr ""
"<literal>TM</literal> не затрагивает замыкающие пробелы. Функции "
"<function>to_timestamp</function> и <function>to_date</function> игнорируют "
"указание <literal>TM</literal>."

#: func.xml:6085(para)
msgid ""
"<function>to_timestamp</function> and <function>to_date</function> skip "
"multiple blank spaces in the input string unless the <literal>FX</literal> "
"option is used. For example, <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;"
"&nbsp;JUN', 'YYYY MON')</literal> works, but "
"<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</"
"literal> returns an error because <function>to_timestamp</function> expects "
"one space only. <literal>FX</literal> must be specified as the first item in "
"the template."
msgstr ""
"<function>to_timestamp</function> и <function>to_date</function> пропускают "
"повторяющиеся пробелы во входной строке, если только не используется "
"параметр <literal>FX</literal>. Например, <literal>to_timestamp('2000&nbsp;"
"&nbsp;&nbsp;&nbsp;JUN', 'YYYY MON')</literal> будет работать, но "
"<literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN', 'FXYYYY MON')</"
"literal> вернёт ошибку, так как <function>to_timestamp</function> в данном "
"случае ожидает только один разделяющий пробел. Приставка <literal>FX</"
"literal> должна быть первой в шаблоне."

#: func.xml:6098(para)
msgid ""
"<function>to_timestamp</function> and <function>to_date</function> exist to "
"handle input formats that cannot be converted by simple casting. These "
"functions interpret input liberally, with minimal error checking. While they "
"produce valid output, the conversion can yield unexpected results. For "
"example, input to these functions is not restricted by normal ranges, thus "
"<literal>to_date('20096040','YYYYMMDD')</literal> returns "
"<literal>2014-01-17</literal> rather than causing an error. Casting does not "
"have this behavior."
msgstr ""
"<function>to_timestamp</function> и <function>to_date</function> "
"предназначены для обработки входных форматов, для которых недостаточно "
"простого приведения. Эти функции интерпретируют вводимые данные с "
"послаблениями, проверяя только грубые ошибки. Хотя они выдают корректные "
"данные, результат может отличаться от ожидаемого. В частности, входные "
"аргументы этих функций не ограничиваются обычными диапазонами, так что "
"<literal>to_date('20096040','YYYYMMDD')</literal> выдаёт "
"<literal>2014-01-17</literal>, а не ошибку. С приведением такого не "
"происходит."

#: func.xml:6112(para)
msgid ""
"Ordinary text is allowed in <function>to_char</function> templates and will "
"be output literally. You can put a substring in double quotes to force it to "
"be interpreted as literal text even if it contains pattern key words. For "
"example, in <literal>'\"Hello Year \"YYYY'</literal>, the <literal>YYYY</"
"literal> will be replaced by the year data, but the single <literal>Y</"
"literal> in <literal>Year</literal> will not be. In <function>to_date</"
"function>, <function>to_number</function>, and <function>to_timestamp</"
"function>, double-quoted strings skip the number of input characters "
"contained in the string, e.g. <literal>\"XX\"</literal> skips two input "
"characters."
msgstr ""
"Шаблоны для функций <function>to_char</function> могут содержать обычный "
"текст; он будет выведен в неизменном виде. Чтобы вывести текст "
"принудительно, например, если в нём оказываются поддерживаемые коды, его "
"можно заключить в кавычки. Например, в строке <literal>'\"Hello Year "
"\"YYYY'</literal>, код <literal>YYYY</literal> будет заменён номером года, а "
"буква <literal>Y</literal> в слове <literal>Year</literal> останется "
"неизменной. В функциях <function>to_date</function>, <function>to_number</"
"function> и <function>to_timestamp</function> при обработке подстроки в "
"кавычках просто пропускаются символы входной строки по числу символов в "
"подстроке, например для <literal>\"XX\"</literal> будут пропущены два "
"символа."

#: func.xml:6127(para)
msgid ""
"If you want to have a double quote in the output you must precede it with a "
"backslash, for example <literal>'\\\"YYYY Month\\\"'</literal>."
msgstr ""
"Если вы хотите получить в результате кавычки, перед ними нужно добавить "
"обратную косую черту, например так: <literal>'\\\"YYYY Month\\\"'</literal>."

#: func.xml:6135(para)
msgid ""
"If the year format specification is less than four digits, e.g. "
"<literal>YYY</literal>, and the supplied year is less than four digits, the "
"year will be adjusted to be nearest to the year 2020, e.g. <literal>95</"
"literal> becomes 1995."
msgstr ""
"Если формат года определяется менее, чем 4 цифрами, например, как "
"<literal>YYY</literal>, и в переданном значении года тоже меньше 4 цифр, год "
"пересчитывается в максимально близкий к году 2020, т. е. <literal>95</"
"literal> воспринимается как 1995."

#: func.xml:6144(para)
msgid ""
"The <literal>YYYY</literal> conversion from string to <type>timestamp</type> "
"or <type>date</type> has a restriction when processing years with more than "
"4 digits. You must use some non-digit character or template after "
"<literal>YYYY</literal>, otherwise the year is always interpreted as 4 "
"digits. For example (with the year 20000): <literal>to_date('200001131', "
"'YYYYMMDD')</literal> will be interpreted as a 4-digit year; instead use a "
"non-digit separator after the year, like <literal>to_date('20000-1131', "
"'YYYY-MMDD')</literal> or <literal>to_date('20000Nov31', 'YYYYMonDD')</"
"literal>."
msgstr ""
"С преобразованием <literal>YYYY</literal> из строки в тип <type>timestamp</"
"type> или <type>date</type> связано ограничение, когда обрабатываемый год "
"записывается более чем 4 цифрами. После <literal>YYYY</literal> необходимо "
"будет добавить не цифровой символ или соответствующий код, иначе год всегда "
"будет восприниматься как 4 цифры. Например, в <literal>to_date('200001131', "
"'YYYYMMDD')</literal> (с годом 20000) год будет интерпретирован как "
"состоящий из 4 цифр; чтобы исправить ситуацию, нужно добавить не цифровой "
"разделитель после года, как в <literal>to_date('20000-1131', 'YYYY-MMDD')</"
"literal>, или код как в <literal>to_date('20000Nov31', 'YYYYMonDD')</"
"literal>."

#: func.xml:6159(para)
msgid ""
"In conversions from string to <type>timestamp</type> or <type>date</type>, "
"the <literal>CC</literal> (century) field is ignored if there is a "
"<literal>YYY</literal>, <literal>YYYY</literal> or <literal>Y,YYY</literal> "
"field. If <literal>CC</literal> is used with <literal>YY</literal> or "
"<literal>Y</literal> then the year is computed as the year in the specified "
"century. If the century is specified but the year is not, the first year of "
"the century is assumed."
msgstr ""
"В преобразованиях из строки в тип <type>timestamp</type> или <type>date</"
"type>, поле <literal>CC</literal> (век) игнорируется, если шаблон включает "
"поля <literal>YYY</literal>, <literal>YYYY</literal> или <literal>Y,YYY</"
"literal>. Когда <literal>CC</literal> используется с <literal>YY</literal> "
"или <literal>Y</literal>, год вычисляется как год данного столетия. Если "
"присутствует только код столетия, без года, подразумевается первый год этого "
"века."

#: func.xml:6178(para)
msgid ""
"Year, week number, and weekday: for example <literal>to_date('2006-42-4', "
"'IYYY-IW-ID')</literal> returns the date <literal>2006-10-19</literal>. If "
"you omit the weekday it is assumed to be 1 (Monday)."
msgstr ""
"Год, номер недели и дня недели: например, <literal>to_date('2006-42-4', "
"'IYYY-IW-ID')</literal> возвращает дату <literal>2006-10-19</literal>. Если "
"день недели опускается, он считается равным 1 (понедельнику)."

#: func.xml:6186(para)
msgid ""
"Year and day of year: for example <literal>to_date('2006-291', 'IYYY-IDDD')</"
"literal> also returns <literal>2006-10-19</literal>."
msgstr ""
"Год и день года: например, <literal>to_date('2006-291', 'IYYY-IDDD')</"
"literal> также возвращает <literal>2006-10-19</literal>."

#: func.xml:6172(para)
msgid ""
"An ISO 8601 week-numbering date (as distinct from a Gregorian date) can be "
"specified to <function>to_timestamp</function> and <function>to_date</"
"function> in one of two ways: <placeholder-1/>"
msgstr ""
"Даты по недельному календарю ISO 8601 (отличающиеся от григорианских) можно "
"передать функциям <function>to_timestamp</function> и <function>to_date</"
"function> одним из двух способов: <placeholder-1/>"

#: func.xml:6193(para)
msgid ""
"Attempting to enter a date using a mixture of ISO 8601 week-numbering fields "
"and Gregorian date fields is nonsensical, and will cause an error. In the "
"context of an ISO 8601 week-numbering year, the concept of a <quote>month</"
"quote> or <quote>day of month</quote> has no meaning. In the context of a "
"Gregorian year, the ISO week has no meaning."
msgstr ""
"Попытка ввести дату из смеси полей григорианского и недельного календаря ISO "
"8601 бессмысленна, поэтому это будет считаться ошибкой. В контексте ISO 8601 "
"понятия <quote>номер месяца</quote> и <quote>день месяца</quote> не "
"существуют, а в григорианском календаре нет понятия номера недели по ISO."

#: func.xml:6202(para)
msgid ""
"While <function>to_date</function> will reject a mixture of Gregorian and "
"ISO week-numbering date fields, <function>to_char</function> will not, since "
"output format specifications like <literal>YYYY-MM-DD (IYYY-IDDD)</literal> "
"can be useful. But avoid writing something like <literal>IYYY-MM-DD</"
"literal>; that would yield surprising results near the start of the year. "
"(See <xref linkend=\"functions-datetime-extract\"/> for more information.)"
msgstr ""
"Тогда как <function>to_date</function> не примет смесь полей григорианского "
"и недельного календаря ISO, <function>to_char</function> способна на это, "
"так как форматы вроде <literal>YYYY-MM-DD (IYYY-IDDD)</literal> могут быть "
"полезны. Но избегайте форматов типа <literal>IYYY-MM-DD</literal>; в "
"противном случае с датами в начале года возможны сюрпризы. (За "
"дополнительными сведениями обратитесь к <xref remap=\"3\" linkend="
"\"functions-datetime-extract\"/>.)"

#: func.xml:6216(para)
msgid ""
"In a conversion from string to <type>timestamp</type>, millisecond "
"(<literal>MS</literal>) or microsecond (<literal>US</literal>) values are "
"used as the seconds digits after the decimal point. For example "
"<literal>to_timestamp('12:3', 'SS:MS')</literal> is not 3 milliseconds, but "
"300, because the conversion counts it as 12 + 0.3 seconds. This means for "
"the format <literal>SS:MS</literal>, the input values <literal>12:3</"
"literal>, <literal>12:30</literal>, and <literal>12:300</literal> specify "
"the same number of milliseconds. To get three milliseconds, one must use "
"<literal>12:003</literal>, which the conversion counts as 12 + 0.003 = "
"12.003 seconds."
msgstr ""
"При преобразовании из текстовой строки в <type>timestamp</type>, "
"миллисекунды (<literal>MS</literal>) или микросекунды (<literal>US</"
"literal>) воспринимаются как дробная часть числа секунд. Например, "
"<literal>to_timestamp('12:3', 'SS:MS')</literal> &mdash; это не 3 "
"миллисекунды, а 300, так как это значение воспринимается как 12 + 0.3 сек. "
"Это значит, что для формата <literal>SS:MS</literal> вводимые значения "
"<literal>12:3</literal>, <literal>12:30</literal> и <literal>12:300</"
"literal> задают одно и то же число миллисекунд. Чтобы получить три "
"миллисекунды, время нужно записать в виде <literal>12:003</literal>, тогда "
"это будет воспринято как 12 + 0.003 = 12.003 сек."

#: func.xml:6230(para)
msgid ""
"Here is a more complex example: <literal>to_timestamp('15:12:02.020.001230', "
"'HH:MI:SS.MS.US')</literal> is 15 hours, 12 minutes, and 2 seconds + 20 "
"milliseconds + 1230 microseconds = 2.021230 seconds."
msgstr ""
"Ещё более сложный пример: <literal>to_timestamp('15:12:02.020.001230', 'HH:"
"MI:SS.MS.US')</literal> будет преобразовано в 15 часов, 12 минут и 2 секунды "
"+ 20 миллисекунд + 1230 микросекунд = 2.021230 seconds."

#: func.xml:6240(para)
msgid ""
"<function>to_char(..., 'ID')</function>'s day of the week numbering matches "
"the <function>extract(isodow from ...)</function> function, but "
"<function>to_char(..., 'D')</function>'s does not match "
"<function>extract(dow from ...)</function>'s day numbering."
msgstr ""
"Нумерация дней недели в <function>to_char(..., 'ID')</function> "
"соответствует функции <function>extract(isodow from ...)</function>, но "
"нумерация <function>to_char(..., 'D')</function> не соответствует нумерации, "
"принятой в <function>extract(dow from ...)</function>."

#: func.xml:6249(para)
msgid ""
"<function>to_char(interval)</function> formats <literal>HH</literal> and "
"<literal>HH12</literal> as shown on a 12-hour clock, i.e. zero hours and 36 "
"hours output as <literal>12</literal>, while <literal>HH24</literal> outputs "
"the full hour value, which can exceed 23 for intervals."
msgstr ""
"Функция <function>to_char(interval)</function> обрабатывает форматы "
"<literal>HH</literal> и <literal>HH12</literal> в рамках 12 часов, то есть 0 "
"и 36 часов будут выводиться как <literal>12</literal>, тогда как "
"<literal>HH24</literal> выводит значение полностью и для интервалов "
"выводимое значение может превышать 23."

#: func.xml:6060(para)
msgid "Usage notes for date/time formatting: <placeholder-1/>"
msgstr "Замечания по использованию форматов даты/времени: <placeholder-1/>"

#: func.xml:6260(para)
msgid ""
"<xref linkend=\"functions-formatting-numeric-table\"/> shows the template "
"patterns available for formatting numeric values."
msgstr ""
"Коды форматирования числовых значений перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-numeric-table\"/>."

#: func.xml:6266(title)
msgid "Template Patterns for Numeric Formatting"
msgstr "Коды форматирования чисел"

#: func.xml:6276(literal)
msgid "9"
msgstr "9"

#: func.xml:6277(entry)
msgid "value with the specified number of digits"
msgstr "значение с заданным количеством цифр"

#: func.xml:6280(literal) func.xml:12256(literal)
msgid "0"
msgstr "0"

#: func.xml:6281(entry)
msgid "value with leading zeros"
msgstr "значение с ведущими нулями"

#: func.xml:6284(entry)
msgid "<literal>.</literal> (period)"
msgstr "<literal>.</literal> (точка)"

#: func.xml:6285(entry)
msgid "decimal point"
msgstr "десятичная точка"

#: func.xml:6288(entry)
msgid "<literal>,</literal> (comma)"
msgstr "<literal>,</literal> (запятая)"

#: func.xml:6289(entry)
msgid "group (thousand) separator"
msgstr "разделитель групп (тысяч)"

#: func.xml:6292(literal)
msgid "PR"
msgstr "PR"

#: func.xml:6293(entry)
msgid "negative value in angle brackets"
msgstr "отрицательное значение в угловых скобках"

#: func.xml:6296(literal)
msgid "S"
msgstr "S"

#: func.xml:6297(entry)
msgid "sign anchored to number (uses locale)"
msgstr "знак, добавляемый к числу (с учётом локали)"

#: func.xml:6300(literal)
msgid "L"
msgstr "L"

#: func.xml:6301(entry)
msgid "currency symbol (uses locale)"
msgstr "символ денежной единицы (с учётом локали)"

#: func.xml:6305(entry)
msgid "decimal point (uses locale)"
msgstr "разделитель целой и дробной части числа (с учётом локали)"

#: func.xml:6308(literal)
msgid "G"
msgstr "G"

#: func.xml:6309(entry)
msgid "group separator (uses locale)"
msgstr "разделитель групп (с учётом локали)"

#: func.xml:6313(entry)
msgid "minus sign in specified position (if number &lt; 0)"
msgstr "знак минус в заданной позиции (если число &lt; 0)"

#: func.xml:6316(literal)
msgid "PL"
msgstr "PL"

#: func.xml:6317(entry)
msgid "plus sign in specified position (if number &gt; 0)"
msgstr "знак плюс в заданной позиции (если число &gt; 0)"

#: func.xml:6320(literal)
msgid "SG"
msgstr "SG"

#: func.xml:6321(entry)
msgid "plus/minus sign in specified position"
msgstr "знак плюс или минус в заданной позиции"

#: func.xml:6324(literal)
msgid "RN"
msgstr "RN"

#: func.xml:6325(entry)
msgid "Roman numeral (input between 1 and 3999)"
msgstr "число римскими цифрами (в диапазоне от 1 до 3999)"

#: func.xml:6328(entry)
msgid "<literal>TH</literal> or <literal>th</literal>"
msgstr "<literal>TH</literal> или <literal>th</literal>"

#: func.xml:6329(entry)
msgid "ordinal number suffix"
msgstr "окончание порядкового числительного"

#: func.xml:6332(literal)
msgid "V"
msgstr "V"

#: func.xml:6333(entry)
msgid "shift specified number of digits (see notes)"
msgstr "сдвиг на заданное количество цифр (см. замечания)"

#: func.xml:6336(literal)
msgid "EEEE"
msgstr "EEEE"

#: func.xml:6337(entry)
msgid "exponent for scientific notation"
msgstr "экспоненциальная запись числа"

#: func.xml:6348(para)
msgid ""
"A sign formatted using <literal>SG</literal>, <literal>PL</literal>, or "
"<literal>MI</literal> is not anchored to the number; for example, "
"<literal>to_char(-12, 'MI9999')</literal> produces <literal>'-&nbsp;"
"&nbsp;12'</literal> but <literal>to_char(-12, 'S9999')</literal> produces "
"<literal>'&nbsp;&nbsp;-12'</literal>. The Oracle implementation does not "
"allow the use of <literal>MI</literal> before <literal>9</literal>, but "
"rather requires that <literal>9</literal> precede <literal>MI</literal>."
msgstr ""
"Знак числа, полученный кодами <literal>SG</literal>, <literal>PL</literal> "
"или <literal>MI</literal>, не присоединяется к числу; например, "
"<literal>to_char(-12, 'MI9999')</literal> выдаёт <literal>'-&nbsp;&nbsp;12'</"
"literal>, тогда как <literal>to_char(-12, 'S9999')</literal> &mdash; "
"<literal>'&nbsp;&nbsp;-12'</literal>. В Oracle <literal>MI</literal> не "
"может идти перед <literal>9</literal>, наоборот <literal>9</literal> нужно "
"указать перед <literal>MI</literal>."

#: func.xml:6362(para)
msgid ""
"<literal>9</literal> results in a value with the same number of digits as "
"there are <literal>9</literal>s. If a digit is not available it outputs a "
"space."
msgstr ""
"<literal>9</literal> выводит значение с таким количеством цифр, какое было "
"бы, если бы оно состояло из девяток. Если цифры в данном месте не "
"оказывается, выводится пробел."

#: func.xml:6370(para)
msgid ""
"<literal>TH</literal> does not convert values less than zero and does not "
"convert fractional numbers."
msgstr ""
"<literal>TH</literal> не преобразует значения меньше 0 и не поддерживает "
"дробные числа."

#: func.xml:6377(para)
msgid ""
"<literal>PL</literal>, <literal>SG</literal>, and <literal>TH</literal> are "
"<productname>PostgreSQL</productname> extensions."
msgstr ""
"<literal>PL</literal>, <literal>SG</literal> и <literal>TH</literal> &mdash; "
"расширения <productname>PostgreSQL</productname>."

#: func.xml:6385(para)
msgid ""
"<literal>V</literal> with <function>to_char</function> multiplies the input "
"values by <literal>10^<replaceable>n</replaceable></literal>, where "
"<replaceable>n</replaceable> is the number of digits following <literal>V</"
"literal>. <literal>V</literal> with <function>to_number</function> divides "
"in a similar manner. <function>to_char</function> and <function>to_number</"
"function> do not support the use of <literal>V</literal> combined with a "
"decimal point (e.g., <literal>99.9V99</literal> is not allowed)."
msgstr ""
"<literal>V</literal> c <function>to_char</function> умножает вводимое "
"значение на <literal>10^<replaceable>n</replaceable></literal>, где "
"<replaceable>n</replaceable> — число цифр, следующих за <literal>V</"
"literal>. <literal>V</literal> с <function>to_number</function> подобным "
"образом делит значение. Функции <function>to_char</function> и "
"<function>to_number</function> не поддерживают <literal>V</literal> с "
"дробными числами (например, <literal>99.9V99</literal> не допускается)."

#: func.xml:6400(para)
msgid ""
"<literal>EEEE</literal> (scientific notation) cannot be used in combination "
"with any of the other formatting patterns or modifiers other than digit and "
"decimal point patterns, and must be at the end of the format string (e.g., "
"<literal>9.99EEEE</literal> is a valid pattern)."
msgstr ""
"Код <literal>EEEE</literal> (научная запись) не может сочетаться с любыми "
"другими вариантами форматирования или модификаторами, за исключением цифр и "
"десятичной точки, и должен располагаться в конце строки шаблона (например, "
"<literal>9.99EEEE</literal> &mdash; допустимый шаблон)."

#: func.xml:6343(para)
msgid "Usage notes for numeric formatting: <placeholder-1/>"
msgstr "Замечания по использованию форматов чисел: <placeholder-1/>"

#: func.xml:6410(para)
msgid ""
"Certain modifiers can be applied to any template pattern to alter its "
"behavior. For example, <literal>FM9999</literal> is the <literal>9999</"
"literal> pattern with the <literal>FM</literal> modifier. <xref linkend="
"\"functions-formatting-numericmod-table\"/> shows the modifier patterns for "
"numeric formatting."
msgstr ""
"Для изменения поведения кодов к ним могут быть применены определённые "
"модификаторы. Например, <literal>FM9999</literal> обрабатывается как код "
"<literal>9999</literal> с модификатором <literal>FM</literal>. Все "
"модификаторы для форматирования чисел перечислены в <xref remap=\"6\" "
"linkend=\"functions-formatting-numericmod-table\"/>."

#: func.xml:6420(title)
msgid "Template Pattern Modifiers for Numeric Formatting"
msgstr "Модификаторы шаблонов для форматирования чисел"

#: func.xml:6433(literal)
msgid "FM9999"
msgstr "FM9999"

#: func.xml:6438(literal)
msgid "999TH"
msgstr "999TH"

#: func.xml:6443(literal)
msgid "999th"
msgstr "999th"

#: func.xml:6449(para)
msgid ""
"<xref linkend=\"functions-formatting-examples-table\"/> shows some examples "
"of the use of the <function>to_char</function> function."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-formatting-examples-table\"/> "
"приведены некоторые примеры использования функции <function>to_char</"
"function>."

#: func.xml:6455(title)
msgid "<function>to_char</function> Examples"
msgstr "Примеры <function>to_char</function>"

#: func.xml:6459(entry) func.xml:7871(entry)
msgid "Expression"
msgstr "Выражение"

#: func.xml:6465(literal)
msgid "to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')"
msgstr "to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')"

#: func.xml:6466(literal)
msgid "'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'"
msgstr "'Tuesday&nbsp;&nbsp;,&nbsp;06&nbsp;&nbsp;05:39:18'"

#: func.xml:6469(literal)
msgid "to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')"
msgstr "to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')"

#: func.xml:6470(literal)
msgid "'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'"
msgstr "'Tuesday,&nbsp;6&nbsp;&nbsp;05:39:18'"

#: func.xml:6473(literal)
msgid "to_char(-0.1, '99.99')"
msgstr "to_char(-0.1, '99.99')"

#: func.xml:6474(literal)
msgid "'&nbsp;&nbsp;-.10'"
msgstr "'&nbsp;&nbsp;-.10'"

#: func.xml:6477(literal)
msgid "to_char(-0.1, 'FM9.99')"
msgstr "to_char(-0.1, 'FM9.99')"

#: func.xml:6478(literal)
msgid "'-.1'"
msgstr "'-.1'"

#: func.xml:6481(literal)
msgid "to_char(0.1, '0.9')"
msgstr "to_char(0.1, '0.9')"

#: func.xml:6482(literal)
msgid "'&nbsp;0.1'"
msgstr "'&nbsp;0.1'"

#: func.xml:6485(literal)
msgid "to_char(12, '9990999.9')"
msgstr "to_char(12, '9990999.9')"

#: func.xml:6486(literal)
msgid "'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'"
msgstr "'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'"

#: func.xml:6489(literal)
msgid "to_char(12, 'FM9990999.9')"
msgstr "to_char(12, 'FM9990999.9')"

#: func.xml:6490(literal)
msgid "'0012.'"
msgstr "'0012.'"

#: func.xml:6493(literal)
msgid "to_char(485, '999')"
msgstr "to_char(485, '999')"

#: func.xml:6494(literal)
msgid "'&nbsp;485'"
msgstr "'&nbsp;485'"

#: func.xml:6497(literal)
msgid "to_char(-485, '999')"
msgstr "to_char(-485, '999')"

#: func.xml:6498(literal) func.xml:6558(literal)
msgid "'-485'"
msgstr "'-485'"

#: func.xml:6501(literal)
msgid "to_char(485, '9&nbsp;9&nbsp;9')"
msgstr "to_char(485, '9&nbsp;9&nbsp;9')"

#: func.xml:6502(literal)
msgid "'&nbsp;4&nbsp;8&nbsp;5'"
msgstr "'&nbsp;4&nbsp;8&nbsp;5'"

#: func.xml:6505(literal)
msgid "to_char(1485, '9,999')"
msgstr "to_char(1485, '9,999')"

#: func.xml:6506(literal)
msgid "'&nbsp;1,485'"
msgstr "'&nbsp;1,485'"

#: func.xml:6509(literal)
msgid "to_char(1485, '9G999')"
msgstr "to_char(1485, '9G999')"

#: func.xml:6510(literal)
msgid "'&nbsp;1&nbsp;485'"
msgstr "'&nbsp;1&nbsp;485'"

#: func.xml:6513(literal)
msgid "to_char(148.5, '999.999')"
msgstr "to_char(148.5, '999.999')"

#: func.xml:6514(literal)
msgid "'&nbsp;148.500'"
msgstr "'&nbsp;148.500'"

#: func.xml:6517(literal)
msgid "to_char(148.5, 'FM999.999')"
msgstr "to_char(148.5, 'FM999.999')"

#: func.xml:6518(literal)
msgid "'148.5'"
msgstr "'148.5'"

#: func.xml:6521(literal)
msgid "to_char(148.5, 'FM999.990')"
msgstr "to_char(148.5, 'FM999.990')"

#: func.xml:6522(literal)
msgid "'148.500'"
msgstr "'148.500'"

#: func.xml:6525(literal)
msgid "to_char(148.5, '999D999')"
msgstr "to_char(148.5, '999D999')"

#: func.xml:6526(literal)
msgid "'&nbsp;148,500'"
msgstr "'&nbsp;148,500'"

#: func.xml:6529(literal)
msgid "to_char(3148.5, '9G999D999')"
msgstr "to_char(3148.5, '9G999D999')"

#: func.xml:6530(literal)
msgid "'&nbsp;3&nbsp;148,500'"
msgstr "'&nbsp;3&nbsp;148,500'"

#: func.xml:6533(literal)
msgid "to_char(-485, '999S')"
msgstr "to_char(-485, '999S')"

#: func.xml:6534(literal) func.xml:6538(literal)
msgid "'485-'"
msgstr "'485-'"

#: func.xml:6537(literal)
msgid "to_char(-485, '999MI')"
msgstr "to_char(-485, '999MI')"

#: func.xml:6541(literal)
msgid "to_char(485, '999MI')"
msgstr "to_char(485, '999MI')"

#: func.xml:6542(literal)
msgid "'485&nbsp;'"
msgstr "'485&nbsp;'"

#: func.xml:6545(literal)
msgid "to_char(485, 'FM999MI')"
msgstr "to_char(485, 'FM999MI')"

#: func.xml:6546(literal)
msgid "'485'"
msgstr "'485'"

#: func.xml:6549(literal)
msgid "to_char(485, 'PL999')"
msgstr "to_char(485, 'PL999')"

#: func.xml:6550(literal) func.xml:6554(literal)
msgid "'+485'"
msgstr "'+485'"

#: func.xml:6553(literal)
msgid "to_char(485, 'SG999')"
msgstr "to_char(485, 'SG999')"

#: func.xml:6557(literal)
msgid "to_char(-485, 'SG999')"
msgstr "to_char(-485, 'SG999')"

#: func.xml:6561(literal)
msgid "to_char(-485, '9SG99')"
msgstr "to_char(-485, '9SG99')"

#: func.xml:6562(literal)
msgid "'4-85'"
msgstr "'4-85'"

#: func.xml:6565(literal)
msgid "to_char(-485, '999PR')"
msgstr "to_char(-485, '999PR')"

#: func.xml:6566(literal)
msgid "'&lt;485&gt;'"
msgstr "'&lt;485&gt;'"

#: func.xml:6569(literal)
msgid "to_char(485, 'L999')"
msgstr "to_char(485, 'L999')"

#: func.xml:6570(literal)
msgid "'DM&nbsp;485'"
msgstr "'DM&nbsp;485'"

#: func.xml:6573(literal)
msgid "to_char(485, 'RN')"
msgstr "to_char(485, 'RN')"

#: func.xml:6574(literal)
msgid "'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'"
msgstr "'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'"

#: func.xml:6577(literal)
msgid "to_char(485, 'FMRN')"
msgstr "to_char(485, 'FMRN')"

#: func.xml:6578(literal)
msgid "'CDLXXXV'"
msgstr "'CDLXXXV'"

#: func.xml:6581(literal)
msgid "to_char(5.2, 'FMRN')"
msgstr "to_char(5.2, 'FMRN')"

#: func.xml:6582(literal)
msgid "'V'"
msgstr "'V'"

#: func.xml:6585(literal)
msgid "to_char(482, '999th')"
msgstr "to_char(482, '999th')"

#: func.xml:6586(literal)
msgid "'&nbsp;482nd'"
msgstr "'&nbsp;482nd'"

#: func.xml:6589(literal)
msgid "to_char(485, '\"Good&nbsp;number:\"999')"
msgstr "to_char(485, '\"Good&nbsp;number:\"999')"

#: func.xml:6590(literal)
msgid "'Good&nbsp;number:&nbsp;485'"
msgstr "'Good&nbsp;number:&nbsp;485'"

#: func.xml:6593(literal)
msgid "to_char(485.8, '\"Pre:\"999\"&nbsp;Post:\"&nbsp;.999')"
msgstr "to_char(485.8, '\"Pre:\"999\"&nbsp;Post:\"&nbsp;.999')"

#: func.xml:6594(literal)
msgid "'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'"
msgstr "'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'"

#: func.xml:6597(literal)
msgid "to_char(12, '99V999')"
msgstr "to_char(12, '99V999')"

#: func.xml:6598(literal)
msgid "'&nbsp;12000'"
msgstr "'&nbsp;12000'"

#: func.xml:6601(literal)
msgid "to_char(12.4, '99V999')"
msgstr "to_char(12.4, '99V999')"

#: func.xml:6602(literal)
msgid "'&nbsp;12400'"
msgstr "'&nbsp;12400'"

#: func.xml:6605(literal)
msgid "to_char(12.45, '99V9')"
msgstr "to_char(12.45, '99V9')"

#: func.xml:6606(literal)
msgid "'&nbsp;125'"
msgstr "'&nbsp;125'"

#: func.xml:6609(literal)
msgid "to_char(0.0004859, '9.99EEEE')"
msgstr "to_char(0.0004859, '9.99EEEE')"

#: func.xml:6610(literal)
msgid "' 4.86e-04'"
msgstr "' 4.86e-04'"

#: func.xml:6620(title)
msgid "Date/Time Functions and Operators"
msgstr "Операторы и функции даты/времени"

#: func.xml:6622(para)
msgid ""
"<xref linkend=\"functions-datetime-table\"/> shows the available functions "
"for date/time value processing, with details appearing in the following "
"subsections. <xref linkend=\"operators-datetime-table\"/> illustrates the "
"behaviors of the basic arithmetic operators (<literal>+</literal>, "
"<literal>*</literal>, etc.). For formatting functions, refer to <xref "
"linkend=\"functions-formatting\"/>. You should be familiar with the "
"background information on date/time data types from <xref linkend=\"datatype-"
"datetime\"/>."
msgstr ""
"Все существующие функции для обработки даты/времени перечислены в <xref "
"remap=\"6\" linkend=\"functions-datetime-table\"/>, а подробнее они описаны "
"в следующих подразделах. Поведение основных арифметических операторов "
"(<literal>+</literal>, <literal>*</literal> и т. д.) описано в <xref remap="
"\"6\" linkend=\"operators-datetime-table\"/>. Функции форматирования этих "
"типов данных были перечислены в <xref remap=\"6\" linkend=\"functions-"
"formatting\"/>. Общую информацию об этих типах вы получили (или можете "
"получить) в <xref remap=\"6\" linkend=\"datatype-datetime\"/>."

#: func.xml:6634(para)
msgid ""
"All the functions and operators described below that take <type>time</type> "
"or <type>timestamp</type> inputs actually come in two variants: one that "
"takes <type>time with time zone</type> or <type>timestamp with time zone</"
"type>, and one that takes <type>time without time zone</type> or "
"<type>timestamp without time zone</type>. For brevity, these variants are "
"not shown separately. Also, the <literal>+</literal> and <literal>*</"
"literal> operators come in commutative pairs (for example both date + "
"integer and integer + date); we show only one of each such pair."
msgstr ""
"Все описанные ниже функции и операторы принимают две разновидности типов "
"<type>time</type> или <type>timestamp</type>: с часовым поясом (<type>time "
"with time zone</type> и <type>timestamp with time zone</type>) и без него "
"(<type>time without time zone</type> и <type>timestamp without time zone</"
"type>). Для краткости здесь они рассматриваются вместе. Кроме того, "
"операторы <literal>+</literal> и <literal>*</literal> обладают "
"переместительным свойством (например, date + integer = integer + date); "
"здесь будет приведён только один вариант для каждой пары."

#: func.xml:6645(title)
msgid "Date/Time Operators"
msgstr "Операторы даты/времени"

#: func.xml:6659(literal)
msgid "date '2001-09-28' + integer '7'"
msgstr "date '2001-09-28' + integer '7'"

#: func.xml:6660(literal)
msgid "date '2001-10-05'"
msgstr "date '2001-10-05'"

#: func.xml:6665(literal)
msgid "date '2001-09-28' + interval '1 hour'"
msgstr "date '2001-09-28' + interval '1 hour'"

#: func.xml:6666(literal)
msgid "timestamp '2001-09-28 01:00:00'"
msgstr "timestamp '2001-09-28 01:00:00'"

#: func.xml:6671(literal)
msgid "date '2001-09-28' + time '03:00'"
msgstr "date '2001-09-28' + time '03:00'"

#: func.xml:6672(literal)
msgid "timestamp '2001-09-28 03:00:00'"
msgstr "timestamp '2001-09-28 03:00:00'"

#: func.xml:6677(literal)
msgid "interval '1 day' + interval '1 hour'"
msgstr "interval '1 day' + interval '1 hour'"

#: func.xml:6678(literal)
msgid "interval '1 day 01:00:00'"
msgstr "interval '1 day 01:00:00'"

#: func.xml:6683(literal)
msgid "timestamp '2001-09-28 01:00' + interval '23 hours'"
msgstr "timestamp '2001-09-28 01:00' + interval '23 hours'"

#: func.xml:6684(literal)
msgid "timestamp '2001-09-29 00:00:00'"
msgstr "timestamp '2001-09-29 00:00:00'"

#: func.xml:6689(literal)
msgid "time '01:00' + interval '3 hours'"
msgstr "time '01:00' + interval '3 hours'"

#: func.xml:6690(literal)
msgid "time '04:00:00'"
msgstr "time '04:00:00'"

#: func.xml:6695(literal)
msgid "- interval '23 hours'"
msgstr "- interval '23 hours'"

#: func.xml:6696(literal)
msgid "interval '-23:00:00'"
msgstr "interval '-23:00:00'"

#: func.xml:6701(literal)
msgid "date '2001-10-01' - date '2001-09-28'"
msgstr "date '2001-10-01' - date '2001-09-28'"

#: func.xml:6702(entry)
msgid "<literal>integer '3'</literal> (days)"
msgstr "<literal>integer '3'</literal> (дня)"

#: func.xml:6707(literal)
msgid "date '2001-10-01' - integer '7'"
msgstr "date '2001-10-01' - integer '7'"

#: func.xml:6708(literal)
msgid "date '2001-09-24'"
msgstr "date '2001-09-24'"

#: func.xml:6713(literal)
msgid "date '2001-09-28' - interval '1 hour'"
msgstr "date '2001-09-28' - interval '1 hour'"

#: func.xml:6714(literal)
msgid "timestamp '2001-09-27 23:00:00'"
msgstr "timestamp '2001-09-27 23:00:00'"

#: func.xml:6719(literal)
msgid "time '05:00' - time '03:00'"
msgstr "time '05:00' - time '03:00'"

#: func.xml:6720(literal)
msgid "interval '02:00:00'"
msgstr "interval '02:00:00'"

#: func.xml:6725(literal)
msgid "time '05:00' - interval '2 hours'"
msgstr "time '05:00' - interval '2 hours'"

#: func.xml:6726(literal)
msgid "time '03:00:00'"
msgstr "time '03:00:00'"

#: func.xml:6731(literal)
msgid "timestamp '2001-09-28 23:00' - interval '23 hours'"
msgstr "timestamp '2001-09-28 23:00' - interval '23 hours'"

#: func.xml:6732(literal)
msgid "timestamp '2001-09-28 00:00:00'"
msgstr "timestamp '2001-09-28 00:00:00'"

#: func.xml:6737(literal)
msgid "interval '1 day' - interval '1 hour'"
msgstr "interval '1 day' - interval '1 hour'"

#: func.xml:6738(literal)
msgid "interval '1 day -01:00:00'"
msgstr "interval '1 day -01:00:00'"

#: func.xml:6743(literal)
msgid "timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'"
msgstr "timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'"

#: func.xml:6744(literal)
msgid "interval '1 day 15:00:00'"
msgstr "interval '1 day 15:00:00'"

#: func.xml:6749(literal)
msgid "900 * interval '1 second'"
msgstr "900 * interval '1 second'"

#: func.xml:6750(literal)
msgid "interval '00:15:00'"
msgstr "interval '00:15:00'"

#: func.xml:6755(literal)
msgid "21 * interval '1 day'"
msgstr "21 * interval '1 day'"

#: func.xml:6756(literal)
msgid "interval '21 days'"
msgstr "interval '21 days'"

#: func.xml:6761(literal)
msgid "double precision '3.5' * interval '1 hour'"
msgstr "double precision '3.5' * interval '1 hour'"

#: func.xml:6762(literal)
msgid "interval '03:30:00'"
msgstr "interval '03:30:00'"

#: func.xml:6767(literal)
msgid "interval '1 hour' / double precision '1.5'"
msgstr "interval '1 hour' / double precision '1.5'"

#: func.xml:6768(literal)
msgid "interval '00:40:00'"
msgstr "interval '00:40:00'"

#: func.xml:6775(title)
msgid "Date/Time Functions"
msgstr "Функции даты/времени"

#: func.xml:6790(indexterm)
msgid "<primary>age</primary>"
msgstr "<primary>age</primary>"

#: func.xml:6793(function)
msgid "age(<placeholder-1/>, <placeholder-2/>)"
msgstr "age(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:6796(entry)
msgid ""
"Subtract arguments, producing a <quote>symbolic</quote> result that uses "
"years and months, rather than just days"
msgstr ""
"Вычитает аргументы и выдаёт <quote>символический</quote> результат с годами "
"и месяцами, а не просто днями"

#: func.xml:6798(literal)
msgid "age(timestamp '2001-04-10', timestamp '1957-06-13')"
msgstr "age(timestamp '2001-04-10', timestamp '1957-06-13')"

#: func.xml:6799(literal)
msgid "43 years 9 mons 27 days"
msgstr "43 years 9 mons 27 days (43 года 9 месяцев 27 дней)"

#: func.xml:6803(function)
msgid "age(<placeholder-1/>)"
msgstr "age(<placeholder-1/>)"

#: func.xml:6805(entry)
msgid "Subtract from <function>current_date</function> (at midnight)"
msgstr ""
"Вычитает дату/время из <function>current_date</function> (полночь текущего "
"дня)"

#: func.xml:6806(literal)
msgid "age(timestamp '1957-06-13')"
msgstr "age(timestamp '1957-06-13')"

#: func.xml:6807(literal)
msgid "43 years 8 mons 3 days"
msgstr "43 years 8 mons 3 days (43 года 8 месяцев 3 дня)"

#: func.xml:6812(indexterm)
msgid "<primary>clock_timestamp</primary>"
msgstr "<primary>clock_timestamp</primary>"

#: func.xml:6815(function)
msgid "clock_timestamp()"
msgstr "clock_timestamp&zwsp;()"

#: func.xml:6818(entry)
msgid ""
"Current date and time (changes during statement execution); see <xref "
"linkend=\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата и время (меняется в процессе выполнения операторов); см. <xref "
"remap=\"4\" linkend=\"functions-datetime-current\"/>"

#: func.xml:6827(indexterm)
msgid "<primary>current_date</primary>"
msgstr "<primary>current_date</primary>"

#: func.xml:6830(function)
msgid "current_date"
msgstr "current_date"

#: func.xml:6833(entry)
msgid "Current date; see <xref linkend=\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата; см. <xref remap=\"4\" linkend=\"functions-datetime-current\"/>"

#: func.xml:6842(indexterm)
msgid "<primary>current_time</primary>"
msgstr "<primary>current_time</primary>"

#: func.xml:6845(function)
msgid "current_time"
msgstr "current_time"

#: func.xml:6847(type) func.xml:7897(type) func.xml:7899(type)
msgid "time with time zone"
msgstr "time with time zone"

#: func.xml:6848(entry) func.xml:7019(entry)
msgid "Current time of day; see <xref linkend=\"functions-datetime-current\"/>"
msgstr ""
"Текущее время суток; см. <xref remap=\"4\" linkend=\"functions-datetime-"
"current\"/>"

#: func.xml:6857(indexterm)
msgid "<primary>current_timestamp</primary>"
msgstr "<primary>current_timestamp</primary>"

#: func.xml:6860(function)
msgid "current_timestamp"
msgstr "current_timestamp"

#: func.xml:6863(entry) func.xml:7034(entry) func.xml:7168(entry)
#: func.xml:7214(entry)
msgid ""
"Current date and time (start of current transaction); see <xref linkend="
"\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата и время (на момент начала транзакции); см. <xref remap=\"4\" "
"linkend=\"functions-datetime-current\"/>"

#: func.xml:6872(indexterm) func.xml:7340(indexterm)
msgid "<primary>date_part</primary>"
msgstr "<primary>date_part</primary>"

#: func.xml:6875(function) func.xml:6886(function)
msgid "date_part(<placeholder-1/>, <placeholder-2/>)"
msgstr "date_part(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:6878(entry) func.xml:6888(entry)
msgid ""
"Get subfield (equivalent to <function>extract</function>); see <xref linkend="
"\"functions-datetime-extract\"/>"
msgstr ""
"Возвращает поле даты (равнозначно <function>extract</function>); см. <xref "
"remap=\"4\" linkend=\"functions-datetime-extract\"/>"

#: func.xml:6881(literal)
msgid "date_part('hour', timestamp '2001-02-16 20:38:40')"
msgstr "date_part('hour', timestamp '2001-02-16 20:38:40')"

#: func.xml:6891(literal)
msgid "date_part('month', interval '2 years 3 months')"
msgstr "date_part('month', interval '2 years 3 months')"

#: func.xml:6897(indexterm) func.xml:7791(indexterm)
msgid "<primary>date_trunc</primary>"
msgstr "<primary>date_trunc</primary>"

#: func.xml:6900(function) func.xml:6910(function)
msgid "date_trunc(<placeholder-1/>, <placeholder-2/>)"
msgstr "date_trunc(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:6903(entry) func.xml:6912(entry)
msgid ""
"Truncate to specified precision; see also <xref linkend=\"functions-datetime-"
"trunc\"/>"
msgstr ""
"Отсекает компоненты даты до заданной точности; см. также <xref linkend="
"\"functions-datetime-trunc\"/>"

#: func.xml:6905(literal)
msgid "date_trunc('hour', timestamp '2001-02-16 20:38:40')"
msgstr "date_trunc('hour', timestamp '2001-02-16 20:38:40')"

#: func.xml:6906(literal)
msgid "2001-02-16 20:00:00"
msgstr "2001-02-16 20:00:00"

#: func.xml:6914(literal)
msgid "date_trunc('hour', interval '2 days 3 hours 40 minutes')"
msgstr "date_trunc('hour', interval '2 days 3 hours 40 minutes')"

#: func.xml:6915(literal)
msgid "2 days 03:00:00"
msgstr "2 days 03:00:00"

#: func.xml:6920(indexterm) func.xml:7343(indexterm)
msgid "<primary>extract</primary>"
msgstr "<primary>extract</primary>"

#: func.xml:6923(function) func.xml:6934(function)
msgid "extract"
msgstr "extract"

#: func.xml:6923(literal) func.xml:6934(literal)
msgid "<placeholder-1/>(<placeholder-2/> from <placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/> from <placeholder-3/>)"

#: func.xml:6927(entry) func.xml:6937(entry)
msgid "Get subfield; see <xref linkend=\"functions-datetime-extract\"/>"
msgstr ""
"Возвращает поле даты; см. <xref remap=\"4\" linkend=\"functions-datetime-"
"extract\"/>"

#: func.xml:6929(literal)
msgid "extract(hour from timestamp '2001-02-16 20:38:40')"
msgstr "extract(hour from timestamp '2001-02-16 20:38:40')"

#: func.xml:6939(literal)
msgid "extract(month from interval '2 years 3 months')"
msgstr "extract(month from interval '2 years 3 months')"

#: func.xml:6945(indexterm)
msgid "<primary>isfinite</primary>"
msgstr "<primary>isfinite</primary>"

#: func.xml:6948(function) func.xml:6957(function) func.xml:6965(function)
msgid "isfinite(<placeholder-1/>)"
msgstr "isfinite(<placeholder-1/>)"

#: func.xml:6951(entry)
msgid "Test for finite date (not +/-infinity)"
msgstr "Проверяет конечность даты (её отличие от +/-бесконечности)"

#: func.xml:6952(literal)
msgid "isfinite(date '2001-02-16')"
msgstr "isfinite(date '2001-02-16')"

#: func.xml:6953(literal) func.xml:6961(literal) func.xml:6969(literal)
#: func.xml:12710(literal) func.xml:12732(literal) func.xml:12743(literal)
msgctxt "literal"
msgid "true"
msgstr "true"

#: func.xml:6959(entry)
msgid "Test for finite time stamp (not +/-infinity)"
msgstr "Проверяет конечность времени (его отличие от +/-бесконечности)"

#: func.xml:6960(literal)
msgid "isfinite(timestamp '2001-02-16 21:28:30')"
msgstr "isfinite(timestamp '2001-02-16 21:28:30')"

#: func.xml:6967(entry)
msgid "Test for finite interval"
msgstr "Проверяет конечность интервала"

#: func.xml:6968(literal)
msgid "isfinite(interval '4 hours')"
msgstr "isfinite(interval '4 hours')"

#: func.xml:6974(indexterm)
msgid "<primary>justify_days</primary>"
msgstr "<primary>justify_days</primary>"

#: func.xml:6977(function)
msgid "justify_days(<placeholder-1/>)"
msgstr "justify_days(<placeholder-1/>)"

#: func.xml:6980(entry)
msgid "Adjust interval so 30-day time periods are represented as months"
msgstr ""
"Преобразует интервал так, что каждый 30-дневный период считается одним "
"месяцем"

#: func.xml:6981(literal)
msgid "justify_days(interval '35 days')"
msgstr "justify_days(interval '35 days')"

#: func.xml:6982(literal)
msgid "1 mon 5 days"
msgstr "1 mon 5 days (1 месяц 5 дней)"

#: func.xml:6987(indexterm)
msgid "<primary>justify_hours</primary>"
msgstr "<primary>justify_hours</primary>"

#: func.xml:6990(function)
msgid "justify_hours(<placeholder-1/>)"
msgstr "justify_hours(<placeholder-1/>)"

#: func.xml:6993(entry)
msgid "Adjust interval so 24-hour time periods are represented as days"
msgstr ""
"Преобразует интервал так, что каждый 24-часовой период считается одним днём"

#: func.xml:6994(literal)
msgid "justify_hours(interval '27 hours')"
msgstr "justify_hours(interval '27 hours')"

#: func.xml:6995(literal)
msgid "1 day 03:00:00"
msgstr "1 day 03:00:00 (1 день 03:00:00)"

#: func.xml:7000(indexterm)
msgid "<primary>justify_interval</primary>"
msgstr "<primary>justify_interval</primary>"

#: func.xml:7003(function)
msgid "justify_interval(<placeholder-1/>)"
msgstr "justify_interval(<placeholder-1/>)"

#: func.xml:7006(entry)
msgid ""
"Adjust interval using <function>justify_days</function> and "
"<function>justify_hours</function>, with additional sign adjustments"
msgstr ""
"Преобразует интервал с применением <function>justify_days</function> и "
"<function>justify_hours</function> и дополнительно корректирует знаки"

#: func.xml:7007(literal)
msgid "justify_interval(interval '1 mon -1 hour')"
msgstr "justify_interval(interval '1 mon -1 hour')"

#: func.xml:7008(literal)
msgid "29 days 23:00:00"
msgstr "29 days 23:00:00 (29 дней 23:00:00)"

#: func.xml:7013(indexterm)
msgid "<primary>localtime</primary>"
msgstr "<primary>localtime</primary>"

#: func.xml:7016(function)
msgid "localtime"
msgstr "localtime"

#: func.xml:7018(type) func.xml:7101(type)
msgid "time"
msgstr "time"

#: func.xml:7028(indexterm)
msgid "<primary>localtimestamp</primary>"
msgstr "<primary>localtimestamp</primary>"

#: func.xml:7031(function)
msgid "localtimestamp"
msgstr "localtimestamp"

#: func.xml:7043(indexterm)
msgid "<primary>make_date</primary>"
msgstr "<primary>make_date</primary>"

#: func.xml:7048(parameter) func.xml:7116(parameter) func.xml:7140(parameter)
msgctxt "parameter"
msgid "year"
msgstr "year"

#: func.xml:7049(parameter) func.xml:7117(parameter) func.xml:7141(parameter)
msgctxt "parameter"
msgid "month"
msgstr "month"

#: func.xml:7050(parameter) func.xml:7118(parameter) func.xml:7142(parameter)
msgctxt "parameter"
msgid "day"
msgstr "day"

#: func.xml:7047(function)
msgid ""
"make_date(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"make_date(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#: func.xml:7055(entry)
msgid "Create date from year, month and day fields"
msgstr "Образует дату из полей: year (год), month (месяц) и day (день)"

#: func.xml:7058(literal)
msgid "make_date(2013, 7, 15)"
msgstr "make_date(2013, 7, 15)"

#: func.xml:7059(literal)
msgid "2013-07-15"
msgstr "2013-07-15"

#: func.xml:7064(indexterm)
msgid "<primary>make_interval</primary>"
msgstr "<primary>make_interval</primary>"

#: func.xml:7069(parameter)
msgid "years"
msgstr "years"

#: func.xml:7070(parameter)
msgid "months"
msgstr "months"

#: func.xml:7071(parameter)
msgid "weeks"
msgstr "weeks"

#: func.xml:7072(parameter)
msgid "days"
msgstr "days"

#: func.xml:7073(parameter)
msgid "hours"
msgstr "hours"

#: func.xml:7074(parameter)
msgid "mins"
msgstr "mins"

#: func.xml:7075(parameter)
msgid "secs"
msgstr "secs"

#: func.xml:7068(function)
msgid ""
"make_interval(<placeholder-1/> <placeholder-2/> DEFAULT 0, <placeholder-3/> "
"<placeholder-4/> DEFAULT 0, <placeholder-5/> <placeholder-6/> DEFAULT 0, "
"<placeholder-7/> <placeholder-8/> DEFAULT 0, <placeholder-9/> "
"<placeholder-10/> DEFAULT 0, <placeholder-11/> <placeholder-12/> DEFAULT 0, "
"<placeholder-13/> <placeholder-14/> DEFAULT 0.0)"
msgstr ""
"make_interval(<placeholder-1/> <placeholder-2/> DEFAULT 0, <placeholder-3/> "
"<placeholder-4/> DEFAULT 0, <placeholder-5/> <placeholder-6/> DEFAULT 0, "
"<placeholder-7/> <placeholder-8/> DEFAULT 0, <placeholder-9/> "
"<placeholder-10/> DEFAULT 0, <placeholder-11/> <placeholder-12/> DEFAULT 0, "
"<placeholder-13/> <placeholder-14/> DEFAULT 0.0)"

#: func.xml:7080(entry)
msgid ""
"Create interval from years, months, weeks, days, hours, minutes and seconds "
"fields"
msgstr ""
"Образует интервал из полей: years (годы), months (месяцы), weeks (недели), "
"days (дни), hours (часы), minutes (минуты) и secs (секунды)"

#: func.xml:7084(literal)
msgid "make_interval(days =&gt; 10)"
msgstr "make_interval(days =&gt; 10)"

#: func.xml:7085(literal)
msgid "10 days"
msgstr "10 days"

#: func.xml:7090(indexterm)
msgid "<primary>make_time</primary>"
msgstr "<primary>make_time</primary>"

#: func.xml:7095(parameter) func.xml:7119(parameter) func.xml:7143(parameter)
msgctxt "parameter"
msgid "hour"
msgstr "hour"

#: func.xml:7096(parameter) func.xml:7120(parameter) func.xml:7144(parameter)
msgid "min"
msgstr "min"

#: func.xml:7097(parameter) func.xml:7121(parameter) func.xml:7145(parameter)
msgid "sec"
msgstr "sec"

#: func.xml:7094(function)
msgid ""
"make_time(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"make_time(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#: func.xml:7102(entry)
msgid "Create time from hour, minute and seconds fields"
msgstr "Образует время из полей: hour (час), minute (минута) и sec (секунда)"

#: func.xml:7105(literal)
msgid "make_time(8, 15, 23.5)"
msgstr "make_time(8, 15, 23.5)"

#: func.xml:7106(literal)
msgid "08:15:23.5"
msgstr "08:15:23.5"

#: func.xml:7111(indexterm)
msgid "<primary>make_timestamp</primary>"
msgstr "<primary>make_timestamp</primary>"

#: func.xml:7115(function)
msgid ""
"make_timestamp(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>, <placeholder-9/> <placeholder-10/>, <placeholder-11/> "
"<placeholder-12/>)"
msgstr ""
"make_timestamp(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>, <placeholder-9/> <placeholder-10/>, <placeholder-11/> "
"<placeholder-12/>)"

#: func.xml:7126(entry)
msgid "Create timestamp from year, month, day, hour, minute and seconds fields"
msgstr ""
"Образует дату и время из полей: year (год), month (месяц), day (день), hour "
"(час), minute (минута) и sec (секунда)"

#: func.xml:7129(literal)
msgid "make_timestamp(2013, 7, 15, 8, 15, 23.5)"
msgstr "make_timestamp(2013, 7, 15, 8, 15, 23.5)"

#: func.xml:7130(literal)
msgid "2013-07-15 08:15:23.5"
msgstr "2013-07-15 08:15:23.5"

#: func.xml:7135(indexterm)
msgid "<primary>make_timestamptz</primary>"
msgstr "<primary>make_timestamptz</primary>"

#: func.xml:7146(parameter)
msgctxt "parameter"
msgid "timezone"
msgstr "timezone"

#: func.xml:7139(function)
msgid ""
"make_timestamptz(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>, <placeholder-9/> <placeholder-10/>, <placeholder-11/> "
"<placeholder-12/>, <optional><placeholder-13/> <placeholder-14/></optional>)"
msgstr ""
"make_timestamptz(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>, <placeholder-7/> "
"<placeholder-8/>, <placeholder-9/> <placeholder-10/>, <placeholder-11/> "
"<placeholder-12/>, <optional><placeholder-13/> <placeholder-14/></optional>)"

#: func.xml:7151(entry)
msgid ""
"Create timestamp with time zone from year, month, day, hour, minute and "
"seconds fields; if <parameter>timezone</parameter> is not specified, the "
"current time zone is used"
msgstr ""
"Образует дату и время с часовым поясом из полей: year (год), month (месяц), "
"day (день), hour (час), minute (минута) и sec (секунда). Если параметр "
"<parameter>timezone</parameter> (часовой пояс) не указан, используется "
"текущий часовой пояс."

#: func.xml:7156(literal)
msgid "make_timestamptz(2013, 7, 15, 8, 15, 23.5)"
msgstr "make_timestamptz(2013, 7, 15, 8, 15, 23.5)"

#: func.xml:7157(literal)
msgid "2013-07-15 08:15:23.5+01"
msgstr "2013-07-15 08:15:23.5+01"

#: func.xml:7162(indexterm)
msgid "<primary>now</primary>"
msgstr "<primary>now</primary>"

#: func.xml:7165(function)
msgid "now()"
msgstr "now()"

#: func.xml:7177(indexterm)
msgid "<primary>statement_timestamp</primary>"
msgstr "<primary>statement_timestamp</primary>"

#: func.xml:7180(function)
msgid "statement_timestamp()"
msgstr "statement_timestamp()"

#: func.xml:7183(entry)
msgid ""
"Current date and time (start of current statement); see <xref linkend="
"\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата и время (на момент начала текущего оператора); см. <xref remap="
"\"4\" linkend=\"functions-datetime-current\"/>"

#: func.xml:7192(indexterm)
msgid "<primary>timeofday</primary>"
msgstr "<primary>timeofday</primary>"

#: func.xml:7195(function)
msgid "timeofday()"
msgstr "timeofday()"

#: func.xml:7198(entry)
msgid ""
"Current date and time (like <function>clock_timestamp</function>, but as a "
"<type>text</type> string); see <xref linkend=\"functions-datetime-current\"/>"
msgstr ""
"Текущая дата и время (как <function>clock_timestamp</function>, но в виде "
"строки типа <type>text</type>); см. <xref remap=\"4\" linkend=\"functions-"
"datetime-current\"/>"

#: func.xml:7208(indexterm)
msgid "<primary>transaction_timestamp</primary>"
msgstr "<primary>transaction_timestamp</primary>"

#: func.xml:7211(function)
msgid "transaction_timestamp()"
msgstr "transaction_timestamp()"

#: func.xml:7225(function)
msgid "to_timestamp(<placeholder-1/>)"
msgstr "to_timestamp(<placeholder-1/>)"

#: func.xml:7228(entry)
msgid "Convert Unix epoch (seconds since 1970-01-01 00:00:00+00) to timestamp"
msgstr ""
"Преобразует время эпохи Unix (число секунд с 1970-01-01 00:00:00+00) в "
"стандартное время"

#: func.xml:7230(literal)
msgid "to_timestamp(1284352323)"
msgstr "to_timestamp(1284352323)"

#: func.xml:7231(literal)
msgid "2010-09-13 04:32:03+00"
msgstr "2010-09-13 04:32:03+00"

#: func.xml:7238(indexterm)
msgid "<primary>OVERLAPS</primary>"
msgstr "<primary>OVERLAPS</primary>"

#: func.xml:7237(para)
msgid ""
"<placeholder-1/> In addition to these functions, the SQL <literal>OVERLAPS</"
"literal> operator is supported: <synopsis>\n"
"(<replaceable>start1</replaceable>, <replaceable>end1</replaceable>) "
"OVERLAPS (<replaceable>start2</replaceable>, <replaceable>end2</"
"replaceable>)\n"
"(<replaceable>start1</replaceable>, <replaceable>length1</replaceable>) "
"OVERLAPS (<replaceable>start2</replaceable>, <replaceable>length2</"
"replaceable>)\n"
"</synopsis> This expression yields true when two time periods (defined by "
"their endpoints) overlap, false when they do not overlap. The endpoints can "
"be specified as pairs of dates, times, or time stamps; or as a date, time, "
"or time stamp followed by an interval. When a pair of values is provided, "
"either the start or the end can be written first; <literal>OVERLAPS</"
"literal> automatically takes the earlier value of the pair as the start. "
"Each time period is considered to represent the half-open interval "
"<replaceable>start</replaceable> <literal>&lt;=</literal> <replaceable>time</"
"replaceable> <literal>&lt;</literal> <replaceable>end</replaceable>, unless "
"<replaceable>start</replaceable> and <replaceable>end</replaceable> are "
"equal in which case it represents that single time instant. This means for "
"instance that two time periods with only an endpoint in common do not "
"overlap."
msgstr ""
"<placeholder-1/> В дополнение к этим функциям поддерживается SQL-оператор "
"<literal>OVERLAPS</literal>: <synopsis>\n"
"(<replaceable>начало1</replaceable>, <replaceable>конец1</replaceable>) "
"OVERLAPS (<replaceable>начало2</replaceable>, <replaceable>конец2</"
"replaceable>)\n"
"(<replaceable>начало1</replaceable>, <replaceable>длительность1</"
"replaceable>) OVERLAPS (<replaceable>начало2</replaceable>, "
"<replaceable>длительность2</replaceable>)\n"
"</synopsis> Его результатом будет true, когда два периода времени "
"(определённые своими границами) пересекаются, и false в противном случае. "
"Границы периода можно задать либо в виде пары дат, времени или дат со "
"временем, либо как дату, время (или дату со временем) c интервалом. Когда "
"указывается пара значений, первым может быть и начало, и конец периода: "
"<literal>OVERLAPS</literal> автоматически считает началом периода меньшее "
"значение. Периоды времени считаются наполовину открытыми, т. е. "
"<replaceable>начало</replaceable><literal>&lt;=</literal><replaceable>время</"
"replaceable><literal>&lt;</literal><replaceable>конец</replaceable>, если "
"только <replaceable>начало</replaceable> и <replaceable>конец</replaceable> "
"не равны &mdash; в этом случае период представляет один момент времени. Это "
"означает, например, что два периода, имеющие только общую границу, не будут "
"считаться пересекающимися."

#: func.xml:7264(lineannotation) func.xml:7267(lineannotation)
#: func.xml:7270(lineannotation) func.xml:7273(lineannotation)
#: func.xml:7326(lineannotation) func.xml:7330(lineannotation)
#: func.xml:7332(lineannotation) func.xml:7334(lineannotation)
#: func.xml:7375(lineannotation) func.xml:7377(lineannotation)
#: func.xml:7402(lineannotation) func.xml:7405(lineannotation)
#: func.xml:7422(lineannotation) func.xml:7437(lineannotation)
#: func.xml:7457(lineannotation) func.xml:7476(lineannotation)
#: func.xml:7479(lineannotation) func.xml:7488(lineannotation)
#: func.xml:7502(lineannotation) func.xml:7517(lineannotation)
#: func.xml:7537(lineannotation) func.xml:7539(lineannotation)
#: func.xml:7565(lineannotation) func.xml:7579(lineannotation)
#: func.xml:7599(lineannotation) func.xml:7613(lineannotation)
#: func.xml:7629(lineannotation) func.xml:7632(lineannotation)
#: func.xml:7635(lineannotation) func.xml:7649(lineannotation)
#: func.xml:7665(lineannotation) func.xml:7668(lineannotation)
#: func.xml:7725(lineannotation) func.xml:7740(lineannotation)
#: func.xml:7780(lineannotation) func.xml:7783(lineannotation)
msgid "Result:"
msgstr "Результат:"

#: func.xml:7264(computeroutput) func.xml:7273(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "true"
msgstr "true"

#: func.xml:7267(computeroutput) func.xml:7270(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "false"
msgstr "false"

#: func.xml:7261(screen)
#, no-wrap
msgid ""
"SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2002-10-30');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2002-10-30');\n"
"<placeholder-3/><placeholder-4/>\n"
"SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2001-10-31');\n"
"<placeholder-5/><placeholder-6/>\n"
"SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2001-10-31');\n"
"<placeholder-7/><placeholder-8/>"
msgstr ""
"SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2002-10-30');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2002-10-30');\n"
"<placeholder-3/><placeholder-4/>\n"
"SELECT (DATE '2001-10-29', DATE '2001-10-30') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2001-10-31');\n"
"<placeholder-5/><placeholder-6/>\n"
"SELECT (DATE '2001-10-30', DATE '2001-10-30') OVERLAPS\n"
"       (DATE '2001-10-30', DATE '2001-10-31');\n"
"<placeholder-7/><placeholder-8/>"

#: func.xml:7276(para)
msgid ""
"When adding an <type>interval</type> value to (or subtracting an "
"<type>interval</type> value from) a <type>timestamp with time zone</type> "
"value, the days component advances or decrements the date of the "
"<type>timestamp with time zone</type> by the indicated number of days. "
"Across daylight saving time changes (when the session time zone is set to a "
"time zone that recognizes DST), this means <literal>interval '1 day'</"
"literal> does not necessarily equal <literal>interval '24 hours'</literal>. "
"For example, with the session time zone set to <literal>CST7CDT</literal>, "
"<literal>timestamp with time zone '2005-04-02 12:00-07' + interval '1 day'</"
"literal> will produce <literal>timestamp with time zone '2005-04-03 "
"12:00-06'</literal>, while adding <literal>interval '24 hours'</literal> to "
"the same initial <type>timestamp with time zone</type> produces "
"<literal>timestamp with time zone '2005-04-03 13:00-06'</literal>, as there "
"is a change in daylight saving time at <literal>2005-04-03 02:00</literal> "
"in time zone <literal>CST7CDT</literal>."
msgstr ""
"При добавлении к дате со временем типа <type>timestamp with time zone</type> "
"значения <type>interval</type> (или при вычитании из него <type>interval</"
"type>), поле дней в этой дате увеличивается (или уменьшается) на указанное "
"число дней. При пересечении границы перехода на летнее время (если в часовом "
"поясе текущего сеанса производится этот переход) это означает, что "
"<literal>interval '1 day'</literal> и <literal>interval '24 hours'</literal> "
"не обязательно будут равны. Например, в часовом поясе <literal>CST7CDT</"
"literal> результатом выражения <literal>timestamp with time zone '2005-04-02 "
"12:00-07' + interval '1 day' </literal> будет <literal>timestamp with time "
"zone '2005-04-03 12:00-06'</literal>, тогда как, если добавить "
"<literal>interval '24 hours'</literal> к тому же значению <type>timestamp "
"with time zone</type>, в результате получится <literal>timestamp with time "
"zone '2005-04-03 13:00-06'</literal>. Эта разница объясняется тем, что "
"<literal>2005-04-03 02:00</literal> в часовом поясе <literal>CST7CDT</"
"literal> произошёл переход на летнее время."

#: func.xml:7294(para)
msgid ""
"Note there can be ambiguity in the <literal>months</literal> field returned "
"by <function>age</function> because different months have different numbers "
"of days. <productname>PostgreSQL</productname>'s approach uses the month "
"from the earlier of the two dates when calculating partial months. For "
"example, <literal>age('2004-06-01', '2004-04-30')</literal> uses April to "
"yield <literal>1 mon 1 day</literal>, while using May would yield <literal>1 "
"mon 2 days</literal> because May has 31 days, while April has only 30."
msgstr ""
"Обратите внимание на возможную неоднозначность в поле <literal>months</"
"literal> в результате функции <function>age</function>, вызванную тем, что "
"число дней в разных месяцах неодинаково. Вычисляя оставшиеся дни месяца, "
"<productname>PostgreSQL</productname> рассматривает месяц меньшей из двух "
"дат. Например, результатом <literal>age('2004-06-01', '2004-04-30')</"
"literal> будет <literal>1 mon 1 day</literal>, так как в апреле 30 дней, а "
"то же выражение с датой 30 мая выдаст <literal>1 mon 2 days</literal>, так "
"как в мае 31 день."

#: func.xml:7304(para)
msgid ""
"Subtraction of dates and timestamps can also be complex. One conceptually "
"simple way to perform subtraction is to convert each value to a number of "
"seconds using <literal>EXTRACT(EPOCH FROM ...)</literal>, then subtract the "
"results; this produces the number of <emphasis>seconds</emphasis> between "
"the two values. This will adjust for the number of days in each month, "
"timezone changes, and daylight saving time adjustments. Subtraction of date "
"or timestamp values with the <quote><literal>-</literal></quote> operator "
"returns the number of days (24-hours) and hours/minutes/seconds between the "
"values, making the same adjustments. The <function>age</function> function "
"returns years, months, days, and hours/minutes/seconds, performing field-by-"
"field subtraction and then adjusting for negative field values. The "
"following queries illustrate the differences in these approaches. The sample "
"results were produced with <literal>timezone = 'US/Eastern'</literal>; there "
"is a daylight saving time change between the two dates used:"
msgstr ""
"Вычитание дат и дат со временем также может быть нетривиальной операцией. "
"Один принципиально простой способ выполнить такое вычисление &mdash; "
"преобразовать каждое значение в количество секунд, используя "
"<literal>EXTRACT(EPOCH FROM ...)</literal>, а затем найти разницу "
"результатов; при этом будет получено число <emphasis>секунд</emphasis> между "
"двумя датами. При этом будет учтено неодинаковое число дней в месяцах, "
"изменения часовых поясов и переходы на летнее время. При вычитании дат или "
"дат со временем с помощью оператора <quote><literal>-</literal></quote> "
"выдаётся число дней (по 24 часа) и часов/минут/секунд между данными "
"значениями, с учётом тех же факторов. Функция <function>age</function> "
"возвращает число лет, месяцев, дней и часов/минут/секунд, выполняя вычитание "
"по полям, а затем пересчитывая отрицательные значения. Различие этих "
"подходов иллюстрируют следующие запросы. Показанные результаты были получены "
"для часового пояса <literal>'US/Eastern'</literal>; между двумя заданными "
"датами произошёл переход на летнее время:"

#: func.xml:7326(computeroutput)
#, no-wrap
msgid "10537200"
msgstr "10537200"

#: func.xml:7330(computeroutput)
#, no-wrap
msgid "121.958333333333"
msgstr "121.958333333333"

#: func.xml:7332(computeroutput)
#, no-wrap
msgid "121 days 23:00:00"
msgstr "121 days 23:00:00"

#: func.xml:7334(computeroutput)
#, no-wrap
msgid "4 mons"
msgstr "4 mons"

#: func.xml:7323(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -\n"
"       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -\n"
"        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))\n"
"        / 60 / 60 / 24;\n"
"<placeholder-3/><placeholder-4/>\n"
"SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';\n"
"<placeholder-5/><placeholder-6/>\n"
"SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');\n"
"<placeholder-7/><placeholder-8/>"
msgstr ""
"SELECT EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -\n"
"       EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT (EXTRACT(EPOCH FROM timestamptz '2013-07-01 12:00:00') -\n"
"        EXTRACT(EPOCH FROM timestamptz '2013-03-01 12:00:00'))\n"
"        / 60 / 60 / 24;\n"
"<placeholder-3/><placeholder-4/>\n"
"SELECT timestamptz '2013-07-01 12:00:00' - timestamptz '2013-03-01 12:00:00';\n"
"<placeholder-5/><placeholder-6/>\n"
"SELECT age(timestamptz '2013-07-01 12:00:00', timestamptz '2013-03-01 12:00:00');\n"
"<placeholder-7/><placeholder-8/>"

#: func.xml:7338(title)
msgid "<function>EXTRACT</function>, <function>date_part</function>"
msgstr "<function>EXTRACT</function>, <function>date_part</function>"

#: func.xml:7348(replaceable)
msgctxt "replaceable"
msgid "field"
msgstr "field"

#: func.xml:7348(replaceable)
msgid "source"
msgstr "source"

#: func.xml:7347(synopsis)
#, no-wrap
msgid "EXTRACT(<placeholder-1/> FROM <placeholder-2/>)"
msgstr "EXTRACT(<placeholder-1/> FROM <placeholder-2/>)"

#: func.xml:7367(literal) func.xml:7830(literal)
msgid "century"
msgstr "century"

#: func.xml:7369(para)
msgid "The century"
msgstr "Век:"

#: func.xml:7375(computeroutput) func.xml:7502(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "20"
msgstr "20"

#: func.xml:7377(computeroutput)
#, no-wrap
msgid "21"
msgstr "21"

#: func.xml:7373(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT EXTRACT(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-3/><placeholder-4/>"

#: func.xml:7380(para)
msgid ""
"The first century starts at 0001-01-01 00:00:00 AD, although they did not "
"know it at the time. This definition applies to all Gregorian calendar "
"countries. There is no century number 0, you go from -1 century to 1 "
"century. If you disagree with this, please write your complaint to: Pope, "
"Cathedral Saint-Peter of Roma, Vatican."
msgstr ""
"Первый век начался 0001-01-01 00:00:00, хотя люди в то время и не считали "
"так. Это определение распространяется на все страны с григорианским "
"календарём. Века с номером 0 нет было; считается, что 1 наступил после -1. "
"Если такое положение вещей вас не устраивает, направляйте жалобы по адресу: "
"Ватикан, Собор Святого Петра, Папе."

#: func.xml:7395(para)
msgid ""
"For <type>timestamp</type> values, the day (of the month) field (1 - 31) ; "
"for <type>interval</type> values, the number of days"
msgstr ""
"Для значений <type>timestamp</type> это день месяца (1 - 31), для значений "
"<type>interval</type> &mdash; число дней"

#: func.xml:7402(computeroutput) func.xml:7780(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "16"
msgstr "16"

#: func.xml:7405(computeroutput) func.xml:7665(computeroutput)
#, no-wrap
msgid "40"
msgstr "40"

#: func.xml:7400(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(DAY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(DAY FROM INTERVAL '40 days 1 minute');\n"
"<placeholder-3/><placeholder-4/>"

#: func.xml:7414(literal) func.xml:7829(literal)
msgid "decade"
msgstr "decade"

#: func.xml:7416(para)
msgid "The year field divided by 10"
msgstr "Год, делённый на 10"

#: func.xml:7422(computeroutput)
#, no-wrap
msgid "200"
msgstr "200"

#: func.xml:7420(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7428(literal)
msgid "dow"
msgstr "dow"

#: func.xml:7430(para)
msgid ""
"The day of the week as Sunday (<literal>0</literal>) to Saturday "
"(<literal>6</literal>)"
msgstr ""
"День недели, считая с воскресенья (<literal>0</literal>) до субботы "
"(<literal>6</literal>)"

#: func.xml:7437(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "5"
msgstr "5"

#: func.xml:7435(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(DOW FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7439(para)
msgid ""
"Note that <function>extract</function>'s day of the week numbering differs "
"from that of the <function>to_char(..., 'D')</function> function."
msgstr ""
"Заметьте, что в <function>extract</function> дни недели нумеруются не так, "
"как в функции <function>to_char(..., 'D')</function>."

#: func.xml:7449(literal)
msgid "doy"
msgstr "doy"

#: func.xml:7451(para)
msgid "The day of the year (1 - 365/366)"
msgstr "День года (1 - 365/366)"

#: func.xml:7457(computeroutput)
#, no-wrap
msgid "47"
msgstr "47"

#: func.xml:7455(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(DOY FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7463(literal)
msgid "epoch"
msgstr "epoch"

#: func.xml:7465(para)
msgid ""
"For <type>timestamp with time zone</type> values, the number of seconds "
"since 1970-01-01 00:00:00 UTC (can be negative); for <type>date</type> and "
"<type>timestamp</type> values, the number of seconds since 1970-01-01 "
"00:00:00 local time; for <type>interval</type> values, the total number of "
"seconds in the interval"
msgstr ""
"Для значений <type>timestamp with time zone</type> это число секунд с "
"1970-01-01 00:00:00 UTC (может быть отрицательным); для значений <type>date</"
"type> и <type>timestamp</type> это число секунд с 1970-01-01 00:00:00 по "
"местному времени, а для <type>interval</type> &mdash; общая длительность "
"интервала в секундах"

#: func.xml:7476(computeroutput)
#, no-wrap
msgid "982384720.12"
msgstr "982384720.12"

#: func.xml:7479(computeroutput)
#, no-wrap
msgid "442800"
msgstr "442800"

#: func.xml:7474(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40.12-08');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(EPOCH FROM TIMESTAMP WITH TIME ZONE\n"
" '2001-02-16 20:38:40.12-08');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(EPOCH FROM INTERVAL '5 days 3 hours');\n"
"<placeholder-3/><placeholder-4/>"

#: func.xml:7482(para)
msgid ""
"You can convert an epoch value back to a time stamp with "
"<function>to_timestamp</function>:"
msgstr ""
"Преобразовать время эпохи назад, в значение дата/время, с помощью "
"<function>to_timestamp</function> можно так:"

#: func.xml:7488(computeroutput)
#, no-wrap
msgid "2001-02-17 04:38:40.12+00"
msgstr "2001-02-17 04:38:40.12+00"

#: func.xml:7486(screen)
#, no-wrap
msgid ""
"SELECT to_timestamp(982384720.12);\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT to_timestamp(982384720.12);\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7494(literal) func.xml:7823(literal)
msgctxt "literal"
msgid "hour"
msgstr "hour"

#: func.xml:7496(para)
msgid "The hour field (0 - 23)"
msgstr "Час (0 - 23)"

#: func.xml:7500(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7508(literal)
msgid "isodow"
msgstr "isodow"

#: func.xml:7510(para)
msgid ""
"The day of the week as Monday (<literal>1</literal>) to Sunday (<literal>7</"
"literal>)"
msgstr ""
"День недели, считая с понедельника (<literal>1</literal>) до воскресенья "
"(<literal>7</literal>)"

#: func.xml:7517(computeroutput) func.xml:7725(computeroutput)
#, no-wrap
msgid "7"
msgstr "7"

#: func.xml:7515(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(ISODOW FROM TIMESTAMP '2001-02-18 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7519(para)
msgid ""
"This is identical to <literal>dow</literal> except for Sunday. This matches "
"the <acronym>ISO</acronym> 8601 day of the week numbering."
msgstr ""
"Результат отличается от <literal>dow</literal> только для воскресенья. Такая "
"нумерация соответствует <acronym>ISO</acronym> 8601."

#: func.xml:7528(literal)
msgid "isoyear"
msgstr "isoyear"

#: func.xml:7530(para)
msgid ""
"The <acronym>ISO</acronym> 8601 week-numbering year that the date falls in "
"(not applicable to intervals)"
msgstr ""
"Год по недельному календарю <acronym>ISO</acronym> 8601, в который попадает "
"дата (неприменимо к интервалам)"

#: func.xml:7537(computeroutput)
#, no-wrap
msgid "2005"
msgstr "2005"

#: func.xml:7539(computeroutput)
#, no-wrap
msgid "2006"
msgstr "2006"

#: func.xml:7535(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-01');\n"
"<placeholder-1/><placeholder-2/>\n"
"SELECT EXTRACT(ISOYEAR FROM DATE '2006-01-02');\n"
"<placeholder-3/><placeholder-4/>"

#: func.xml:7542(para)
msgid ""
"Each <acronym>ISO</acronym> 8601 week-numbering year begins with the Monday "
"of the week containing the 4th of January, so in early January or late "
"December the <acronym>ISO</acronym> year may be different from the Gregorian "
"year. See the <literal>week</literal> field for more information."
msgstr ""
"Год по недельному календарю <acronym>ISO</acronym> начинается с понедельника "
"недели, в которой оказывается 4 января, так что в начале января или в конце "
"декабря год по <acronym>ISO</acronym> может отличаться от года по "
"григорианскому календарю. Подробнее об этом рассказывается в описании поля "
"<literal>week</literal>."

#: func.xml:7549(para)
msgid "This field is not available in PostgreSQL releases prior to 8.3."
msgstr "Этого поля не было в PostgreSQL до версии 8.3."

#: func.xml:7556(literal) func.xml:7819(literal)
msgid "microseconds"
msgstr "microseconds"

#: func.xml:7558(para)
msgid ""
"The seconds field, including fractional parts, multiplied by 1 000 000; note "
"that this includes full seconds"
msgstr ""
"Значение секунд с дробной частью, умноженное на 1 000 000; заметьте, что оно "
"включает и целые секунды"

#: func.xml:7565(computeroutput)
#, no-wrap
msgid "28500000"
msgstr "28500000"

#: func.xml:7563(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(MICROSECONDS FROM TIME '17:12:28.5');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7571(literal) func.xml:7831(literal)
msgid "millennium"
msgstr "millennium"

#: func.xml:7573(para)
msgid "The millennium"
msgstr "Тысячелетие"

#: func.xml:7579(computeroutput) func.xml:7632(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "3"
msgstr "3"

#: func.xml:7577(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7582(para)
msgid ""
"Years in the 1900s are in the second millennium. The third millennium "
"started January 1, 2001."
msgstr ""
"Годы 20 века относятся ко второму тысячелетию. Третье тысячелетие началось 1 "
"января 2001 г."

#: func.xml:7590(literal) func.xml:7820(literal)
msgid "milliseconds"
msgstr "milliseconds"

#: func.xml:7592(para)
msgid ""
"The seconds field, including fractional parts, multiplied by 1000. Note that "
"this includes full seconds."
msgstr ""
"Значение секунд с дробной частью, умноженное на 1 000; заметьте, что оно "
"включает и целые секунды."

#: func.xml:7599(computeroutput)
#, no-wrap
msgid "28500"
msgstr "28500"

#: func.xml:7597(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(MILLISECONDS FROM TIME '17:12:28.5');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7605(literal) func.xml:7822(literal)
msgid "minute"
msgstr "minute"

#: func.xml:7607(para)
msgid "The minutes field (0 - 59)"
msgstr "Минуты (0 - 59)"

#: func.xml:7613(computeroutput)
#, no-wrap
msgid "38"
msgstr "38"

#: func.xml:7611(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7621(para)
msgid ""
"For <type>timestamp</type> values, the number of the month within the year "
"(1 - 12) ; for <type>interval</type> values, the number of months, modulo 12 "
"(0 - 11)"
msgstr ""
"Для значений <type>timestamp</type> это номер месяца в году (1 - 12), а для "
"<type>interval</type> &mdash; остаток от деления числа месяцев на 12 (в "
"интервале 0 - 11)"

#: func.xml:7629(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "2"
msgstr "2"

#: func.xml:7635(computeroutput) func.xml:7649(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "1"
msgstr "1"

#: func.xml:7627(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');\n"
"<placeholder-3/><placeholder-4/>\n"
"\n"
"SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');\n"
"<placeholder-5/><placeholder-6/>"
msgstr ""
"SELECT EXTRACT(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(MONTH FROM INTERVAL '2 years 3 months');\n"
"<placeholder-3/><placeholder-4/>\n"
"\n"
"SELECT EXTRACT(MONTH FROM INTERVAL '2 years 13 months');\n"
"<placeholder-5/><placeholder-6/>"

#: func.xml:7641(literal) func.xml:7827(literal)
msgid "quarter"
msgstr "quarter"

#: func.xml:7643(para)
msgid "The quarter of the year (1 - 4) that the date is in"
msgstr "Квартал года (1 - 4), к которому относится дата"

#: func.xml:7647(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7655(literal) func.xml:7821(literal)
msgid "second"
msgstr "second"

#: func.xml:7659(simpara)
msgid "60 if leap seconds are implemented by the operating system"
msgstr "60, если операционная система поддерживает секунды координации"

#: func.xml:7657(para)
msgid "The seconds field, including fractional parts (0 - 59<placeholder-1/>)"
msgstr "Секунды, включая дробную часть (0 - 59<placeholder-1/>)"

#: func.xml:7668(computeroutput)
#, no-wrap
msgid "28.5"
msgstr "28.5"

#: func.xml:7663(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT EXTRACT(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT EXTRACT(SECOND FROM TIME '17:12:28.5');\n"
"<placeholder-3/><placeholder-4/>"

#: func.xml:7673(literal)
msgctxt "literal"
msgid "timezone"
msgstr "timezone"

#: func.xml:7675(para)
msgid ""
"The time zone offset from UTC, measured in seconds. Positive values "
"correspond to time zones east of UTC, negative values to zones west of UTC. "
"(Technically, <productname>PostgreSQL</productname> does not use UTC because "
"leap seconds are not handled.)"
msgstr ""
"Смещение часового пояса от UTC, представленное в секундах. Положительные "
"значения соответствуют часовым поясам к востоку от UTC, а отрицательные "
"&mdash; к западу. (Строго говоря, в <productname>PostgreSQL</productname> "
"используется не UTC, так как секунды координации не учитываются.)"

#: func.xml:7686(literal)
msgid "timezone_hour"
msgstr "timezone_hour"

#: func.xml:7688(para)
msgid "The hour component of the time zone offset"
msgstr "Поле часов в смещении часового пояса"

#: func.xml:7695(literal)
msgid "timezone_minute"
msgstr "timezone_minute"

#: func.xml:7697(para)
msgid "The minute component of the time zone offset"
msgstr "Поле минут в смещении часового пояса"

#: func.xml:7704(literal) func.xml:7825(literal)
msgid "week"
msgstr "week"

#: func.xml:7706(para)
msgid ""
"The number of the <acronym>ISO</acronym> 8601 week-numbering week of the "
"year. By definition, ISO weeks start on Mondays and the first week of a year "
"contains January 4 of that year. In other words, the first Thursday of a "
"year is in week 1 of that year."
msgstr ""
"Номер недели в году по недельному календарю <acronym>ISO</acronym> 8601. По "
"определению, недели <acronym>ISO</acronym> 8601 начинаются с понедельника, а "
"первая неделя года включает 4 января этого года. Другими словами, первый "
"четверг года всегда оказывается в 1 неделе этого года."

#: func.xml:7712(para)
msgid ""
"In the ISO week-numbering system, it is possible for early-January dates to "
"be part of the 52nd or 53rd week of the previous year, and for late-December "
"dates to be part of the first week of the next year. For example, "
"<literal>2005-01-01</literal> is part of the 53rd week of year 2004, and "
"<literal>2006-01-01</literal> is part of the 52nd week of year 2005, while "
"<literal>2012-12-31</literal> is part of the first week of 2013. It's "
"recommended to use the <literal>isoyear</literal> field together with "
"<literal>week</literal> to get consistent results."
msgstr ""
"В системе нумерации недель ISO первые числа января могут относиться к 52-ой "
"или 53-ей неделе предыдущего года, а последние числа декабря &mdash; к "
"первой неделе следующего года. Например, <literal>2005-01-01</literal> "
"относится к 53-ей неделе 2004 г., а <literal>2006-01-01</literal> &mdash; к "
"52-ей неделе 2005 г., тогда как <literal>2012-12-31</literal> включается в "
"первую неделю 2013 г. Поэтому для получения согласованных результатов "
"рекомендуется использовать поле <literal>isoyear</literal> в паре с "
"<literal>week</literal>."

#: func.xml:7723(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7731(literal) func.xml:7828(literal)
msgctxt "literal"
msgid "year"
msgstr "year"

#: func.xml:7733(para)
msgid ""
"The year field. Keep in mind there is no <literal>0 AD</literal>, so "
"subtracting <literal>BC</literal> years from <literal>AD</literal> years "
"should be done with care."
msgstr ""
"Поле года. Учтите, что года <literal>0</literal> не было, и это следует "
"иметь в виду, вычитая из годов нашей эры годы до нашей эры."

#: func.xml:7740(computeroutput)
#, no-wrap
msgid "2001"
msgstr "2001"

#: func.xml:7738(screen)
#, no-wrap
msgid ""
"SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"
msgstr ""
"SELECT EXTRACT(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>"

#: func.xml:7351(para)
msgid ""
"The <function>extract</function> function retrieves subfields such as year "
"or hour from date/time values. <replaceable>source</replaceable> must be a "
"value expression of type <type>timestamp</type>, <type>time</type>, or "
"<type>interval</type>. (Expressions of type <type>date</type> are cast to "
"<type>timestamp</type> and can therefore be used as well.) "
"<replaceable>field</replaceable> is an identifier or string that selects "
"what field to extract from the source value. The <function>extract</"
"function> function returns values of type <type>double precision</type>. The "
"following are valid field names: <placeholder-1/>"
msgstr ""
"Функция <function>extract</function> получает из значений даты/времени поля, "
"такие как год или час. Здесь <replaceable>источник</replaceable> &mdash; "
"значение типа <type>timestamp</type>, <type>time</type> или <type>interval</"
"type>. (Выражения типа <type>date</type> приводятся к типу <type>timestamp</"
"type>, так что допускается и этот тип.) Указанное <replaceable>поле</"
"replaceable> представляет собой идентификатор, по которому из источника "
"выбирается заданное поле. Функция <function>extract</function> возвращает "
"значения типа <type>double precision</type>. Допустимые поля: <placeholder-1/"
">"

#: func.xml:7749(para)
msgid ""
"When the input value is +/-Infinity, <function>extract</function> returns +/-"
"Infinity for monotonically-increasing fields (<literal>epoch</literal>, "
"<literal>julian</literal>, <literal>year</literal>, <literal>isoyear</"
"literal>, <literal>decade</literal>, <literal>century</literal>, and "
"<literal>millennium</literal>). For other fields, NULL is returned. "
"<productname>PostgreSQL</productname> versions before 9.6 returned zero for "
"all cases of infinite input."
msgstr ""
"С аргументом +/-бесконечность <function>extract</function> возвращает +/-"
"бесконечность для монотонно увеличивающихся полей (<literal>epoch</literal>, "
"<literal>julian</literal>, <literal>year</literal>, <literal>isoyear</"
"literal>, <literal>decade</literal>, <literal>century</literal> и "
"<literal>millennium</literal>). Для других полей возвращается NULL. До "
"версии 9.6 <productname>PostgreSQL</productname> возвращал ноль для всех "
"случаев с бесконечными аргументами."

#: func.xml:7759(para)
msgid ""
"The <function>extract</function> function is primarily intended for "
"computational processing. For formatting date/time values for display, see "
"<xref linkend=\"functions-formatting\"/>."
msgstr ""
"Функция <function>extract</function> в основном предназначена для "
"вычислительных целей. Функции форматирования даты/времени описаны в <xref "
"remap=\"6\" linkend=\"functions-formatting\"/>."

#: func.xml:7765(para)
msgid ""
"The <function>date_part</function> function is modeled on the traditional "
"<productname>Ingres</productname> equivalent to the <acronym>SQL</acronym>-"
"standard function <function>extract</function>: <synopsis>\n"
"date_part('<replaceable>field</replaceable>', <replaceable>source</"
"replaceable>)\n"
"</synopsis> Note that here the <replaceable>field</replaceable> parameter "
"needs to be a string value, not a name. The valid field names for "
"<function>date_part</function> are the same as for <function>extract</"
"function>."
msgstr ""
"Функция <function>date_part</function> эмулирует традиционный для "
"<productname>Ingres</productname> эквивалент стандартной <acronym>SQL</"
"acronym>-функции <function>extract</function>: <synopsis>\n"
"date_part('<replaceable>поле</replaceable>', <replaceable>источник</"
"replaceable>)\n"
"</synopsis> Заметьте, что здесь параметр <replaceable>поле</replaceable> "
"должен быть строковым значением, а не именем. Функция <function>date_part</"
"function> воспринимает те же поля, что и <function>extract</function>."

#: func.xml:7783(computeroutput)
#, no-wrap
msgctxt "computeroutput"
msgid "4"
msgstr "4"

#: func.xml:7778(screen)
#, no-wrap
msgid ""
"SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT date_part('hour', INTERVAL '4 hours 3 minutes');\n"
"<placeholder-3/><placeholder-4/>"
msgstr ""
"SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');\n"
"<placeholder-1/><placeholder-2/>\n"
"\n"
"SELECT date_part('hour', INTERVAL '4 hours 3 minutes');\n"
"<placeholder-3/><placeholder-4/>"

#: func.xml:7789(function)
msgid "date_trunc"
msgstr "date_trunc"

#: func.xml:7795(para)
msgid ""
"The function <function>date_trunc</function> is conceptually similar to the "
"<function>trunc</function> function for numbers."
msgstr ""
"Функция <function>date_trunc</function> работает подобно <function>trunc</"
"function> для чисел."

#: func.xml:7800(para)
msgid ""
"<synopsis>\n"
"date_trunc('<replaceable>field</replaceable>', <replaceable>source</"
"replaceable>)\n"
"</synopsis> <replaceable>source</replaceable> is a value expression of type "
"<type>timestamp</type> or <type>interval</type>. (Values of type <type>date</"
"type> and <type>time</type> are cast automatically to <type>timestamp</type> "
"or <type>interval</type>, respectively.) <replaceable>field</replaceable> "
"selects to which precision to truncate the input value. The return value is "
"of type <type>timestamp</type> or <type>interval</type> with all fields that "
"are less significant than the selected one set to zero (or one, for day and "
"month)."
msgstr ""
"<synopsis>\n"
"date_trunc('<replaceable>поле</replaceable>', <replaceable>значение</"
"replaceable>)\n"
"</synopsis> Здесь <replaceable>значение</replaceable> &mdash; это выражение "
"типа <type>timestamp</type> или <type>interval</type>. (Значения типов "
"<type>date</type> и <type>time</type> автоматически приводятся к типам "
"<type>timestamp</type> и <type>interval</type>, соответственно.) Параметр "
"<replaceable>поле</replaceable> определяет, до какой точности обрезать "
"переданное значение. Возвращаемое значение будет иметь тип <type>timestamp</"
"type> или <type>interval</type> и все его значения, менее значимые, чем "
"заданное поле, будут равны нулю (или единице, если это номер дня или месяца)."

#: func.xml:7816(para)
msgid "Valid values for <replaceable>field</replaceable> are: <placeholder-1/>"
msgstr ""
"Параметр <replaceable>поле</replaceable> может принимать следующие значения: "
"<placeholder-1/>"

#: func.xml:7835(para)
msgid ""
"Examples: <screen>\n"
"SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 "
"20:00:00</computeroutput>\n"
"\n"
"SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-01-01 "
"00:00:00</computeroutput>\n"
"</screen>"
msgstr ""
"Примеры: <screen>\n"
"SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-02-16 "
"20:00:00</computeroutput>\n"
"\n"
"SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-01-01 "
"00:00:00</computeroutput>\n"
"</screen>"

#: func.xml:7848(literal)
msgid "AT TIME ZONE"
msgstr "AT TIME ZONE"

#: func.xml:7850(indexterm)
msgid "<primary>time zone</primary> <secondary>conversion</secondary>"
msgstr "<primary>часовой пояс</primary> <secondary>преобразование</secondary>"

#: func.xml:7855(indexterm)
msgid "<primary>AT TIME ZONE</primary>"
msgstr "<primary>AT TIME ZONE</primary>"

#: func.xml:7859(para)
msgid ""
"The <literal>AT TIME ZONE</literal> construct allows conversions of time "
"stamps to different time zones. <xref linkend=\"functions-datetime-"
"zoneconvert-table\"/> shows its variants."
msgstr ""
"Конструкция <literal>AT TIME ZONE</literal> позволяет переводить время в "
"разные часовые пояса. Все её разновидности показаны в <xref remap=\"6\" "
"linkend=\"functions-datetime-zoneconvert-table\"/>."

#: func.xml:7867(title)
msgid "<literal>AT TIME ZONE</literal> Variants"
msgstr "Разновидности <literal>AT TIME ZONE</literal>"

#: func.xml:7880(type) func.xml:7890(type)
msgid "timestamp without time zone"
msgstr "timestamp without time zone"

#: func.xml:7880(replaceable) func.xml:7888(replaceable)
#: func.xml:7897(replaceable)
msgid "zone"
msgstr "часовой_пояс"

#: func.xml:7880(literal) func.xml:7888(literal) func.xml:7897(literal)
msgid "<placeholder-1/> AT TIME ZONE <placeholder-2/>"
msgstr "<placeholder-1/> AT TIME ZONE <placeholder-2/>"

#: func.xml:7883(entry)
msgid ""
"Treat given time stamp <emphasis>without time zone</emphasis> as located in "
"the specified time zone"
msgstr ""
"Воспринимает заданное время <emphasis>без указания часового пояса</emphasis> "
"как время в указанном часовом поясе"

#: func.xml:7891(entry)
msgid ""
"Convert given time stamp <emphasis>with time zone</emphasis> to the new time "
"zone, with no time zone designation"
msgstr ""
"Переводит данное значение timestamp <emphasis>с часовым поясом</emphasis> в "
"другой часовой пояс, но не сохраняет информацию о нём в результате"

#: func.xml:7900(entry)
msgid ""
"Convert given time <emphasis>with time zone</emphasis> to the new time zone"
msgstr ""
"Переводит данное время <emphasis>с часовым поясом</emphasis> в другой "
"часовой пояс"

#: func.xml:7906(para)
msgid ""
"In these expressions, the desired time zone <replaceable>zone</replaceable> "
"can be specified either as a text string (e.g., <literal>'PST'</literal>) or "
"as an interval (e.g., <literal>INTERVAL '-08:00'</literal>). In the text "
"case, a time zone name can be specified in any of the ways described in "
"<xref linkend=\"datatype-timezones\"/>."
msgstr ""
"В этих выражениях желаемый <replaceable>часовой_пояс</replaceable> можно "
"задать либо в виде текстовой строки (например, <literal>'PST'</literal>) или "
"как интервал (например, <literal>INTERVAL '-08:00'</literal>). В первом "
"случае название часового пояса можно указать любым из способов, описанных в "
"<xref remap=\"6\" linkend=\"datatype-timezones\"/>."

#: func.xml:7914(para)
msgid ""
"Examples (assuming the local time zone is <literal>PST8PDT</literal>): "
"<screen>\n"
"SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 "
"19:38:40-08</computeroutput>\n"
"\n"
"SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE "
"'MST';\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-02-16 "
"18:38:40</computeroutput>\n"
"</screen> The first example takes a time stamp without time zone and "
"interprets it as MST time (UTC-7), which is then converted to PST (UTC-8) "
"for display. The second example takes a time stamp specified in EST (UTC-5) "
"and converts it to local time in MST (UTC-7)."
msgstr ""
"Примеры (в предположении, что местный часовой пояс <literal>PST8PDT</"
"literal>): <screen>\n"
"SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-02-16 "
"19:38:40-08</computeroutput>\n"
"\n"
"SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE "
"'MST';\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-02-16 "
"18:38:40</computeroutput>\n"
"</screen> В первом примере время без часового пояса интерпретируется как "
"время в часовом поясе MST (UTC-7), а затем оно преобразуется в PST (UTC-8) "
"для вывода. Во втором примере время, указанное с часовым поясом EST (UTC-5), "
"преобразуется во время для часового пояса MST (UTC-7)."

#: func.xml:7928(para)
msgid ""
"The function <literal><function>timezone</function>(<replaceable>zone</"
"replaceable>, <replaceable>timestamp</replaceable>)</literal> is equivalent "
"to the SQL-conforming construct <literal><replaceable>timestamp</"
"replaceable> AT TIME ZONE <replaceable>zone</replaceable></literal>."
msgstr ""
"Функция <literal><function>timezone</function>(<replaceable>часовой_пояс</"
"replaceable>, <replaceable>время</replaceable>)</literal> равнозначна SQL-"
"совместимой конструкции <literal><replaceable>время</replaceable> AT TIME "
"ZONE <replaceable>часовой_пояс</replaceable></literal>."

#: func.xml:7937(title)
msgid "Current Date/Time"
msgstr "Текущая дата/время"

#: func.xml:7939(indexterm)
msgid "<primary>date</primary> <secondary>current</secondary>"
msgstr "<primary>дата</primary> <secondary>текущая</secondary>"

#: func.xml:7944(indexterm)
msgid "<primary>time</primary> <secondary>current</secondary>"
msgstr "<primary>время</primary> <secondary>текущее</secondary>"

#: func.xml:7949(para)
msgid ""
"<productname>PostgreSQL</productname> provides a number of functions that "
"return values related to the current date and time. These SQL-standard "
"functions all return values based on the start time of the current "
"transaction: <synopsis>\n"
"CURRENT_DATE\n"
"CURRENT_TIME\n"
"CURRENT_TIMESTAMP\n"
"CURRENT_TIME(<replaceable>precision</replaceable>)\n"
"CURRENT_TIMESTAMP(<replaceable>precision</replaceable>)\n"
"LOCALTIME\n"
"LOCALTIMESTAMP\n"
"LOCALTIME(<replaceable>precision</replaceable>)\n"
"LOCALTIMESTAMP(<replaceable>precision</replaceable>)\n"
"</synopsis>"
msgstr ""
"<productname>PostgreSQL</productname> предоставляет набор функций, результат "
"которых зависит от текущей даты и времени. Все следующие функции "
"соответствуют стандарту SQL и возвращают значения, отражающие время начала "
"текущей транзакции: <synopsis>\n"
"CURRENT_DATE\n"
"CURRENT_TIME\n"
"CURRENT_TIMESTAMP\n"
"CURRENT_TIME(<replaceable>точность</replaceable>)\n"
"CURRENT_TIMESTAMP(<replaceable>точность</replaceable>)\n"
"LOCALTIME\n"
"LOCALTIMESTAMP\n"
"LOCALTIME(<replaceable>точность</replaceable>)\n"
"LOCALTIMESTAMP(<replaceable>точность</replaceable>)\n"
"</synopsis>"

#: func.xml:7967(para)
msgid ""
"<function>CURRENT_TIME</function> and <function>CURRENT_TIMESTAMP</function> "
"deliver values with time zone; <function>LOCALTIME</function> and "
"<function>LOCALTIMESTAMP</function> deliver values without time zone."
msgstr ""
"<function>CURRENT_TIME</function> и <function>CURRENT_TIMESTAMP</function> "
"возвращают время с часовым поясом. В результатах <function>LOCALTIME</"
"function> и <function>LOCALTIMESTAMP</function> нет информации о часовом "
"поясе."

#: func.xml:7974(para)
msgid ""
"<function>CURRENT_TIME</function>, <function>CURRENT_TIMESTAMP</function>, "
"<function>LOCALTIME</function>, and <function>LOCALTIMESTAMP</function> can "
"optionally take a precision parameter, which causes the result to be rounded "
"to that many fractional digits in the seconds field. Without a precision "
"parameter, the result is given to the full available precision."
msgstr ""
"<function>CURRENT_TIME</function>, <function>CURRENT_TIMESTAMP</function>, "
"<function>LOCALTIME</function> и <function>LOCALTIMESTAMP</function> могут "
"принимать необязательный параметр точности, определяющий, до какого знака "
"после запятой следует округлять поле секунд. Если этот параметр отсутствует, "
"результат будет иметь максимально возможную точность."

#: func.xml:7985(para)
msgid ""
"Some examples: <screen>\n"
"SELECT CURRENT_TIME;\n"
"<lineannotation>Result: </lineannotation><computeroutput>14:39:53.662522-05</"
"computeroutput>\n"
"\n"
"SELECT CURRENT_DATE;\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-12-23</"
"computeroutput>\n"
"\n"
"SELECT CURRENT_TIMESTAMP;\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.662522-05</computeroutput>\n"
"\n"
"SELECT CURRENT_TIMESTAMP(2);\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.66-05</computeroutput>\n"
"\n"
"SELECT LOCALTIMESTAMP;\n"
"<lineannotation>Result: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.662522</computeroutput>\n"
"</screen>"
msgstr ""
"Несколько примеров: <screen>\n"
"SELECT CURRENT_TIME;\n"
"<lineannotation>Результат: </"
"lineannotation><computeroutput>14:39:53.662522-05</computeroutput>\n"
"\n"
"SELECT CURRENT_DATE;\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23</"
"computeroutput>\n"
"\n"
"SELECT CURRENT_TIMESTAMP;\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.662522-05</computeroutput>\n"
"\n"
"SELECT CURRENT_TIMESTAMP(2);\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.66-05</computeroutput>\n"
"\n"
"SELECT LOCALTIMESTAMP;\n"
"<lineannotation>Результат: </lineannotation><computeroutput>2001-12-23 "
"14:39:53.662522</computeroutput>\n"
"</screen>"

#: func.xml:8005(para)
msgid ""
"Since these functions return the start time of the current transaction, "
"their values do not change during the transaction. This is considered a "
"feature: the intent is to allow a single transaction to have a consistent "
"notion of the <quote>current</quote> time, so that multiple modifications "
"within the same transaction bear the same time stamp."
msgstr ""
"Так как эти функции возвращают время начала текущей транзакции, во время "
"транзакции эти значения не меняются. Это считается не ошибкой, а "
"особенностью реализации: цель такого поведения в том, чтобы в одной "
"транзакции <quote>текущее</quote> время было одинаковым и для разных "
"изменений в одной транзакций записывалась одна отметка времени."

#: func.xml:8016(para)
msgid "Other database systems might advance these values more frequently."
msgstr "В других СУБД эти значения могут изменяться чаще."

#: func.xml:8022(para)
msgid ""
"<productname>PostgreSQL</productname> also provides functions that return "
"the start time of the current statement, as well as the actual current time "
"at the instant the function is called. The complete list of non-SQL-standard "
"time functions is: <synopsis>\n"
"transaction_timestamp()\n"
"statement_timestamp()\n"
"clock_timestamp()\n"
"timeofday()\n"
"now()\n"
"</synopsis>"
msgstr ""
"В <productname>PostgreSQL</productname> есть также функции, возвращающие "
"время начала текущего оператора, а также текущее время в момент вызова "
"функции. Таким образом, в <productname>PostgreSQL</productname> есть "
"следующие функции, не описанные в стандарте SQL: <synopsis>\n"
"transaction_timestamp()\n"
"statement_timestamp()\n"
"clock_timestamp()\n"
"timeofday()\n"
"now()\n"
"</synopsis>"

#: func.xml:8036(para)
msgid ""
"<function>transaction_timestamp()</function> is equivalent to "
"<function>CURRENT_TIMESTAMP</function>, but is named to clearly reflect what "
"it returns. <function>statement_timestamp()</function> returns the start "
"time of the current statement (more specifically, the time of receipt of the "
"latest command message from the client). <function>statement_timestamp()</"
"function> and <function>transaction_timestamp()</function> return the same "
"value during the first command of a transaction, but might differ during "
"subsequent commands. <function>clock_timestamp()</function> returns the "
"actual current time, and therefore its value changes even within a single "
"SQL command. <function>timeofday()</function> is a historical "
"<productname>PostgreSQL</productname> function. Like "
"<function>clock_timestamp()</function>, it returns the actual current time, "
"but as a formatted <type>text</type> string rather than a <type>timestamp "
"with time zone</type> value. <function>now()</function> is a traditional "
"<productname>PostgreSQL</productname> equivalent to "
"<function>transaction_timestamp()</function>."
msgstr ""
"Функция <function>transaction_timestamp()</function> равнозначна конструкции "
"<function>CURRENT_TIMESTAMP</function>, но в её названии явно отражено, что "
"она возвращает. Функция <function>statement_timestamp()</function> "
"возвращает время начала текущего оператора (более точно, время получения "
"последнего командного сообщения от клиента). Функции "
"<function>statement_timestamp()</function> и "
"<function>transaction_timestamp()</function> возвращают одно и то же "
"значение в первой команде транзакции, но в последующих их показания будут "
"расходиться. Функция <function>clock_timestamp()</function> возвращает "
"фактическое текущее время, так что её значение меняется в рамках одной "
"команды SQL. Функция <function>timeofday()</function> существует в "
"<productname>PostgreSQL</productname> по историческим причинам и, подобно "
"<function>clock_timestamp()</function>, она возвращает фактическое текущее "
"время, но представленное в виде форматированной строки типа <type>text</"
"type>, а не значения <type>timestamp with time zone</type>. Функция "
"<function>now()</function> &mdash; традиционный для <productname>PostgreSQL</"
"productname> эквивалент функции <function>transaction_timestamp()</function>."

#: func.xml:8062(programlisting)
#, no-wrap
msgid ""
"SELECT CURRENT_TIMESTAMP;\n"
"SELECT now();\n"
"SELECT TIMESTAMP 'now';  -- incorrect for use with DEFAULT"
msgstr ""
"SELECT CURRENT_TIMESTAMP;\n"
"SELECT now();\n"
"SELECT TIMESTAMP 'now';  -- не подходит для DEFAULT"

#: func.xml:8057(para)
msgid ""
"All the date/time data types also accept the special literal value "
"<literal>now</literal> to specify the current date and time (again, "
"interpreted as the transaction start time). Thus, the following three all "
"return the same result: <placeholder-1/>"
msgstr ""
"Все типы даты/времени также принимают специальное буквальное значение "
"<literal>now</literal>, подразумевающее текущую дату и время (тоже на момент "
"начала транзакции). Таким образом, результат следующих трёх операторов будет "
"одинаковым: <placeholder-1/>"

#: func.xml:8070(para)
msgid ""
"You do not want to use the third form when specifying a <literal>DEFAULT</"
"literal> clause while creating a table. The system will convert "
"<literal>now</literal> to a <type>timestamp</type> as soon as the constant "
"is parsed, so that when the default value is needed, the time of the table "
"creation would be used! The first two forms will not be evaluated until the "
"default value is used, because they are function calls. Thus they will give "
"the desired behavior of defaulting to the time of row insertion."
msgstr ""
"Третья форма не подходит для указания в качестве значения <literal>DEFAULT</"
"literal> при создании таблицы. Система преобразует <literal>now</literal> в "
"значение <type>timestamp</type> в момент разбора константы, поэтому, когда "
"будет вставляться значение по умолчанию, в соответствующем столбце окажется "
"время создания таблицы! Первые две формы не будут вычисляться, пока не "
"потребуется значение по умолчанию, так как это вызовы функции. Поэтому они "
"дадут желаемый результат при добавлении строки в таблицу."

#: func.xml:8084(title)
msgid "Delaying Execution"
msgstr "Задержка выполнения"

#: func.xml:8086(indexterm)
msgid "<primary>pg_sleep</primary>"
msgstr "<primary>pg_sleep</primary>"

#: func.xml:8089(indexterm)
msgid "<primary>pg_sleep_for</primary>"
msgstr "<primary>pg_sleep_for</primary>"

#: func.xml:8092(indexterm)
msgid "<primary>pg_sleep_until</primary>"
msgstr "<primary>pg_sleep_until</primary>"

#: func.xml:8095(indexterm)
msgid "<primary>sleep</primary>"
msgstr "<primary>sleep</primary>"

#: func.xml:8098(indexterm)
msgid "<primary>delay</primary>"
msgstr "<primary>задержка</primary>"

#: func.xml:8121(programlisting)
#, no-wrap
msgid ""
"SELECT pg_sleep(1.5);\n"
"SELECT pg_sleep_for('5 minutes');\n"
"SELECT pg_sleep_until('tomorrow 03:00');"
msgstr ""
"SELECT pg_sleep(1.5);\n"
"SELECT pg_sleep_for('5 minutes');\n"
"SELECT pg_sleep_until('tomorrow 03:00');"

#: func.xml:8102(para)
msgid ""
"The following functions are available to delay execution of the server "
"process: <synopsis>\n"
"pg_sleep(<replaceable>seconds</replaceable>)\n"
"pg_sleep_for(<type>interval</type>)\n"
"pg_sleep_until(<type>timestamp with time zone</type>)\n"
"</synopsis> <function>pg_sleep</function> makes the current session's "
"process sleep until <replaceable>seconds</replaceable> seconds have elapsed. "
"<replaceable>seconds</replaceable> is a value of type <type>double "
"precision</type>, so fractional-second delays can be specified. "
"<function>pg_sleep_for</function> is a convenience function for larger sleep "
"times specified as an <type>interval</type>. <function>pg_sleep_until</"
"function> is a convenience function for when a specific wake-up time is "
"desired. For example: <placeholder-1/>"
msgstr ""
"В случае необходимости вы можете приостановить выполнение серверного "
"процесса, используя следующие функции: <synopsis>\n"
"pg_sleep(<replaceable>сек</replaceable>)\n"
"pg_sleep_for(<type>interval</type>)\n"
"pg_sleep_until(<type>timestamp with time zone</type>)\n"
"</synopsis> Функция <function>pg_sleep</function> переводит процесс текущего "
"сеанса в спящее состояние на указанное число секунд (<replaceable>сек</"
"replaceable>). Параметр <replaceable>сек</replaceable> имеет тип "
"<type>double precision</type>, так что в нём можно указать и дробное число. "
"Функция <function>pg_sleep_for</function> введена для удобства, ей можно "
"передать большие значения задержки в типе <type>interval</type>. А "
"<function>pg_sleep_until</function> удобнее использовать, когда необходимо "
"задать определённое время выхода из спящего состояния. Например: "
"<placeholder-1/>"

#: func.xml:8129(para)
msgid ""
"The effective resolution of the sleep interval is platform-specific; 0.01 "
"seconds is a common value. The sleep delay will be at least as long as "
"specified. It might be longer depending on factors such as server load. In "
"particular, <function>pg_sleep_until</function> is not guaranteed to wake up "
"exactly at the specified time, but it will not wake up any earlier."
msgstr ""
"Действительное разрешение интервала задержки зависит от платформы; обычно "
"это 0.01. Фактическая длительность задержки не будет меньше указанного "
"времени, но может быть больше, в зависимости, например от нагрузки на "
"сервер. В частности, не гарантируется, что <function>pg_sleep_until</"
"function> проснётся именно в указанное время, но она точно не проснётся "
"раньше."

#: func.xml:8139(para)
msgid ""
"Make sure that your session does not hold more locks than necessary when "
"calling <function>pg_sleep</function> or its variants. Otherwise other "
"sessions might have to wait for your sleeping process, slowing down the "
"entire system."
msgstr ""
"Прежде чем вызывать <function>pg_sleep</function> или её вариации, убедитесь "
"в том, что в текущем сеансе нет ненужных блокировок. В противном случае в "
"состояние ожидания могут перейти и другие сеансы, так что это отразится на "
"системе в целом."

#: func.xml:8152(title) func.xml:8168(title)
msgid "Enum Support Functions"
msgstr "Функции для перечислений"

#: func.xml:8161(programlisting)
#, no-wrap
msgid "CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green', 'blue', 'purple');"
msgstr ""
"CREATE TYPE rainbow AS ENUM ('red', 'orange', 'yellow', 'green',\n"
" 'blue', 'purple');"

#: func.xml:8154(para)
msgid ""
"For enum types (described in <xref linkend=\"datatype-enum\"/>), there are "
"several functions that allow cleaner programming without hard-coding "
"particular values of an enum type. These are listed in <xref linkend="
"\"functions-enum-table\"/>. The examples assume an enum type created as: "
"<placeholder-1/>"
msgstr ""
"Для типов перечислений (описанных в <xref remap=\"6\" linkend=\"datatype-enum"
"\"/>) предусмотрено несколько функций, которые позволяют сделать код чище, "
"не &laquo;зашивая&raquo; в нём конкретные значения перечисления. Эти функции "
"перечислены в <xref remap=\"6\" linkend=\"functions-enum-table\"/>. В этих "
"примерах подразумевается, что перечисление создано так: <placeholder-1/>"

#: func.xml:8181(indexterm)
msgid "<primary>enum_first</primary>"
msgstr "<primary>enum_first</primary>"

#: func.xml:8184(literal)
msgid "enum_first(anyenum)"
msgstr "enum_first(anyenum)"

#: func.xml:8186(entry)
msgid "Returns the first value of the input enum type"
msgstr "Возвращает первое значение заданного перечисления"

#: func.xml:8187(literal)
msgid "enum_first(null::rainbow)"
msgstr "enum_first(null::rainbow)"

#: func.xml:8188(literal)
msgid "red"
msgstr "red"

#: func.xml:8192(indexterm)
msgid "<primary>enum_last</primary>"
msgstr "<primary>enum_last</primary>"

#: func.xml:8195(literal)
msgid "enum_last(anyenum)"
msgstr "enum_last(anyenum)"

#: func.xml:8197(entry)
msgid "Returns the last value of the input enum type"
msgstr "Возвращает последнее значение заданного перечисления"

#: func.xml:8198(literal)
msgid "enum_last(null::rainbow)"
msgstr "enum_last(null::rainbow)"

#: func.xml:8199(literal)
msgid "purple"
msgstr "purple"

#: func.xml:8203(indexterm)
msgid "<primary>enum_range</primary>"
msgstr "<primary>enum_range</primary>"

#: func.xml:8206(literal)
msgid "enum_range(anyenum)"
msgstr "enum_range(anyenum)"

#: func.xml:8208(entry)
msgid "Returns all values of the input enum type in an ordered array"
msgstr "Возвращает все значения заданного перечисления в упорядоченном массиве"

#: func.xml:8209(literal)
msgid "enum_range(null::rainbow)"
msgstr "enum_range(null::rainbow)"

#: func.xml:8210(literal)
msgid "{red,orange,yellow,green,blue,purple}"
msgstr "{red,orange,yellow,green,blue,purple}"

#: func.xml:8213(literal)
msgid "enum_range(anyenum, anyenum)"
msgstr "enum_range(anyenum, anyenum)"

#: func.xml:8214(entry)
msgid ""
"Returns the range between the two given enum values, as an ordered array. "
"The values must be from the same enum type. If the first parameter is null, "
"the result will start with the first value of the enum type. If the second "
"parameter is null, the result will end with the last value of the enum type."
msgstr ""
"Возвращает набор значений, лежащих между двумя заданными, в виде "
"упорядоченного массива. Эти значения должны принадлежать одному "
"перечислению. Если первый параметр равен NULL, функция возвращает первое "
"значение перечисления, а если NULL второй &mdash; последнее."

#: func.xml:8222(literal)
msgid "enum_range('orange'::rainbow, 'green'::rainbow)"
msgstr "enum_range('orange'::rainbow, 'green'::rainbow)"

#: func.xml:8223(literal)
msgid "{orange,yellow,green}"
msgstr "{orange,yellow,green}"

#: func.xml:8226(literal)
msgid "enum_range(NULL, 'green'::rainbow)"
msgstr "enum_range(NULL, 'green'::rainbow)"

#: func.xml:8227(literal)
msgid "{red,orange,yellow,green}"
msgstr "{red,orange,yellow,green}"

#: func.xml:8230(literal)
msgid "enum_range('orange'::rainbow, NULL)"
msgstr "enum_range('orange'::rainbow, NULL)"

#: func.xml:8231(literal)
msgid "{orange,yellow,green,blue,purple}"
msgstr "{orange,yellow,green,blue,purple}"

#: func.xml:8237(para)
msgid ""
"Notice that except for the two-argument form of <function>enum_range</"
"function>, these functions disregard the specific value passed to them; they "
"care only about its declared data type. Either null or a specific value of "
"the type can be passed, with the same result. It is more common to apply "
"these functions to a table column or function argument than to a hardwired "
"type name as suggested by the examples."
msgstr ""
"Заметьте, что за исключением варианта <function>enum_range</function> с "
"двумя аргументами, эти функции не обращают внимание на конкретное переданное "
"им значение; их интересует только объявленный тип. Они возвращают один и тот "
"же результат, когда им передаётся NULL или любое другое значение типа. "
"Обычно эти функции применяются к столбцам таблицы или аргументам внешних "
"функций, а не к предопределённым типам, как показано в этих примерах."

#: func.xml:8248(title)
msgid "Geometric Functions and Operators"
msgstr "Геометрические функции и операторы"

#: func.xml:8250(para)
msgid ""
"The geometric types <type>point</type>, <type>box</type>, <type>lseg</type>, "
"<type>line</type>, <type>path</type>, <type>polygon</type>, and "
"<type>circle</type> have a large set of native support functions and "
"operators, shown in <xref linkend=\"functions-geometry-op-table\"/>, <xref "
"linkend=\"functions-geometry-func-table\"/>, and <xref linkend=\"functions-"
"geometry-conv-table\"/>."
msgstr ""
"Для геометрических типов <type>point</type>, <type>box</type>, <type>lseg</"
"type>, <type>line</type>, <type>path</type>, <type>polygon</type> и "
"<type>circle</type> разработан большой набор встроенных функций и "
"операторов, представленный в <xref remap=\"6\" linkend=\"functions-geometry-"
"op-table\"/>, <xref remap=\"6\" linkend=\"functions-geometry-func-table\"/> "
"и <xref remap=\"6\" linkend=\"functions-geometry-conv-table\"/>."

#: func.xml:8261(para)
msgid ""
"Note that the <quote>same as</quote> operator, <literal>~=</literal>, "
"represents the usual notion of equality for the <type>point</type>, "
"<type>box</type>, <type>polygon</type>, and <type>circle</type> types. Some "
"of these types also have an <literal>=</literal> operator, but <literal>=</"
"literal> compares for equal <emphasis>areas</emphasis> only. The other "
"scalar comparison operators (<literal>&lt;=</literal> and so on) likewise "
"compare areas for these types."
msgstr ""
"Заметьте, что оператор <quote>идентичности</quote>, <literal>~=</literal>, "
"представляет обычное сравнение на равенство значений <type>point</type>, "
"<type>box</type>, <type>polygon</type> и <type>circle</type>. Для некоторых "
"из этих типов определён также оператор <literal>=</literal>, но <literal>=</"
"literal> проверяет только равенство <emphasis>площадей</emphasis>. Другие "
"скалярные операторы сравнения (<literal>&lt;=</literal> и т. д.) так же "
"сравнивают площади значений этих типов."

#: func.xml:8273(title)
msgid "Geometric Operators"
msgstr "Геометрические операторы"

#: func.xml:8285(entry) func.xml:8290(entry)
msgid "Translation"
msgstr "Сдвиг"

#: func.xml:8286(literal)
msgid "box '((0,0),(1,1))' + point '(2.0,0)'"
msgstr "box '((0,0),(1,1))' + point '(2.0,0)'"

#: func.xml:8291(literal)
msgid "box '((0,0),(1,1))' - point '(2.0,0)'"
msgstr "box '((0,0),(1,1))' - point '(2.0,0)'"

#: func.xml:8295(entry) func.xml:8300(entry)
msgid "Scaling/rotation"
msgstr "Масштабирование/поворот"

#: func.xml:8296(literal)
msgid "box '((0,0),(1,1))' * point '(2.0,0)'"
msgstr "box '((0,0),(1,1))' * point '(2.0,0)'"

#: func.xml:8301(literal)
msgid "box '((0,0),(2,2))' / point '(2.0,0)'"
msgstr "box '((0,0),(2,2))' / point '(2.0,0)'"

#: func.xml:8305(entry)
msgid "Point or box of intersection"
msgstr "Точка или прямоугольник в пересечении"

#: func.xml:8306(literal)
msgid "'((1,-1),(-1,1))' # '((1,1),(-1,-1))'"
msgstr "'((1,-1),(-1,1))' # '((1,1),(-1,-1))'"

#: func.xml:8310(entry)
msgid "Number of points in path or polygon"
msgstr "Число точек в пути или вершин в многоугольнике"

#: func.xml:8311(literal)
msgid "# '((1,0),(0,1),(-1,0))'"
msgstr "# '((1,0),(0,1),(-1,0))'"

#: func.xml:8314(literal)
msgid "@-@"
msgstr "@-@"

#: func.xml:8315(entry)
msgid "Length or circumference"
msgstr "Длина, периметр или длина окружности"

#: func.xml:8316(literal)
msgid "@-@ path '((0,0),(1,0))'"
msgstr "@-@ path '((0,0),(1,0))'"

#: func.xml:8319(literal) func.xml:9194(literal)
msgid "@@"
msgstr "@@"

#: func.xml:8320(entry)
msgid "Center"
msgstr "Центр"

#: func.xml:8321(literal)
msgid "@@ circle '((0,0),10)'"
msgstr "@@ circle '((0,0),10)'"

#: func.xml:8324(literal)
msgid "##"
msgstr "##"

#: func.xml:8325(entry)
msgid "Closest point to first operand on second operand"
msgstr "Точка, ближайшая к первому операнду и принадлежащая второму"

#: func.xml:8326(literal)
msgid "point '(0,0)' ## lseg '((2,0),(0,2))'"
msgstr "point '(0,0)' ## lseg '((2,0),(0,2))'"

#: func.xml:8329(literal) func.xml:9236(literal)
msgid "&lt;-&gt;"
msgstr "&lt;-&gt;"

#: func.xml:8330(entry)
msgid "Distance between"
msgstr "Расстояние между операндами"

#: func.xml:8331(literal)
msgid "circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'"
msgstr "circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'"

#: func.xml:8334(literal) func.xml:8870(literal) func.xml:9215(literal)
#: func.xml:12052(literal) func.xml:12541(literal)
msgid "&amp;&amp;"
msgstr "&amp;&amp;"

#: func.xml:8335(entry)
msgid "Overlaps? (One point in common makes this true.)"
msgstr ""
"Пересекаются ли операнды? (Для положительного ответа достаточно одной общей "
"точки.)"

#: func.xml:8336(literal)
msgid "box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'"
msgstr "box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'"

#: func.xml:8340(entry)
msgid "Is strictly left of?"
msgstr "Строго слева?"

#: func.xml:8341(literal)
msgid "circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'"
msgstr "circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'"

#: func.xml:8345(entry)
msgid "Is strictly right of?"
msgstr "Строго справа?"

#: func.xml:8346(literal)
msgid "circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'"
msgstr "circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'"

#: func.xml:8349(literal) func.xml:12562(literal)
msgid "&amp;&lt;"
msgstr "&amp;&lt;"

#: func.xml:8350(entry)
msgid "Does not extend to the right of?"
msgstr "Не простирается правее?"

#: func.xml:8351(literal)
msgid "box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'"
msgstr "box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'"

#: func.xml:8354(literal) func.xml:12569(literal)
msgid "&amp;&gt;"
msgstr "&amp;&gt;"

#: func.xml:8355(entry)
msgid "Does not extend to the left of?"
msgstr "Не простирается левее?"

#: func.xml:8356(literal)
msgid "box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'"
msgstr "box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'"

#: func.xml:8359(literal)
msgid "&lt;&lt;|"
msgstr "&lt;&lt;|"

#: func.xml:8360(entry)
msgid "Is strictly below?"
msgstr "Строго ниже?"

#: func.xml:8361(literal)
msgid "box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'"
msgstr "box '((0,0),(3,3))' &lt;&lt;| box '((3,4),(5,5))'"

#: func.xml:8364(literal)
msgid "|&gt;&gt;"
msgstr "|&gt;&gt;"

#: func.xml:8365(entry)
msgid "Is strictly above?"
msgstr "Строго выше?"

#: func.xml:8366(literal)
msgid "box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'"
msgstr "box '((3,4),(5,5))' |&gt;&gt; box '((0,0),(3,3))'"

#: func.xml:8369(literal)
msgid "&amp;&lt;|"
msgstr "&amp;&lt;|"

#: func.xml:8370(entry)
msgid "Does not extend above?"
msgstr "Не простирается выше?"

#: func.xml:8371(literal)
msgid "box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'"
msgstr "box '((0,0),(1,1))' &amp;&lt;| box '((0,0),(2,2))'"

#: func.xml:8374(literal)
msgid "|&amp;&gt;"
msgstr "|&amp;&gt;"

#: func.xml:8375(entry)
msgid "Does not extend below?"
msgstr "Не простирается ниже?"

#: func.xml:8376(literal)
msgid "box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'"
msgstr "box '((0,0),(3,3))' |&amp;&gt; box '((0,0),(2,2))'"

#: func.xml:8379(literal)
msgid "&lt;^"
msgstr "&lt;^"

#: func.xml:8380(entry)
msgid "Is below (allows touching)?"
msgstr "Ниже (может касаться)?"

#: func.xml:8381(literal)
msgid "circle '((0,0),1)' &lt;^ circle '((0,5),1)'"
msgstr "circle '((0,0),1)' &lt;^ circle '((0,5),1)'"

#: func.xml:8384(literal)
msgid "&gt;^"
msgstr "&gt;^"

#: func.xml:8385(entry)
msgid "Is above (allows touching)?"
msgstr "Выше (может касаться)?"

#: func.xml:8386(literal)
msgid "circle '((0,5),1)' &gt;^ circle '((0,0),1)'"
msgstr "circle '((0,5),1)' &gt;^ circle '((0,0),1)'"

#: func.xml:8389(literal)
msgid "?#"
msgstr "?#"

#: func.xml:8390(entry)
msgid "Intersects?"
msgstr "Пересекает?"

#: func.xml:8391(literal)
msgid "lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'"
msgstr "lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'"

#: func.xml:8394(literal) func.xml:8399(literal)
msgid "?-"
msgstr "?-"

#: func.xml:8395(entry)
msgid "Is horizontal?"
msgstr "Горизонтальный объект?"

#: func.xml:8396(literal)
msgid "?- lseg '((-1,0),(1,0))'"
msgstr "?- lseg '((-1,0),(1,0))'"

#: func.xml:8400(entry)
msgid "Are horizontally aligned?"
msgstr "Выровнены по горизонтали?"

#: func.xml:8401(literal)
msgid "point '(1,0)' ?- point '(0,0)'"
msgstr "point '(1,0)' ?- point '(0,0)'"

#: func.xml:8404(literal) func.xml:8409(literal) func.xml:10745(literal)
msgid "?|"
msgstr "?|"

#: func.xml:8405(entry)
msgid "Is vertical?"
msgstr "Вертикальный объект?"

#: func.xml:8406(literal)
msgid "?| lseg '((-1,0),(1,0))'"
msgstr "?| lseg '((-1,0),(1,0))'"

#: func.xml:8410(entry)
msgid "Are vertically aligned?"
msgstr "Выровнены по вертикали?"

#: func.xml:8411(literal)
msgid "point '(0,1)' ?| point '(0,0)'"
msgstr "point '(0,1)' ?| point '(0,0)'"

#: func.xml:8414(literal)
msgid "?-|"
msgstr "?-|"

#: func.xml:8415(entry)
msgid "Is perpendicular?"
msgstr "Перпендикулярны?"

#: func.xml:8416(literal)
msgid "lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'"
msgstr "lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'"

#: func.xml:8419(literal)
msgid "?||"
msgstr "?||"

#: func.xml:8420(entry)
msgid "Are parallel?"
msgstr "Параллельны?"

#: func.xml:8421(literal)
msgid "lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'"
msgstr "lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'"

#: func.xml:8424(literal) func.xml:9243(literal) func.xml:10724(literal)
#: func.xml:12038(literal) func.xml:12513(literal) func.xml:12520(literal)
msgid "@&gt;"
msgstr "@&gt;"

#: func.xml:8425(entry)
msgid "Contains?"
msgstr "Первый объект включает второй?"

#: func.xml:8426(literal)
msgid "circle '((0,0),2)' @&gt; point '(1,1)'"
msgstr "circle '((0,0),2)' @&gt; point '(1,1)'"

#: func.xml:8429(literal) func.xml:9250(literal) func.xml:10731(literal)
#: func.xml:12045(literal) func.xml:12527(literal) func.xml:12534(literal)
msgid "&lt;@"
msgstr "&lt;@"

#: func.xml:8430(entry)
msgid "Contained in or on?"
msgstr "Первый объект включён во второй?"

#: func.xml:8431(literal)
msgid "point '(1,1)' &lt;@ circle '((0,0),2)'"
msgstr "point '(1,1)' &lt;@ circle '((0,0),2)'"

#: func.xml:8434(literal)
msgid "~="
msgstr "~="

#: func.xml:8435(entry)
msgid "Same as?"
msgstr "Одинаковы?"

#: func.xml:8436(literal)
msgid "polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'"
msgstr "polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'"

#: func.xml:8443(para)
msgid ""
"Before <productname>PostgreSQL</productname> 8.2, the containment operators "
"<literal>@&gt;</literal> and <literal>&lt;@</literal> were respectively "
"called <literal>~</literal> and <literal>@</literal>. These names are still "
"available, but are deprecated and will eventually be removed."
msgstr ""
"До <productname>PostgreSQL</productname> 8.2 операторы включения "
"<literal>@&gt;</literal> и <literal>&lt;@</literal> назывались "
"соответственно <literal>~</literal> и <literal>@</literal>. Эти имена по-"
"прежнему доступны, но считаются устаревшими и в конце концов будут удалены."

#: func.xml:8451(indexterm)
msgid "<primary>area</primary>"
msgstr "<primary>area</primary>"

#: func.xml:8454(indexterm)
msgid "<primary>center</primary>"
msgstr "<primary>center</primary>"

#: func.xml:8457(indexterm)
msgid "<primary>diameter</primary>"
msgstr "<primary>diameter</primary>"

#: func.xml:8460(indexterm)
msgid "<primary>height</primary>"
msgstr "<primary>height</primary>"

#: func.xml:8463(indexterm)
msgid "<primary>isclosed</primary>"
msgstr "<primary>isclosed</primary>"

#: func.xml:8466(indexterm)
msgid "<primary>isopen</primary>"
msgstr "<primary>isopen</primary>"

#: func.xml:8472(indexterm)
msgid "<primary>npoints</primary>"
msgstr "<primary>npoints</primary>"

#: func.xml:8475(indexterm)
msgid "<primary>pclose</primary>"
msgstr "<primary>pclose</primary>"

#: func.xml:8478(indexterm)
msgid "<primary>popen</primary>"
msgstr "<primary>popen</primary>"

#: func.xml:8481(indexterm)
msgid "<primary>radius</primary>"
msgstr "<primary>radius</primary>"

#: func.xml:8484(indexterm)
msgid "<primary>width</primary>"
msgstr "<primary>width</primary>"

#: func.xml:8489(title)
msgid "Geometric Functions"
msgstr "Геометрические функции"

#: func.xml:8501(replaceable) func.xml:8507(replaceable)
#: func.xml:8537(replaceable)
msgid "object"
msgstr "объект"

#: func.xml:8501(function)
msgid "area(<placeholder-1/>)"
msgstr "area(<placeholder-1/>)"

#: func.xml:8503(entry)
msgid "area"
msgstr "площадь"

#: func.xml:8504(literal)
msgid "area(box '((0,0),(1,1))')"
msgstr "area(box '((0,0),(1,1))')"

#: func.xml:8507(function)
msgid "center(<placeholder-1/>)"
msgstr "center(<placeholder-1/>)"

#: func.xml:8508(type) func.xml:8615(type) func.xml:8621(type)
#: func.xml:8650(type) func.xml:8662(type) func.xml:8679(type)
#: func.xml:8703(type) func.xml:8709(type) func.xml:8715(type)
#: func.xml:8721(type) func.xml:8727(type)
msgctxt "type"
msgid "point"
msgstr "point"

#: func.xml:8509(entry)
msgid "center"
msgstr "центр"

#: func.xml:8510(literal)
msgid "center(box '((0,0),(1,2))')"
msgstr "center(box '((0,0),(1,2))')"

#: func.xml:8513(type) func.xml:8576(type) func.xml:8608(type)
#: func.xml:8645(type) func.xml:8651(type) func.xml:8657(type)
#: func.xml:8714(type) func.xml:8743(type) func.xml:8749(type)
msgid "circle"
msgstr "circle"

#: func.xml:8513(function)
msgid "diameter(<placeholder-1/>)"
msgstr "diameter(<placeholder-1/>)"

#: func.xml:8515(entry)
msgid "diameter of circle"
msgstr "диаметр круга"

#: func.xml:8516(literal)
msgid "diameter(circle '((0,0),2.0)')"
msgstr "diameter(circle '((0,0),2.0)')"

#: func.xml:8519(type) func.xml:8582(type) func.xml:8610(type)
#: func.xml:8616(type) func.xml:8622(type) func.xml:8628(type)
#: func.xml:8633(type) func.xml:8634(type) func.xml:8643(type)
#: func.xml:8672(type) func.xml:8708(type) func.xml:8736(type)
msgid "box"
msgstr "box"

#: func.xml:8519(function)
msgid "height(<placeholder-1/>)"
msgstr "height(<placeholder-1/>)"

#: func.xml:8521(entry)
msgid "vertical size of box"
msgstr "вертикальный размер прямоугольника"

#: func.xml:8522(literal)
msgid "height(box '((0,0),(1,1))')"
msgstr "height(box '((0,0),(1,1))')"

#: func.xml:8525(type) func.xml:8531(type) func.xml:8543(type)
#: func.xml:8555(type) func.xml:8556(type) func.xml:8570(type)
#: func.xml:8571(type) func.xml:8691(type) func.xml:8755(type)
msgid "path"
msgstr "path"

#: func.xml:8525(function)
msgid "isclosed(<placeholder-1/>)"
msgstr "isclosed(<placeholder-1/>)"

#: func.xml:8527(entry)
msgid "a closed path?"
msgstr "замкнутый путь?"

#: func.xml:8528(literal)
msgid "isclosed(path '((0,0),(1,1),(2,0))')"
msgstr "isclosed(path '((0,0),(1,1),(2,0))')"

#: func.xml:8531(function)
msgid "isopen(<placeholder-1/>)"
msgstr "isopen(<placeholder-1/>)"

#: func.xml:8533(entry)
msgid "an open path?"
msgstr "открытый путь?"

#: func.xml:8534(literal)
msgid "isopen(path '[(0,0),(1,1),(2,0)]')"
msgstr "isopen(path '[(0,0),(1,1),(2,0)]')"

#: func.xml:8539(entry)
msgctxt "entry"
msgid "length"
msgstr "длина"

#: func.xml:8540(literal)
msgid "length(path '((-1,0),(1,0))')"
msgstr "length(path '((-1,0),(1,0))')"

#: func.xml:8543(function) func.xml:8549(function)
msgid "npoints(<placeholder-1/>)"
msgstr "npoints(<placeholder-1/>)"

#: func.xml:8545(entry) func.xml:8551(entry)
msgid "number of points"
msgstr "число точек"

#: func.xml:8546(literal)
msgid "npoints(path '[(0,0),(1,1),(2,0)]')"
msgstr "npoints(path '[(0,0),(1,1),(2,0)]')"

#: func.xml:8549(type) func.xml:8627(type) func.xml:8656(type)
#: func.xml:8689(type) func.xml:8726(type) func.xml:8738(type)
#: func.xml:8744(type) func.xml:8750(type) func.xml:8756(type)
msgid "polygon"
msgstr "polygon"

#: func.xml:8552(literal)
msgid "npoints(polygon '((1,1),(0,0))')"
msgstr "npoints(polygon '((1,1),(0,0))')"

#: func.xml:8555(function)
msgid "pclose(<placeholder-1/>)"
msgstr "pclose(<placeholder-1/>)"

#: func.xml:8557(entry)
msgid "convert path to closed"
msgstr "преобразует путь в замкнутый"

#: func.xml:8558(literal)
msgid "pclose(path '[(0,0),(1,1),(2,0)]')"
msgstr "pclose(path '[(0,0),(1,1),(2,0)]')"

#: func.xml:8570(function)
msgid "popen(<placeholder-1/>)"
msgstr "popen(<placeholder-1/>)"

#: func.xml:8572(entry)
msgid "convert path to open"
msgstr "преобразует путь в открытый"

#: func.xml:8573(literal)
msgid "popen(path '((0,0),(1,1),(2,0))')"
msgstr "popen(path '((0,0),(1,1),(2,0))')"

#: func.xml:8576(function)
msgid "radius(<placeholder-1/>)"
msgstr "radius(<placeholder-1/>)"

#: func.xml:8578(entry)
msgid "radius of circle"
msgstr "радиус окружности"

#: func.xml:8579(literal)
msgid "radius(circle '((0,0),2.0)')"
msgstr "radius(circle '((0,0),2.0)')"

#: func.xml:8582(function)
msgid "width(<placeholder-1/>)"
msgstr "width(<placeholder-1/>)"

#: func.xml:8584(entry)
msgid "horizontal size of box"
msgstr "горизонтальный размер прямоугольника"

#: func.xml:8585(literal)
msgid "width(box '((0,0),(1,1))')"
msgstr "width(box '((0,0),(1,1))')"

#: func.xml:8592(title)
msgid "Geometric Type Conversion Functions"
msgstr "Функции преобразования геометрических типов"

#: func.xml:8605(indexterm)
msgid "<primary>box</primary>"
msgstr "<primary>box</primary>"

#: func.xml:8608(function) func.xml:8615(function) func.xml:8627(function)
msgid "box(<placeholder-1/>)"
msgstr "box(<placeholder-1/>)"

#: func.xml:8611(entry)
msgid "circle to box"
msgstr "окружность в прямоугольник"

#: func.xml:8612(literal)
msgid "box(circle '((0,0),2.0)')"
msgstr "box(circle '((0,0),2.0)')"

#: func.xml:8617(entry)
msgid "point to empty box"
msgstr "точка в пустой прямоугольник"

#: func.xml:8618(literal)
msgid "box(point '(0,0)')"
msgstr "box(point '(0,0)')"

#: func.xml:8621(function)
msgid "box(<placeholder-1/>, <placeholder-2/>)"
msgstr "box(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8623(entry)
msgid "points to box"
msgstr "точки в прямоугольник"

#: func.xml:8624(literal)
msgid "box(point '(0,0)', point '(1,1)')"
msgstr "box(point '(0,0)', point '(1,1)')"

#: func.xml:8629(entry)
msgid "polygon to box"
msgstr "многоугольник в прямоугольник"

#: func.xml:8630(literal)
msgid "box(polygon '((0,0),(1,1),(2,0))')"
msgstr "box(polygon '((0,0),(1,1),(2,0))')"

#: func.xml:8633(function)
msgid "bound_box(<placeholder-1/>, <placeholder-2/>)"
msgstr "bound_box(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8635(entry)
msgid "boxes to bounding box"
msgstr "прямоугольники в окружающий прямоугольник"

#: func.xml:8636(literal)
msgid "bound_box(box '((0,0),(1,1))', box '((3,3),(4,4))')"
msgstr "bound_box(box '((0,0),(1,1))', box '((3,3),(4,4))')"

#: func.xml:8640(indexterm)
msgid "<primary>circle</primary>"
msgstr "<primary>круг</primary>"

#: func.xml:8643(function) func.xml:8656(function)
msgid "circle(<placeholder-1/>)"
msgstr "circle(<placeholder-1/>)"

#: func.xml:8646(entry)
msgid "box to circle"
msgstr "прямоугольник в окружность"

#: func.xml:8647(literal)
msgid "circle(box '((0,0),(1,1))')"
msgstr "circle(box '((0,0),(1,1))')"

#: func.xml:8650(function)
msgid "circle(<placeholder-1/>, <placeholder-2/>)"
msgstr "circle(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8652(entry)
msgid "center and radius to circle"
msgstr "окружность из центра и радиуса"

#: func.xml:8653(literal)
msgid "circle(point '(0,0)', 2.0)"
msgstr "circle(point '(0,0)', 2.0)"

#: func.xml:8658(entry)
msgid "polygon to circle"
msgstr "многоугольник в окружность"

#: func.xml:8659(literal)
msgid "circle(polygon '((0,0),(1,1),(2,0))')"
msgstr "circle(polygon '((0,0),(1,1),(2,0))')"

#: func.xml:8662(function)
msgid "line(<placeholder-1/>, <placeholder-2/>)"
msgstr "line(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8663(type)
msgid "line"
msgstr "line"

#: func.xml:8664(entry)
msgid "points to line"
msgstr "точки в прямую"

#: func.xml:8665(literal)
msgid "line(point '(-1,0)', point '(1,0)')"
msgstr "line(point '(-1,0)', point '(1,0)')"

#: func.xml:8669(indexterm)
msgid "<primary>lseg</primary>"
msgstr "<primary>lseg</primary>"

#: func.xml:8672(function)
msgid "lseg(<placeholder-1/>)"
msgstr "lseg(<placeholder-1/>)"

#: func.xml:8674(type) func.xml:8680(type) func.xml:8720(type)
msgid "lseg"
msgstr "lseg"

#: func.xml:8675(entry)
msgid "box diagonal to line segment"
msgstr "диагональ прямоугольника в отрезок"

#: func.xml:8676(literal)
msgid "lseg(box '((-1,0),(1,0))')"
msgstr "lseg(box '((-1,0),(1,0))')"

#: func.xml:8679(function)
msgid "lseg(<placeholder-1/>, <placeholder-2/>)"
msgstr "lseg(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8681(entry)
msgid "points to line segment"
msgstr "точки в отрезок"

#: func.xml:8682(literal)
msgid "lseg(point '(-1,0)', point '(1,0)')"
msgstr "lseg(point '(-1,0)', point '(1,0)')"

#: func.xml:8686(indexterm)
msgid "<primary>path</primary>"
msgstr "<primary>path</primary>"

#: func.xml:8689(function)
msgid "path(<placeholder-1/>)"
msgstr "path(<placeholder-1/>)"

#: func.xml:8692(entry)
msgid "polygon to path"
msgstr "многоугольник в путь"

#: func.xml:8693(literal)
msgid "path(polygon '((0,0),(1,1),(2,0))')"
msgstr "path(polygon '((0,0),(1,1),(2,0))')"

#: func.xml:8697(indexterm)
msgid "<primary>point</primary>"
msgstr "<primary>точка</primary>"

#: func.xml:8700(function)
msgctxt "function"
msgid "point"
msgstr "point"

#: func.xml:8704(entry)
msgid "construct point"
msgstr "образует точку"

#: func.xml:8705(literal)
msgid "point(23.4, -44.5)"
msgstr "point(23.4, -44.5)"

#: func.xml:8708(function) func.xml:8714(function) func.xml:8720(function)
#: func.xml:8726(function)
msgid "point(<placeholder-1/>)"
msgstr "point(<placeholder-1/>)"

#: func.xml:8710(entry)
msgid "center of box"
msgstr "центр прямоугольника"

#: func.xml:8711(literal)
msgid "point(box '((-1,0),(1,0))')"
msgstr "point(box '((-1,0),(1,0))')"

#: func.xml:8716(entry)
msgid "center of circle"
msgstr "центр окружности"

#: func.xml:8717(literal)
msgid "point(circle '((0,0),2.0)')"
msgstr "point(circle '((0,0),2.0)')"

#: func.xml:8722(entry)
msgid "center of line segment"
msgstr "центр отрезка"

#: func.xml:8723(literal)
msgid "point(lseg '((-1,0),(1,0))')"
msgstr "point(lseg '((-1,0),(1,0))')"

#: func.xml:8728(entry)
msgid "center of polygon"
msgstr "центр многоугольника"

#: func.xml:8729(literal)
msgid "point(polygon '((0,0),(1,1),(2,0))')"
msgstr "point(polygon '((0,0),(1,1),(2,0))')"

#: func.xml:8733(indexterm)
msgid "<primary>polygon</primary>"
msgstr "<primary>многоугольник</primary>"

#: func.xml:8736(function) func.xml:8743(function) func.xml:8755(function)
msgid "polygon(<placeholder-1/>)"
msgstr "polygon(<placeholder-1/>)"

#: func.xml:8739(entry)
msgid "box to 4-point polygon"
msgstr "прямоугольник в многоугольник с 4 вершинами"

#: func.xml:8740(literal)
msgid "polygon(box '((0,0),(1,1))')"
msgstr "polygon(box '((0,0),(1,1))')"

#: func.xml:8745(entry)
msgid "circle to 12-point polygon"
msgstr "круг в многоугольник с 12 вершинами"

#: func.xml:8746(literal)
msgid "polygon(circle '((0,0),2.0)')"
msgstr "polygon(circle '((0,0),2.0)')"

#: func.xml:8749(replaceable)
msgid "npts"
msgstr "число_точек"

#: func.xml:8749(function)
msgid "polygon(<placeholder-1/>, <placeholder-2/>)"
msgstr "polygon(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:8751(entry)
msgid ""
"circle to <replaceable class=\"parameter\">npts</replaceable>-point polygon"
msgstr ""
"окружность с заданным <replaceable class=\"parameter\">числом_точек</"
"replaceable>"

#: func.xml:8752(literal)
msgid "polygon(12, circle '((0,0),2.0)')"
msgstr "polygon(12, circle '((0,0),2.0)')"

#: func.xml:8757(entry)
msgid "path to polygon"
msgstr "путь в многоугольник"

#: func.xml:8758(literal)
msgid "polygon(path '((0,0),(1,1),(2,0))')"
msgstr "polygon(path '((0,0),(1,1),(2,0))')"

#: func.xml:8764(para)
msgid ""
"It is possible to access the two component numbers of a <type>point</type> "
"as though the point were an array with indexes 0 and 1. For example, if "
"<literal>t.p</literal> is a <type>point</type> column then <literal>SELECT "
"p[0] FROM t</literal> retrieves the X coordinate and <literal>UPDATE t SET "
"p[1] = ...</literal> changes the Y coordinate. In the same way, a value of "
"type <type>box</type> or <type>lseg</type> can be treated as an array of two "
"<type>point</type> values."
msgstr ""
"К двум компонентам типа <type>point</type> (точка) можно обратиться, как к "
"элементам массива с индексами 0 и 1. Например, если <literal>t.p</literal> "
"&mdash; столбец типа <type>point</type>, <literal>SELECT p[0] FROM t</"
"literal> вернёт координату X, а <literal>UPDATE t SET p[1] = ...</literal> "
"изменит координату Y. Таким же образом, значение типа <type>box</type> или "
"<type>lseg</type> можно воспринимать как массив двух значений типа "
"<type>point</type>."

#: func.xml:8774(para)
msgid ""
"The <function>area</function> function works for the types <type>box</type>, "
"<type>circle</type>, and <type>path</type>. The <function>area</function> "
"function only works on the <type>path</type> data type if the points in the "
"<type>path</type> are non-intersecting. For example, the <type>path</type> "
"<literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal> will "
"not work; however, the following visually identical <type>path</type> "
"<literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</"
"literal> will work. If the concept of an intersecting versus non-"
"intersecting <type>path</type> is confusing, draw both of the above "
"<type>path</type>s side by side on a piece of graph paper."
msgstr ""
"Функция <function>area</function> работает с типами <type>box</type>, "
"<type>circle</type> и <type>path</type>. При этом для типа <type>path</type> "
"заданный путь не должен быть самопересекающимся. Например, эта функция не "
"примет значение типа <type>path</type> <literal>'((0,0),(0,1),(2,1),(2,2),"
"(1,2),(1,0),(0,0))'::PATH</literal>, но примет визуально идентичный путь "
"<literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</"
"literal>. Если вы не вполне поняли, что здесь подразумевается под "
"самопересечением пути, нарисуйте на бумаге две фигуры по приведённым "
"координатам."

#: func.xml:8794(title)
msgid "Network Address Functions and Operators"
msgstr "Функции и операторы для работы с сетевыми адресами"

#: func.xml:8796(para)
msgid ""
"<xref linkend=\"cidr-inet-operators-table\"/> shows the operators available "
"for the <type>cidr</type> and <type>inet</type> types. The operators "
"<literal>&lt;&lt;</literal>, <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;"
"</literal>, <literal>&gt;&gt;=</literal>, and <literal>&amp;&amp;</literal> "
"test for subnet inclusion. They consider only the network parts of the two "
"addresses (ignoring any host part) and determine whether one network is "
"identical to or a subnet of the other."
msgstr ""
"В <xref linkend=\"cidr-inet-operators-table\"/> показаны операторы, "
"работающие с типами <type>cidr</type> и <type>inet</type>. Операторы "
"<literal>&lt;&lt;</literal>, <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;"
"</literal>, <literal>&gt;&gt;=</literal> и <literal>&amp;&amp;</literal> "
"проверяют включения подсетей, рассматривая только биты сети в обоих адресах "
"(игнорируя биты узлов) и определяя, идентична ли одна сеть другой или её "
"подсети."

#: func.xml:8809(title)
msgid "<type>cidr</type> and <type>inet</type> Operators"
msgstr "Операторы для типов <type>cidr</type> и <type>inet</type>"

#: func.xml:8821(entry)
msgid "is less than"
msgstr "меньше"

#: func.xml:8822(literal)
msgid "inet '192.168.1.5' &lt; inet '192.168.1.6'"
msgstr "inet '192.168.1.5' &lt; inet '192.168.1.6'"

#: func.xml:8826(entry)
msgid "is less than or equal"
msgstr "меньше или равно"

#: func.xml:8827(literal)
msgid "inet '192.168.1.5' &lt;= inet '192.168.1.5'"
msgstr "inet '192.168.1.5' &lt;= inet '192.168.1.5'"

#: func.xml:8831(entry)
msgid "equals"
msgstr "равно"

#: func.xml:8832(literal)
msgid "inet '192.168.1.5' = inet '192.168.1.5'"
msgstr "inet '192.168.1.5' = inet '192.168.1.5'"

#: func.xml:8836(entry)
msgid "is greater or equal"
msgstr "больше или равно"

#: func.xml:8837(literal)
msgid "inet '192.168.1.5' &gt;= inet '192.168.1.5'"
msgstr "inet '192.168.1.5' &gt;= inet '192.168.1.5'"

#: func.xml:8841(entry)
msgid "is greater than"
msgstr "больше"

#: func.xml:8842(literal)
msgid "inet '192.168.1.5' &gt; inet '192.168.1.4'"
msgstr "inet '192.168.1.5' &gt; inet '192.168.1.4'"

#: func.xml:8845(literal) func.xml:12003(literal) func.xml:12478(literal)
msgid "&lt;&gt;"
msgstr "&lt;&gt;"

#: func.xml:8846(entry)
msgid "is not equal"
msgstr "не равно"

#: func.xml:8847(literal)
msgid "inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'"
msgstr "inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'"

#: func.xml:8851(entry) func.xml:12046(entry)
msgid "is contained by"
msgstr "содержится в"

#: func.xml:8852(literal)
msgid "inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'"
msgstr "inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'"

#: func.xml:8855(literal)
msgid "&lt;&lt;="
msgstr "&lt;&lt;="

#: func.xml:8856(entry)
msgid "is contained by or equals"
msgstr "равно или содержится в"

#: func.xml:8857(literal)
msgid "inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'"
msgstr "inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'"

#: func.xml:8861(entry) func.xml:12039(entry)
msgid "contains"
msgstr "содержит"

#: func.xml:8862(literal)
msgid "inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'"
msgstr "inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'"

#: func.xml:8865(literal)
msgid "&gt;&gt;="
msgstr "&gt;&gt;="

#: func.xml:8866(entry)
msgid "contains or equals"
msgstr "равно или содержит"

#: func.xml:8867(literal)
msgid "inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'"
msgstr "inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'"

#: func.xml:8871(entry)
msgid "contains or is contained by"
msgstr "содержит или содержится в"

#: func.xml:8872(literal)
msgid "inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'"
msgstr "inet '192.168.1/24' &amp;&amp; inet '192.168.1.80/28'"

#: func.xml:8877(literal)
msgid "~ inet '192.168.1.6'"
msgstr "~ inet '192.168.1.6'"

#: func.xml:8882(literal)
msgid "inet '192.168.1.6' &amp; inet '0.0.0.255'"
msgstr "inet '192.168.1.6' &amp; inet '0.0.0.255'"

#: func.xml:8887(literal)
msgid "inet '192.168.1.6' | inet '0.0.0.255'"
msgstr "inet '192.168.1.6' | inet '0.0.0.255'"

#: func.xml:8892(literal)
msgid "inet '192.168.1.6' + 25"
msgstr "inet '192.168.1.6' + 25"

#: func.xml:8897(literal)
msgid "inet '192.168.1.43' - 36"
msgstr "inet '192.168.1.43' - 36"

#: func.xml:8902(literal)
msgid "inet '192.168.1.43' - inet '192.168.1.19'"
msgstr "inet '192.168.1.43' - inet '192.168.1.19'"

#: func.xml:8908(para)
msgid ""
"<xref linkend=\"cidr-inet-functions-table\"/> shows the functions available "
"for use with the <type>cidr</type> and <type>inet</type> types. The "
"<function>abbrev</function>, <function>host</function>, and <function>text</"
"function> functions are primarily intended to offer alternative display "
"formats."
msgstr ""
"В <xref remap=\"6\" linkend=\"cidr-inet-functions-table\"/> перечислены "
"функции, работающие с типами <type>cidr</type> и <type>inet</type>. Функции "
"<function>abbrev</function>, <function>host</function> и <function>text</"
"function> предназначены в основном для вывода данных в альтернативных "
"форматах."

#: func.xml:8918(title)
msgid "<type>cidr</type> and <type>inet</type> Functions"
msgstr "Функции для типов <type>cidr</type> и <type>inet</type>"

#: func.xml:8932(indexterm)
msgid "<primary>abbrev</primary>"
msgstr "<primary>abbrev</primary>"

#: func.xml:8935(type) func.xml:8954(type) func.xml:8956(type)
#: func.xml:8966(type) func.xml:8979(type) func.xml:8991(type)
#: func.xml:8993(type) func.xml:9003(type) func.xml:9015(type)
#: func.xml:9017(type) func.xml:9027(type) func.xml:9039(type)
#: func.xml:9041(type) func.xml:9058(type) func.xml:9070(type)
#: func.xml:9082(type) func.xml:15329(type) func.xml:15341(type)
msgid "inet"
msgstr "inet"

#: func.xml:8935(function) func.xml:8943(function)
msgid "abbrev(<placeholder-1/>)"
msgstr "abbrev(<placeholder-1/>)"

#: func.xml:8938(entry) func.xml:8945(entry)
msgid "abbreviated display format as text"
msgstr "вывод адрес в кратком текстовом виде"

#: func.xml:8939(literal)
msgid "abbrev(inet '10.1.0.0/16')"
msgstr "abbrev(inet '10.1.0.0/16')"

#: func.xml:8940(literal)
msgid "10.1.0.0/16"
msgstr "10.1.0.0/16"

#: func.xml:8943(type) func.xml:9029(type) func.xml:9047(type)
#: func.xml:9048(type) func.xml:9084(type)
msgid "cidr"
msgstr "cidr"

#: func.xml:8946(literal)
msgid "abbrev(cidr '10.1.0.0/16')"
msgstr "abbrev(cidr '10.1.0.0/16')"

#: func.xml:8947(literal)
msgid "10.1/16"
msgstr "10.1/16"

#: func.xml:8951(indexterm)
msgid "<primary>broadcast</primary>"
msgstr "<primary>broadcast</primary>"

#: func.xml:8954(function)
msgid "broadcast(<placeholder-1/>)"
msgstr "broadcast(<placeholder-1/>)"

#: func.xml:8957(entry)
msgid "broadcast address for network"
msgstr "широковещательный адрес сети"

#: func.xml:8958(literal)
msgid "broadcast('192.168.1.5/24')"
msgstr "broadcast('192.168.1.5/&zwsp;24')"

#: func.xml:8959(literal)
msgid "192.168.1.255/24"
msgstr "192.168.1.255/&zwsp;24"

#: func.xml:8963(indexterm)
msgid "<primary>family</primary>"
msgstr "<primary>family</primary>"

#: func.xml:8966(function)
msgid "family(<placeholder-1/>)"
msgstr "family(<placeholder-1/>)"

#: func.xml:8969(entry)
msgid ""
"extract family of address; <literal>4</literal> for IPv4, <literal>6</"
"literal> for IPv6"
msgstr ""
"возвращает семейство адреса; <literal>4</literal> для адреса IPv4, "
"<literal>6</literal> для IPv6"

#: func.xml:8971(literal)
msgid "family('::1')"
msgstr "family('::1')"

#: func.xml:8976(indexterm)
msgid "<primary>host</primary>"
msgstr "<primary>host</primary>"

#: func.xml:8979(function)
msgid "host(<placeholder-1/>)"
msgstr "host(<placeholder-1/>)"

#: func.xml:8982(entry)
msgid "extract IP address as text"
msgstr "извлекает IP-адрес в виде текста"

#: func.xml:8983(literal)
msgid "host('192.168.1.5/24')"
msgstr "host('192.168.1.5/&zwsp;24')"

#: func.xml:8984(literal)
msgid "192.168.1.5"
msgstr "192.168.1.5"

#: func.xml:8988(indexterm)
msgid "<primary>hostmask</primary>"
msgstr "<primary>hostmask</primary>"

#: func.xml:8991(function)
msgid "hostmask(<placeholder-1/>)"
msgstr "hostmask(<placeholder-1/>)"

#: func.xml:8994(entry)
msgid "construct host mask for network"
msgstr "вычисляет маску узла для сетевого адреса"

#: func.xml:8995(literal)
msgid "hostmask('192.168.23.20/30')"
msgstr "hostmask('192.168.23.20/&zwsp;30')"

#: func.xml:8996(literal)
msgid "0.0.0.3"
msgstr "0.0.0.3"

#: func.xml:9000(indexterm)
msgid "<primary>masklen</primary>"
msgstr "<primary>masklen</primary>"

#: func.xml:9003(function)
msgid "masklen(<placeholder-1/>)"
msgstr "masklen(<placeholder-1/>)"

#: func.xml:9006(entry)
msgid "extract netmask length"
msgstr "выдаёт длину маски сети"

#: func.xml:9007(literal)
msgid "masklen('192.168.1.5/24')"
msgstr "masklen('192.168.1.5/&zwsp;24')"

#: func.xml:9008(literal)
msgid "24"
msgstr "24"

#: func.xml:9012(indexterm)
msgid "<primary>netmask</primary>"
msgstr "<primary>netmask</primary>"

#: func.xml:9015(function)
msgid "netmask(<placeholder-1/>)"
msgstr "netmask(<placeholder-1/>)"

#: func.xml:9018(entry)
msgid "construct netmask for network"
msgstr "вычисляет маску сети для сетевого адреса"

#: func.xml:9019(literal)
msgid "netmask('192.168.1.5/24')"
msgstr "netmask('192.168.1.5/&zwsp;24')"

#: func.xml:9020(literal)
msgid "255.255.255.0"
msgstr "255.255.255.0"

#: func.xml:9024(indexterm)
msgid "<primary>network</primary>"
msgstr "<primary>network</primary>"

#: func.xml:9027(function)
msgid "network(<placeholder-1/>)"
msgstr "network(<placeholder-1/>)"

#: func.xml:9030(entry)
msgid "extract network part of address"
msgstr "извлекает компонент сети из адреса"

#: func.xml:9031(literal)
msgid "network('192.168.1.5/24')"
msgstr "network('192.168.1.5/&zwsp;24')"

#: func.xml:9032(literal)
msgid "192.168.1.0/24"
msgstr "192.168.1.0/24"

#: func.xml:9036(indexterm)
msgid "<primary>set_masklen</primary>"
msgstr "<primary>set_masklen</primary>"

#: func.xml:9039(function) func.xml:9047(function)
msgid "set_masklen(<placeholder-1/>, <placeholder-2/>)"
msgstr "set_masklen(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:9042(entry)
msgid "set netmask length for <type>inet</type> value"
msgstr "задаёт размер маски для значения <type>inet</type>"

#: func.xml:9043(literal)
msgid "set_masklen('192.168.1.5/24', 16)"
msgstr "set_masklen('192.168.1.5/&zwsp;24', 16)"

#: func.xml:9044(literal)
msgid "192.168.1.5/16"
msgstr "192.168.1.5/16"

#: func.xml:9049(entry)
msgid "set netmask length for <type>cidr</type> value"
msgstr "задаёт размер маски для значения <type>cidr</type>"

#: func.xml:9050(literal)
msgid "set_masklen('192.168.1.0/24'::cidr, 16)"
msgstr "set_masklen('192.168.1.0/&zwsp;24'::cidr, 16)"

#: func.xml:9051(literal)
msgid "192.168.0.0/16"
msgstr "192.168.0.0/16"

#: func.xml:9055(indexterm)
msgid "<primary>text</primary>"
msgstr "<primary>text</primary>"

#: func.xml:9058(function)
msgid "text(<placeholder-1/>)"
msgstr "text(<placeholder-1/>)"

#: func.xml:9061(entry)
msgid "extract IP address and netmask length as text"
msgstr "выводит в текстовом виде IP-адрес и длину маски"

#: func.xml:9062(literal)
msgid "text(inet '192.168.1.5')"
msgstr "text(inet '192.168.1.5')"

#: func.xml:9063(literal)
msgid "192.168.1.5/32"
msgstr "192.168.1.5/32"

#: func.xml:9067(indexterm)
msgid "<primary>inet_same_family</primary>"
msgstr "<primary>inet_same_family</primary>"

#: func.xml:9070(function)
msgid "inet_same_family(<placeholder-1/>, <placeholder-2/>)"
msgstr "inet_same_family(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:9073(entry)
msgid "are the addresses from the same family?"
msgstr "адреса относятся к одному семейству?"

#: func.xml:9074(literal)
msgid "inet_same_family('192.168.1.5/24', '::1')"
msgstr "inet_same_family('192.168.1.5/24', '::1')"

#: func.xml:9075(literal) func.xml:12699(literal) func.xml:12721(literal)
msgctxt "literal"
msgid "false"
msgstr "false"

#: func.xml:9079(indexterm)
msgid "<primary>inet_merge</primary>"
msgstr "<primary>inet_merge</primary>"

#: func.xml:9082(function)
msgid "inet_merge(<placeholder-1/>, <placeholder-2/>)"
msgstr "inet_merge(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:9085(entry)
msgid "the smallest network which includes both of the given networks"
msgstr "наименьшая сеть, включающая обе заданные сети"

#: func.xml:9086(literal)
msgid "inet_merge('192.168.1.5/24', '192.168.2.5/24')"
msgstr "inet_merge('192.168.1.5/24', '192.168.2.5/24')"

#: func.xml:9087(literal)
msgid "192.168.0.0/22"
msgstr "192.168.0.0/22"

#: func.xml:9093(para)
msgid ""
"Any <type>cidr</type> value can be cast to <type>inet</type> implicitly or "
"explicitly; therefore, the functions shown above as operating on <type>inet</"
"type> also work on <type>cidr</type> values. (Where there are separate "
"functions for <type>inet</type> and <type>cidr</type>, it is because the "
"behavior should be different for the two cases.) Also, it is permitted to "
"cast an <type>inet</type> value to <type>cidr</type>. When this is done, any "
"bits to the right of the netmask are silently zeroed to create a valid "
"<type>cidr</type> value. In addition, you can cast a text value to "
"<type>inet</type> or <type>cidr</type> using normal casting syntax: for "
"example, <literal>inet(<replaceable>expression</replaceable>)</literal> or "
"<literal><replaceable>colname</replaceable>::cidr</literal>."
msgstr ""
"Любое значение <type>cidr</type> можно привести к типу <type>inet</type>, "
"явно или нет; поэтому все функции, показанные выше с типом <type>inet</"
"type>, также будут работать со значениями <type>cidr</type>. (Некоторые из "
"функций указаны отдельно для типов <type>inet</type> и <type>cidr</type>, "
"потому что их поведение с разными типами различается.) Кроме того, значение "
"<type>inet</type> тоже можно привести к типу <type>cidr</type>. При этом все "
"биты справа от сетевой маски просто обнуляются, чтобы значение стало "
"допустимым для типа <type>cidr</type>. К типам <type>inet</type> и "
"<type>cidr</type> можно привести и обычные текстовые значения, используя "
"обычный синтаксис, например: <literal>inet(<replaceable>выражение</"
"replaceable>)</literal> или <literal><replaceable>столбец</replaceable>::"
"cidr</literal>."

#: func.xml:9109(para)
msgid ""
"<xref linkend=\"macaddr-functions-table\"/> shows the functions available "
"for use with the <type>macaddr</type> type. The function "
"<literal><function>trunc(<type>macaddr</type>)</function></literal> returns "
"a MAC address with the last 3 bytes set to zero. This can be used to "
"associate the remaining prefix with a manufacturer."
msgstr ""
"В <xref remap=\"6\" linkend=\"macaddr-functions-table\"/> приведена функция, "
"предназначенная для работы с типом <type>macaddr</type>. Функция "
"<literal><function>trunc(<type>macaddr</type>)</function></literal> "
"возвращает MAC-адрес, последние 3 байта в котором равны 0. Это может быть "
"полезно для вычисления префикса, определяющего производителя."

#: func.xml:9118(title)
msgid "<type>macaddr</type> Functions"
msgstr "Функции <type>macaddr</type>"

#: func.xml:9135(type) func.xml:9137(type)
msgid "macaddr"
msgstr "macaddr"

#: func.xml:9135(function)
msgid "trunc(<placeholder-1/>)"
msgstr "trunc(<placeholder-1/>)"

#: func.xml:9138(entry)
msgid "set last 3 bytes to zero"
msgstr "обнуляет последние 3 байта"

#: func.xml:9139(literal)
msgid "trunc(macaddr '12:34:56:78:90:ab')"
msgstr "trunc(macaddr '12:34:56:&zwsp;78:90:ab')"

#: func.xml:9140(literal)
msgid "12:34:56:00:00:00"
msgstr "12:34:56:&zwsp;00:00:00"

#: func.xml:9146(para)
msgid ""
"The <type>macaddr</type> type also supports the standard relational "
"operators (<literal>&gt;</literal>, <literal>&lt;=</literal>, etc.) for "
"lexicographical ordering, and the bitwise arithmetic operators (<literal>~</"
"literal>, <literal>&amp;</literal> and <literal>|</literal>) for NOT, AND "
"and OR."
msgstr ""
"Тип <type>macaddr</type> также поддерживает стандартные реляционные "
"операторы лексической сортировки (<literal>&gt;</literal>, <literal>&lt;=</"
"literal> и т. д.) и операторы битовой арифметики (<literal>~</literal>, "
"<literal>&amp;</literal> и <literal>|</literal>), соответствующие операциям "
"NOT, AND и OR."

#: func.xml:9158(title)
msgid "Text Search Functions and Operators"
msgstr "Функции и операторы текстового поиска"

#: func.xml:9160(indexterm)
msgid ""
"<primary>full text search</primary> <secondary>functions and operators</"
"secondary>"
msgstr ""
"<primary>полнотекстовый поиск</primary> <secondary>функции и операторы</"
"secondary>"

#: func.xml:9165(indexterm)
msgid ""
"<primary>text search</primary> <secondary>functions and operators</secondary>"
msgstr ""
"<primary>поиск текста</primary> <secondary>функции и операторы</secondary>"

#: func.xml:9170(para)
msgid ""
"<xref linkend=\"textsearch-operators-table\"/>, <xref linkend=\"textsearch-"
"functions-table\"/> and <xref linkend=\"textsearch-functions-debug-table\"/> "
"summarize the functions and operators that are provided for full text "
"searching. See <xref linkend=\"textsearch\"/> for a detailed explanation of "
"<productname>PostgreSQL</productname>'s text search facility."
msgstr ""
"В <xref remap=\"6\" linkend=\"textsearch-operators-table\"/>, <xref remap="
"\"6\" linkend=\"textsearch-functions-table\"/> и <xref remap=\"6\" linkend="
"\"textsearch-functions-debug-table\"/> собраны все существующие функции и "
"операторы, предназначенные для полнотекстового поиска. Во всех деталях "
"возможности полнотекстового поиска в <productname>PostgreSQL</productname> "
"описаны в <xref remap=\"6\" linkend=\"textsearch\"/>."

#: func.xml:9181(title)
msgid "Text Search Operators"
msgstr "Операторы текстового поиска"

#: func.xml:9196(entry)
msgid "<type>tsvector</type> matches <type>tsquery</type> ?"
msgstr "<type>tsvector</type> соответствует <type>tsquery</type> ?"

#: func.xml:9197(literal)
msgid "to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')"
msgstr "to_tsvector('fat cats ate rats') @@ to_tsquery('cat &amp; rat')"

#: func.xml:9201(literal)
msgid "@@@"
msgstr "@@@"

#: func.xml:9203(entry)
msgid "deprecated synonym for <literal>@@</literal>"
msgstr "устаревший синоним для <literal>@@</literal>"

#: func.xml:9204(literal)
msgid "to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')"
msgstr "to_tsvector('fat cats ate rats') @@@ to_tsquery('cat &amp; rat')"

#: func.xml:9209(type) func.xml:9295(type) func.xml:9317(type)
#: func.xml:9378(type) func.xml:9380(type) func.xml:9391(type)
#: func.xml:9393(type) func.xml:9403(type) func.xml:9405(type)
#: func.xml:9429(type) func.xml:9439(type) func.xml:9441(type)
#: func.xml:9449(type) func.xml:9451(type) func.xml:9461(type)
#: func.xml:9463(type) func.xml:9485(type) func.xml:9497(type)
#: func.xml:9553(type) func.xml:9590(type)
msgid "tsvector"
msgstr "tsvector"

#: func.xml:9210(entry)
msgid "concatenate <type>tsvector</type>s"
msgstr "объединяет два значения <type>tsvector</type>"

#: func.xml:9211(literal)
msgid "'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector"
msgstr "'a:1 b:2'::tsvector || 'c:1 d:2 b:3'::tsvector"

#: func.xml:9212(literal)
msgid "'a':1 'b':2,5 'c':3 'd':4"
msgstr "'a':1 'b':2,5 'c':3 'd':4"

#: func.xml:9216(type) func.xml:9223(type) func.xml:9230(type)
#: func.xml:9237(type) func.xml:9329(type) func.xml:9343(type)
#: func.xml:9355(type) func.xml:9366(type) func.xml:9417(type)
#: func.xml:9473(type) func.xml:9485(type) func.xml:9497(type)
#: func.xml:9509(type) func.xml:9511(type) func.xml:9518(type)
#: func.xml:9519(type) func.xml:9529(type) func.xml:9531(type)
#: func.xml:9540(type) func.xml:9542(type)
msgid "tsquery"
msgstr "tsquery"

#: func.xml:9217(entry)
msgid "AND <type>tsquery</type>s together"
msgstr "логическое И (AND) двух запросов <type>tsquery</type>"

#: func.xml:9218(literal)
msgid "'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery"
msgstr "'fat | rat'::tsquery &amp;&amp; 'cat'::tsquery"

#: func.xml:9219(literal)
msgid "( 'fat' | 'rat' ) &amp; 'cat'"
msgstr "( 'fat' | 'rat' ) &amp; 'cat'"

#: func.xml:9224(entry)
msgid "OR <type>tsquery</type>s together"
msgstr "логическое ИЛИ (OR) двух запросов <type>tsquery</type>"

#: func.xml:9225(literal)
msgid "'fat | rat'::tsquery || 'cat'::tsquery"
msgstr "'fat | rat'::tsquery || 'cat'::tsquery"

#: func.xml:9226(literal)
msgid "( 'fat' | 'rat' ) | 'cat'"
msgstr "( 'fat' | 'rat' ) | 'cat'"

#: func.xml:9231(entry)
msgid "negate a <type>tsquery</type>"
msgstr "отрицание запроса <type>tsquery</type>"

#: func.xml:9232(literal)
msgid "!! 'cat'::tsquery"
msgstr "!! 'cat'::tsquery"

#: func.xml:9233(literal)
msgid "!'cat'"
msgstr "!'cat'"

#: func.xml:9238(entry)
msgid "<type>tsquery</type> followed by <type>tsquery</type>"
msgstr "<type>tsquery</type> предшествует <type>tsquery</type>"

#: func.xml:9239(literal)
msgid "to_tsquery('fat') &lt;-&gt; to_tsquery('rat')"
msgstr "to_tsquery('fat') &lt;-&gt; to_tsquery('rat')"

#: func.xml:9240(literal) func.xml:9359(literal)
msgid "'fat' &lt;-&gt; 'rat'"
msgstr "'fat' &lt;-&gt; 'rat'"

#: func.xml:9245(entry)
msgid "<type>tsquery</type> contains another ?"
msgstr "запрос <type>tsquery</type> включает другой?"

#: func.xml:9246(literal)
msgid "'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery"
msgstr "'cat'::tsquery @&gt; 'cat &amp; rat'::tsquery"

#: func.xml:9247(literal) func.xml:12537(literal)
msgid "f"
msgstr "f"

#: func.xml:9252(entry)
msgid "<type>tsquery</type> is contained in ?"
msgstr "запрос <type>tsquery</type> включён в другой?"

#: func.xml:9253(literal)
msgid "'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery"
msgstr "'cat'::tsquery &lt;@ 'cat &amp; rat'::tsquery"

#: func.xml:9261(para)
msgid ""
"The <type>tsquery</type> containment operators consider only the lexemes "
"listed in the two queries, ignoring the combining operators."
msgstr ""
"Операторы включения <type>tsquery</type> рассматривают только лексемы двух "
"запросов, игнорируя операторы их сочетания."

#: func.xml:9267(para)
msgid ""
"In addition to the operators shown in the table, the ordinary B-tree "
"comparison operators (<literal>=</literal>, <literal>&lt;</literal>, etc) "
"are defined for types <type>tsvector</type> and <type>tsquery</type>. These "
"are not very useful for text searching but allow, for example, unique "
"indexes to be built on columns of these types."
msgstr ""
"В дополнение к операторам, перечисленным в этой таблице, для типов "
"<type>tsvector</type> и <type>tsquery</type> определены обычные операторы "
"сравнения для B-дерева (<literal>=</literal>, <literal>&lt;</literal> и т. "
"д.). Они не очень полезны для поиска, но позволяют, в частности, создавать "
"индексы для столбцов этих типов."

#: func.xml:9276(title)
msgid "Text Search Functions"
msgstr "Функции текстового поиска"

#: func.xml:9290(indexterm)
msgid "<primary>array_to_tsvector</primary>"
msgstr "<primary>array_to_tsvector</primary>"

#: func.xml:9293(function)
msgid "array_to_tsvector(<placeholder-1/>)"
msgstr "array_to_tsvector(<placeholder-1/>)"

#: func.xml:9296(entry)
msgid "convert array of lexemes to <type>tsvector</type>"
msgstr "преобразует массив лексем в <type>tsvector</type>"

#: func.xml:9297(literal)
msgid "array_to_tsvector('{fat,cat,rat}'::text[])"
msgstr "array_to_tsvector('{fat,cat,rat}'::text[])"

#: func.xml:9298(literal) func.xml:9408(literal)
msgid "'cat' 'fat' 'rat'"
msgstr "'cat' 'fat' 'rat'"

#: func.xml:9302(indexterm)
msgid "<primary>get_current_ts_config</primary>"
msgstr "<primary>get_current_ts_config</primary>"

#: func.xml:9305(function)
msgctxt "function"
msgid "get_current_ts_config()"
msgstr "get_current_ts_config()"

#: func.xml:9307(type) func.xml:9341(type) func.xml:9353(type)
#: func.xml:9415(type) func.xml:9427(type) func.xml:9473(type)
#: func.xml:9636(type)
msgid "regconfig"
msgstr "regconfig"

#: func.xml:9308(entry)
msgid "get default text search configuration"
msgstr "получает конфигурацию текстового поиска по умолчанию"

#: func.xml:9309(literal)
msgctxt "literal"
msgid "get_current_ts_config()"
msgstr "get_current_ts_config()"

#: func.xml:9310(literal)
msgid "english"
msgstr "english"

#: func.xml:9319(type) func.xml:9331(type) func.xml:9485(type)
#: func.xml:9497(type) func.xml:9540(type) func.xml:9660(type)
#: func.xml:9668(type) func.xml:9679(type) func.xml:9687(type)
#: func.xml:9698(type) func.xml:10774(type) func.xml:13964(type)
#: func.xml:14125(type) func.xml:14128(type) func.xml:14141(type)
#: func.xml:14170(type) func.xml:14230(type) func.xml:16737(type)
#: func.xml:16742(type) func.xml:17173(type) func.xml:17178(type)
#: func.xml:17269(type) func.xml:17274(type) func.xml:17310(type)
#: func.xml:17315(type) func.xml:17320(type) func.xml:17325(type)
#: func.xml:17330(type) func.xml:17335(type) func.xml:17340(type)
#: func.xml:17345(type) func.xml:17350(type) func.xml:17370(type)
#: func.xml:17401(type) func.xml:18943(type) func.xml:19498(type)
msgid "integer"
msgstr "integer"

#: func.xml:9320(entry)
msgid "number of lexemes in <type>tsvector</type>"
msgstr "число лексем в значении <type>tsvector</type>"

#: func.xml:9321(literal)
msgid "length('fat:2,4 cat:3 rat:5A'::tsvector)"
msgstr "length('fat:2,4 cat:3 rat:5A'::tsvector)"

#: func.xml:9326(indexterm)
msgid "<primary>numnode</primary>"
msgstr "<primary>numnode</primary>"

#: func.xml:9329(function)
msgid "numnode(<placeholder-1/>)"
msgstr "numnode(<placeholder-1/>)"

#: func.xml:9332(entry)
msgid "number of lexemes plus operators in <type>tsquery</type>"
msgstr "число лексем и операторов в запросе <type>tsquery</type>"

#: func.xml:9333(literal)
msgid "numnode('(fat &amp; rat) | cat'::tsquery)"
msgstr "numnode('(fat &amp; rat) | cat'::tsquery)"

#: func.xml:9338(indexterm)
msgid "<primary>plainto_tsquery</primary>"
msgstr "<primary>plainto_tsquery</primary>"

#: func.xml:9341(replaceable) func.xml:9353(replaceable)
#: func.xml:9415(replaceable) func.xml:9427(replaceable)
#: func.xml:9473(replaceable) func.xml:9636(replaceable)
msgid "config"
msgstr "конфигурация"

#: func.xml:9341(optional) func.xml:9353(optional) func.xml:9415(optional)
#: func.xml:9427(optional)
msgid "<placeholder-1/> <placeholder-2/> ,"
msgstr "<placeholder-1/> <placeholder-2/> ,"

#: func.xml:9341(replaceable) func.xml:9353(replaceable)
#: func.xml:9366(replaceable) func.xml:9415(replaceable)
#: func.xml:9473(replaceable) func.xml:9485(replaceable)
#: func.xml:9497(replaceable) func.xml:9509(replaceable)
#: func.xml:9518(replaceable)
msgid "query"
msgstr "запрос"

#: func.xml:9341(function)
msgid "plainto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "plainto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:9344(entry)
msgid "produce <type>tsquery</type> ignoring punctuation"
msgstr "выдаёт значение <type>tsquery</type>, игнорируя пунктуацию"

#: func.xml:9345(literal)
msgid "plainto_tsquery('english', 'The Fat Rats')"
msgstr "plainto_tsquery('english', 'The Fat Rats')"

#: func.xml:9346(literal) func.xml:9420(literal)
msgid "'fat' &amp; 'rat'"
msgstr "'fat' &amp; 'rat'"

#: func.xml:9350(indexterm)
msgid "<primary>phraseto_tsquery</primary>"
msgstr "<primary>phraseto_tsquery</primary>"

#: func.xml:9353(function)
msgid "phraseto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "phraseto_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:9356(entry)
msgid ""
"produce <type>tsquery</type> that searches for a phrase, ignoring punctuation"
msgstr ""
"выдаёт значение <type>tsquery</type> для поиска фразы, игнорируя пунктуацию"

#: func.xml:9358(literal)
msgid "phraseto_tsquery('english', 'The Fat Rats')"
msgstr "phraseto_tsquery('english', 'The Fat Rats')"

#: func.xml:9363(indexterm)
msgid "<primary>querytree</primary>"
msgstr "<primary>querytree</primary>"

#: func.xml:9366(function)
msgid "querytree(<placeholder-1/> <placeholder-2/>)"
msgstr "querytree(<placeholder-1/> <placeholder-2/>)"

#: func.xml:9369(entry)
msgid "get indexable part of a <type>tsquery</type>"
msgstr "получает индексируемую часть запроса <type>tsquery</type>"

#: func.xml:9370(literal)
msgid "querytree('foo &amp; ! bar'::tsquery)"
msgstr "querytree('foo &amp; ! bar'::tsquery)"

#: func.xml:9371(literal)
msgid "'foo'"
msgstr "'foo'"

#: func.xml:9375(indexterm)
msgid "<primary>setweight</primary>"
msgstr "<primary>setweight</primary>"

#: func.xml:9378(replaceable) func.xml:9391(replaceable)
#: func.xml:9439(replaceable) func.xml:9449(replaceable)
#: func.xml:9461(replaceable) func.xml:9485(replaceable)
#: func.xml:9497(replaceable)
msgid "vector"
msgstr "вектор"

#: func.xml:9378(replaceable) func.xml:9391(replaceable)
msgid "weight"
msgstr "вес"

#: func.xml:9378(type) func.xml:9391(type)
msgid "\"char\""
msgstr "\"char\""

#: func.xml:9378(function)
msgid ""
"setweight(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"setweight(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#: func.xml:9381(entry)
msgid ""
"assign <replaceable class=\"parameter\">weight</replaceable> to each element "
"of <replaceable class=\"parameter\">vector</replaceable>"
msgstr ""
"назначает <replaceable class=\"parameter\">вес</replaceable> каждому "
"элементу <replaceable class=\"parameter\">вектора</replaceable>"

#: func.xml:9382(literal)
msgid "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')"
msgstr "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A')"

#: func.xml:9383(literal)
msgid "'cat':3A 'fat':2A,4A 'rat':5A"
msgstr "'cat':3A 'fat':2A,4A 'rat':5A"

#: func.xml:9387(indexterm)
msgid ""
"<primary>setweight</primary> <secondary>setweight for specific lexeme(s)</"
"secondary>"
msgstr ""
"<primary>setweight</primary> <secondary>назначение веса определённым "
"лексемам</secondary>"

#: func.xml:9391(replaceable) func.xml:9449(replaceable)
#: func.xml:9636(replaceable)
msgid "lexemes"
msgstr "лексемы"

#: func.xml:9391(function)
msgid ""
"setweight(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"setweight(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, <placeholder-5/> <placeholder-6/>)"

#: func.xml:9394(entry)
msgid ""
"assign <replaceable class=\"parameter\">weight</replaceable> to elements of "
"<replaceable class=\"parameter\">vector</replaceable> that are listed in "
"<replaceable class=\"parameter\">lexemes</replaceable>"
msgstr ""
"назначает <replaceable class=\"parameter\">вес</replaceable> элементам "
"<replaceable class=\"parameter\">вектора</replaceable>, перечисленным в "
"массиве <replaceable class=\"parameter\">лексемы</replaceable>"

#: func.xml:9395(literal)
msgid "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A', '{cat,rat}')"
msgstr "setweight('fat:2,4 cat:3 rat:5B'::tsvector, 'A', '{cat,rat}')"

#: func.xml:9396(literal)
msgid "'cat':3A 'fat':2,4 'rat':5A"
msgstr "'cat':3A 'fat':2,4 'rat':5A"

#: func.xml:9400(indexterm)
msgid "<primary>strip</primary>"
msgstr "<primary>strip</primary>"

#: func.xml:9403(function)
msgid "strip(<placeholder-1/>)"
msgstr "strip(<placeholder-1/>)"

#: func.xml:9406(entry)
msgid "remove positions and weights from <type>tsvector</type>"
msgstr "убирает позиции и веса из значения <type>tsvector</type>"

#: func.xml:9407(literal)
msgid "strip('fat:2,4 cat:3 rat:5A'::tsvector)"
msgstr "strip('fat:2,4 cat:3 rat:5A'::tsvector)"

#: func.xml:9412(indexterm)
msgid "<primary>to_tsquery</primary>"
msgstr "<primary>to_tsquery</primary>"

#: func.xml:9415(function)
msgid "to_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "to_tsquery(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:9418(entry)
msgid "normalize words and convert to <type>tsquery</type>"
msgstr "нормализует слова и переводит их в <type>tsquery</type>"

#: func.xml:9419(literal)
msgid "to_tsquery('english', 'The &amp; Fat &amp; Rats')"
msgstr "to_tsquery('english', 'The &amp; Fat &amp; Rats')"

#: func.xml:9424(indexterm)
msgid "<primary>to_tsvector</primary>"
msgstr "<primary>to_tsvector</primary>"

#: func.xml:9427(replaceable) func.xml:9473(replaceable)
#: func.xml:9636(replaceable) func.xml:9660(replaceable)
#: func.xml:9668(replaceable)
msgid "document"
msgstr "документ"

#: func.xml:9427(function)
msgid "to_tsvector(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "to_tsvector(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:9430(entry)
msgid "reduce document text to <type>tsvector</type>"
msgstr "сокращает текст документа до значения <type>tsvector</type>"

#: func.xml:9431(literal)
msgid "to_tsvector('english', 'The Fat Rats')"
msgstr "to_tsvector('english', 'The Fat Rats')"

#: func.xml:9432(literal)
msgid "'fat':2 'rat':3"
msgstr "'fat':2 'rat':3"

#: func.xml:9436(indexterm)
msgid "<primary>ts_delete</primary>"
msgstr "<primary>ts_delete</primary>"

#: func.xml:9439(replaceable) func.xml:9590(replaceable)
msgid "lexeme"
msgstr "лексема"

#: func.xml:9439(function) func.xml:9449(function)
msgid ""
"ts_delete(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"ts_delete(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#: func.xml:9442(entry)
msgid ""
"remove given <replaceable class=\"parameter\">lexeme</replaceable> from "
"<replaceable class=\"parameter\">vector</replaceable>"
msgstr ""
"удаляет заданную <replaceable class=\"parameter\">лексему</replaceable> из "
"<replaceable class=\"parameter\">вектора</replaceable>"

#: func.xml:9443(literal)
msgid "ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')"
msgstr "ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, 'fat')"

#: func.xml:9444(literal)
msgid "'cat':3 'rat':5A"
msgstr "'cat':3 'rat':5A"

#: func.xml:9452(entry)
msgid ""
"remove any occurrence of lexemes in <replaceable class=\"parameter"
"\">lexemes</replaceable> from <replaceable class=\"parameter\">vector</"
"replaceable>"
msgstr ""
"удаляет все вхождения лексем, перечисленных в массиве <replaceable class="
"\"parameter\">лексемы</replaceable>, из <replaceable class=\"parameter"
"\">вектора</replaceable>"

#: func.xml:9453(literal)
msgid "ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])"
msgstr "ts_delete('fat:2,4 cat:3 rat:5A'::tsvector, ARRAY['fat','rat'])"

#: func.xml:9454(literal)
msgid "'cat':3"
msgstr "'cat':3"

#: func.xml:9458(indexterm)
msgid "<primary>ts_filter</primary>"
msgstr "<primary>ts_filter</primary>"

#: func.xml:9461(replaceable) func.xml:9485(replaceable)
#: func.xml:9497(replaceable) func.xml:9590(replaceable)
#: func.xml:9698(replaceable)
msgid "weights"
msgstr "веса"

#: func.xml:9461(type)
msgid "\"char\"[]"
msgstr "\"char\"[]"

#: func.xml:9461(function)
msgid ""
"ts_filter(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"ts_filter(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#: func.xml:9464(entry)
msgid ""
"Select only elements with given <replaceable class=\"parameter\">weights</"
"replaceable> from <replaceable class=\"parameter\">vector</replaceable>"
msgstr ""
"выбирает из <replaceable class=\"parameter\">вектора</replaceable> только "
"элементы с заданным <replaceable class=\"parameter\">весом</replaceable>"

#: func.xml:9465(literal)
msgid "ts_filter('fat:2,4 cat:3b rat:5A'::tsvector, '{a,b}')"
msgstr "ts_filter('fat:2,4 cat:3b rat:5A'::tsvector, '{a,b}')"

#: func.xml:9466(literal)
msgid "'cat':3B 'rat':5A"
msgstr "'cat':3B 'rat':5A"

#: func.xml:9470(indexterm)
msgid "<primary>ts_headline</primary>"
msgstr "<primary>ts_headline</primary>"

#: func.xml:9473(optional) func.xml:9485(optional) func.xml:9497(optional)
#: func.xml:9636(optional) func.xml:9698(optional)
msgid "<placeholder-1/> <placeholder-2/>,"
msgstr "<placeholder-1/> <placeholder-2/>,"

#: func.xml:9473(replaceable)
msgctxt "replaceable"
msgid "options"
msgstr "параметры"

#: func.xml:9473(function)
msgid ""
"ts_headline(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_headline(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>)"

#: func.xml:9476(entry)
msgid "display a query match"
msgstr "выводит фрагмент, соответствующий запросу"

#: func.xml:9477(literal)
msgid "ts_headline('x y z', 'z'::tsquery)"
msgstr "ts_headline('x y z', 'z'::tsquery)"

#: func.xml:9478(literal)
msgid "x y &lt;b&gt;z&lt;/b&gt;"
msgstr "x y &lt;b&gt;z&lt;/b&gt;"

#: func.xml:9482(indexterm)
msgid "<primary>ts_rank</primary>"
msgstr "<primary>ts_rank</primary>"

#: func.xml:9485(type) func.xml:9497(type)
msgid "float4[]"
msgstr "float4[]"

#: func.xml:9485(replaceable) func.xml:9497(replaceable)
msgid "normalization"
msgstr "нормализация"

#: func.xml:9485(function)
msgid ""
"ts_rank(<placeholder-1/> <placeholder-2/> <placeholder-3/>, <placeholder-4/> "
"<placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_rank(<placeholder-1/> <placeholder-2/> <placeholder-3/>, <placeholder-4/> "
"<placeholder-5/> <placeholder-6/>)"

#: func.xml:9487(type) func.xml:9499(type)
msgid "float4"
msgstr "float4"

#: func.xml:9488(entry)
msgid "rank document for query"
msgstr "вычисляет ранг документа по отношению к запросу"

#: func.xml:9489(literal)
msgid "ts_rank(textsearch, query)"
msgstr "ts_rank(textsearch, query)"

#: func.xml:9490(literal)
msgid "0.818"
msgstr "0.818"

#: func.xml:9494(indexterm)
msgid "<primary>ts_rank_cd</primary>"
msgstr "<primary>ts_rank_cd</primary>"

#: func.xml:9497(function)
msgid ""
"ts_rank_cd(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_rank_cd(<placeholder-1/> <placeholder-2/> <placeholder-3/>, "
"<placeholder-4/> <placeholder-5/> <placeholder-6/>)"

#: func.xml:9500(entry)
msgid "rank document for query using cover density"
msgstr ""
"вычисляет ранг документа по отношению к запросу, используя плотность "
"покрытия (CDR)"

#: func.xml:9501(literal)
msgid "ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)"
msgstr "ts_rank_cd('{0.1, 0.2, 0.4, 1.0}', textsearch, query)"

#: func.xml:9502(literal)
msgid "2.01317"
msgstr "2.01317"

#: func.xml:9506(indexterm)
msgid "<primary>ts_rewrite</primary>"
msgstr "<primary>ts_rewrite</primary>"

#: func.xml:9509(replaceable) func.xml:9987(replaceable)
msgid "target"
msgstr "цель"

#: func.xml:9509(replaceable)
msgid "substitute"
msgstr "замена"

#: func.xml:9509(function)
msgid ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:9512(entry)
msgid ""
"replace <replaceable>target</replaceable> with <replaceable>substitute</"
"replaceable> within query"
msgstr ""
"подставляет в запросе вместо <replaceable>цели</replaceable> "
"<replaceable>замену</replaceable>"

#: func.xml:9514(literal)
msgid "ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)"
msgstr "ts_rewrite('a &amp; b'::tsquery, 'a'::tsquery, 'foo|bar'::tsquery)"

#: func.xml:9515(literal) func.xml:9522(literal)
msgid "'b' &amp; ( 'foo' | 'bar' )"
msgstr "'b' &amp; ( 'foo' | 'bar' )"

#: func.xml:9518(replaceable)
msgid "select"
msgstr "выборка"

#: func.xml:9518(function)
msgid ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"ts_rewrite(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:9520(entry)
msgid ""
"replace using targets and substitutes from a <command>SELECT</command> "
"command"
msgstr ""
"заменяет элементы запроса, выбирая цели и подстановки командой "
"<command>SELECT</command>"

#: func.xml:9521(literal)
msgid "SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')"
msgstr "SELECT ts_rewrite('a &amp; b'::tsquery, 'SELECT t,s FROM aliases')"

#: func.xml:9526(indexterm)
msgid "<primary>tsquery_phrase</primary>"
msgstr "<primary>tsquery_phrase</primary>"

#: func.xml:9529(replaceable) func.xml:9540(replaceable)
msgid "query1"
msgstr "запрос1"

#: func.xml:9529(replaceable) func.xml:9540(replaceable)
msgid "query2"
msgstr "запрос2"

#: func.xml:9529(function)
msgid ""
"tsquery_phrase(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"tsquery_phrase(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:9532(entry)
msgid ""
"make query that searches for <replaceable>query1</replaceable> followed by "
"<replaceable>query2</replaceable> (same as <literal>&lt;-&gt;</literal> "
"operator)"
msgstr ""
"создаёт запрос, который ищет <replaceable>запрос1</replaceable>, за которым "
"идёт <replaceable>запрос2</replaceable> (как делает оператор <literal>&lt;-"
"&gt;</literal>)"

#: func.xml:9535(literal)
msgid "tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))"
msgstr "tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'))"

#: func.xml:9536(literal)
msgid "'fat' &lt;-&gt; 'cat'"
msgstr "'fat' &lt;-&gt; 'cat'"

#: func.xml:9540(replaceable)
msgid "distance"
msgstr "расстояние"

#: func.xml:9540(function)
msgid ""
"tsquery_phrase(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"tsquery_phrase(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:9543(entry)
msgid ""
"make query that searches for <replaceable>query1</replaceable> followed by "
"<replaceable>query2</replaceable> at maximum distance <replaceable>distance</"
"replaceable>"
msgstr ""
"создаёт запрос, который ищет <replaceable>запрос1</replaceable>, за которым "
"идёт <replaceable>запрос2</replaceable> в пределах заданного "
"<replaceable>расстояния</replaceable>"

#: func.xml:9545(literal)
msgid "tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)"
msgstr "tsquery_phrase(to_tsquery('fat'), to_tsquery('cat'), 10)"

#: func.xml:9546(literal)
msgid "'fat' &lt;10&gt; 'cat'"
msgstr "'fat' &lt;10&gt; 'cat'"

#: func.xml:9550(indexterm)
msgid "<primary>tsvector_to_array</primary>"
msgstr "<primary>tsvector_to_array</primary>"

#: func.xml:9553(function)
msgid "tsvector_to_array(<placeholder-1/>)"
msgstr "tsvector_to_array(<placeholder-1/>)"

#: func.xml:9556(entry)
msgid "convert <type>tsvector</type> to array of lexemes"
msgstr "преобразует <type>tsvector</type> в массив лексем"

#: func.xml:9557(literal)
msgid "tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)"
msgstr "tsvector_to_array('fat:2,4 cat:3 rat:5A'::tsvector)"

#: func.xml:9558(literal)
msgid "{cat,fat,rat}"
msgstr "{cat,fat,rat}"

#: func.xml:9562(indexterm)
msgid "<primary>tsvector_update_trigger</primary>"
msgstr "<primary>tsvector_update_trigger</primary>"

#: func.xml:9565(function)
msgid "tsvector_update_trigger()"
msgstr "tsvector_update_trigger()"

#: func.xml:9567(type) func.xml:9579(type)
msgid "trigger"
msgstr "trigger"

#: func.xml:9568(entry) func.xml:9580(entry)
msgid "trigger function for automatic <type>tsvector</type> column update"
msgstr ""
"триггерная функция для автоматического изменения столбца типа "
"<type>tsvector</type>"

#: func.xml:9569(literal)
msgid ""
"CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.swedish', "
"title, body)"
msgstr ""
"CREATE TRIGGER ... tsvector_update_trigger(tsvcol, 'pg_catalog.&zwsp;"
"swedish', title, body)"

#: func.xml:9574(indexterm)
msgid "<primary>tsvector_update_trigger_column</primary>"
msgstr "<primary>tsvector_update_trigger_column</primary>"

#: func.xml:9577(function)
msgid "tsvector_update_trigger_column()"
msgstr "tsvector_update_trigger_column()"

#: func.xml:9581(literal)
msgid ""
"CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, "
"body)"
msgstr ""
"CREATE TRIGGER ... tsvector_update_trigger_column(tsvcol, configcol, title, "
"body)"

#: func.xml:9586(indexterm)
msgid "<primary>unnest</primary> <secondary>for tsvector</secondary>"
msgstr "<primary>unnest</primary> <secondary>для tsvector</secondary>"

#: func.xml:9590(replaceable)
msgid "positions"
msgstr "позиции"

#: func.xml:9590(type)
msgid "smallint[]"
msgstr "smallint[]"

#: func.xml:9590(function)
msgid ""
"unnest(<placeholder-1/>, OUT <placeholder-2/> <placeholder-3/>, OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>)"
msgstr ""
"unnest(<placeholder-1/>, OUT <placeholder-2/> <placeholder-3/>, OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>)"

#: func.xml:9592(type) func.xml:9638(type) func.xml:9662(type)
#: func.xml:9669(type) func.xml:9681(type) func.xml:9688(type)
#: func.xml:9700(type) func.xml:11285(type) func.xml:16419(type)
#: func.xml:16482(type) func.xml:17749(type)
msgid "setof record"
msgstr "setof record"

#: func.xml:9593(entry)
msgid "expand a tsvector to a set of rows"
msgstr "разворачивает tsvector в набор строк"

#: func.xml:9594(literal)
msgid "unnest('fat:2,4 cat:3 rat:5A'::tsvector)"
msgstr "unnest('fat:2,4 cat:3 rat:5A'::tsvector)"

#: func.xml:9595(literal)
msgid "(cat,{3},{D}) ..."
msgstr "(cat,{3},{D}) ..."

#: func.xml:9602(para)
msgid ""
"All the text search functions that accept an optional <type>regconfig</type> "
"argument will use the configuration specified by <xref linkend=\"guc-default-"
"text-search-config\"/> when that argument is omitted."
msgstr ""
"Все функции текстового поиска, принимающие необязательный аргумент "
"<type>regconfig</type>, будут использовать конфигурацию, указанную в "
"параметре <xref linkend=\"guc-default-text-search-config\"/>, когда этот "
"аргумент опущен."

#: func.xml:9610(para)
msgid ""
"The functions in <xref linkend=\"textsearch-functions-debug-table\"/> are "
"listed separately because they are not usually used in everyday text "
"searching operations. They are helpful for development and debugging of new "
"text search configurations."
msgstr ""
"Функции в <xref remap=\"6\" linkend=\"textsearch-functions-debug-table\"/> "
"перечислены отдельно, так как они не очень полезны в традиционных операциях "
"поиска. Они предназначены в основном для разработки и отладки новых "
"конфигураций текстового поиска."

#: func.xml:9619(title)
msgid "Text Search Debugging Functions"
msgstr "Функции отладки текстового поиска"

#: func.xml:9633(indexterm)
msgid "<primary>ts_debug</primary>"
msgstr "<primary>ts_debug</primary>"

#: func.xml:9636(replaceable) func.xml:9679(replaceable)
#: func.xml:9687(replaceable)
msgid "alias"
msgstr "псевдоним"

#: func.xml:9636(replaceable) func.xml:9679(replaceable)
#: func.xml:9687(replaceable)
msgid "description"
msgstr "описание"

#: func.xml:9636(replaceable) func.xml:9648(replaceable)
#: func.xml:9660(replaceable) func.xml:9668(replaceable)
msgid "token"
msgstr "фрагмент"

#: func.xml:9636(replaceable)
msgid "dictionaries"
msgstr "словари"

#: func.xml:9636(type)
msgid "regdictionary[]"
msgstr "regdictionary[]"

#: func.xml:9636(replaceable)
msgid "dictionary"
msgstr "словарь"

#: func.xml:9636(type) func.xml:9648(type)
msgid "regdictionary"
msgstr "regdictionary"

#: func.xml:9636(function)
msgid ""
"ts_debug(<placeholder-1/> <placeholder-2/> <placeholder-3/>, OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>, "
"OUT <placeholder-8/> <placeholder-9/>, OUT <placeholder-10/> <placeholder-11/"
">, OUT <placeholder-12/> <placeholder-13/>, OUT <placeholder-14/> "
"<placeholder-15/>)"
msgstr ""
"ts_debug(<placeholder-1/> <placeholder-2/> <placeholder-3/>, OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>, "
"OUT <placeholder-8/> <placeholder-9/>, OUT <placeholder-10/> <placeholder-11/"
">, OUT <placeholder-12/> <placeholder-13/>, OUT <placeholder-14/> "
"<placeholder-15/>)"

#: func.xml:9639(entry)
msgid "test a configuration"
msgstr "проверяет конфигурацию"

#: func.xml:9640(literal)
msgid "ts_debug('english', 'The Brightest supernovaes')"
msgstr "ts_debug('english', 'The Brightest supernovaes')"

#: func.xml:9641(literal)
msgid "(asciiword,\"Word, all ASCII\",The,{english_stem},english_stem,{}) ..."
msgstr ""
"(asciiword,\"Word, all ASCII\",The,{&zwsp;english_stem&zwsp;},&zwsp;"
"english_stem,{}) ..."

#: func.xml:9645(indexterm)
msgid "<primary>ts_lexize</primary>"
msgstr "<primary>ts_lexize</primary>"

#: func.xml:9648(replaceable)
msgid "dict"
msgstr "словарь"

#: func.xml:9648(function)
msgid ""
"ts_lexize(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"ts_lexize(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#: func.xml:9651(entry)
msgid "test a dictionary"
msgstr "проверяет словарь"

#: func.xml:9652(literal)
msgid "ts_lexize('english_stem', 'stars')"
msgstr "ts_lexize('english_stem', 'stars')"

#: func.xml:9653(literal)
msgid "{star}"
msgstr "{star}"

#: func.xml:9657(indexterm)
msgid "<primary>ts_parse</primary>"
msgstr "<primary>ts_parse</primary>"

#: func.xml:9660(replaceable) func.xml:9679(replaceable)
msgid "parser_name"
msgstr "имя_анализатора"

#: func.xml:9660(replaceable) func.xml:9668(replaceable)
#: func.xml:9679(replaceable) func.xml:9687(replaceable)
msgid "tokid"
msgstr "код_фрагмента"

#: func.xml:9660(function) func.xml:9668(function)
msgid ""
"ts_parse(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/> "
"<placeholder-8/>)"
msgstr ""
"ts_parse(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">, OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/> "
"<placeholder-8/>)"

#: func.xml:9663(entry) func.xml:9670(entry)
msgid "test a parser"
msgstr "проверяет анализатор"

#: func.xml:9664(literal)
msgid "ts_parse('default', 'foo - bar')"
msgstr "ts_parse('default', 'foo - bar')"

#: func.xml:9665(literal) func.xml:9672(literal)
msgid "(1,foo) ..."
msgstr "(1,foo) ..."

#: func.xml:9668(replaceable) func.xml:9687(replaceable)
msgctxt "replaceable"
msgid "parser_oid"
msgstr "oid_анализатора"

#: func.xml:9668(type) func.xml:9687(type) func.xml:15374(type)
#: func.xml:15379(type) func.xml:16737(type) func.xml:16742(type)
#: func.xml:17193(type) func.xml:17213(type) func.xml:17228(type)
#: func.xml:18331(type) func.xml:18363(type) func.xml:18610(type)
#: func.xml:18692(type) func.xml:18857(type) func.xml:18873(type)
msgid "oid"
msgstr "oid"

#: func.xml:9671(literal)
msgid "ts_parse(3722, 'foo - bar')"
msgstr "ts_parse(3722, 'foo - bar')"

#: func.xml:9676(indexterm)
msgid "<primary>ts_token_type</primary>"
msgstr "<primary>ts_token_type</primary>"

#: func.xml:9679(function) func.xml:9687(function)
msgid ""
"ts_token_type(<placeholder-1/> <placeholder-2/>, OUT <placeholder-3/> "
"<placeholder-4/>, OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/"
"> <placeholder-8/>)"
msgstr ""
"ts_token_type(<placeholder-1/> <placeholder-2/>, OUT <placeholder-3/> "
"<placeholder-4/>, OUT <placeholder-5/> <placeholder-6/>, OUT <placeholder-7/"
"> <placeholder-8/>)"

#: func.xml:9682(entry) func.xml:9689(entry)
msgid "get token types defined by parser"
msgstr "получает типы фрагментов, определённые анализатором"

#: func.xml:9683(literal)
msgid "ts_token_type('default')"
msgstr "ts_token_type('default')"

#: func.xml:9684(literal) func.xml:9691(literal)
msgid "(1,asciiword,\"Word, all ASCII\") ..."
msgstr "(1,asciiword,\"Word, all ASCII\") ..."

#: func.xml:9690(literal)
msgid "ts_token_type(3722)"
msgstr "ts_token_type(3722)"

#: func.xml:9695(indexterm)
msgid "<primary>ts_stat</primary>"
msgstr "<primary>ts_stat</primary>"

#: func.xml:9698(replaceable)
msgid "sqlquery"
msgstr "sql_запрос"

#: func.xml:9698(replaceable)
msgid "word"
msgstr "слово"

#: func.xml:9698(replaceable)
msgid "ndoc"
msgstr "число_док"

#: func.xml:9698(replaceable)
msgid "nentry"
msgstr "число_вхожд"

#: func.xml:9698(function)
msgid ""
"ts_stat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>, "
"OUT <placeholder-8/> <placeholder-9/>)"
msgstr ""
"ts_stat(<placeholder-1/> <placeholder-2/>, <placeholder-3/> OUT "
"<placeholder-4/> <placeholder-5/>, OUT <placeholder-6/> <placeholder-7/>, "
"OUT <placeholder-8/> <placeholder-9/>)"

#: func.xml:9701(entry)
msgid "get statistics of a <type>tsvector</type> column"
msgstr "получает статистику столбца <type>tsvector</type>"

#: func.xml:9702(literal)
msgid "ts_stat('SELECT vector from apod')"
msgstr "ts_stat('SELECT vector from apod')"

#: func.xml:9703(literal)
msgid "(foo,10,15) ..."
msgstr "(foo,10,15) ..."

#: func.xml:9713(title)
msgid "XML Functions"
msgstr "XML-функции"

#: func.xml:9715(para)
msgid ""
"The functions and function-like expressions described in this section "
"operate on values of type <type>xml</type>. Check <xref linkend=\"datatype-"
"xml\"/> for information about the <type>xml</type> type. The function-like "
"expressions <function>xmlparse</function> and <function>xmlserialize</"
"function> for converting to and from type <type>xml</type> are not repeated "
"here. Use of most of these functions requires the installation to have been "
"built with <command>configure --with-libxml</command>."
msgstr ""
"Функции и подобные им выражения, описанные в этом разделе, работают со "
"значениями типа <type>xml</type>. Информацию о типе <type>xml</type> вы "
"можете найти в <xref remap=\"6\" linkend=\"datatype-xml\"/>. Выражения "
"<function>xmlparse</function> и <function>xmlserialize</function>, "
"преобразующие значения <type>xml</type> в текст и обратно, здесь повторно не "
"рассматриваются. Для использования большинства этих функций дистрибутив "
"должен быть собран с ключом <command>configure --with-libxml</command>."

#: func.xml:9727(title)
msgid "Producing XML Content"
msgstr "Создание XML-контента"

#: func.xml:9729(para)
msgid ""
"A set of functions and function-like expressions are available for producing "
"XML content from SQL data. As such, they are particularly suitable for "
"formatting query results into XML documents for processing in client "
"applications."
msgstr ""
"Для получения XML-контента из данных SQL существует целый набор функций и "
"функциональных выражений, особенно полезных для выдачи клиентским "
"приложениям результатов запроса в виде XML-документов."

#: func.xml:9737(literal)
msgctxt "literal"
msgid "xmlcomment"
msgstr "xmlcomment"

#: func.xml:9739(indexterm)
msgid "<primary>xmlcomment</primary>"
msgstr "<primary>xmlcomment</primary>"

#: func.xml:9744(function)
msgctxt "function"
msgid "xmlcomment"
msgstr "xmlcomment"

#: func.xml:9744(replaceable) func.xml:10016(replaceable)
#: func.xml:10138(replaceable) func.xml:10188(replaceable)
#: func.xml:10189(replaceable) func.xml:10190(replaceable)
msgctxt "replaceable"
msgid "text"
msgstr "текст"

#: func.xml:9743(synopsis) func.xml:10047(synopsis)
#, no-wrap
msgctxt "synopsis"
msgid "<placeholder-1/>(<placeholder-2/>)"
msgstr "<placeholder-1/>(<placeholder-2/>)"

#: func.xml:9747(para)
msgid ""
"The function <function>xmlcomment</function> creates an XML value containing "
"an XML comment with the specified text as content. The text cannot contain "
"<quote><literal>--</literal></quote> or end with a <quote><literal>-</"
"literal></quote> so that the resulting construct is a valid XML comment. If "
"the argument is null, the result is null."
msgstr ""
"Функция <function>xmlcomment</function> создаёт XML-значение, содержащее XML-"
"комментарий с заданным текстом. Этот текст не должен содержать "
"<quote><literal>--</literal></quote> или заканчиваться знаком "
"<quote><literal>-</literal></quote>, чтобы результирующая конструкция была "
"допустимой в XML. Если аргумент этой функции NULL, результатом её тоже будет "
"NULL."

#: func.xml:9755(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlcomment('hello');\n"
"\n"
"  xmlcomment\n"
"--------------\n"
" <!--hello-->\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xmlcomment('hello');\n"
"\n"
"  xmlcomment\n"
"--------------\n"
" <!--hello-->\n"
"]]></screen>"

#: func.xml:9768(literal)
msgctxt "literal"
msgid "xmlconcat"
msgstr "xmlconcat"

#: func.xml:9770(indexterm)
msgid "<primary>xmlconcat</primary>"
msgstr "<primary>xmlconcat</primary>"

#: func.xml:9775(function)
msgctxt "function"
msgid "xmlconcat"
msgstr "xmlconcat"

#: func.xml:9775(replaceable) func.xml:10016(replaceable)
#: func.xml:10048(replaceable) func.xml:10118(replaceable)
#: func.xml:10138(replaceable) func.xml:10266(replaceable)
#: func.xml:10327(replaceable)
msgctxt "replaceable"
msgid "xml"
msgstr "xml"

#: func.xml:9775(optional) func.xml:9832(optional) func.xml:9930(optional)
#: func.xml:11885(optional) func.xml:11950(optional) func.xml:11953(optional)
#: func.xml:14714(optional) func.xml:14745(optional)
msgid ", ..."
msgstr ", ..."

#: func.xml:9774(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/><placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/><placeholder-3/>)"

#: func.xml:9778(para)
msgid ""
"The function <function>xmlconcat</function> concatenates a list of "
"individual XML values to create a single value containing an XML content "
"fragment. Null values are omitted; the result is only null if there are no "
"nonnull arguments."
msgstr ""
"Функция <function>xmlconcat</function> объединяет несколько XML-значений и "
"выдаёт в результате один фрагмент XML-контента. Значения NULL отбрасываются, "
"так что результат будет равен NULL, только если все аргументы равны NULL."

#: func.xml:9785(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlconcat('<abc/>', '<bar>foo</bar>');\n"
"\n"
"      xmlconcat\n"
"----------------------\n"
" <abc/><bar>foo</bar>\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xmlconcat('<abc/>', '<bar>foo</bar>');\n"
"\n"
"      xmlconcat\n"
"----------------------\n"
" <abc/><bar>foo</bar>\n"
"]]></screen>"

#: func.xml:9796(para)
msgid ""
"XML declarations, if present, are combined as follows. If all argument "
"values have the same XML version declaration, that version is used in the "
"result, else no version is used. If all argument values have the standalone "
"declaration value <quote>yes</quote>, then that value is used in the result. "
"If all argument values have a standalone declaration value and at least one "
"is <quote>no</quote>, then that is used in the result. Else the result will "
"have no standalone declaration. If the result is determined to require a "
"standalone declaration but no version declaration, a version declaration "
"with version 1.0 will be used because XML requires an XML declaration to "
"contain a version declaration. Encoding declarations are ignored and removed "
"in all cases."
msgstr ""
"XML-объявления, если они присутствуют, обрабатываются следующим образом. "
"Если во всех аргументах содержатся объявления одной версии XML, эта версия "
"будет выдана в результате; в противном случае версии не будет. Если во всех "
"аргументах определён атрибут standalone со значением <quote>yes</quote>, это "
"же значение будет выдано в результате. Если во всех аргументах есть "
"объявление standalone, но минимум в одном со значением <quote>no</quote>, в "
"результате будет это значение. В противном случае в результате не будет "
"объявления standalone. Если же окажется, что в результате должно "
"присутствовать объявление standalone, а версия не определена, тогда в "
"результате будет выведена версия 1.0, так как XML-объявление не будет "
"допустимым без указания версии. Указания кодировки игнорируются и будут "
"удалены в любых случаях."

#: func.xml:9812(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlconcat('<?xml version=\"1.1\"?><foo/>', '<?xml version=\"1.1\" "
"standalone=\"no\"?><bar/>');\n"
"\n"
"             xmlconcat\n"
"-----------------------------------\n"
" <?xml version=\"1.1\"?><foo/><bar/>\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xmlconcat('<?xml version=\"1.1\"?><foo/>', '<?xml version=\"1.1\" "
"standalone=\"no\"?><bar/>');\n"
"\n"
"             xmlconcat\n"
"-----------------------------------\n"
" <?xml version=\"1.1\"?><foo/><bar/>\n"
"]]></screen>"

#: func.xml:9825(literal)
msgctxt "literal"
msgid "xmlelement"
msgstr "xmlelement"

#: func.xml:9827(indexterm)
msgid "<primary>xmlelement</primary>"
msgstr "<primary>xmlelement</primary>"

#: func.xml:9832(function)
msgctxt "function"
msgid "xmlelement"
msgstr "xmlelement"

#: func.xml:9832(replaceable) func.xml:9930(replaceable)
#: func.xml:13016(replaceable) func.xml:13033(replaceable)
msgctxt "replaceable"
msgid "name"
msgstr "имя"

#: func.xml:9832(replaceable) func.xml:11885(replaceable)
#: func.xml:11950(replaceable) func.xml:11953(replaceable)
#: func.xml:13016(replaceable) func.xml:13033(replaceable)
#: func.xml:14140(replaceable) func.xml:14146(replaceable)
#: func.xml:14169(replaceable) func.xml:14175(replaceable)
#: func.xml:14197(replaceable) func.xml:14200(replaceable)
#: func.xml:14213(replaceable) func.xml:14216(replaceable)
#: func.xml:14230(replaceable) func.xml:14234(replaceable)
#: func.xml:14714(replaceable) func.xml:14745(replaceable)
msgctxt "replaceable"
msgid "value"
msgstr "значение"

#: func.xml:9832(replaceable)
msgid "attname"
msgstr "атрибут"

#: func.xml:9832(optional) func.xml:9930(optional)
msgid "AS <placeholder-1/>"
msgstr "AS <placeholder-1/>"

#: func.xml:9832(optional)
msgid ", xmlattributes(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr ", xmlattributes(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:9832(replaceable)
msgid ", content, ..."
msgstr ", содержимое, ..."

#: func.xml:9831(synopsis)
#, no-wrap
msgid "<placeholder-1/>(name <placeholder-2/> <placeholder-3/> <optional><placeholder-4/></optional>)"
msgstr ""
"<placeholder-1/>(name <placeholder-2/> <placeholder-3/>\n"
"  <optional><placeholder-4/></optional>)"

#: func.xml:9835(para)
msgid ""
"The <function>xmlelement</function> expression produces an XML element with "
"the given name, attributes, and content."
msgstr ""
"Выражение <function>xmlelement</function> создаёт XML-элемент с заданным "
"именем, атрибутами и содержимым."

#: func.xml:9840(para)
msgid ""
"Examples: <screen><![CDATA[\n"
"SELECT xmlelement(name foo);\n"
"\n"
" xmlelement\n"
"------------\n"
" <foo/>\n"
"\n"
"SELECT xmlelement(name foo, xmlattributes('xyz' as bar));\n"
"\n"
"    xmlelement\n"
"------------------\n"
" <foo bar=\"xyz\"/>\n"
"\n"
"SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', "
"'ent');\n"
"\n"
"             xmlelement\n"
"-------------------------------------\n"
" <foo bar=\"2007-01-26\">content</foo>\n"
"]]></screen>"
msgstr ""
"Примеры: <screen><![CDATA[\n"
"SELECT xmlelement(name foo);\n"
"\n"
" xmlelement\n"
"------------\n"
" <foo/>\n"
"\n"
"SELECT xmlelement(name foo, xmlattributes('xyz' as bar));\n"
"\n"
"    xmlelement\n"
"------------------\n"
" <foo bar=\"xyz\"/>\n"
"\n"
"SELECT xmlelement(name foo, xmlattributes(current_date as bar), 'cont', "
"'ent');\n"
"\n"
"             xmlelement\n"
"-------------------------------------\n"
" <foo bar=\"2007-01-26\">content</foo>\n"
"]]></screen>"

#: func.xml:9863(para)
msgid ""
"Element and attribute names that are not valid XML names are escaped by "
"replacing the offending characters by the sequence "
"<literal>_x<replaceable>HHHH</replaceable>_</literal>, where "
"<replaceable>HHHH</replaceable> is the character's Unicode codepoint in "
"hexadecimal notation. For example: <screen><![CDATA[\n"
"SELECT xmlelement(name \"foo$bar\", xmlattributes('xyz' as \"a&b\"));\n"
"\n"
"            xmlelement\n"
"----------------------------------\n"
" <foo_x0024_bar a_x0026_b=\"xyz\"/>\n"
"]]></screen>"
msgstr ""
"Если имена элементов и атрибутов содержат символы, недопустимые в XML, эти "
"символы заменяются последовательностями <literal>_x<replaceable>HHHH</"
"replaceable>_</literal>, где <replaceable>HHHH</replaceable> — "
"шестнадцатеричный код символа в Unicode. Например: <screen><![CDATA[\n"
"SELECT xmlelement(name \"foo$bar\", xmlattributes('xyz' as \"a&b\"));\n"
"\n"
"            xmlelement\n"
"----------------------------------\n"
" <foo_x0024_bar a_x0026_b=\"xyz\"/>\n"
"]]></screen>"

#: func.xml:9878(para)
msgid ""
"An explicit attribute name need not be specified if the attribute value is a "
"column reference, in which case the column's name will be used as the "
"attribute name by default. In other cases, the attribute must be given an "
"explicit name. So this example is valid: <screen>\n"
"CREATE TABLE test (a xml, b xml);\n"
"SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;\n"
"</screen> But these are not: <screen>\n"
"SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;\n"
"SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;\n"
"</screen>"
msgstr ""
"Если в качестве значения атрибута используется столбец таблицы, имя атрибута "
"можно не указывать явно, этим именем станет имя столбца. Во всех остальных "
"случаях имя атрибута должно быть определено явно. Таким образом, это "
"выражение допустимо: <screen>\n"
"CREATE TABLE test (a xml, b xml);\n"
"SELECT xmlelement(name test, xmlattributes(a, b)) FROM test;\n"
"</screen> А следующие варианты &mdash; нет: <screen>\n"
"SELECT xmlelement(name test, xmlattributes('constant'), a, b) FROM test;\n"
"SELECT xmlelement(name test, xmlattributes(func(a, b))) FROM test;\n"
"</screen>"

#: func.xml:9895(para)
msgid ""
"Element content, if specified, will be formatted according to its data type. "
"If the content is itself of type <type>xml</type>, complex XML documents can "
"be constructed. For example: <screen><![CDATA[\n"
"SELECT xmlelement(name foo, xmlattributes('xyz' as bar),\n"
"                            xmlelement(name abc),\n"
"                            xmlcomment('test'),\n"
"                            xmlelement(name xyz));\n"
"\n"
"                  xmlelement\n"
"----------------------------------------------\n"
" <foo bar=\"xyz\"><abc/><!--test--><xyz/></foo>\n"
"]]></screen> Content of other types will be formatted into valid XML "
"character data. This means in particular that the characters &lt;, &gt;, and "
"&amp; will be converted to entities. Binary data (data type <type>bytea</"
"type>) will be represented in base64 or hex encoding, depending on the "
"setting of the configuration parameter <xref linkend=\"guc-xmlbinary\"/>. "
"The particular behavior for individual data types is expected to evolve in "
"order to align the SQL and PostgreSQL data types with the XML Schema "
"specification, at which point a more precise description will appear."
msgstr ""
"Содержимое элемента, если оно задано, будет форматировано согласно его типу "
"данных. Когда оно само имеет тип <type>xml</type>, из него можно "
"конструировать сложные XML-документы. Например: <screen><![CDATA[\n"
"SELECT xmlelement(name foo, xmlattributes('xyz' as bar),\n"
"                            xmlelement(name abc),\n"
"                            xmlcomment('test'),\n"
"                            xmlelement(name xyz));\n"
"\n"
"                  xmlelement\n"
"----------------------------------------------\n"
" <foo bar=\"xyz\"><abc/><!--test--><xyz/></foo>\n"
"]]></screen> Содержимое других типов будет оформлено в виде блока символьных "
"данных XML. Это, в частности, означает, что символы &lt;, &gt; и &amp; будут "
"преобразованы в сущности XML. Двоичные данные (данные типа <type>bytea</"
"type>) представляются в кодировке base64 или в шестнадцатеричном виде, в "
"зависимости от значения параметра <xref linkend=\"guc-xmlbinary\"/>. Следует "
"ожидать, что конкретные представления отдельных типов данных могут быть "
"изменены для приведения типов SQL и PostgreSQL в соответствие со стандартом "
"XML Schema, когда появится его более полное описание."

#: func.xml:9923(literal)
msgctxt "literal"
msgid "xmlforest"
msgstr "xmlforest"

#: func.xml:9925(indexterm)
msgid "<primary>xmlforest</primary>"
msgstr "<primary>xmlforest</primary>"

#: func.xml:9930(function)
msgctxt "function"
msgid "xmlforest"
msgstr "xmlforest"

#: func.xml:9930(replaceable) func.xml:9987(replaceable)
msgctxt "replaceable"
msgid "content"
msgstr "содержимое"

#: func.xml:9929(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/> <placeholder-3/> <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/> <placeholder-3/> <placeholder-4/>)"

#: func.xml:9933(para)
msgid ""
"The <function>xmlforest</function> expression produces an XML forest "
"(sequence) of elements using the given names and content."
msgstr ""
"Выражение <function>xmlforest</function> создаёт последовательность XML-"
"элементов с заданными именами и содержимым."

#: func.xml:9938(para)
msgid ""
"Examples: <screen><![CDATA[\n"
"SELECT xmlforest('abc' AS foo, 123 AS bar);\n"
"\n"
"          xmlforest\n"
"------------------------------\n"
" <foo>abc</foo><bar>123</bar>\n"
"\n"
"\n"
"SELECT xmlforest(table_name, column_name)\n"
"FROM information_schema.columns\n"
"WHERE table_schema = 'pg_catalog';\n"
"\n"
"                                         xmlforest\n"
"-------------------------------------------------------------------------------------------\n"
" <table_name>pg_authid</table_name><column_name>rolname</column_name>\n"
" <table_name>pg_authid</table_name><column_name>rolsuper</column_name>\n"
" ...\n"
"]]></screen> As seen in the second example, the element name can be omitted "
"if the content value is a column reference, in which case the column name is "
"used by default. Otherwise, a name must be specified."
msgstr ""
"Примеры: <screen><![CDATA[\n"
"SELECT xmlforest('abc' AS foo, 123 AS bar);\n"
"\n"
"          xmlforest\n"
"------------------------------\n"
" <foo>abc</foo><bar>123</bar>\n"
"\n"
"\n"
"SELECT xmlforest(table_name, column_name)\n"
"FROM information_schema.columns\n"
"WHERE table_schema = 'pg_catalog';\n"
"\n"
"                                         xmlforest\n"
"-------------------------------------------------------------------------------------------\n"
" <table_name>pg_authid</table_name><column_name>rolname</column_name>\n"
" <table_name>pg_authid</table_name><column_name>rolsuper</column_name>\n"
" ...\n"
"]]></screen> Как показано во втором примере, имя элемента можно опустить, "
"если источником содержимого служит столбец (в этом случае именем элемента по "
"умолчанию будет имя столбца). В противном случае это имя необходимо "
"указывать."

#: func.xml:9964(para)
msgid ""
"Element names that are not valid XML names are escaped as shown for "
"<function>xmlelement</function> above. Similarly, content data is escaped to "
"make valid XML content, unless it is already of type <type>xml</type>."
msgstr ""
"Имена элементов с символами, недопустимыми для XML, преобразуются так же, "
"как и для <function>xmlelement</function>. Данные содержимого тоже "
"приводятся к виду, допустимому для XML (кроме данных, которые уже имеют тип "
"<type>xml</type>)."

#: func.xml:9971(para)
msgid ""
"Note that XML forests are not valid XML documents if they consist of more "
"than one element, so it might be useful to wrap <function>xmlforest</"
"function> expressions in <function>xmlelement</function>."
msgstr ""
"Заметьте, что такие XML-последовательности не являются допустимыми XML-"
"документами, если они содержат больше одного элемента на верхнем уровне, "
"поэтому может иметь смысл вложить выражения <function>xmlforest</function> в "
"<function>xmlelement</function>."

#: func.xml:9980(literal)
msgctxt "literal"
msgid "xmlpi"
msgstr "xmlpi"

#: func.xml:9982(indexterm)
msgid "<primary>xmlpi</primary>"
msgstr "<primary>xmlpi</primary>"

#: func.xml:9987(function)
msgctxt "function"
msgid "xmlpi"
msgstr "xmlpi"

#: func.xml:9986(synopsis)
#, no-wrap
msgid "<placeholder-1/>(name <placeholder-2/> <placeholder-3/>)"
msgstr "<placeholder-1/>(name <placeholder-2/> <placeholder-3/>)"

#: func.xml:9990(para)
msgid ""
"The <function>xmlpi</function> expression creates an XML processing "
"instruction. The content, if present, must not contain the character "
"sequence <literal>?&gt;</literal>."
msgstr ""
"Выражение <function>xmlpi</function> создаёт инструкцию обработки XML. "
"Содержимое, если оно задано, не должно содержать последовательность символов "
"<literal>?&gt;</literal>."

#: func.xml:9996(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlpi(name php, 'echo \"hello world\";');\n"
"\n"
"            xmlpi\n"
"-----------------------------\n"
" <?php echo \"hello world\";?>\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xmlpi(name php, 'echo \"hello world\";');\n"
"\n"
"            xmlpi\n"
"-----------------------------\n"
" <?php echo \"hello world\";?>\n"
"]]></screen>"

#: func.xml:10009(literal)
msgctxt "literal"
msgid "xmlroot"
msgstr "xmlroot"

#: func.xml:10011(indexterm)
msgid "<primary>xmlroot</primary>"
msgstr "<primary>xmlroot</primary>"

#: func.xml:10016(function)
msgctxt "function"
msgid "xmlroot"
msgstr "xmlroot"

#: func.xml:10016(optional)
msgid ", standalone yes|no|no value"
msgstr ", standalone yes|no|нет значения"

#: func.xml:10015(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/>, version <placeholder-3/> | no value <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, version <placeholder-3/> | нет значения <placeholder-4/>)"

#: func.xml:10019(para)
msgid ""
"The <function>xmlroot</function> expression alters the properties of the "
"root node of an XML value. If a version is specified, it replaces the value "
"in the root node's version declaration; if a standalone setting is "
"specified, it replaces the value in the root node's standalone declaration."
msgstr ""
"Выражение <function>xmlroot</function> изменяет свойства корневого узла XML-"
"значения. Если в нём указывается версия, она заменяет значение в объявлении "
"версии корневого узла; также в корневой узел переносится значение свойства "
"standalone."

#: func.xml:10041(literal)
msgctxt "literal"
msgid "xmlagg"
msgstr "xmlagg"

#: func.xml:10043(indexterm) func.xml:13126(indexterm)
msgid "<primary>xmlagg</primary>"
msgstr "<primary>xmlagg</primary>"

#: func.xml:10048(function)
msgctxt "function"
msgid "xmlagg"
msgstr "xmlagg"

#: func.xml:10051(para)
msgid ""
"The function <function>xmlagg</function> is, unlike the other functions "
"described here, an aggregate function. It concatenates the input values to "
"the aggregate function call, much like <function>xmlconcat</function> does, "
"except that concatenation occurs across rows rather than across expressions "
"in a single row. See <xref linkend=\"functions-aggregate\"/> for additional "
"information about aggregate functions."
msgstr ""
"Функция <function>xmlagg</function>, в отличие от других описанных здесь "
"функций, является агрегатной. Она соединяет значения, поступающие на вход "
"агрегатной функции, подобно функции <function>xmlconcat</function>, но "
"делает это, обрабатывая множество строк, а не несколько выражений в одной "
"строке. Дополнительно агрегатные функции описаны в <xref remap=\"6\" linkend="
"\"functions-aggregate\"/>."

#: func.xml:10061(para)
msgid ""
"Example: <screen><![CDATA[\n"
"CREATE TABLE test (y int, x xml);\n"
"INSERT INTO test VALUES (1, '<foo>abc</foo>');\n"
"INSERT INTO test VALUES (2, '<bar/>');\n"
"SELECT xmlagg(x) FROM test;\n"
"        xmlagg\n"
"----------------------\n"
" <foo>abc</foo><bar/>\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"CREATE TABLE test (y int, x xml);\n"
"INSERT INTO test VALUES (1, '<foo>abc</foo>');\n"
"INSERT INTO test VALUES (2, '<bar/>');\n"
"SELECT xmlagg(x) FROM test;\n"
"        xmlagg\n"
"----------------------\n"
" <foo>abc</foo><bar/>\n"
"]]></screen>"

#: func.xml:10074(para)
msgid ""
"To determine the order of the concatenation, an <literal>ORDER BY</literal> "
"clause may be added to the aggregate call as described in <xref linkend="
"\"syntax-aggregates\"/>. For example: <screen><![CDATA[\n"
"SELECT xmlagg(x ORDER BY y DESC) FROM test;\n"
"        xmlagg\n"
"----------------------\n"
" <bar/><foo>abc</foo>\n"
"]]></screen>"
msgstr ""
"Чтобы задать порядок сложения элементов, в агрегатный вызов можно добавить "
"предложение <literal>ORDER BY</literal>, описанное в <xref linkend=\"syntax-"
"aggregates\"/>. Например: <screen><![CDATA[\n"
"SELECT xmlagg(x ORDER BY y DESC) FROM test;\n"
"        xmlagg\n"
"----------------------\n"
" <bar/><foo>abc</foo>\n"
"]]></screen>"

#: func.xml:10087(para)
msgid ""
"The following non-standard approach used to be recommended in previous "
"versions, and may still be useful in specific cases: <screen><![CDATA[\n"
"SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;\n"
"        xmlagg\n"
"----------------------\n"
" <bar/><foo>abc</foo>\n"
"]]></screen>"
msgstr ""
"Следующий нестандартный подход рекомендовался в предыдущих версиях и может "
"быть по-прежнему полезен в некоторых случаях: <screen><![CDATA[\n"
"SELECT xmlagg(x) FROM (SELECT * FROM test ORDER BY y DESC) AS tab;\n"
"        xmlagg\n"
"----------------------\n"
" <bar/><foo>abc</foo>\n"
"]]></screen>"

#: func.xml:10103(title)
msgid "XML Predicates"
msgstr "Условия с XML"

#: func.xml:10105(para)
msgid ""
"The expressions described in this section check properties of <type>xml</"
"type> values."
msgstr ""
"Описанные в этом разделе выражения проверяют свойства значений <type>xml</"
"type>."

#: func.xml:10111(literal)
msgid "IS DOCUMENT"
msgstr "IS DOCUMENT"

#: func.xml:10113(indexterm)
msgid "<primary>IS DOCUMENT</primary>"
msgstr "<primary>IS DOCUMENT</primary>"

#: func.xml:10117(synopsis)
#, no-wrap
msgid "<placeholder-1/> IS DOCUMENT"
msgstr "<placeholder-1/> IS DOCUMENT"

#: func.xml:10121(para)
msgid ""
"The expression <literal>IS DOCUMENT</literal> returns true if the argument "
"XML value is a proper XML document, false if it is not (that is, it is a "
"content fragment), or null if the argument is null. See <xref linkend="
"\"datatype-xml\"/> about the difference between documents and content "
"fragments."
msgstr ""
"Выражение <literal>IS DOCUMENT</literal> возвращает true, если аргумент "
"представляет собой правильный XML-документ, false в противном случае (т. е. "
"если это фрагмент содержимого) и NULL, если его аргумент также NULL. Чем "
"документы отличаются от фрагментов содержимого, вы можете узнать в <xref "
"remap=\"6\" linkend=\"datatype-xml\"/>."

#: func.xml:10131(literal)
msgctxt "literal"
msgid "XMLEXISTS"
msgstr "XMLEXISTS"

#: func.xml:10133(indexterm)
msgid "<primary>XMLEXISTS</primary>"
msgstr "<primary>XMLEXISTS</primary>"

#: func.xml:10138(function)
msgctxt "function"
msgid "XMLEXISTS"
msgstr "XMLEXISTS"

#: func.xml:10138(optional)
msgid "BY REF"
msgstr "BY REF"

#: func.xml:10137(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/> PASSING <placeholder-3/> <placeholder-4/> <placeholder-5/>)"
msgstr ""
"<placeholder-1/>(<placeholder-2/>\n"
" PASSING <placeholder-3/> <placeholder-4/> <placeholder-5/>)"

#: func.xml:10141(para)
msgid ""
"The function <function>xmlexists</function> returns true if the XPath "
"expression in the first argument returns any nodes, and false otherwise. (If "
"either argument is null, the result is null.)"
msgstr ""
"Функция <function>xmlexists</function> возвращает true, если выражение XPath "
"в первом аргументе возвращает какие либо узлы, и false &mdash; в противном "
"случае. (Если один из аргументов равен NULL, результатом также будет NULL.)"

#: func.xml:10148(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF "
"'<towns><town>Toronto</town><town>Ottawa</town></towns>');\n"
"\n"
" xmlexists\n"
"------------\n"
" t\n"
"(1 row)\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xmlexists('//town[text() = ''Toronto'']' PASSING BY REF "
"'<towns><town>Toronto</town><town>Ottawa</town></towns>');\n"
"\n"
" xmlexists\n"
"------------\n"
" t\n"
"(1 row)\n"
"]]></screen>"

#: func.xml:10160(para)
msgid ""
"The <literal>BY REF</literal> clauses have no effect in PostgreSQL, but are "
"allowed for SQL conformance and compatibility with other implementations. "
"Per SQL standard, the first <literal>BY REF</literal> is required, the "
"second is optional. Also note that the SQL standard specifies the "
"<function>xmlexists</function> construct to take an XQuery expression as "
"first argument, but PostgreSQL currently only supports XPath, which is a "
"subset of XQuery."
msgstr ""
"Указания <literal>BY REF</literal> не несут смысловой нагрузки в PostgreSQL, "
"но могут присутствовать для соответствия стандарту SQL и совместимости с "
"другими реализациями. По стандарту SQL первое указание <literal>BY REF</"
"literal> является обязательным, а второе &mdash; нет. Также заметьте, что, "
"согласно стандарту SQL, конструкция <function>xmlexists</function> должна "
"принимать в первом аргументе выражение XQuery, но PostgreSQL в настоящее "
"время поддерживает только XPath, подмножество XQuery."

#: func.xml:10173(literal)
msgctxt "literal"
msgid "xml_is_well_formed"
msgstr "xml_is_well_formed"

#: func.xml:10175(indexterm)
msgid "<primary>xml_is_well_formed</primary>"
msgstr "<primary>xml_is_well_formed</primary>"

#: func.xml:10179(indexterm)
msgid "<primary>xml_is_well_formed_document</primary>"
msgstr "<primary>xml_is_well_formed_document</primary>"

#: func.xml:10183(indexterm)
msgid "<primary>xml_is_well_formed_content</primary>"
msgstr "<primary>xml_is_well_formed_content</primary>"

#: func.xml:10188(function)
msgctxt "function"
msgid "xml_is_well_formed"
msgstr "xml_is_well_formed"

#: func.xml:10189(function)
msgid "xml_is_well_formed_document"
msgstr "xml_is_well_formed_document"

#: func.xml:10190(function)
msgid "xml_is_well_formed_content"
msgstr "xml_is_well_formed_content"

#: func.xml:10187(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/>(<placeholder-2/>)\n"
"<placeholder-3/>(<placeholder-4/>)\n"
"<placeholder-5/>(<placeholder-6/>)"
msgstr ""
"<placeholder-1/>(<placeholder-2/>)\n"
"<placeholder-3/>(<placeholder-4/>)\n"
"<placeholder-5/>(<placeholder-6/>)"

#: func.xml:10193(para)
msgid ""
"These functions check whether a <type>text</type> string is well-formed XML, "
"returning a Boolean result. <function>xml_is_well_formed_document</function> "
"checks for a well-formed document, while "
"<function>xml_is_well_formed_content</function> checks for well-formed "
"content. <function>xml_is_well_formed</function> does the former if the "
"<xref linkend=\"guc-xmloption\"/> configuration parameter is set to "
"<literal>DOCUMENT</literal>, or the latter if it is set to <literal>CONTENT</"
"literal>. This means that <function>xml_is_well_formed</function> is useful "
"for seeing whether a simple cast to type <type>xml</type> will succeed, "
"whereas the other two functions are useful for seeing whether the "
"corresponding variants of <function>XMLPARSE</function> will succeed."
msgstr ""
"Эти функции проверяют, является ли <type>текст</type> правильно оформленным "
"XML, и возвращают соответствующее логическое значение. Функция "
"<function>xml_is_well_formed_document</function> проверяет аргумент как "
"правильно оформленный документ, а <function>xml_is_well_formed_content</"
"function> &mdash; правильно оформленное содержание. Функция "
"<function>xml_is_well_formed</function> может делать первое или второе, в "
"зависимости от значения параметра конфигурации <xref linkend=\"guc-xmloption"
"\"/> (<literal>DOCUMENT</literal> или <literal>CONTENT</literal>, "
"соответственно). Это значит, что <function>xml_is_well_formed</function> "
"помогает понять, будет ли успешным простое приведение к типу <type>xml</"
"type>, тогда как две другие функции проверяют, будут ли успешны "
"соответствующие варианты <function>XMLPARSE</function>."

#: func.xml:10208(para)
msgid ""
"Examples: <screen><![CDATA[\n"
"SET xmloption TO DOCUMENT;\n"
"SELECT xml_is_well_formed('<>');\n"
" xml_is_well_formed \n"
"--------------------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed('<abc/>');\n"
" xml_is_well_formed \n"
"--------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SET xmloption TO CONTENT;\n"
"SELECT xml_is_well_formed('abc');\n"
" xml_is_well_formed \n"
"--------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed_document('<pg:foo xmlns:pg=\"http://postgresql.org/"
"stuff\">bar</pg:foo>');\n"
" xml_is_well_formed_document \n"
"-----------------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed_document('<pg:foo xmlns:pg=\"http://postgresql.org/"
"stuff\">bar</my:foo>');\n"
" xml_is_well_formed_document \n"
"-----------------------------\n"
" f\n"
"(1 row)\n"
"]]></screen> The last example shows that the checks include whether "
"namespaces are correctly matched."
msgstr ""
"Примеры: <screen><![CDATA[\n"
"SET xmloption TO DOCUMENT;\n"
"SELECT xml_is_well_formed('<>');\n"
" xml_is_well_formed \n"
"--------------------\n"
" f\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed('<abc/>');\n"
" xml_is_well_formed \n"
"--------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SET xmloption TO CONTENT;\n"
"SELECT xml_is_well_formed('abc');\n"
" xml_is_well_formed \n"
"--------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed_document('<pg:foo xmlns:pg=\"http://postgresql.org/"
"stuff\">bar</pg:foo>');\n"
" xml_is_well_formed_document \n"
"-----------------------------\n"
" t\n"
"(1 row)\n"
"\n"
"SELECT xml_is_well_formed_document('<pg:foo xmlns:pg=\"http://postgresql.org/"
"stuff\">bar</my:foo>');\n"
" xml_is_well_formed_document \n"
"-----------------------------\n"
" f\n"
"(1 row)\n"
"]]></screen> Последний пример показывает, что при проверке также учитываются "
"сопоставления пространств имён."

#: func.xml:10252(title)
msgid "Processing XML"
msgstr "Обработка XML"

#: func.xml:10254(indexterm)
msgid "<primary>XPath</primary>"
msgstr "<primary>XPath</primary>"

#: func.xml:10258(para)
msgid ""
"To process values of data type <type>xml</type>, PostgreSQL offers the "
"functions <function>xpath</function> and <function>xpath_exists</function>, "
"which evaluate XPath 1.0 expressions."
msgstr ""
"Для обработки значений типа <type>xml</type> с помощью выражений XPath 1.0 в "
"PostgreSQL представлены функции <function>xpath</function> и "
"<function>xpath_exists</function>."

#: func.xml:10266(function)
msgctxt "function"
msgid "xpath"
msgstr "xpath"

#: func.xml:10266(replaceable) func.xml:10327(replaceable)
msgctxt "replaceable"
msgid "xpath"
msgstr "xpath"

#: func.xml:10266(replaceable) func.xml:10327(replaceable)
msgid "nsarray"
msgstr "nsarray"

#: func.xml:10265(synopsis) func.xml:10326(synopsis)
#, no-wrap
msgctxt "synopsis"
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:10269(para)
msgid ""
"The function <function>xpath</function> evaluates the XPath expression "
"<replaceable>xpath</replaceable> (a <type>text</type> value) against the XML "
"value <replaceable>xml</replaceable>. It returns an array of XML values "
"corresponding to the node set produced by the XPath expression. If the XPath "
"expression returns a scalar value rather than a node set, a single-element "
"array is returned."
msgstr ""
"Функция <function>xpath</function> вычисляет выражение XPath (аргумент "
"<replaceable>xpath</replaceable> типа <type>text</type>) для заданного "
"<replaceable>xml</replaceable>. Она возвращает массив XML-значений с набором "
"узлов, полученных в результате выражения XPath. Если выражение XPath выдаёт "
"не набор узлов, а скалярное значение, возвращается массив из одного элемента."

#: func.xml:10279(para)
msgid ""
"The second argument must be a well formed XML document. In particular, it "
"must have a single root node element."
msgstr ""
"Вторым аргументом должен быть правильно оформленный XML-документ. В "
"частности, в нём должен быть единственный корневой элемент."

#: func.xml:10284(para)
msgid ""
"The optional third argument of the function is an array of namespace "
"mappings. This array should be a two-dimensional <type>text</type> array "
"with the length of the second axis being equal to 2 (i.e., it should be an "
"array of arrays, each of which consists of exactly 2 elements). The first "
"element of each array entry is the namespace name (alias), the second the "
"namespace URI. It is not required that aliases provided in this array be the "
"same as those being used in the XML document itself (in other words, both in "
"the XML document and in the <function>xpath</function> function context, "
"aliases are <emphasis>local</emphasis>)."
msgstr ""
"В необязательном третьем аргументе функции передаются сопоставления "
"пространств имён. Эти сопоставления должны определяться в двумерном массиве "
"типа <type>text</type>, во второй размерности которого 2 элемента (т. е. это "
"должен быть массив массивов, состоящих из 2 элементов). В первом элементе "
"каждого массива определяется псевдоним (префикс) пространства имён, а во "
"втором &mdash; его URI. Псевдонимы, определённые в этом массиве, не "
"обязательно должны совпадать с префиксами пространств имён в самом XML-"
"документе (другими словами, для XML-документа и функции <function>xpath</"
"function> псевдонимы имеют <emphasis>локальный</emphasis> характер)."

#: func.xml:10296(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xpath('/my:a/text()', '<my:a xmlns:my=\"http://example.com\">test</my:"
"a>',\n"
"             ARRAY[ARRAY['my', 'http://example.com']]);\n"
"\n"
" xpath  \n"
"--------\n"
" {test}\n"
"(1 row)\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xpath('/my:a/text()', '<my:a xmlns:my=\"http://example.com\">test</my:"
"a>',\n"
"             ARRAY[ARRAY['my', 'http://example.com']]);\n"
"\n"
" xpath  \n"
"--------\n"
" {test}\n"
"(1 row)\n"
"]]></screen>"

#: func.xml:10309(para)
msgid ""
"To deal with default (anonymous) namespaces, do something like this: "
"<screen><![CDATA[\n"
"SELECT xpath('//mydefns:b/text()', '<a xmlns=\"http://example.com\"><b>test</"
"b></a>',\n"
"             ARRAY[ARRAY['mydefns', 'http://example.com']]);\n"
"\n"
" xpath\n"
"--------\n"
" {test}\n"
"(1 row)\n"
"]]></screen>"
msgstr ""
"Для пространства имён по умолчанию (анонимного) это выражение можно записать "
"так: <screen><![CDATA[\n"
"SELECT xpath('//mydefns:b/text()', '<a xmlns=\"http://example.com\"><b>test</"
"b></a>',\n"
"             ARRAY[ARRAY['mydefns', 'http://example.com']]);\n"
"\n"
" xpath\n"
"--------\n"
" {test}\n"
"(1 row)\n"
"]]></screen>"

#: func.xml:10322(indexterm)
msgid "<primary>xpath_exists</primary>"
msgstr "<primary>xpath_exists</primary>"

#: func.xml:10327(function)
msgid "xpath_exists"
msgstr "xpath_exists"

#: func.xml:10330(para)
msgid ""
"The function <function>xpath_exists</function> is a specialized form of the "
"<function>xpath</function> function. Instead of returning the individual XML "
"values that satisfy the XPath, this function returns a Boolean indicating "
"whether the query was satisfied or not. This function is equivalent to the "
"standard <literal>XMLEXISTS</literal> predicate, except that it also offers "
"support for a namespace mapping argument."
msgstr ""
"Функция <function>xpath_exists</function> представляет собой "
"специализированную форму функции <function>xpath</function>. Она возвращает "
"не весь набор XML-узлов, удовлетворяющих выражению XPath, а только одно "
"логическое значение, показывающее, есть ли такие узлы. Эта функция "
"равнозначна стандартному условию <literal>XMLEXISTS</literal>, за "
"исключением того, что она также поддерживает сопоставления пространств имён."

#: func.xml:10339(para)
msgid ""
"Example: <screen><![CDATA[\n"
"SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my=\"http://example.com"
"\">test</my:a>',\n"
"                     ARRAY[ARRAY['my', 'http://example.com']]);\n"
"\n"
" xpath_exists  \n"
"--------------\n"
" t\n"
"(1 row)\n"
"]]></screen>"
msgstr ""
"Пример: <screen><![CDATA[\n"
"SELECT xpath_exists('/my:a/text()', '<my:a xmlns:my=\"http://example.com"
"\">test</my:a>',\n"
"                     ARRAY[ARRAY['my', 'http://example.com']]);\n"
"\n"
" xpath_exists  \n"
"--------------\n"
" t\n"
"(1 row)\n"
"]]></screen>"

#: func.xml:10354(title)
msgid "Mapping Tables to XML"
msgstr "Отображение таблиц в XML"

#: func.xml:10356(indexterm)
msgid "<primary>XML export</primary>"
msgstr "<primary>экспорт в XML</primary>"

#: func.xml:10360(para)
msgid ""
"The following functions map the contents of relational tables to XML values. "
"They can be thought of as XML export functionality: <synopsis>\n"
"table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns "
"text)\n"
"query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)\n"
"cursor_to_xml(cursor refcursor, count int, nulls boolean,\n"
"              tableforest boolean, targetns text)\n"
"</synopsis> The return type of each function is <type>xml</type>."
msgstr ""
"Следующие функции отображают содержимое реляционных таблиц в значения XML. "
"Их можно рассматривать как средства экспорта в XML: <synopsis>\n"
"table_to_xml(tbl regclass, nulls boolean, tableforest boolean, targetns "
"text)\n"
"query_to_xml(query text, nulls boolean, tableforest boolean, targetns text)\n"
"cursor_to_xml(cursor refcursor, count int, nulls boolean,\n"
"              tableforest boolean, targetns text)\n"
"</synopsis> Результат всех этих функций имеет тип <type>xml</type>."

#: func.xml:10372(para)
msgid ""
"<function>table_to_xml</function> maps the content of the named table, "
"passed as parameter <parameter>tbl</parameter>. The <type>regclass</type> "
"type accepts strings identifying tables using the usual notation, including "
"optional schema qualifications and double quotes. <function>query_to_xml</"
"function> executes the query whose text is passed as parameter "
"<parameter>query</parameter> and maps the result set. "
"<function>cursor_to_xml</function> fetches the indicated number of rows from "
"the cursor specified by the parameter <parameter>cursor</parameter>. This "
"variant is recommended if large tables have to be mapped, because the result "
"value is built up in memory by each function."
msgstr ""
"<function>table_to_xml</function> отображает в xml содержимое таблицы, имя "
"которой задаётся в параметре <parameter>tbl</parameter>. Тип <type>regclass</"
"type> принимает идентификаторы строк в обычной записи, которые могут "
"содержать указание схемы и кавычки. Функция <function>query_to_xml</"
"function> выполняет запрос, текст которого передаётся в параметре "
"<parameter>query</parameter>, и отображает в xml результирующий набор. "
"Последняя функция, <function>cursor_to_xml</function> выбирает указанное "
"число строк из курсора, переданного в параметре <parameter>cursor</"
"parameter>. Этот вариант рекомендуется использовать с большими таблицами, "
"так как все эти функции создают результирующий xml в памяти."

#: func.xml:10387(para)
msgid ""
"If <parameter>tableforest</parameter> is false, then the resulting XML "
"document looks like this: <screen><![CDATA[\n"
"<tablename>\n"
"  <row>\n"
"    <columnname1>data</columnname1>\n"
"    <columnname2>data</columnname2>\n"
"  </row>\n"
"\n"
"  <row>\n"
"    ...\n"
"  </row>\n"
"\n"
"  ...\n"
"</tablename>\n"
"]]></screen> If <parameter>tableforest</parameter> is true, the result is an "
"XML content fragment that looks like this: <screen><![CDATA[\n"
"<tablename>\n"
"  <columnname1>data</columnname1>\n"
"  <columnname2>data</columnname2>\n"
"</tablename>\n"
"\n"
"<tablename>\n"
"  ...\n"
"</tablename>\n"
"\n"
"...\n"
"]]></screen> If no table name is available, that is, when mapping a query or "
"a cursor, the string <literal>table</literal> is used in the first format, "
"<literal>row</literal> in the second format."
msgstr ""
"Если параметр <parameter>tableforest</parameter> имеет значение false, "
"результирующий XML-документ выглядит так: <screen><![CDATA[\n"
"<имя_таблицы>\n"
"  <row>\n"
"    <имя_столбца1> данные </имя_столбца1>\n"
"    <имя_столбца2> данные </имя_столбца2>\n"
"  </row>\n"
"\n"
"  <row>\n"
"    ...\n"
"  </row>\n"
"\n"
"  ...\n"
"</имя_таблицы>\n"
"]]></screen> А если <parameter>tableforest</parameter> равен true, в "
"результате будет выведен следующий фрагмент XML: <screen><![CDATA[\n"
"<имя_таблицы>\n"
"  <имя_столбца1> данные </имя_столбца1>\n"
"  <имя_столбца2> данные </имя_столбца2>\n"
"</имя_таблицы>\n"
"\n"
"<имя_таблицы>\n"
"  ...\n"
"</имя_таблицы>\n"
"\n"
"...\n"
"]]></screen> Если имя таблицы неизвестно, например, при отображении "
"результатов запроса или курсора, вместо него в первом случае вставляется "
"<literal>table</literal>, а во втором — <literal>row</literal>."

#: func.xml:10425(para)
msgid ""
"The choice between these formats is up to the user. The first format is a "
"proper XML document, which will be important in many applications. The "
"second format tends to be more useful in the <function>cursor_to_xml</"
"function> function if the result values are to be reassembled into one "
"document later on. The functions for producing XML content discussed above, "
"in particular <function>xmlelement</function>, can be used to alter the "
"results to taste."
msgstr ""
"Выбор между этими форматами остаётся за пользователем. Первый вариант "
"позволяет создать готовый XML-документ, что может быть полезно для многих "
"приложений, а второй удобно применять с функцией <function>cursor_to_xml</"
"function>, если её результаты будут собираться в документ позже. Полученный "
"результат можно изменить по вкусу с помощью рассмотренных выше функций "
"создания XML-содержимого, в частности <function>xmlelement</function>."

#: func.xml:10436(para)
msgid ""
"The data values are mapped in the same way as described for the function "
"<function>xmlelement</function> above."
msgstr ""
"Значения данных эти функции отображают так же, как и ранее описанная функция "
"<function>xmlelement</function>."

#: func.xml:10441(para)
msgid ""
"The parameter <parameter>nulls</parameter> determines whether null values "
"should be included in the output. If true, null values in columns are "
"represented as: <screen><![CDATA[\n"
"<columnname xsi:nil=\"true\"/>\n"
"]]></screen> where <literal>xsi</literal> is the XML namespace prefix for "
"XML Schema Instance. An appropriate namespace declaration will be added to "
"the result value. If false, columns containing null values are simply "
"omitted from the output."
msgstr ""
"Параметр <parameter>nulls</parameter> определяет, нужно ли включать в "
"результат значения NULL. Если он установлен, значения NULL в столбцах "
"представляются так: <screen><![CDATA[\n"
"<имя_столбца xsi:nil=\"true\"/>\n"
"]]></screen> Здесь <literal>xsi</literal> &mdash; префикс пространства имён "
"XML Schema Instance. При этом в результирующий XML будет добавлено "
"соответствующее объявление пространства имён. Если же данный параметр равен "
"false, столбцы со значениями NULL просто не будут выводиться."

#: func.xml:10454(para)
msgid ""
"The parameter <parameter>targetns</parameter> specifies the desired XML "
"namespace of the result. If no particular namespace is wanted, an empty "
"string should be passed."
msgstr ""
"Параметр <parameter>targetns</parameter> определяет целевое пространство "
"имён для результирующего XML. Если пространство имён не нужно, значением "
"этого параметра должна быть пустая строка."

#: func.xml:10460(para)
msgid ""
"The following functions return XML Schema documents describing the mappings "
"performed by the corresponding functions above: <synopsis>\n"
"table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean, "
"targetns text)\n"
"query_to_xmlschema(query text, nulls boolean, tableforest boolean, targetns "
"text)\n"
"cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean, "
"targetns text)\n"
"</synopsis> It is essential that the same parameters are passed in order to "
"obtain matching XML data mappings and XML Schema documents."
msgstr ""
"Следующие функции выдают документы XML Schema, которые содержат схемы "
"отображений, выполняемых соответствующими ранее рассмотренными функциями: "
"<synopsis>\n"
"table_to_xmlschema(tbl regclass, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"query_to_xmlschema(query text, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"cursor_to_xmlschema(cursor refcursor, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"</synopsis> Чтобы результаты отображения данных в XML соответствовали XML-"
"схемам, важно, чтобы паре функций передавались одинаковые параметры."

#: func.xml:10472(para)
msgid ""
"The following functions produce XML data mappings and the corresponding XML "
"Schema in one document (or forest), linked together. They can be useful "
"where self-contained and self-describing results are wanted: <synopsis>\n"
"table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest boolean, "
"targetns text)\n"
"query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean, "
"targetns text)\n"
"</synopsis>"
msgstr ""
"Следующие функции выдают отображение данных в XML и соответствующую XML-"
"схему в одном документе (или фрагменте), объединяя их вместе. Это может быть "
"полезно там, где желательно получить самодостаточные результаты с описанием: "
"<synopsis>\n"
"table_to_xml_and_xmlschema(tbl regclass, nulls boolean, tableforest "
"boolean,\n"
"  targetns text)\n"
"query_to_xml_and_xmlschema(query text, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"</synopsis>"

#: func.xml:10483(para)
msgid ""
"In addition, the following functions are available to produce analogous "
"mappings of entire schemas or the entire current database: <synopsis>\n"
"schema_to_xml(schema name, nulls boolean, tableforest boolean, targetns "
"text)\n"
"schema_to_xmlschema(schema name, nulls boolean, tableforest boolean, "
"targetns text)\n"
"schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest boolean, "
"targetns text)\n"
"\n"
"database_to_xml(nulls boolean, tableforest boolean, targetns text)\n"
"database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)\n"
"database_to_xml_and_xmlschema(nulls boolean, tableforest boolean, targetns "
"text)\n"
"</synopsis> Note that these potentially produce a lot of data, which needs "
"to be built up in memory. When requesting content mappings of large schemas "
"or databases, it might be worthwhile to consider mapping the tables "
"separately instead, possibly even through a cursor."
msgstr ""
"В дополнение к ним есть следующие функции, способные выдать аналогичные "
"представления для целых схем в базе данных или даже всей текущей базы "
"данных: <synopsis>\n"
"schema_to_xml(schema name, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"schema_to_xmlschema(schema name, nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"schema_to_xml_and_xmlschema(schema name, nulls boolean, tableforest "
"boolean,\n"
"  targetns text)\n"
"\n"
"database_to_xml(nulls boolean, tableforest boolean, targetns text)\n"
"database_to_xmlschema(nulls boolean, tableforest boolean, targetns text)\n"
"database_to_xml_and_xmlschema(nulls boolean, tableforest boolean,\n"
"  targetns text)\n"
"</synopsis> Заметьте, что объём таких данных может быть очень большим, а XML "
"будет создаваться в памяти. Поэтому, вместо того, чтобы пытаться отобразить "
"в XML сразу всё содержимое больших схем или баз данных, лучше делать это по "
"таблицам, возможно даже используя курсор."

#: func.xml:10503(para)
msgid ""
"The result of a schema content mapping looks like this: <screen><![CDATA[\n"
"<schemaname>\n"
"\n"
"table1-mapping\n"
"\n"
"table2-mapping\n"
"\n"
"...\n"
"\n"
"</schemaname>]]></screen> where the format of a table mapping depends on the "
"<parameter>tableforest</parameter> parameter as explained above."
msgstr ""
"Результат отображения содержимого схемы будет выглядеть так: <screen><!"
"[CDATA[\n"
"<имя_схемы>\n"
"\n"
"отображение-таблицы1\n"
"\n"
"отображение-таблицы2\n"
"\n"
"...\n"
"\n"
"</имя_схемы>]]></screen> Формат отображения таблицы определяется параметром "
"<parameter>tableforest</parameter>, описанным выше."

#: func.xml:10521(para)
msgid ""
"The result of a database content mapping looks like this: <screen><![CDATA[\n"
"<dbname>\n"
"\n"
"<schema1name>\n"
"  ...\n"
"</schema1name>\n"
"\n"
"<schema2name>\n"
"  ...\n"
"</schema2name>\n"
"\n"
"...\n"
"\n"
"</dbname>]]></screen> where the schema mapping is as above."
msgstr ""
"Результат отображения содержимого базы данных будет таким: <screen><!"
"[CDATA[\n"
"<имя_схемы>\n"
"\n"
"<имя_схемы1>\n"
"  ...\n"
"</имя_схемы1>\n"
"\n"
"<имя_схемы2>\n"
"  ...\n"
"</имя_схемы2>\n"
"\n"
"...\n"
"\n"
"</имя_схемы>]]></screen> Здесь отображение схемы имеет вид, показанный выше."

#: func.xml:10542(para)
msgid ""
"As an example of using the output produced by these functions, <xref linkend="
"\"xslt-xml-html\"/> shows an XSLT stylesheet that converts the output of "
"<function>table_to_xml_and_xmlschema</function> to an HTML document "
"containing a tabular rendition of the table data. In a similar manner, the "
"results from these functions can be converted into other XML-based formats."
msgstr ""
"В качестве примера, иллюстрирующего использование результата этих функций, "
"на <xref remap=\"6\" linkend=\"xslt-xml-html\"/> показано XSLT-"
"преобразование, которое переводит результат функции "
"<function>table_to_xml_and_xmlschema</function> в HTML-документ, содержащий "
"таблицу с данными. Подобным образом результаты этих функций можно "
"преобразовать и в другие форматы на базе XML."

#: func.xml:10553(title)
msgid "XSLT Stylesheet for Converting SQL/XML Output to HTML"
msgstr "XSLT-преобразование, переводящее результат SQL/XML в формат HTML"

#: func.xml:10605(title)
msgid "JSON Functions and Operators"
msgstr "Функции и операторы JSON"

#: func.xml:10607(indexterm)
msgid "<primary>JSON</primary> <secondary>functions and operators</secondary>"
msgstr "<primary>JSON</primary> <secondary>функции и операторы</secondary>"

#: func.xml:10612(para)
msgid ""
"<xref linkend=\"functions-json-op-table\"/> shows the operators that are "
"available for use with the two JSON data types (see <xref linkend=\"datatype-"
"json\"/>)."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-json-op-table\"/> перечислены "
"функции, позволяющие создавать данные в формате JSON (см. <xref remap=\"4\" "
"linkend=\"datatype-json\"/>)."

#: func.xml:10619(title)
msgid "<type>json</type> and <type>jsonb</type> Operators"
msgstr "Операторы для типов <type>json</type> и <type>jsonb</type>"

#: func.xml:10624(entry) func.xml:10717(entry)
msgid "Right Operand Type"
msgstr "Тип правого операнда"

#: func.xml:10632(literal) func.xml:10640(literal)
msgid "-&gt;"
msgstr "-&gt;"

#: func.xml:10634(entry)
msgid ""
"Get JSON array element (indexed from zero, negative integers count from the "
"end)"
msgstr ""
"Выдаёт элемент массива JSON (по номеру от 0, отрицательные числа задают "
"позиции с конца)"

#: func.xml:10636(literal)
msgid "'[{\"a\":\"foo\"},{\"b\":\"bar\"},{\"c\":\"baz\"}]'::json-&gt;2"
msgstr "'[{\"a\":\"foo\"},{\"b\":\"bar\"},{\"c\":\"baz\"}]'::json-&gt;2"

#: func.xml:10637(literal)
msgid "{\"c\":\"baz\"}"
msgstr "{\"c\":\"baz\"}"

#: func.xml:10642(entry)
msgid "Get JSON object field by key"
msgstr "Выдаёт поле объекта JSON по ключу"

#: func.xml:10643(literal)
msgid "'{\"a\": {\"b\":\"foo\"}}'::json-&gt;'a'"
msgstr "'{\"a\": {\"b\":\"foo\"}}'::json-&gt;'a'"

#: func.xml:10644(literal)
msgid "{\"b\":\"foo\"}"
msgstr "{\"b\":\"foo\"}"

#: func.xml:10647(literal) func.xml:10654(literal)
msgid "-&gt;&gt;"
msgstr "-&gt;&gt;"

#: func.xml:10649(entry)
msgid "Get JSON array element as <type>text</type>"
msgstr "Выдаёт элемент массива JSON в типе <type>text</type>"

#: func.xml:10650(literal)
msgid "'[1,2,3]'::json-&gt;&gt;2"
msgstr "'[1,2,3]'::json-&gt;&gt;2"

#: func.xml:10656(entry)
msgid "Get JSON object field as <type>text</type>"
msgstr "Выдаёт поле объекта JSON в типе <type>text</type>"

#: func.xml:10657(literal)
msgid "'{\"a\":1,\"b\":2}'::json-&gt;&gt;'b'"
msgstr "'{\"a\":1,\"b\":2}'::json-&gt;&gt;'b'"

#: func.xml:10661(literal)
msgid "#&gt;"
msgstr "#&gt;"

#: func.xml:10663(entry)
msgid "Get JSON object at specified path"
msgstr "Выдаёт объект JSON по заданному пути"

#: func.xml:10664(literal)
msgid "'{\"a\": {\"b\":{\"c\": \"foo\"}}}'::json#&gt;'{a,b}'"
msgstr "'{\"a\": {\"b\":{\"c\": \"foo\"}}}'::json#&gt;'{a,b}'"

#: func.xml:10665(literal)
msgid "{\"c\": \"foo\"}"
msgstr "{\"c\": \"foo\"}"

#: func.xml:10668(literal)
msgid "#&gt;&gt;"
msgstr "#&gt;&gt;"

#: func.xml:10670(entry)
msgid "Get JSON object at specified path as <type>text</type>"
msgstr "Выдаёт объект JSON по заданному пути в типе <type>text</type>"

#: func.xml:10671(literal)
msgid "'{\"a\":[1,2,3],\"b\":[4,5,6]}'::json#&gt;&gt;'{a,2}'"
msgstr "'{\"a\":[1,2,3],\"b\":[4,5,6]}'::json#&gt;&gt;'{a,2}'"

#: func.xml:10679(para)
msgid ""
"There are parallel variants of these operators for both the <type>json</"
"type> and <type>jsonb</type> types. The field/element/path extraction "
"operators return the same type as their left-hand input (either <type>json</"
"type> or <type>jsonb</type>), except for those specified as returning "
"<type>text</type>, which coerce the value to text. The field/element/path "
"extraction operators return NULL, rather than failing, if the JSON input "
"does not have the right structure to match the request; for example if no "
"such element exists. The field/element/path extraction operators that accept "
"integer JSON array subscripts all support negative subscripting from the end "
"of arrays."
msgstr ""
"Эти операторы существуют в двух вариациях для типов <type>json</type> и "
"<type>jsonb</type>. Операторы извлечения поля/элемента/пути возвращают тот "
"же тип, что у операнда слева (<type>json</type> или <type>jsonb</type>), за "
"исключением тех, что возвращают тип <type>text</type> (они возвращают "
"значение как текстовое). Если входные данные JSON не содержат структуры, "
"удовлетворяющей запросу, например в них нет искомого элемента, то операторы "
"извлечения поля/элемента/пути не выдают ошибку, а возвращают NULL. Все "
"операторы извлечения поля/элемента/пути, принимающие целочисленные позиции в "
"массивах JSON, поддерживают и отсчёт от конца массива по отрицательной "
"позиции."

#: func.xml:10694(para)
msgid ""
"The standard comparison operators shown in <xref linkend=\"functions-"
"comparison-op-table\"/> are available for <type>jsonb</type>, but not for "
"<type>json</type>. They follow the ordering rules for B-tree operations "
"outlined at <xref linkend=\"json-indexing\"/>."
msgstr ""
"Стандартные операторы сравнения, приведённые в <xref remap=\"6\" linkend="
"\"functions-comparison-op-table\"/>, есть для типа <type>jsonb</type>, но не "
"для <type>json</type>. Они следуют правилам сортировки для операций B-"
"дерева, описанным в <xref remap=\"6\" linkend=\"json-indexing\"/>."

#: func.xml:10701(para)
msgid ""
"Some further operators also exist only for <type>jsonb</type>, as shown in "
"<xref linkend=\"functions-jsonb-op-table\"/>. Many of these operators can be "
"indexed by <type>jsonb</type> operator classes. For a full description of "
"<type>jsonb</type> containment and existence semantics, see <xref linkend="
"\"json-containment\"/>. <xref linkend=\"json-indexing\"/> describes how "
"these operators can be used to effectively index <type>jsonb</type> data."
msgstr ""
"Некоторые из следующих операторов существуют только для <type>jsonb</type>, "
"как показано в <xref remap=\"6\" linkend=\"functions-jsonb-op-table\"/>. "
"Многие из этих операторов могут быть проиндексированы с помощью классов "
"операторов <type>jsonb</type>. Полное описание проверок на вхождение и "
"существование для <type>jsonb</type> приведено в <xref remap=\"6\" linkend="
"\"json-containment\"/>. Как эти операторы могут использоваться для "
"эффективного индексирования данных <type>jsonb</type>, описано в <xref remap="
"\"6\" linkend=\"json-indexing\"/>."

#: func.xml:10712(title)
msgid "Additional <type>jsonb</type> Operators"
msgstr "Дополнительные операторы <type>jsonb</type>"

#: func.xml:10725(type) func.xml:10732(type) func.xml:10760(type)
#: func.xml:11128(type) func.xml:11306(type) func.xml:11318(type)
#: func.xml:11344(type) func.xml:13005(type) func.xml:13039(type)
msgid "jsonb"
msgstr "jsonb"

#: func.xml:10726(entry)
msgid ""
"Does the left JSON value contain the right JSON path/value entries at the "
"top level?"
msgstr ""
"Левое значение JSON содержит на верхнем уровне путь/значение JSON справа?"

#: func.xml:10728(literal)
msgid "'{\"a\":1, \"b\":2}'::jsonb @&gt; '{\"b\":2}'::jsonb"
msgstr "'{\"a\":1, \"b\":2}'::jsonb @&gt; '{\"b\":2}'::jsonb"

#: func.xml:10733(entry)
msgid ""
"Are the left JSON path/value entries contained at the top level within the "
"right JSON value?"
msgstr ""
"Путь/значение JSON слева содержится на верхнем уровне в правом значении JSON?"

#: func.xml:10735(literal)
msgid "'{\"b\":2}'::jsonb &lt;@ '{\"a\":1, \"b\":2}'::jsonb"
msgstr "'{\"b\":2}'::jsonb &lt;@ '{\"a\":1, \"b\":2}'::jsonb"

#: func.xml:10740(entry)
msgid ""
"Does the <emphasis>string</emphasis> exist as a top-level key within the "
"JSON value?"
msgstr ""
"Присутствует ли <emphasis>строка</emphasis> в качестве ключа верхнего уровня "
"в значении JSON?"

#: func.xml:10742(literal)
msgid "'{\"a\":1, \"b\":2}'::jsonb ? 'b'"
msgstr "'{\"a\":1, \"b\":2}'::jsonb ? 'b'"

#: func.xml:10747(entry)
msgid ""
"Do any of these array <emphasis>strings</emphasis> exist as top-level keys?"
msgstr ""
"Какие-либо <emphasis>строки</emphasis> массива присутствуют в качестве "
"ключей верхнего уровня?"

#: func.xml:10749(literal)
msgid "'{\"a\":1, \"b\":2, \"c\":3}'::jsonb ?| array['b', 'c']"
msgstr "'{\"a\":1, \"b\":2, \"c\":3}'::jsonb ?| array['b', 'c']"

#: func.xml:10752(literal)
msgid "?&amp;"
msgstr "?&amp;"

#: func.xml:10754(entry)
msgid ""
"Do all of these array <emphasis>strings</emphasis> exist as top-level keys?"
msgstr ""
"Все <emphasis>строки</emphasis> массива присутствуют в качестве ключей "
"верхнего уровня?"

#: func.xml:10756(literal)
msgid "'[\"a\", \"b\"]'::jsonb ?&amp; array['a', 'b']"
msgstr "'[\"a\", \"b\"]'::jsonb ?&amp; array['a', 'b']"

#: func.xml:10761(entry)
msgid ""
"Concatenate two <type>jsonb</type> values into a new <type>jsonb</type> value"
msgstr ""
"Соединяет два значения <type>jsonb</type> в новое значение <type>jsonb</type>"

#: func.xml:10762(literal)
msgid "'[\"a\", \"b\"]'::jsonb || '[\"c\", \"d\"]'::jsonb"
msgstr "'[\"a\", \"b\"]'::jsonb || '[\"c\", \"d\"]'::jsonb"

#: func.xml:10767(entry)
msgid ""
"Delete key/value pair or <emphasis>string</emphasis> element from left "
"operand. Key/value pairs are matched based on their key value."
msgstr ""
"Удаляет пару ключ/значение или элемент-<emphasis>строку</emphasis> из левого "
"операнда. Пары ключ/значение выбираются по значению ключа."

#: func.xml:10770(literal)
msgid "'{\"a\": \"b\"}'::jsonb - 'a'"
msgstr "'{\"a\": \"b\"}'::jsonb - 'a'"

#: func.xml:10775(entry)
msgid ""
"Delete the array element with specified index (Negative integers count from "
"the end). Throws an error if top level container is not an array."
msgstr ""
"Удаляет из массива элемент в заданной позиции (отрицательные номера позиций "
"отсчитываются от конца). Выдаёт ошибку, если контейнер верхнего уровня — не "
"массив."

#: func.xml:10778(literal)
msgid "'[\"a\", \"b\"]'::jsonb - 1"
msgstr "'[\"a\", \"b\"]'::jsonb - 1"

#: func.xml:10781(literal)
msgid "#-"
msgstr "#-"

#: func.xml:10783(entry)
msgid ""
"Delete the field or element with specified path (for JSON arrays, negative "
"integers count from the end)"
msgstr ""
"Удаляет поле или элемент с заданным путём (для массивов JSON отрицательные "
"номера позиций отсчитываются от конца)"

#: func.xml:10785(literal)
msgid "'[\"a\", {\"b\":1}]'::jsonb #- '{1,b}'"
msgstr "'[\"a\", {\"b\":1}]'::jsonb #- '{1,b}'"

#: func.xml:10792(para)
msgid ""
"The <literal>||</literal> operator concatenates the elements at the top "
"level of each of its operands. It does not operate recursively. For example, "
"if both operands are objects with a common key field name, the value of the "
"field in the result will just be the value from the right hand operand."
msgstr ""
"Оператор <literal>||</literal> соединяет элементы верхнего уровня обоих "
"операндов. Вложенность при этом не учитывается. Например, если оба операнда "
"содержат поле с одноимённым ключом, значением поля в результате будет "
"значение, взятое из правого операнда."

#: func.xml:10800(para)
msgid ""
"<xref linkend=\"functions-json-creation-table\"/> shows the functions that "
"are available for creating <type>json</type> and <type>jsonb</type> values. "
"(There are no equivalent functions for <type>jsonb</type>, of the "
"<literal>row_to_json</literal> and <literal>array_to_json</literal> "
"functions. However, the <literal>to_jsonb</literal> function supplies much "
"the same functionality as these functions would.)"
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-json-creation-table\"/> показаны "
"функции, позволяющие создавать значения типов <type>json</type> и "
"<type>jsonb</type>. (Для типа <type>jsonb</type> нет аналогов функций "
"<literal>row_to_json</literal> и <literal>array_to_json</literal>, но "
"практически тот же результат можно получить с помощью <literal>to_jsonb</"
"literal>.)"

#: func.xml:10808(indexterm)
msgid "<primary>to_json</primary>"
msgstr "<primary>to_json</primary>"

#: func.xml:10811(indexterm)
msgid "<primary>array_to_json</primary>"
msgstr "<primary>array_to_json</primary>"

#: func.xml:10814(indexterm)
msgid "<primary>row_to_json</primary>"
msgstr "<primary>row_to_json</primary>"

#: func.xml:10817(indexterm)
msgid "<primary>json_build_array</primary>"
msgstr "<primary>json_build_array</primary>"

#: func.xml:10820(indexterm)
msgid "<primary>json_build_object</primary>"
msgstr "<primary>json_build_object</primary>"

#: func.xml:10823(indexterm)
msgid "<primary>json_object</primary>"
msgstr "<primary>json_object</primary>"

#: func.xml:10826(indexterm)
msgid "<primary>to_jsonb</primary>"
msgstr "<primary>to_jsonb</primary>"

#: func.xml:10829(indexterm)
msgid "<primary>jsonb_build_array</primary>"
msgstr "<primary>jsonb_build_array</primary>"

#: func.xml:10832(indexterm)
msgid "<primary>jsonb_build_object</primary>"
msgstr "<primary>jsonb_build_object</primary>"

#: func.xml:10835(indexterm)
msgid "<primary>jsonb_object</primary>"
msgstr "<primary>jsonb_object</primary>"

#: func.xml:10840(title)
msgid "JSON Creation Functions"
msgstr "Функции для создания JSON"

#: func.xml:10852(literal)
msgid "to_json(anyelement)"
msgstr "to_json(anyelement)"

#: func.xml:10853(literal)
msgid "to_jsonb(anyelement)"
msgstr "to_jsonb(anyelement)"

#: func.xml:10855(entry)
msgid ""
"Returns the value as <type>json</type> or <type>jsonb</type>. Arrays and "
"composites are converted (recursively) to arrays and objects; otherwise, if "
"there is a cast from the type to <type>json</type>, the cast function will "
"be used to perform the conversion; otherwise, a scalar value is produced. "
"For any scalar type other than a number, a Boolean, or a null value, the "
"text representation will be used, in such a fashion that it is a valid "
"<type>json</type> or <type>jsonb</type> value."
msgstr ""
"Возвращает значение в виде <type>json</type> или <type>jsonb</type>. Массивы "
"и составные структуры преобразуются (рекурсивно) в массивы и объекты; для "
"других типов, для которых определено приведение к <type>json</type>, "
"применяется эта функция приведения, а для всех остальных выдаётся скалярное "
"значение. Значения всех скалярных типов, кроме числового, логического и "
"NULL, представляются в текстовом виде, в стиле, допустимом для значений "
"<type>json</type> или <type>jsonb</type>."

#: func.xml:10865(literal)
msgid "to_json('Fred said \"Hi.\"'::text)"
msgstr "to_json('Fred said \"Hi.\"'::text)"

#: func.xml:10866(literal)
msgid "\"Fred said \\\"Hi.\\\"\""
msgstr "\"Fred said \\\"Hi.\\\"\""

#: func.xml:10870(literal)
msgid "array_to_json(anyarray [, pretty_bool])"
msgstr "array_to_json(anyarray [, pretty_bool])"

#: func.xml:10872(entry)
msgid ""
"Returns the array as a JSON array. A PostgreSQL multidimensional array "
"becomes a JSON array of arrays. Line feeds will be added between dimension-1 "
"elements if <parameter>pretty_bool</parameter> is true."
msgstr ""
"Возвращает массив в виде массива JSON. Многомерный массив PostgreSQL "
"становится массивом массивов JSON. Если параметр <parameter>pretty_bool</"
"parameter> равен true, между элементами 1-ой размерности вставляются разрывы "
"строк."

#: func.xml:10877(literal)
msgid "array_to_json('{{1,5},{99,100}}'::int[])"
msgstr "array_to_json('{{1,5},{99,100}}'::int[])"

#: func.xml:10878(literal)
msgid "[[1,5],[99,100]]"
msgstr "[[1,5],[99,100]]"

#: func.xml:10882(literal)
msgid "row_to_json(record [, pretty_bool])"
msgstr "row_to_json(record [, pretty_bool])"

#: func.xml:10884(entry)
msgid ""
"Returns the row as a JSON object. Line feeds will be added between level-1 "
"elements if <parameter>pretty_bool</parameter> is true."
msgstr ""
"Возвращает кортеж в виде объекта JSON. Если параметр <parameter>pretty_bool</"
"parameter> равен true, между элементами 1-ой размерности вставляются разрывы "
"строк."

#: func.xml:10888(literal)
msgid "row_to_json(row(1,'foo'))"
msgstr "row_to_json(row(1,'foo'))"

#: func.xml:10889(literal)
msgid "{\"f1\":1,\"f2\":\"foo\"}"
msgstr "{\"f1\":1,\"f2\":\"foo\"}"

#: func.xml:10892(literal)
msgid "json_build_array(VARIADIC \"any\")"
msgstr "json_build_array(VARIADIC \"any\")"

#: func.xml:10893(literal)
msgid "jsonb_build_array(VARIADIC \"any\")"
msgstr "jsonb_build_array(VARIADIC \"any\")"

#: func.xml:10895(entry)
msgid ""
"Builds a possibly-heterogeneously-typed JSON array out of a variadic "
"argument list."
msgstr ""
"Формирует массив JSON (возможно, разнородный) из переменного списка "
"аргументов."

#: func.xml:10899(literal)
msgid "json_build_array(1,2,'3',4,5)"
msgstr "json_build_array(1,2,'3',4,5)"

#: func.xml:10900(literal)
msgid "[1, 2, \"3\", 4, 5]"
msgstr "[1, 2, \"3\", 4, 5]"

#: func.xml:10903(literal)
msgid "json_build_object(VARIADIC \"any\")"
msgstr "json_build_object(VARIADIC \"any\")"

#: func.xml:10904(literal)
msgid "jsonb_build_object(VARIADIC \"any\")"
msgstr "jsonb_build_object(VARIADIC \"any\")"

#: func.xml:10906(entry)
msgid ""
"Builds a JSON object out of a variadic argument list. By convention, the "
"argument list consists of alternating keys and values."
msgstr ""
"Формирует объект JSON из переменного списка аргументов. По соглашению в этом "
"списке перечисляются по очереди ключи и значения."

#: func.xml:10911(literal)
msgid "json_build_object('foo',1,'bar',2)"
msgstr "json_build_object('foo',1,'bar',2)"

#: func.xml:10912(literal)
msgid "{\"foo\": 1, \"bar\": 2}"
msgstr "{\"foo\": 1, \"bar\": 2}"

#: func.xml:10915(literal)
msgid "json_object(text[])"
msgstr "json_object(text[])"

#: func.xml:10916(literal)
msgid "jsonb_object(text[])"
msgstr "jsonb_object(text[])"

#: func.xml:10918(entry)
msgid ""
"Builds a JSON object out of a text array. The array must have either exactly "
"one dimension with an even number of members, in which case they are taken "
"as alternating key/value pairs, or two dimensions such that each inner array "
"has exactly two elements, which are taken as a key/value pair."
msgstr ""
"Формирует объект JSON из текстового массива. Этот массив должен иметь либо "
"одну размерность с чётным числом элементов (в этом случае они воспринимаются "
"как чередующиеся ключи/значения), либо две размерности и при этом каждый "
"внутренний массив содержит ровно два элемента, которые воспринимаются как "
"пара ключ/значение."

#: func.xml:10925(literal)
msgid "json_object('{a, 1, b, \"def\", c, 3.5}')"
msgstr "json_object('{a, 1, b, \"def\", c, 3.5}')"

#: func.xml:10926(literal)
msgid "json_object('{{a, 1},{b, \"def\"},{c, 3.5}}')"
msgstr "json_object('{{a, 1},{b, \"def\"},{c, 3.5}}')"

#: func.xml:10927(literal)
msgid "{\"a\": \"1\", \"b\": \"def\", \"c\": \"3.5\"}"
msgstr "{\"a\": \"1\", \"b\": \"def\", \"c\": \"3.5\"}"

#: func.xml:10930(literal)
msgid "json_object(keys text[], values text[])"
msgstr "json_object(keys text[], values text[])"

#: func.xml:10931(literal)
msgid "jsonb_object(keys text[], values text[])"
msgstr "jsonb_object(keys text[], values text[])"

#: func.xml:10933(entry)
msgid ""
"This form of <function>json_object</function> takes keys and values pairwise "
"from two separate arrays. In all other respects it is identical to the one-"
"argument form."
msgstr ""
"Эта форма <function>json_object</function> принимает ключи и значения по "
"парам из двух отдельных массивов. Во всех остальных отношениях она не "
"отличается от формы с одним аргументом."

#: func.xml:10937(literal)
msgid "json_object('{a, b}', '{1,2}')"
msgstr "json_object('{a, b}', '{1,2}')"

#: func.xml:10938(literal)
msgid "{\"a\": \"1\", \"b\": \"2\"}"
msgstr "{\"a\": \"1\", \"b\": \"2\"}"

#: func.xml:10945(para)
msgid ""
"<function>array_to_json</function> and <function>row_to_json</function> have "
"the same behavior as <function>to_json</function> except for offering a "
"pretty-printing option. The behavior described for <function>to_json</"
"function> likewise applies to each individual value converted by the other "
"JSON creation functions."
msgstr ""
"Функции <function>array_to_json</function> и <function>row_to_json</"
"function> подобны <function>to_json</function>, но предлагают возможность "
"улучшенного вывода. Действие <function>to_json</function>, описанное выше, "
"распространяется на каждое отдельное значение, преобразуемое этими функциями."

#: func.xml:10954(para)
msgid ""
"The <xref linkend=\"hstore\"/> extension has a cast from <type>hstore</type> "
"to <type>json</type>, so that <type>hstore</type> values converted via the "
"JSON creation functions will be represented as JSON objects, not as "
"primitive string values."
msgstr ""
"В расширении <xref linkend=\"hstore\"/> определено преобразование из "
"<type>hstore</type> в <type>json</type>, так что значения <type>hstore</"
"type>, преобразуемые функциями создания JSON, будут представлены в виде "
"объектов JSON, а не как примитивные строковые значения."

#: func.xml:10962(para)
msgid ""
"<xref linkend=\"functions-json-processing-table\"/> shows the functions that "
"are available for processing <type>json</type> and <type>jsonb</type> values."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-json-processing-table\"/> показаны "
"функции, предназначенные для работы со значениями <type>json</type> и "
"<type>jsonb</type>."

#: func.xml:10967(indexterm)
msgid "<primary>json_array_length</primary>"
msgstr "<primary>json_array_length</primary>"

#: func.xml:10970(indexterm)
msgid "<primary>jsonb_array_length</primary>"
msgstr "<primary>jsonb_array_length</primary>"

#: func.xml:10973(indexterm)
msgid "<primary>json_each</primary>"
msgstr "<primary>json_each</primary>"

#: func.xml:10976(indexterm)
msgid "<primary>jsonb_each</primary>"
msgstr "<primary>jsonb_each</primary>"

#: func.xml:10979(indexterm)
msgid "<primary>json_each_text</primary>"
msgstr "<primary>json_each_text</primary>"

#: func.xml:10982(indexterm)
msgid "<primary>jsonb_each_text</primary>"
msgstr "<primary>jsonb_each_text</primary>"

#: func.xml:10985(indexterm)
msgid "<primary>json_extract_path</primary>"
msgstr "<primary>json_extract_path</primary>"

#: func.xml:10988(indexterm)
msgid "<primary>jsonb_extract_path</primary>"
msgstr "<primary>jsonb_extract_path</primary>"

#: func.xml:10991(indexterm)
msgid "<primary>json_extract_path_text</primary>"
msgstr "<primary>json_extract_path_text</primary>"

#: func.xml:10994(indexterm)
msgid "<primary>jsonb_extract_path_text</primary>"
msgstr "<primary>jsonb_extract_path_text</primary>"

#: func.xml:10997(indexterm)
msgid "<primary>json_object_keys</primary>"
msgstr "<primary>json_object_keys</primary>"

#: func.xml:11000(indexterm)
msgid "<primary>jsonb_object_keys</primary>"
msgstr "<primary>jsonb_object_keys</primary>"

#: func.xml:11003(indexterm)
msgid "<primary>json_populate_record</primary>"
msgstr "<primary>json_populate_record</primary>"

#: func.xml:11006(indexterm)
msgid "<primary>jsonb_populate_record</primary>"
msgstr "<primary>jsonb_populate_record</primary>"

#: func.xml:11009(indexterm)
msgid "<primary>json_populate_recordset</primary>"
msgstr "<primary>json_populate_recordset</primary>"

#: func.xml:11012(indexterm)
msgid "<primary>jsonb_populate_recordset</primary>"
msgstr "<primary>jsonb_populate_recordset</primary>"

#: func.xml:11015(indexterm)
msgid "<primary>json_array_elements</primary>"
msgstr "<primary>json_array_elements</primary>"

#: func.xml:11018(indexterm)
msgid "<primary>jsonb_array_elements</primary>"
msgstr "<primary>jsonb_array_elements</primary>"

#: func.xml:11021(indexterm)
msgid "<primary>json_array_elements_text</primary>"
msgstr "<primary>json_array_elements_text</primary>"

#: func.xml:11024(indexterm)
msgid "<primary>jsonb_array_elements_text</primary>"
msgstr "<primary>jsonb_array_elements_text</primary>"

#: func.xml:11027(indexterm)
msgid "<primary>json_typeof</primary>"
msgstr "<primary>json_typeof</primary>"

#: func.xml:11030(indexterm)
msgid "<primary>jsonb_typeof</primary>"
msgstr "<primary>jsonb_typeof</primary>"

#: func.xml:11033(indexterm)
msgid "<primary>json_to_record</primary>"
msgstr "<primary>json_to_record</primary>"

#: func.xml:11036(indexterm)
msgid "<primary>jsonb_to_record</primary>"
msgstr "<primary>jsonb_to_record</primary>"

#: func.xml:11039(indexterm)
msgid "<primary>json_to_recordset</primary>"
msgstr "<primary>json_to_recordset</primary>"

#: func.xml:11042(indexterm)
msgid "<primary>jsonb_to_recordset</primary>"
msgstr "<primary>jsonb_to_recordset</primary>"

#: func.xml:11045(indexterm)
msgid "<primary>json_strip_nulls</primary>"
msgstr "<primary>json_strip_nulls</primary>"

#: func.xml:11048(indexterm)
msgid "<primary>jsonb_strip_nulls</primary>"
msgstr "<primary>jsonb_strip_nulls</primary>"

#: func.xml:11051(indexterm)
msgid "<primary>jsonb_set</primary>"
msgstr "<primary>jsonb_set</primary>"

#: func.xml:11054(indexterm)
msgid "<primary>jsonb_insert</primary>"
msgstr "<primary>jsonb_insert</primary>"

#: func.xml:11057(indexterm)
msgid "<primary>jsonb_pretty</primary>"
msgstr "<primary>jsonb_pretty</primary>"

#: func.xml:11062(title)
msgid "JSON Processing Functions"
msgstr "Функции для обработки JSON"

#: func.xml:11075(literal)
msgid "json_array_length(json)"
msgstr "json_array_length(json)"

#: func.xml:11076(literal)
msgid "jsonb_array_length(jsonb)"
msgstr "jsonb_array_length(jsonb)"

#: func.xml:11079(entry)
msgid "Returns the number of elements in the outermost JSON array."
msgstr "Возвращает число элементов во внешнем массиве JSON."

#: func.xml:11082(literal)
msgid "json_array_length('[1,2,3,{\"f1\":1,\"f2\":[5,6]},4]')"
msgstr "json_array_length('[1,2,3,{\"f1\":1,\"f2\":[5,6]},4]')"

#: func.xml:11086(literal)
msgid "json_each(json)"
msgstr "json_each(json)"

#: func.xml:11087(literal)
msgid "jsonb_each(jsonb)"
msgstr "jsonb_each(jsonb)"

#: func.xml:11089(literal)
msgid "setof key text, value json"
msgstr "setof key text, value json"

#: func.xml:11090(literal)
msgid "setof key text, value jsonb"
msgstr "setof key text, value jsonb"

#: func.xml:11092(entry)
msgid "Expands the outermost JSON object into a set of key/value pairs."
msgstr ""
"Разворачивает внешний объект JSON в набор пар ключ/значение (key/value)."

#: func.xml:11095(literal)
msgid "select * from json_each('{\"a\":\"foo\", \"b\":\"bar\"}')"
msgstr "select * from json_each('{\"a\":\"foo\", \"b\":\"bar\"}')"

#: func.xml:11097(programlisting)
#, no-wrap
msgid ""
" key | value\n"
"-----+-------\n"
" a   | \"foo\"\n"
" b   | \"bar\""
msgstr ""
" key | value\n"
"-----+-------\n"
" a   | \"foo\"\n"
" b   | \"bar\""

#: func.xml:11106(literal)
msgid "json_each_text(json)"
msgstr "json_each_text(json)"

#: func.xml:11107(literal)
msgid "jsonb_each_text(jsonb)"
msgstr "jsonb_each_text(jsonb)"

#: func.xml:11109(type)
msgid "setof key text, value text"
msgstr "setof key text, value text"

#: func.xml:11110(entry)
msgid ""
"Expands the outermost JSON object into a set of key/value pairs. The "
"returned values will be of type <type>text</type>."
msgstr ""
"Разворачивает внешний объект JSON в набор пар ключ/значение (key/value). "
"Возвращаемые значения будут иметь тип <type>text</type>."

#: func.xml:11114(literal)
msgid "select * from json_each_text('{\"a\":\"foo\", \"b\":\"bar\"}')"
msgstr "select * from json_each_text('{\"a\":\"foo\", \"b\":\"bar\"}')"

#: func.xml:11116(programlisting)
#, no-wrap
msgid ""
" key | value\n"
"-----+-------\n"
" a   | foo\n"
" b   | bar"
msgstr ""
" key | value\n"
"-----+-------\n"
" a   | foo\n"
" b   | bar"

#: func.xml:11125(literal)
msgid "json_extract_path(from_json json, VARIADIC path_elems text[])"
msgstr "json_extract_path(from_json json, VARIADIC path_elems text[])"

#: func.xml:11126(literal)
msgid "jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])"
msgstr "jsonb_extract_path(from_json jsonb, VARIADIC path_elems text[])"

#: func.xml:11128(type) func.xml:11306(type) func.xml:12988(type)
#: func.xml:13022(type)
msgid "json"
msgstr "json"

#: func.xml:11130(entry)
msgid ""
"Returns JSON value pointed to by <replaceable>path_elems</replaceable> "
"(equivalent to <literal>#&gt;</literal> operator)."
msgstr ""
"Возвращает значение JSON по пути, заданному элементами пути "
"(<replaceable>path_elems</replaceable>) (равнозначно оператору <literal>#&gt;"
"</literal> operator)."

#: func.xml:11134(literal)
msgid ""
"json_extract_path('{\"f2\":{\"f3\":1},\"f4\":{\"f5\":99,\"f6\":\"foo"
"\"}}','f4')"
msgstr ""
"json_extract_path('{\"f2\":{\"f3\":1},\"f4\":{\"f5\":99,\"f6\":\"foo"
"\"}}','f4')"

#: func.xml:11135(literal)
msgid "{\"f5\":99,\"f6\":\"foo\"}"
msgstr "{\"f5\":99,\"f6\":\"foo\"}"

#: func.xml:11138(literal)
msgid "json_extract_path_text(from_json json, VARIADIC path_elems text[])"
msgstr "json_extract_path_text(from_json json, VARIADIC path_elems text[])"

#: func.xml:11139(literal)
msgid "jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])"
msgstr "jsonb_extract_path_text(from_json jsonb, VARIADIC path_elems text[])"

#: func.xml:11142(entry)
msgid ""
"Returns JSON value pointed to by <replaceable>path_elems</replaceable> as "
"<type>text</type> (equivalent to <literal>#&gt;&gt;</literal> operator)."
msgstr ""
"Возвращает значение JSON по пути, заданному элементами пути "
"<replaceable>path_elems</replaceable>, как <type>text</type> (равнозначно "
"оператору <literal>#&gt;&gt;</literal>)."

#: func.xml:11147(literal)
msgid ""
"json_extract_path_text('{\"f2\":{\"f3\":1},\"f4\":{\"f5\":99,\"f6\":\"foo"
"\"}}','f4', 'f6')"
msgstr ""
"json_extract_path_text('{\"f2\":{\"f3\":1},\"f4\":{\"f5\":99,\"f6\":\"foo"
"\"}}','f4', 'f6')"

#: func.xml:11148(literal)
msgid "foo"
msgstr "foo"

#: func.xml:11151(literal)
msgid "json_object_keys(json)"
msgstr "json_object_keys(json)"

#: func.xml:11152(literal)
msgid "jsonb_object_keys(jsonb)"
msgstr "jsonb_object_keys(jsonb)"

#: func.xml:11155(entry)
msgid "Returns set of keys in the outermost JSON object."
msgstr "Возвращает число ключей во внешнем объекте JSON."

#: func.xml:11158(literal)
msgid ""
"json_object_keys('{\"f1\":\"abc\",\"f2\":{\"f3\":\"a\", \"f4\":\"b\"}}')"
msgstr ""
"json_object_keys('{\"f1\":\"abc\",\"f2\":{\"f3\":\"a\", \"f4\":\"b\"}}')"

#: func.xml:11160(programlisting)
#, no-wrap
msgid ""
" json_object_keys\n"
"------------------\n"
" f1\n"
" f2"
msgstr ""
" json_object_keys\n"
"-----------------\n"
" f1\n"
" f2"

#: func.xml:11169(literal)
msgid "json_populate_record(base anyelement, from_json json)"
msgstr "json_populate_record(base anyelement, from_json json)"

#: func.xml:11170(literal)
msgid "jsonb_populate_record(base anyelement, from_json jsonb)"
msgstr "jsonb_populate_record(base anyelement, from_json jsonb)"

#: func.xml:11173(entry)
msgid ""
"Expands the object in <replaceable>from_json</replaceable> to a row whose "
"columns match the record type defined by <replaceable>base</replaceable> "
"(see note below)."
msgstr ""
"Разворачивает объект из <replaceable>from_json</replaceable> в табличную "
"строку, в которой столбцы соответствуют типу строки, заданному параметром "
"<replaceable>base</replaceable> (см. примечания ниже)."

#: func.xml:11178(literal)
msgid ""
"select * from json_populate_record(null::myrowtype, '{\"a\":1,\"b\":2}')"
msgstr ""
"select * from json_populate_record(null::myrowtype, '{\"a\":1,\"b\":2}')"

#: func.xml:11180(programlisting)
#, no-wrap
msgid ""
" a | b\n"
"---+---\n"
" 1 | 2"
msgstr ""
" a | b\n"
"---+---\n"
" 1 | 2"

#: func.xml:11188(literal)
msgid "json_populate_recordset(base anyelement, from_json json)"
msgstr "json_populate_recordset(base anyelement, from_json json)"

#: func.xml:11189(literal)
msgid "jsonb_populate_recordset(base anyelement, from_json jsonb)"
msgstr "jsonb_populate_recordset(base anyelement, from_json jsonb)"

#: func.xml:11191(type) func.xml:12370(type)
msgid "setof anyelement"
msgstr "setof anyelement"

#: func.xml:11192(entry)
msgid ""
"Expands the outermost array of objects in <replaceable>from_json</"
"replaceable> to a set of rows whose columns match the record type defined by "
"<replaceable>base</replaceable> (see note below)."
msgstr ""
"Разворачивает внешний массив объектов из <replaceable>from_json</"
"replaceable> в набор табличных строк, в котором столбцы соответствуют типу "
"строки, заданному параметром <replaceable>base</replaceable> (см. примечания "
"ниже)."

#: func.xml:11198(literal)
msgid ""
"select * from json_populate_recordset(null::myrowtype, '[{\"a\":1,\"b\":2},"
"{\"a\":3,\"b\":4}]')"
msgstr ""
"select * from json_populate_recordset(null::myrowtype, '[{\"a\":1,\"b\":2},"
"{\"a\":3,\"b\":4}]')"

#: func.xml:11200(programlisting)
#, no-wrap
msgid ""
" a | b\n"
"---+---\n"
" 1 | 2\n"
" 3 | 4"
msgstr ""
" a | b\n"
"---+---\n"
" 1 | 2\n"
" 3 | 4"

#: func.xml:11209(literal)
msgid "json_array_elements(json)"
msgstr "json_array_elements(json)"

#: func.xml:11210(literal)
msgid "jsonb_array_elements(jsonb)"
msgstr "jsonb_array_elements(jsonb)"

#: func.xml:11212(type)
msgid "setof json"
msgstr "setof json"

#: func.xml:11213(type)
msgid "setof jsonb"
msgstr "setof jsonb"

#: func.xml:11215(entry)
msgid "Expands a JSON array to a set of JSON values."
msgstr "Разворачивает массив JSON в набор значений JSON."

#: func.xml:11218(literal)
msgid "select * from json_array_elements('[1,true, [2,false]]')"
msgstr "select * from json_array_elements('[1,true, [2,false]]')"

#: func.xml:11220(programlisting)
#, no-wrap
msgid ""
"   value\n"
"-----------\n"
" 1\n"
" true\n"
" [2,false]"
msgstr ""
"   value\n"
"-----------\n"
" 1\n"
" true\n"
" [2,false]"

#: func.xml:11230(literal)
msgid "json_array_elements_text(json)"
msgstr "json_array_elements_text(json)"

#: func.xml:11231(literal)
msgid "jsonb_array_elements_text(jsonb)"
msgstr "jsonb_array_elements_text(jsonb)"

#: func.xml:11234(entry)
msgid "Expands a JSON array to a set of <type>text</type> values."
msgstr "Разворачивает массив JSON в набор значений <type>text</type>."

#: func.xml:11237(literal)
msgid "select * from json_array_elements_text('[\"foo\", \"bar\"]')"
msgstr "select * from json_array_elements_text('[\"foo\", \"bar\"]')"

#: func.xml:11239(programlisting)
#, no-wrap
msgid ""
"   value\n"
"-----------\n"
" foo\n"
" bar"
msgstr ""
"   value\n"
"-----------\n"
" foo\n"
" bar"

#: func.xml:11248(literal)
msgid "json_typeof(json)"
msgstr "json_typeof(json)"

#: func.xml:11249(literal)
msgid "jsonb_typeof(jsonb)"
msgstr "jsonb_typeof(jsonb)"

#: func.xml:11252(entry)
msgid ""
"Returns the type of the outermost JSON value as a text string. Possible "
"types are <literal>object</literal>, <literal>array</literal>, "
"<literal>string</literal>, <literal>number</literal>, <literal>boolean</"
"literal>, and <literal>null</literal>."
msgstr ""
"Возвращает тип внешнего значения JSON в виде текстовой строки. Возможные "
"типы: <literal>object</literal>, <literal>array</literal>, <literal>string</"
"literal>, <literal>number</literal>, <literal>boolean</literal> и "
"<literal>null</literal>."

#: func.xml:11258(literal)
msgid "json_typeof('-123.4')"
msgstr "json_typeof('-123.4')"

#: func.xml:11259(literal)
msgctxt "literal"
msgid "number"
msgstr "number"

#: func.xml:11262(literal)
msgid "json_to_record(json)"
msgstr "json_to_record(json)"

#: func.xml:11263(literal)
msgid "jsonb_to_record(jsonb)"
msgstr "jsonb_to_record(jsonb)"

#: func.xml:11265(type) func.xml:17091(type) func.xml:17102(type)
#: func.xml:17113(type) func.xml:17124(type) func.xml:19033(type)
msgctxt "type"
msgid "record"
msgstr "record"

#: func.xml:11266(entry)
msgid ""
"Builds an arbitrary record from a JSON object (see note below). As with all "
"functions returning <type>record</type>, the caller must explicitly define "
"the structure of the record with an <literal>AS</literal> clause."
msgstr ""
"Формирует обычную запись из объекта JSON (см. примечания ниже). Как и со "
"всеми функциями, возвращающими <type>record</type>, при вызове необходимо "
"явно определить структуру записи с помощью предложения <literal>AS</literal>."

#: func.xml:11272(literal)
msgid ""
"select * from json_to_record('{\"a\":1,\"b\":[1,2,3],\"c\":\"bar\"}') as x(a "
"int, b text, d text)"
msgstr ""
"select * from json_to_record('{\"a\":1,\"b\":[1,2,3],\"c\":\"bar\"}') as x(a "
"int, b text, d text)"

#: func.xml:11274(programlisting)
#, no-wrap
msgid ""
" a |    b    | d\n"
"---+---------+---\n"
" 1 | [1,2,3] |"
msgstr ""
" a |    b    | d\n"
"---+---------+---\n"
" 1 | [1,2,3] |"

#: func.xml:11282(literal)
msgid "json_to_recordset(json)"
msgstr "json_to_recordset(json)"

#: func.xml:11283(literal)
msgid "jsonb_to_recordset(jsonb)"
msgstr "jsonb_to_recordset(jsonb)"

#: func.xml:11286(entry)
msgid ""
"Builds an arbitrary set of records from a JSON array of objects (see note "
"below). As with all functions returning <type>record</type>, the caller must "
"explicitly define the structure of the record with an <literal>AS</literal> "
"clause."
msgstr ""
"Формирует обычный набор записей из массива объекта JSON (см. примечания "
"ниже). Как и со всеми функциями, возвращающими <type>record</type>, при "
"вызове необходимо явно определить структуру записи с помощью предложения "
"<literal>AS</literal>."

#: func.xml:11292(literal)
msgid ""
"select * from json_to_recordset('[{\"a\":1,\"b\":\"foo\"},{\"a\":\"2\",\"c\":"
"\"bar\"}]') as x(a int, b text);"
msgstr ""
"select * from json_to_recordset('[{\"a\":1,\"b\":\"foo\"},{\"a\":\"2\",\"c\":"
"\"bar\"}]') as x(a int, b text);"

#: func.xml:11294(programlisting)
#, no-wrap
msgid ""
" a |  b\n"
"---+-----\n"
" 1 | foo\n"
" 2 |"
msgstr ""
" a |  b\n"
"---+-----\n"
" 1 | foo\n"
" 2 |"

#: func.xml:11303(literal)
msgid "json_strip_nulls(from_json json)"
msgstr "json_strip_nulls(from_json json)"

#: func.xml:11304(literal)
msgid "jsonb_strip_nulls(from_json jsonb)"
msgstr "jsonb_strip_nulls(from_json jsonb)"

#: func.xml:11307(entry)
msgid ""
"Returns <replaceable>from_json</replaceable> with all object fields that "
"have null values omitted. Other null values are untouched."
msgstr ""
"Возвращает значение <replaceable>from_json</replaceable>, из которого "
"исключаются все поля объекта, содержащие значения NULL. Другие значения NULL "
"остаются нетронутыми."

#: func.xml:11312(literal)
msgid "json_strip_nulls('[{\"f1\":1,\"f2\":null},2,null,3]')"
msgstr "json_strip_nulls('[{\"f1\":1,\"f2\":null},2,null,3]')"

#: func.xml:11313(literal)
msgid "[{\"f1\":1},2,null,3]"
msgstr "[{\"f1\":1},2,null,3]"

#: func.xml:11316(parameter)
msgid "create_missing"
msgstr "create_missing"

#: func.xml:11316(literal)
msgid "jsonb_set(target jsonb, path text[], new_value jsonb<placeholder-1/>)"
msgstr "jsonb_set(target jsonb, path text[], new_value jsonb<placeholder-1/>)"

#: func.xml:11319(entry)
msgid ""
"Returns <replaceable>target</replaceable> with the section designated by "
"<replaceable>path</replaceable> replaced by <replaceable>new_value</"
"replaceable>, or with <replaceable>new_value</replaceable> added if "
"<replaceable>create_missing</replaceable> is true ( default is "
"<literal>true</literal>) and the item designated by <replaceable>path</"
"replaceable> does not exist. As with the path orientated operators, negative "
"integers that appear in <replaceable>path</replaceable> count from the end "
"of JSON arrays."
msgstr ""
"Возвращает значение <replaceable>target</replaceable>, в котором раздел с "
"заданным путём (<replaceable>path</replaceable>) заменяется новым значением "
"(<replaceable>new_value</replaceable>), либо в него добавляется значение "
"<replaceable>new_value</replaceable>, если аргумент "
"<replaceable>create_missing</replaceable> равен <literal>true</literal> (это "
"значение по умолчанию) и элемент, на который ссылается <replaceable>path</"
"replaceable>, не существует. Как и с операторами, рассчитанными на пути, "
"отрицательные числа в пути (<replaceable>path</replaceable>) обозначают "
"отсчёт от конца массивов JSON."

#: func.xml:11331(literal)
msgid ""
"jsonb_set('[{\"f1\":1,\"f2\":null},2,null,3]', '{0,f1}','[2,3,4]', false)"
msgstr ""
"jsonb_set('[{\"f1\":1,\"f2\":null},2,null,3]', '{0,f1}','[2,3,4]', false)"

#: func.xml:11332(literal)
msgid "jsonb_set('[{\"f1\":1,\"f2\":null},2]', '{0,f3}','[2,3,4]')"
msgstr "jsonb_set('[{\"f1\":1,\"f2\":null},2]', '{0,f3}','[2,3,4]')"

#: func.xml:11334(literal)
msgid "[{\"f1\":[2,3,4],\"f2\":null},2,null,3]"
msgstr "[{\"f1\":[2,3,4],\"f2\":null},2,null,3]"

#: func.xml:11335(literal)
msgid "[{\"f1\": 1, \"f2\": null, \"f3\": [2, 3, 4]}, 2]"
msgstr "[{\"f1\": 1, \"f2\": null, \"f3\": [2, 3, 4]}, 2]"

#: func.xml:11341(parameter)
msgid "insert_after"
msgstr "insert_after"

#: func.xml:11340(literal)
msgid ""
"jsonb_insert(target jsonb, path text[], new_value jsonb, "
"<optional><placeholder-1/> <placeholder-2/></optional>)"
msgstr ""
"jsonb_insert(target jsonb, path text[], new_value jsonb, "
"<optional><placeholder-1/> <placeholder-2/></optional>)"

#: func.xml:11345(entry)
msgid ""
"Returns <replaceable>target</replaceable> with <replaceable>new_value</"
"replaceable> inserted. If <replaceable>target</replaceable> section "
"designated by <replaceable>path</replaceable> is in a JSONB array, "
"<replaceable>new_value</replaceable> will be inserted before target or after "
"if <replaceable>insert_after</replaceable> is true (default is "
"<literal>false</literal>). If <replaceable>target</replaceable> section "
"designated by <replaceable>path</replaceable> is in JSONB object, "
"<replaceable>new_value</replaceable> will be inserted only if "
"<replaceable>target</replaceable> does not exist. As with the path "
"orientated operators, negative integers that appear in <replaceable>path</"
"replaceable> count from the end of JSON arrays."
msgstr ""
"Возвращает значение <replaceable>target</replaceable> с вставленным в него "
"новым значением <replaceable>new_value</replaceable>. Если место в "
"<replaceable>target</replaceable>, выбранное путём <replaceable>path</"
"replaceable>, оказывается в массиве JSONB, <replaceable>new_value</"
"replaceable> будет вставлен до (по умолчанию) или после (если параметр "
"<replaceable>insert_after</replaceable> равен true) выбранной позиции. Если "
"место в <replaceable>target</replaceable>, выбранное путём "
"<replaceable>path</replaceable>, оказывается в объекте JSONB, значение "
"<replaceable>new_value</replaceable> будет вставлено в него, только если "
"заданный путь <replaceable>path</replaceable> не существует. Как и с "
"операторами, рассчитанными на пути, отрицательные числа в пути "
"(<replaceable>path</replaceable>) обозначают отсчёт от конца массивов JSON."

#: func.xml:11360(literal)
msgid "jsonb_insert('{\"a\": [0,1,2]}', '{a, 1}', '\"new_value\"')"
msgstr "jsonb_insert('{\"a\": [0,1,2]}', '{a, 1}', '\"new_value\"')"

#: func.xml:11363(literal)
msgid "jsonb_insert('{\"a\": [0,1,2]}', '{a, 1}', '\"new_value\"', true)"
msgstr "jsonb_insert('{\"a\": [0,1,2]}', '{a, 1}', '\"new_value\"', true)"

#: func.xml:11367(literal)
msgid "{\"a\": [0, \"new_value\", 1, 2]}"
msgstr "{\"a\": [0, \"new_value\", 1, 2]}"

#: func.xml:11368(literal)
msgid "{\"a\": [0, 1, \"new_value\", 2]}"
msgstr "{\"a\": [0, 1, \"new_value\", 2]}"

#: func.xml:11372(literal)
msgid "jsonb_pretty(from_json jsonb)"
msgstr "jsonb_pretty(from_json jsonb)"

#: func.xml:11375(entry)
msgid "Returns <replaceable>from_json</replaceable> as indented JSON text."
msgstr ""
"Возвращает значение <replaceable>from_json</replaceable> в виде текста JSON "
"с отступами."

#: func.xml:11379(literal)
msgid "jsonb_pretty('[{\"f1\":1,\"f2\":null},2,null,3]')"
msgstr "jsonb_pretty('[{\"f1\":1,\"f2\":null},2,null,3]')"

#: func.xml:11381(programlisting)
#, no-wrap
msgid ""
"[\n"
"    {\n"
"        \"f1\": 1,\n"
"        \"f2\": null\n"
"    },\n"
"    2,\n"
"    null,\n"
"    3\n"
"]"
msgstr ""
"[\n"
"    {\n"
"        \"f1\": 1,\n"
"        \"f2\": null\n"
"    },\n"
"    2,\n"
"    null,\n"
"    3\n"
"]"

#: func.xml:11399(para)
msgid ""
"Many of these functions and operators will convert Unicode escapes in JSON "
"strings to the appropriate single character. This is a non-issue if the "
"input is type <type>jsonb</type>, because the conversion was already done; "
"but for <type>json</type> input, this may result in throwing an error, as "
"noted in <xref linkend=\"datatype-json\"/>."
msgstr ""
"Многие из этих функций и операторов преобразуют спецпоследовательности "
"Unicode в JSON-строках в соответствующие одиночные символы. Для входных "
"данных типа <type>jsonb</type> это ничем не грозит, так как преобразование "
"уже выполнено; однако для типа <type>json</type> в результате может "
"произойти ошибка, как отмечено в <xref remap=\"6\" linkend=\"datatype-json\"/"
">."

#: func.xml:11409(para)
msgid ""
"In <function>json_populate_record</function>, "
"<function>json_populate_recordset</function>, <function>json_to_record</"
"function> and <function>json_to_recordset</function>, type coercion from the "
"JSON is <quote>best effort</quote> and may not result in desired values for "
"some types. JSON keys are matched to identical column names in the target "
"row type. JSON fields that do not appear in the target row type will be "
"omitted from the output, and target columns that do not match any JSON field "
"will simply be NULL."
msgstr ""
"В <function>json_populate_record</function>, "
"<function>json_populate_recordset</function>, <function>json_to_record</"
"function> и <function>json_to_recordset</function> приведение типов из JSON "
"выполняется <quote>насколько это возможно</quote> и его результаты могут "
"быть не вполне ожидаемыми для некоторых типов. Ключи JSON сопоставляются с "
"идентичными именами столбцов в целевом типе записей. Поля JSON, "
"отсутствующие в целевом типе, в выходные данные не попадают, а целевые "
"столбцы, для которых нет соответствующих полей JSON, будут просто содержать "
"NULL."

#: func.xml:11421(para)
msgid ""
"All the items of the <literal>path</literal> parameter of "
"<literal>jsonb_set</literal> as well as <literal>jsonb_insert</literal> "
"except the last item must be present in the <literal>target</literal>. If "
"<literal>create_missing</literal> is false, all items of the <literal>path</"
"literal> parameter of <literal>jsonb_set</literal> must be present. If these "
"conditions are not met the <literal>target</literal> is returned unchanged."
msgstr ""
"В <literal>target</literal> должны присутствовать все элементы пути, "
"заданного параметром <literal>path</literal> функций <literal>jsonb_set</"
"literal> и <literal>jsonb_insert</literal>, за исключением последнего. Если "
"<literal>create_missing</literal> равен false, должны присутствовать "
"абсолютно все элементы пути <literal>path</literal>, переданного функции "
"<literal>jsonb_set</literal>. Если это условие не выполняется, значение "
"<literal>target</literal> возвращается неизменённым."

#: func.xml:11429(para)
msgid ""
"If the last path item is an object key, it will be created if it is absent "
"and given the new value. If the last path item is an array index, if it is "
"positive the item to set is found by counting from the left, and if negative "
"by counting from the right - <literal>-1</literal> designates the rightmost "
"element, and so on. If the item is out of the range -array_length .. "
"array_length -1, and create_missing is true, the new value is added at the "
"beginning of the array if the item is negative, and at the end of the array "
"if it is positive."
msgstr ""
"Если последним элементом пути оказывается ключ объекта, он будет создан в "
"случае отсутствия и получит новое значение. Если последний элемент пути — "
"позиция в массиве, то когда она положительна, целевой элемент отсчитывается "
"слева, а когда отрицательна — справа, то есть <literal>-1</literal> "
"указывает на самый правый элемент и т. д. Если позиция лежит вне диапазона -"
"длина_массива .. длина_массива -1, и параметр create_missing равен true, "
"новое значение добавляется в начало массива, если позиция отрицательна, и в "
"конец, если положительна."

#: func.xml:11443(para)
msgid ""
"The <literal>json_typeof</literal> function's <literal>null</literal> return "
"value should not be confused with a SQL NULL. While calling "
"<literal>json_typeof('null'::json)</literal> will return <literal>null</"
"literal>, calling <literal>json_typeof(NULL::json)</literal> will return a "
"SQL NULL."
msgstr ""
"Значение <literal>null</literal>, возвращаемое функцией "
"<literal>json_typeof</literal>, не следует путать с SQL NULL. Тогда как при "
"вызове <literal>json_typeof('null'::json)</literal> возвращается "
"<literal>null</literal>, при вызове <literal>json_typeof(NULL::json)</"
"literal> будет возвращено значение SQL NULL."

#: func.xml:11453(para)
msgid ""
"If the argument to <literal>json_strip_nulls</literal> contains duplicate "
"field names in any object, the result could be semantically somewhat "
"different, depending on the order in which they occur. This is not an issue "
"for <literal>jsonb_strip_nulls</literal> since <type>jsonb</type> values "
"never have duplicate object field names."
msgstr ""
"Если аргумент функции <literal>json_strip_nulls</literal> содержит "
"повторяющиеся имена полей в любом объекте, в результате могут проявиться "
"семантические различия, в зависимости от порядка этих полей. Это не проблема "
"для функции <literal>jsonb_strip_nulls</literal>, так как в значениях "
"<type>jsonb</type> имена полей не могут дублироваться."

#: func.xml:11462(para)
msgid ""
"See also <xref linkend=\"functions-aggregate\"/> for the aggregate function "
"<function>json_agg</function> which aggregates record values as JSON, and "
"the aggregate function <function>json_object_agg</function> which aggregates "
"pairs of values into a JSON object, and their <type>jsonb</type> "
"equivalents, <function>jsonb_agg</function> and <function>jsonb_object_agg</"
"function>."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-aggregate\"/> вы также можете узнать "
"об агрегатной функции <function>json_agg</function>, которая агрегирует "
"значения записи в виде JSON, и агрегатной функции <function>json_object_agg</"
"function>, агрегирующей пары значений в объект JSON, а также их аналогах для "
"<type>jsonb</type>, функциях <function>jsonb_agg</function> и "
"<function>jsonb_object_agg</function>."

#: func.xml:11474(title)
msgid "Sequence Manipulation Functions"
msgstr "Функции для работы с последовательностями"

#: func.xml:11476(indexterm)
msgid "<primary>sequence</primary>"
msgstr "<primary>последовательность</primary>"

#: func.xml:11479(indexterm)
msgid "<primary>nextval</primary>"
msgstr "<primary>nextval</primary>"

#: func.xml:11482(indexterm)
msgid "<primary>currval</primary>"
msgstr "<primary>currval</primary>"

#: func.xml:11485(indexterm)
msgid "<primary>lastval</primary>"
msgstr "<primary>lastval</primary>"

#: func.xml:11488(indexterm)
msgid "<primary>setval</primary>"
msgstr "<primary>setval</primary>"

#: func.xml:11492(para)
msgid ""
"This section describes functions for operating on <firstterm>sequence "
"objects</firstterm>, also called sequence generators or just sequences. "
"Sequence objects are special single-row tables created with <xref linkend="
"\"sql-createsequence\"/>. Sequence objects are commonly used to generate "
"unique identifiers for rows of a table. The sequence functions, listed in "
"<xref linkend=\"functions-sequence-table\"/>, provide simple, multiuser-safe "
"methods for obtaining successive sequence values from sequence objects."
msgstr ""
"В этом разделе описаны функции для работы с объектами, представляющими "
"<firstterm>последовательности</firstterm>. Такие объекты (также называемыми "
"генераторами последовательностей или просто последовательностями) являются "
"специальными таблицами из одной строки и создаются командой <xref linkend="
"\"sql-createsequence\"/>. Используются они обычно для получения уникальных "
"идентификаторов строк таблицы. Функции, перечисленные в <xref remap=\"6\" "
"linkend=\"functions-sequence-table\"/>, предоставляют простые и безопасные "
"для параллельного использования методы получения очередных значений таких "
"последовательностей."

#: func.xml:11505(title)
msgid "Sequence Functions"
msgstr "Функции для работы с последовательностями"

#: func.xml:11513(type) func.xml:11525(type) func.xml:11530(type)
#: func.xml:11535(type) func.xml:16507(type) func.xml:18624(type)
#: func.xml:18633(type) func.xml:18644(type) func.xml:18682(type)
#: func.xml:18706(type) func.xml:18855(type) func.xml:18864(type)
#: func.xml:18875(type) func.xml:18941(type) func.xml:18948(type)
msgid "regclass"
msgstr "regclass"

#: func.xml:11513(function)
msgid "currval(<placeholder-1/>)"
msgstr "currval(<placeholder-1/>)"

#: func.xml:11515(entry)
msgid ""
"Return value most recently obtained with <function>nextval</function> for "
"specified sequence"
msgstr ""
"Выдаёт значение заданной последовательности, которое было возвращено при "
"последнем вызове функции <function>nextval</function>"

#: func.xml:11519(function)
msgid "lastval()"
msgstr "lastval()"

#: func.xml:11521(entry)
msgid ""
"Return value most recently obtained with <function>nextval</function> for "
"any sequence"
msgstr ""
"Выдаёт значение любой последовательности, которое было возвращено при "
"последнем вызове функции <function>nextval</function>"

#: func.xml:11525(function)
msgid "nextval(<placeholder-1/>)"
msgstr "nextval(<placeholder-1/>)"

#: func.xml:11527(entry)
msgid "Advance sequence and return new value"
msgstr "Продвигает последовательность к следующему значению и возвращает его"

#: func.xml:11530(function)
msgid "setval(<placeholder-1/>, <placeholder-2/>)"
msgstr "setval(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:11532(entry)
msgid "Set sequence's current value"
msgstr "Устанавливает текущее значение последовательности"

#: func.xml:11535(function)
msgid "setval(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "setval(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:11537(entry)
msgid "Set sequence's current value and <literal>is_called</literal> flag"
msgstr ""
"Устанавливает текущее значение последовательности и флаг <literal>is_called</"
"literal>, указывающий на то, что это значение использовалось"

#: func.xml:11553(programlisting)
#, no-wrap
msgid ""
"nextval('foo')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>\n"
"nextval('FOO')      <lineannotation>operates on sequence <literal>foo</literal></lineannotation>\n"
"nextval('\"Foo\"')    <lineannotation>operates on sequence <literal>Foo</literal></lineannotation>"
msgstr ""
"nextval('foo')      <lineannotation>обращается к последовательности <literal>foo</literal></lineannotation>\n"
"nextval('FOO')      <lineannotation>обращается к последовательности <literal>foo</literal></lineannotation>\n"
"nextval('\"Foo\"')    <lineannotation>обращается к последовательности <literal>Foo</literal></lineannotation>"

#: func.xml:11559(programlisting)
#, no-wrap
msgid ""
"nextval('myschema.foo')     <lineannotation>operates on <literal>myschema.foo</literal></lineannotation>\n"
"nextval('\"myschema\".foo')   <lineannotation>same as above</lineannotation>\n"
"nextval('foo')              <lineannotation>searches search path for <literal>foo</literal></lineannotation>"
msgstr ""
"nextval('myschema.foo')     <lineannotation>обращается к <literal>myschema.foo</literal></lineannotation>\n"
"nextval('\"myschema\".foo')   <lineannotation>то же самое</lineannotation>\n"
"nextval('foo')              <lineannotation>ищет <literal>foo</literal> в пути поиска</lineannotation>"

#: func.xml:11543(para)
msgid ""
"The sequence to be operated on by a sequence function is specified by a "
"<type>regclass</type> argument, which is simply the OID of the sequence in "
"the <structname>pg_class</structname> system catalog. You do not have to "
"look up the OID by hand, however, since the <type>regclass</type> data "
"type's input converter will do the work for you. Just write the sequence "
"name enclosed in single quotes so that it looks like a literal constant. For "
"compatibility with the handling of ordinary <acronym>SQL</acronym> names, "
"the string will be converted to lower case unless it contains double quotes "
"around the sequence name. Thus: <placeholder-1/> The sequence name can be "
"schema-qualified if necessary: <placeholder-2/> See <xref linkend=\"datatype-"
"oid\"/> for more information about <type>regclass</type>."
msgstr ""
"Последовательность, к которой будет обращаться одна из этих функций, "
"определяется аргументом <type>regclass</type>, задающим просто OID "
"последовательности в системном каталоге <structname>pg_class</structname>. "
"Вычислять этот OID вручную не нужно, так как процедура ввода данных "
"<type>regclass</type> автоматически выполнит эту работу за вас. Просто "
"запишите имя последовательности в апострофах, чтобы оно выглядело как "
"строковая константа. Для совместимости с обычными именами <acronym>SQL</"
"acronym> эта строка будет переведена в нижний регистр, если только она не "
"заключена в кавычки. Например: <placeholder-1/> При необходимости имя "
"последовательности можно дополнить именем схемы: <placeholder-2/> Подробнее "
"тип <type>regclass</type> описан в <xref remap=\"6\" linkend=\"datatype-oid"
"\"/>."

#: func.xml:11569(para)
msgid ""
"Before <productname>PostgreSQL</productname> 8.1, the arguments of the "
"sequence functions were of type <type>text</type>, not <type>regclass</"
"type>, and the above-described conversion from a text string to an OID value "
"would happen at run time during each call. For backward compatibility, this "
"facility still exists, but internally it is now handled as an implicit "
"coercion from <type>text</type> to <type>regclass</type> before the function "
"is invoked."
msgstr ""
"В <productname>PostgreSQL</productname> до версии 8.1 аргументы этих функций "
"имели тип <type>text</type>, а не <type>regclass</type>, и поэтому описанное "
"выше преобразование текстовой строки в OID имело место при каждом вызове "
"функции. Это поведение сохраняется и сейчас для обратной совместимости, но "
"сейчас оно реализовано как неявное приведение типа <type>text</type> к типу "
"<type>regclass</type> перед вызовом функции."

#: func.xml:11589(programlisting)
#, no-wrap
msgid "nextval('foo'::text)      <lineannotation><literal>foo</literal> is looked up at runtime</lineannotation>"
msgstr "nextval('foo'::text)      <lineannotation><literal>foo</literal> распознаётся во время выполнения</lineannotation>"

#: func.xml:11579(para)
msgid ""
"When you write the argument of a sequence function as an unadorned literal "
"string, it becomes a constant of type <type>regclass</type>. Since this is "
"really just an OID, it will track the originally identified sequence despite "
"later renaming, schema reassignment, etc. This <quote>early binding</quote> "
"behavior is usually desirable for sequence references in column defaults and "
"views. But sometimes you might want <quote>late binding</quote> where the "
"sequence reference is resolved at run time. To get late-binding behavior, "
"force the constant to be stored as a <type>text</type> constant instead of "
"<type>regclass</type>: <placeholder-1/> Note that late binding was the only "
"behavior supported in <productname>PostgreSQL</productname> releases before "
"8.1, so you might need to do this to preserve the semantics of old "
"applications."
msgstr ""
"Когда вы записываете аргумент функции, работающей с последовательностью, как "
"текстовую строку в чистом виде, она становится константой типа "
"<type>regclass</type>. Так как фактически это будет просто значение OID, оно "
"будет привязано к изначально идентифицированной последовательности, несмотря "
"на то, что она может быть переименована, перенесена в другую схему и т. д. "
"Такое <quote>раннее связывание</quote> обычно желательно для ссылок на "
"последовательности в значениях столбцов по умолчанию и представлениях. Но "
"иногда возникает необходимость в <quote>позднем связывании</quote>, когда "
"ссылки на последовательности распознаются в процессе выполнения. Чтобы "
"получить такое поведение, нужно принудительно изменить тип константы с "
"<type>regclass</type> на <type>text</type>: <placeholder-1/> Заметьте, что "
"версии <productname>PostgreSQL</productname> до 8.1 поддерживали только "
"позднее связывание, так что это может быть полезно и для совместимости со "
"старыми приложениями."

#: func.xml:11597(para)
msgid ""
"Of course, the argument of a sequence function can be an expression as well "
"as a constant. If it is a text expression then the implicit coercion will "
"result in a run-time lookup."
msgstr ""
"Конечно же, аргументом таких функций может быть не только константа, но и "
"выражение. Если это выражение текстового типа, неявное приведение типов "
"повлечёт разрешение имени во время выполнения."

#: func.xml:11609(function)
msgid "nextval"
msgstr "nextval"

#: func.xml:11611(para)
msgid ""
"Advance the sequence object to its next value and return that value. This is "
"done atomically: even if multiple sessions execute <function>nextval</"
"function> concurrently, each will safely receive a distinct sequence value."
msgstr ""
"Продвигает последовательность к следующему значению и возвращает его. Это "
"атомарная операция: если <function>nextval</function> вызывается "
"одновременно в нескольких сеансах, в результате каждого вызова будут "
"гарантированно получены разные значения."

#: func.xml:11618(para)
msgid ""
"If a sequence object has been created with default parameters, successive "
"<function>nextval</function> calls will return successive values beginning "
"with 1. Other behaviors can be obtained by using special parameters in the "
"<xref linkend=\"sql-createsequence\"/> command; see its command reference "
"page for more information."
msgstr ""
"Если последовательность создаётся с параметрами по умолчанию, успешные "
"вызовы <function>nextval</function> получают очередные значения по "
"возрастанию, начиная с 1. Другое поведение можно получить с помощью "
"специальных параметров в команде <xref linkend=\"sql-createsequence\"/>; "
"подробнее это описано на странице описания команды."

#: func.xml:11627(para)
msgid ""
"To avoid blocking concurrent transactions that obtain numbers from the same "
"sequence, a <function>nextval</function> operation is never rolled back; "
"that is, once a value has been fetched it is considered used and will not be "
"returned again. This is true even if the surrounding transaction later "
"aborts, or if the calling query ends up not using the value. For example an "
"<command>INSERT</command> with an <literal>ON CONFLICT</literal> clause will "
"compute the to-be-inserted tuple, including doing any required "
"<function>nextval</function> calls, before detecting any conflict that would "
"cause it to follow the <literal>ON CONFLICT</literal> rule instead. Such "
"cases will leave unused <quote>holes</quote> in the sequence of assigned "
"values. Thus, <productname>PostgreSQL</productname> sequence objects "
"<emphasis>cannot be used to obtain <quote>gapless</quote> sequences</"
"emphasis>."
msgstr ""
"Во избежание блокирования параллельных транзакций, пытающихся получить "
"значения одной последовательности, операция <function>nextval</function> "
"никогда не откатывается; то есть, как только значение было выбрано, оно "
"считается использованным и не будет возвращено снова. Это утверждение верно, "
"даже когда окружающая транзакция впоследствии прерывается или вызывающий "
"запрос никак не использует это значение. Например, команда <command>INSERT</"
"command> с предложением <literal>ON CONFLICT</literal> вычислит кортеж, "
"претендующий на добавление, произведя все требуемые вызовы "
"<function>nextval</function>, прежде чем выявит конфликты, которые могут "
"привести к отработке правил <literal>ON CONFLICT</literal> вместо "
"добавления. В таких ситуациях в последовательности задействованных значений "
"могут образовываться <quote>дыры</quote>. Таким образом, объекты "
"последовательностей <productname>PostgreSQL</productname> <emphasis>не "
"годятся для получения непрерывных последовательностей</emphasis>."

#: func.xml:11648(function)
msgid "currval"
msgstr "currval"

#: func.xml:11650(para)
msgid ""
"Return the value most recently obtained by <function>nextval</function> for "
"this sequence in the current session. (An error is reported if "
"<function>nextval</function> has never been called for this sequence in this "
"session.) Because this is returning a session-local value, it gives a "
"predictable answer whether or not other sessions have executed "
"<function>nextval</function> since the current session did."
msgstr ""
"Возвращает значение, выданное при последнем вызове <function>nextval</"
"function> для этой последовательности в текущем сеансе. (Если в данном "
"сеансе <function>nextval</function> ни разу не вызывалась для данной "
"последовательности, возвращается ошибка.) Так как это значение ограничено "
"рамками сеанса, эта функция выдаёт предсказуемый результат вне зависимости "
"от того, вызвалась ли впоследствии <function>nextval</function> в других "
"сеансах или нет."

#: func.xml:11663(function)
msgid "lastval"
msgstr "lastval"

#: func.xml:11665(para)
msgid ""
"Return the value most recently returned by <function>nextval</function> in "
"the current session. This function is identical to <function>currval</"
"function>, except that instead of taking the sequence name as an argument it "
"refers to whichever sequence <function>nextval</function> was most recently "
"applied to in the current session. It is an error to call <function>lastval</"
"function> if <function>nextval</function> has not yet been called in the "
"current session."
msgstr ""
"Возвращает значение, выданное при последнем вызове <function>nextval</"
"function> в текущем сеансе. Эта функция подобна <function>currval</"
"function>, но она не принимает в параметрах имя последовательности, а "
"обращается к той последовательности, для которой вызывалась "
"<function>nextval</function> в последний раз в текущем сеансе. Если в "
"текущем сеансе функция <function>nextval</function> ещё не вызывалась, при "
"вызове <function>lastval</function> произойдёт ошибка."

#: func.xml:11679(function)
msgid "setval"
msgstr "setval"

#: func.xml:11681(para)
msgid ""
"Reset the sequence object's counter value. The two-parameter form sets the "
"sequence's <literal>last_value</literal> field to the specified value and "
"sets its <literal>is_called</literal> field to <literal>true</literal>, "
"meaning that the next <function>nextval</function> will advance the sequence "
"before returning a value. The value reported by <function>currval</function> "
"is also set to the specified value. In the three-parameter form, "
"<literal>is_called</literal> can be set to either <literal>true</literal> or "
"<literal>false</literal>. <literal>true</literal> has the same effect as the "
"two-parameter form. If it is set to <literal>false</literal>, the next "
"<function>nextval</function> will return exactly the specified value, and "
"sequence advancement commences with the following <function>nextval</"
"function>. Furthermore, the value reported by <function>currval</function> "
"is not changed in this case. For example, <screen>\n"
"SELECT setval('foo', 42);           <lineannotation>Next <function>nextval</"
"function> will return 43</lineannotation>\n"
"SELECT setval('foo', 42, true);     <lineannotation>Same as above</"
"lineannotation>\n"
"SELECT setval('foo', 42, false);    <lineannotation>Next <function>nextval</"
"function> will return 42</lineannotation>\n"
"</screen> The result returned by <function>setval</function> is just the "
"value of its second argument."
msgstr ""
"Сбрасывает счётчик последовательности. В форме с двумя параметрами "
"устанавливает для последовательности заданное значение поля "
"<literal>last_value</literal> и значение <literal>true</literal> для флага "
"<literal>is_called</literal>, показывающего, что при следующем вызове "
"<function>nextval</function> последовательность должна сначала продвинуться "
"к очередному значению, которое будет возвращено. При этом <function>currval</"
"function> также возвратит заданное значение. В форме с тремя параметрами "
"флагу <literal>is_called</literal> можно присвоить <literal>true</literal> "
"или <literal>false</literal>. Со значением <literal>true</literal> она "
"действует так же, как и форма с двумя параметрами. Если же присвоить этому "
"флагу значение <literal>false</literal>, первый вызов <function>nextval</"
"function> после этого вернёт именно заданное значение, а продвижение "
"последовательности произойдёт при последующем вызове <function>nextval</"
"function>. Кроме того, значение, возвращаемое <function>currval</function> в "
"этом случае, не меняется. Например, <screen>\n"
"SELECT setval('foo', 42);           <lineannotation>Следующий вызов "
"<function>nextval</function> вернёт 43</lineannotation>\n"
"SELECT setval('foo', 42, true);     <lineannotation>То же самое</"
"lineannotation>\n"
"SELECT setval('foo', 42, false);    <lineannotation>Следующий вызов "
"<function>nextval</function> вернёт 42</lineannotation>\n"
"</screen> Результатом самой функции <function>setval</function> будет просто "
"значение её второго аргумента."

#: func.xml:11707(para)
msgid ""
"Because sequences are non-transactional, changes made by <function>setval</"
"function> are not undone if the transaction rolls back."
msgstr ""
"Так как значения последовательностей изменяются вне транзакций, действие "
"функции <function>setval</function> не отменяется при откате транзакции."

#: func.xml:11604(para)
msgid "The available sequence functions are: <placeholder-1/>"
msgstr ""
"Ниже описаны все функции, предназначенные для работы с последовательностями: "
"<placeholder-1/>"

#: func.xml:11722(title)
msgid "Conditional Expressions"
msgstr "Условные выражения"

#: func.xml:11724(indexterm)
msgid "<primary>CASE</primary>"
msgstr "<primary>CASE</primary>"

#: func.xml:11728(indexterm)
msgid "<primary>conditional expression</primary>"
msgstr "<primary>условное выражение</primary>"

#: func.xml:11732(para)
msgid ""
"This section describes the <acronym>SQL</acronym>-compliant conditional "
"expressions available in <productname>PostgreSQL</productname>."
msgstr ""
"В этом разделе описаны <acronym>SQL</acronym>-совместимые условные "
"выражения, которые поддерживаются в <productname>PostgreSQL</productname>."

#: func.xml:11738(para)
msgid ""
"If your needs go beyond the capabilities of these conditional expressions, "
"you might want to consider writing a stored procedure in a more expressive "
"programming language."
msgstr ""
"Если возможностей этих условных выражений оказывается недостаточно, "
"вероятно, имеет смысл перейти к написанию хранимых процедур на более мощном "
"языке программирования."

#: func.xml:11746(literal)
msgid "CASE"
msgstr "CASE"

#: func.xml:11748(para)
msgid ""
"The <acronym>SQL</acronym> <token>CASE</token> expression is a generic "
"conditional expression, similar to if/else statements in other programming "
"languages: <synopsis>\n"
"CASE WHEN <replaceable>condition</replaceable> THEN <replaceable>result</"
"replaceable>\n"
"     <optional>WHEN ...</optional>\n"
"     <optional>ELSE <replaceable>result</replaceable></optional>\n"
"END\n"
"</synopsis> <token>CASE</token> clauses can be used wherever an expression "
"is valid. Each <replaceable>condition</replaceable> is an expression that "
"returns a <type>boolean</type> result. If the condition's result is true, "
"the value of the <token>CASE</token> expression is the <replaceable>result</"
"replaceable> that follows the condition, and the remainder of the "
"<token>CASE</token> expression is not processed. If the condition's result "
"is not true, any subsequent <token>WHEN</token> clauses are examined in the "
"same manner. If no <token>WHEN</token> <replaceable>condition</replaceable> "
"yields true, the value of the <token>CASE</token> expression is the "
"<replaceable>result</replaceable> of the <token>ELSE</token> clause. If the "
"<token>ELSE</token> clause is omitted and no condition is true, the result "
"is null."
msgstr ""
"Выражение <token>CASE</token> в <acronym>SQL</acronym> представляет собой "
"общее условное выражение, напоминающее операторы if/else в других языках "
"программирования: <synopsis>\n"
"CASE WHEN <replaceable>условие</replaceable> THEN <replaceable>результат</"
"replaceable>\n"
"     <optional>WHEN ...</optional>\n"
"     <optional>ELSE <replaceable>результат</replaceable></optional>\n"
"END\n"
"</synopsis>Предложения <token>CASE</token> можно использовать везде, где "
"допускаются выражения. Каждое <replaceable>условие</replaceable> в нём "
"представляет собой выражение, возвращающее результат типа <type>boolean</"
"type>. Если результатом выражения оказывается true, значением выражения "
"<token>CASE</token> становится <replaceable>результат</replaceable>, "
"следующий за условием, а остальная часть выражения <token>CASE</token> не "
"вычисляется. Если же условие не выполняется, за ним таким же образом "
"проверяются все последующие предложения <token>WHEN</token>. Если не "
"выполняется ни одно из <replaceable>условий</replaceable> <token>WHEN</"
"token>, значением <token>CASE</token> становится <replaceable>результат</"
"replaceable>, записанный в предложении <token>ELSE</token>. Если при этом "
"предложение <token>ELSE</token> отсутствует, результатом выражения будет "
"NULL."

#: func.xml:11774(para)
msgid ""
"An example: <screen>\n"
"SELECT * FROM test;\n"
"\n"
" a\n"
"---\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"\n"
"SELECT a,\n"
"       CASE WHEN a=1 THEN 'one'\n"
"            WHEN a=2 THEN 'two'\n"
"            ELSE 'other'\n"
"       END\n"
"    FROM test;\n"
"\n"
" a | case\n"
"---+-------\n"
" 1 | one\n"
" 2 | two\n"
" 3 | other\n"
"</screen>"
msgstr ""
"Пример: <screen>\n"
"SELECT * FROM test;\n"
"\n"
" a\n"
"---\n"
" 1\n"
" 2\n"
" 3\n"
"\n"
"\n"
"SELECT a,\n"
"       CASE WHEN a=1 THEN 'one'\n"
"            WHEN a=2 THEN 'two'\n"
"            ELSE 'other'\n"
"       END\n"
"    FROM test;\n"
"\n"
" a | case\n"
"---+-------\n"
" 1 | one\n"
" 2 | two\n"
" 3 | other\n"
"</screen>"

#: func.xml:11801(para)
msgid ""
"The data types of all the <replaceable>result</replaceable> expressions must "
"be convertible to a single output type. See <xref linkend=\"typeconv-union-"
"case\"/> for more details."
msgstr ""
"Типы данных всех выражений <replaceable>результатов</replaceable> должны "
"приводиться к одному выходному типу. Подробнее это описано в <xref remap="
"\"6\" linkend=\"typeconv-union-case\"/>."

#: func.xml:11807(para)
msgid ""
"There is a <quote>simple</quote> form of <token>CASE</token> expression that "
"is a variant of the general form above: <synopsis>\n"
"CASE <replaceable>expression</replaceable>\n"
"    WHEN <replaceable>value</replaceable> THEN <replaceable>result</"
"replaceable>\n"
"    <optional>WHEN ...</optional>\n"
"    <optional>ELSE <replaceable>result</replaceable></optional>\n"
"END\n"
"</synopsis> The first <replaceable>expression</replaceable> is computed, "
"then compared to each of the <replaceable>value</replaceable> expressions in "
"the <token>WHEN</token> clauses until one is found that is equal to it. If "
"no match is found, the <replaceable>result</replaceable> of the <token>ELSE</"
"token> clause (or a null value) is returned. This is similar to the "
"<function>switch</function> statement in C."
msgstr ""
"Существует также <quote>простая</quote> форма выражения <token>CASE</token>, "
"разновидность вышеприведённой общей формы: <synopsis>\n"
"CASE <replaceable>выражение</replaceable>\n"
"    WHEN <replaceable>значение</replaceable> THEN <replaceable>результат</"
"replaceable>\n"
"    <optional>WHEN ...</optional>\n"
"    <optional>ELSE <replaceable>результат</replaceable></optional>\n"
"END\n"
"</synopsis> В такой форме сначала вычисляется первое <replaceable>выражение</"
"replaceable>, а затем его результат сравнивается с выражениями "
"<replaceable>значений</replaceable> в предложениях <token>WHEN</token>, пока "
"не будет найдено равное ему. Если такого не значения не находится, "
"возвращается <replaceable>результат</replaceable> предложения <token>ELSE</"
"token> (или NULL). Эта форма больше похожа на оператор <function>switch</"
"function>, существующий в языке C."

#: func.xml:11828(para)
msgid ""
"The example above can be written using the simple <token>CASE</token> "
"syntax: <screen>\n"
"SELECT a,\n"
"       CASE a WHEN 1 THEN 'one'\n"
"              WHEN 2 THEN 'two'\n"
"              ELSE 'other'\n"
"       END\n"
"    FROM test;\n"
"\n"
" a | case\n"
"---+-------\n"
" 1 | one\n"
" 2 | two\n"
" 3 | other\n"
"</screen>"
msgstr ""
"Показанный ранее пример можно записать по-другому, используя простую форму "
"<token>CASE</token>: <screen>\n"
"SELECT a,\n"
"       CASE a WHEN 1 THEN 'one'\n"
"              WHEN 2 THEN 'two'\n"
"              ELSE 'other'\n"
"       END\n"
"    FROM test;\n"
"\n"
" a | case\n"
"---+-------\n"
" 1 | one\n"
" 2 | two\n"
" 3 | other\n"
"</screen>"

#: func.xml:11851(programlisting)
#, no-wrap
msgid "SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;"
msgstr "SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;"

#: func.xml:11847(para)
msgid ""
"A <token>CASE</token> expression does not evaluate any subexpressions that "
"are not needed to determine the result. For example, this is a possible way "
"of avoiding a division-by-zero failure: <placeholder-1/>"
msgstr ""
"В выражении <token>CASE</token> вычисляются только те подвыражения, которые "
"необходимы для получения результата. Например, так можно избежать ошибки "
"деления на ноль: <placeholder-1/>"

#: func.xml:11857(para)
msgid ""
"As described in <xref linkend=\"syntax-express-eval\"/>, there are various "
"situations in which subexpressions of an expression are evaluated at "
"different times, so that the principle that <quote><token>CASE</token> "
"evaluates only necessary subexpressions</quote> is not ironclad. For example "
"a constant <literal>1/0</literal> subexpression will usually result in a "
"division-by-zero failure at planning time, even if it's within a "
"<token>CASE</token> arm that would never be entered at run time."
msgstr ""
"Как было описано в <xref remap=\"6\" linkend=\"syntax-express-eval\"/>, всё "
"же возможны ситуации, когда подвыражения вычисляются на разных этапах, так "
"что железной гарантии, что в <quote><token>CASE</token> вычисляются только "
"необходимые подвыражения</quote>, в принципе нет. Например, константное "
"подвыражение <literal>1/0</literal> обычно вызывает ошибку деления на ноль "
"на этапе планирования, хотя эта ветвь <token>CASE</token> может вовсе не "
"вычисляться во время выполнения."

#: func.xml:11870(literal)
msgctxt "literal"
msgid "COALESCE"
msgstr "COALESCE"

#: func.xml:11872(indexterm)
msgid "<primary>COALESCE</primary>"
msgstr "<primary>COALESCE</primary>"

#: func.xml:11876(indexterm)
msgid "<primary>NVL</primary>"
msgstr "<primary>NVL</primary>"

#: func.xml:11880(indexterm)
msgid "<primary>IFNULL</primary>"
msgstr "<primary>IFNULL</primary>"

#: func.xml:11885(function)
msgctxt "function"
msgid "COALESCE"
msgstr "COALESCE"

#: func.xml:11884(synopsis) func.xml:11949(synopsis) func.xml:11952(synopsis)
#, no-wrap
msgid "<placeholder-1/>(<placeholder-2/> <placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/> <placeholder-3/>)"

#: func.xml:11893(programlisting)
#, no-wrap
msgid "SELECT COALESCE(description, short_description, '(none)') ..."
msgstr "SELECT COALESCE(description, short_description, '(none)') ..."

#: func.xml:11888(para)
msgid ""
"The <function>COALESCE</function> function returns the first of its "
"arguments that is not null. Null is returned only if all arguments are null. "
"It is often used to substitute a default value for null values when data is "
"retrieved for display, for example: <placeholder-1/> This returns "
"<varname>description</varname> if it is not null, otherwise "
"<varname>short_description</varname> if it is not null, otherwise "
"<literal>(none)</literal>."
msgstr ""
"Функция <function>COALESCE</function> возвращает первый попавшийся аргумент, "
"отличный от NULL. Если же все аргументы равны NULL, результатом тоже будет "
"NULL. Это часто используется при отображении данных для подстановки "
"некоторого значения по умолчанию вместо значений NULL: <placeholder-1/> Этот "
"запрос вернёт значение <varname>description</varname>, если оно не равно "
"NULL, либо <varname>short_description</varname>, если оно не NULL, и строку "
"<literal>(none)</literal>, если оба эти значения равны NULL."

#: func.xml:11900(para)
msgid ""
"Like a <token>CASE</token> expression, <function>COALESCE</function> only "
"evaluates the arguments that are needed to determine the result; that is, "
"arguments to the right of the first non-null argument are not evaluated. "
"This SQL-standard function provides capabilities similar to <function>NVL</"
"function> and <function>IFNULL</function>, which are used in some other "
"database systems."
msgstr ""
"Как и выражение <token>CASE</token>, <function>COALESCE</function> вычисляет "
"только те аргументы, которые необходимы для получения результата; то есть, "
"аргументы правее первого отличного от NULL аргумента не вычисляются. Эта "
"функция соответствует стандарту SQL, а в некоторых других СУБД её аналоги "
"называются <function>NVL</function> и <function>IFNULL</function>."

#: func.xml:11911(literal)
msgctxt "literal"
msgid "NULLIF"
msgstr "NULLIF"

#: func.xml:11913(indexterm)
msgid "<primary>NULLIF</primary>"
msgstr "<primary>NULLIF</primary>"

#: func.xml:11918(function)
msgctxt "function"
msgid "NULLIF"
msgstr "NULLIF"

#: func.xml:11918(replaceable)
msgid "value1"
msgstr "значение1"

#: func.xml:11918(replaceable)
msgid "value2"
msgstr "значение2"

#: func.xml:11917(synopsis)
#, no-wrap
msgctxt "synopsis"
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>)"

#: func.xml:11927(programlisting)
#, no-wrap
msgid "SELECT NULLIF(value, '(none)') ..."
msgstr "SELECT NULLIF(value, '(none)') ..."

#: func.xml:11921(para)
msgid ""
"The <function>NULLIF</function> function returns a null value if "
"<replaceable>value1</replaceable> equals <replaceable>value2</replaceable>; "
"otherwise it returns <replaceable>value1</replaceable>. This can be used to "
"perform the inverse operation of the <function>COALESCE</function> example "
"given above: <placeholder-1/>"
msgstr ""
"Функция <function>NULLIF</function> возвращает значение NULL, если "
"<replaceable>значение1</replaceable> равно <replaceable>значение2</"
"replaceable>; в противном случае она возвращает <replaceable>значение1</"
"replaceable>. Это может быть полезно для реализации обратной операции к "
"<function>COALESCE</function>. В частности, для примера, показанного выше: "
"<placeholder-1/>"

#: func.xml:11931(para)
msgid ""
"In this example, if <literal>value</literal> is <literal>(none)</literal>, "
"null is returned, otherwise the value of <literal>value</literal> is "
"returned."
msgstr ""
"Если аргумент <literal>value</literal> равен <literal>(none)</literal>, "
"результатом выражения будет NULL, а в противном случае &mdash; значение "
"аргумента <literal>value</literal>."

#: func.xml:11940(title)
msgid "<literal>GREATEST</literal> and <literal>LEAST</literal>"
msgstr "<literal>GREATEST</literal> и <literal>LEAST</literal>"

#: func.xml:11942(indexterm)
msgid "<primary>GREATEST</primary>"
msgstr "<primary>GREATEST</primary>"

#: func.xml:11945(indexterm)
msgid "<primary>LEAST</primary>"
msgstr "<primary>LEAST</primary>"

#: func.xml:11950(function)
msgid "GREATEST"
msgstr "GREATEST"

#: func.xml:11953(function)
msgid "LEAST"
msgstr "LEAST"

#: func.xml:11956(para)
msgid ""
"The <function>GREATEST</function> and <function>LEAST</function> functions "
"select the largest or smallest value from a list of any number of "
"expressions. The expressions must all be convertible to a common data type, "
"which will be the type of the result (see <xref linkend=\"typeconv-union-case"
"\"/> for details). NULL values in the list are ignored. The result will be "
"NULL only if all the expressions evaluate to NULL."
msgstr ""
"Функции <function>GREATEST</function> и <function>LEAST</function> выбирают "
"наибольшее или наименьшее значение из списка выражений. Все эти выражения "
"должны приводиться к общему типу данных, который станет типом результата "
"(подробнее об этом в <xref remap=\"6\" linkend=\"typeconv-union-case\"/>). "
"Значения NULL в этом списке игнорируются, так что результат выражения будет "
"равен NULL, только если все его аргументы равны NULL."

#: func.xml:11966(para)
msgid ""
"Note that <function>GREATEST</function> and <function>LEAST</function> are "
"not in the SQL standard, but are a common extension. Some other databases "
"make them return NULL if any argument is NULL, rather than only when all are "
"NULL."
msgstr ""
"Заметьте, что функции <function>GREATEST</function> и <function>LEAST</"
"function> не описаны в стандарте SQL, но часто реализуются в СУБД как "
"расширения. В некоторых других СУБД они могут возвращать NULL, когда не все, "
"а любой из аргументов равен NULL."

#: func.xml:11976(title)
msgid "Array Functions and Operators"
msgstr "Функции и операторы для работы с массивами"

#: func.xml:11978(para)
msgid ""
"<xref linkend=\"array-operators-table\"/> shows the operators available for "
"array types."
msgstr ""
"В <xref remap=\"6\" linkend=\"array-operators-table\"/> показаны операторы, "
"предназначенные для работы с массивами."

#: func.xml:11984(title)
msgid "Array Operators"
msgstr "Операторы для работы с массивами"

#: func.xml:11998(literal)
msgid "ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]"
msgstr "ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]"

#: func.xml:12005(literal)
msgid "ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]"
msgstr "ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]"

#: func.xml:12012(literal)
msgid "ARRAY[1,2,3] &lt; ARRAY[1,2,4]"
msgstr "ARRAY[1,2,3] &lt; ARRAY[1,2,4]"

#: func.xml:12019(literal)
msgid "ARRAY[1,4,3] &gt; ARRAY[1,2,4]"
msgstr "ARRAY[1,4,3] &gt; ARRAY[1,2,4]"

#: func.xml:12025(entry) func.xml:12500(entry)
msgid "less than or equal"
msgstr "меньше или равно"

#: func.xml:12026(literal)
msgid "ARRAY[1,2,3] &lt;= ARRAY[1,2,3]"
msgstr "ARRAY[1,2,3] &lt;= ARRAY[1,2,3]"

#: func.xml:12032(entry) func.xml:12507(entry)
msgid "greater than or equal"
msgstr "больше или равно"

#: func.xml:12033(literal)
msgid "ARRAY[1,4,3] &gt;= ARRAY[1,4,3]"
msgstr "ARRAY[1,4,3] &gt;= ARRAY[1,4,3]"

#: func.xml:12040(literal)
msgid "ARRAY[1,4,3] @&gt; ARRAY[3,1]"
msgstr "ARRAY[1,4,3] @&gt; ARRAY[3,1]"

#: func.xml:12047(literal)
msgid "ARRAY[2,7] &lt;@ ARRAY[1,7,4,2,6]"
msgstr "ARRAY[2,7] &lt;@ ARRAY[1,7,4,2,6]"

#: func.xml:12053(entry)
msgid "overlap (have elements in common)"
msgstr "пересечение (есть общие элементы)"

#: func.xml:12054(literal)
msgid "ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]"
msgstr "ARRAY[1,4,3] &amp;&amp; ARRAY[2,1]"

#: func.xml:12060(entry) func.xml:12067(entry)
msgid "array-to-array concatenation"
msgstr "соединение массива с массивом"

#: func.xml:12061(literal)
msgid "ARRAY[1,2,3] || ARRAY[4,5,6]"
msgstr "ARRAY[1,2,3] || ARRAY[4,5,6]"

#: func.xml:12062(literal)
msgid "{1,2,3,4,5,6}"
msgstr "{1,2,3,4,5,6}"

#: func.xml:12068(literal)
msgid "ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]"
msgstr "ARRAY[1,2,3] || ARRAY[[4,5,6], [7,8,9]]"

#: func.xml:12069(literal)
msgid "{{1,2,3},{4,5,6},{7,8,9}}"
msgstr "{{1,2,3},{4,5,6},{7,8,9}}"

#: func.xml:12074(entry)
msgid "element-to-array concatenation"
msgstr "соединение элемента с массивом"

#: func.xml:12075(literal)
msgid "3 || ARRAY[4,5,6]"
msgstr "3 || ARRAY[4,5,6]"

#: func.xml:12076(literal)
msgid "{3,4,5,6}"
msgstr "{3,4,5,6}"

#: func.xml:12081(entry)
msgid "array-to-element concatenation"
msgstr "соединение массива с элементом"

#: func.xml:12082(literal)
msgid "ARRAY[4,5,6] || 7"
msgstr "ARRAY[4,5,6] || 7"

#: func.xml:12083(literal)
msgid "{4,5,6,7}"
msgstr "{4,5,6,7}"

#: func.xml:12089(para)
msgid ""
"Array comparisons compare the array contents element-by-element, using the "
"default B-tree comparison function for the element data type. In "
"multidimensional arrays the elements are visited in row-major order (last "
"subscript varies most rapidly). If the contents of two arrays are equal but "
"the dimensionality is different, the first difference in the dimensionality "
"information determines the sort order. (This is a change from versions of "
"<productname>PostgreSQL</productname> prior to 8.2: older versions would "
"claim that two arrays with the same contents were equal, even if the number "
"of dimensions or subscript ranges were different.)"
msgstr ""
"Операторы сравнения массивов сравнивают содержимое массивов по элементам, "
"используя при этом функцию сравнения для B-дерева, определённую для типа "
"данного элемента по умолчанию. В многомерных массивах элементы "
"просматриваются по строкам (индекс последней размерности меняется в первую "
"очередь). Если содержимое двух массивов совпадает, а размерности "
"различаются, результат их сравнения будет определяться первым отличием в "
"размерностях. (В <productname>PostgreSQL</productname> до версии 8.2 "
"поведение было другим: два массива с одинаковым содержимом считались "
"одинаковыми, даже если число их размерностей и границы индексов различались.)"

#: func.xml:12102(para)
msgid ""
"See <xref linkend=\"arrays\"/> for more details about array operator "
"behavior. See <xref linkend=\"indexes-types\"/> for more details about which "
"operators support indexed operations."
msgstr ""
"Подробнее поведение операторов с массивами описано в <xref remap=\"6\" "
"linkend=\"arrays\"/>. За дополнительными сведениями об операторах, "
"поддерживающих индексы, обратитесь к <xref remap=\"3\" linkend=\"indexes-"
"types\"/>."

#: func.xml:12108(para)
msgid ""
"<xref linkend=\"array-functions-table\"/> shows the functions available for "
"use with array types. See <xref linkend=\"arrays\"/> for more information "
"and examples of the use of these functions."
msgstr ""
"В <xref remap=\"6\" linkend=\"array-functions-table\"/> перечислены функции, "
"предназначенные для работы с массивами. Дополнительная информация о них и "
"примеры использования приведены в <xref remap=\"6\" linkend=\"arrays\"/>."

#: func.xml:12114(indexterm)
msgid "<primary>array_append</primary>"
msgstr "<primary>array_append</primary>"

#: func.xml:12117(indexterm)
msgid "<primary>array_cat</primary>"
msgstr "<primary>array_cat</primary>"

#: func.xml:12120(indexterm)
msgid "<primary>array_ndims</primary>"
msgstr "<primary>array_ndims</primary>"

#: func.xml:12123(indexterm)
msgid "<primary>array_dims</primary>"
msgstr "<primary>array_dims</primary>"

#: func.xml:12126(indexterm)
msgid "<primary>array_fill</primary>"
msgstr "<primary>array_fill</primary>"

#: func.xml:12129(indexterm)
msgid "<primary>array_length</primary>"
msgstr "<primary>array_length</primary>"

#: func.xml:12132(indexterm)
msgid "<primary>array_lower</primary>"
msgstr "<primary>array_lower</primary>"

#: func.xml:12135(indexterm)
msgid "<primary>array_position</primary>"
msgstr "<primary>array_position</primary>"

#: func.xml:12138(indexterm)
msgid "<primary>array_positions</primary>"
msgstr "<primary>array_positions</primary>"

#: func.xml:12141(indexterm)
msgid "<primary>array_prepend</primary>"
msgstr "<primary>array_prepend</primary>"

#: func.xml:12144(indexterm)
msgid "<primary>array_remove</primary>"
msgstr "<primary>array_remove</primary>"

#: func.xml:12147(indexterm)
msgid "<primary>array_replace</primary>"
msgstr "<primary>array_replace</primary>"

#: func.xml:12150(indexterm)
msgid "<primary>array_to_string</primary>"
msgstr "<primary>array_to_string</primary>"

#: func.xml:12153(indexterm)
msgid "<primary>array_upper</primary>"
msgstr "<primary>array_upper</primary>"

#: func.xml:12156(indexterm)
msgid "<primary>cardinality</primary>"
msgstr "<primary>cardinality</primary>"

#: func.xml:12159(indexterm)
msgid "<primary>string_to_array</primary>"
msgstr "<primary>string_to_array</primary>"

#: func.xml:12162(indexterm)
msgid "<primary>unnest</primary>"
msgstr "<primary>unnest</primary>"

#: func.xml:12167(title)
msgid "Array Functions"
msgstr "Функции для работы с массивами"

#: func.xml:12182(function)
msgid "array_append"
msgstr "array_append"

#: func.xml:12186(entry)
msgid "append an element to the end of an array"
msgstr "добавляет элемент в конец массива"

#: func.xml:12187(literal)
msgid "array_append(ARRAY[1,2], 3)"
msgstr "array_append(ARRAY[1,2], 3)"

#: func.xml:12188(literal) func.xml:12293(literal)
msgid "{1,2,3}"
msgstr "{1,2,3}"

#: func.xml:12193(function)
msgid "array_cat"
msgstr "array_cat"

#: func.xml:12197(entry)
msgid "concatenate two arrays"
msgstr "соединяет два массива"

#: func.xml:12198(literal)
msgid "array_cat(ARRAY[1,2,3], ARRAY[4,5])"
msgstr "array_cat(ARRAY[1,2,3], ARRAY[4,5])"

#: func.xml:12199(literal)
msgid "{1,2,3,4,5}"
msgstr "{1,2,3,4,5}"

#: func.xml:12204(function)
msgid "array_ndims"
msgstr "array_ndims"

#: func.xml:12203(literal) func.xml:12214(literal) func.xml:12343(literal)
#: func.xml:12366(literal) func.xml:12670(literal) func.xml:12681(literal)
#: func.xml:12692(literal) func.xml:12703(literal) func.xml:12714(literal)
#: func.xml:12725(literal) func.xml:12736(literal) func.xml:15854(literal)
msgctxt "literal"
msgid "<placeholder-1/>(<placeholder-2/>)"
msgstr "<placeholder-1/>(<placeholder-2/>)"

#: func.xml:12208(entry)
msgid "returns the number of dimensions of the array"
msgstr "возвращает число размерностей массива"

#: func.xml:12209(literal)
msgid "array_ndims(ARRAY[[1,2,3], [4,5,6]])"
msgstr "array_ndims(ARRAY[[1,2,3], [4,5,6]])"

#: func.xml:12215(function)
msgid "array_dims"
msgstr "array_dims"

#: func.xml:12219(entry)
msgid "returns a text representation of array's dimensions"
msgstr "возвращает текстовое представление размерностей массива"

#: func.xml:12220(literal)
msgid "array_dims(ARRAY[[1,2,3], [4,5,6]])"
msgstr "array_dims(ARRAY[[1,2,3], [4,5,6]])"

#: func.xml:12221(literal)
msgid "[1:2][1:3]"
msgstr "[1:2][1:3]"

#: func.xml:12226(function)
msgid "array_fill"
msgstr "array_fill"

#: func.xml:12226(type) func.xml:12227(type) func.xml:12277(type)
#: func.xml:15362(type)
msgid "int[]"
msgstr "int[]"

#: func.xml:12225(literal) func.xml:12309(literal) func.xml:15672(literal)
#: func.xml:15696(literal) func.xml:15704(literal) func.xml:15719(literal)
#: func.xml:15734(literal) func.xml:15749(literal) func.xml:15764(literal)
#: func.xml:15779(literal) func.xml:15794(literal) func.xml:15809(literal)
#: func.xml:15824(literal) func.xml:15839(literal)
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>, <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/>, <placeholder-4/>)"

#: func.xml:12231(entry)
msgid ""
"returns an array initialized with supplied value and dimensions, optionally "
"with lower bounds other than 1"
msgstr ""
"возвращает массив, заполненный заданным значением и имеющий указанные "
"размерности, в которых нижняя граница может быть отлична от 1"

#: func.xml:12233(literal)
msgid "array_fill(7, ARRAY[3], ARRAY[2])"
msgstr "array_fill(7, ARRAY[3], ARRAY[2])"

#: func.xml:12234(literal)
msgid "[2:4]={7,7,7}"
msgstr "[2:4]={7,7,7}"

#: func.xml:12239(function)
msgid "array_length"
msgstr "array_length"

#: func.xml:12243(entry)
msgid "returns the length of the requested array dimension"
msgstr "возвращает длину указанной размерности массива"

#: func.xml:12244(literal)
msgid "array_length(array[1,2,3], 1)"
msgstr "array_length(array[1,2,3], 1)"

#: func.xml:12250(function)
msgid "array_lower"
msgstr "array_lower"

#: func.xml:12254(entry)
msgid "returns lower bound of the requested array dimension"
msgstr "возвращает нижнюю границу указанной размерности массива"

#: func.xml:12255(literal)
msgid "array_lower('[0:2]={1,2,3}'::int[], 1)"
msgstr "array_lower('[0:2]=&zwsp;{1,2,3}'::int[], 1)"

#: func.xml:12261(function)
msgid "array_position"
msgstr "array_position"

#: func.xml:12260(literal) func.xml:12320(literal) func.xml:12354(literal)
msgctxt "literal"
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:12265(entry)
msgid ""
"returns the subscript of the first occurrence of the second argument in the "
"array, starting at the element indicated by the third argument or at the "
"first element (array must be one-dimensional)"
msgstr ""
"возвращает позицию первого вхождения второго аргумента в массиве, начиная с "
"элемента, выбираемого третьим аргументом, либо с первого элемента (массив "
"должен быть одномерным)"

#: func.xml:12268(literal)
msgid "array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon')"
msgstr ""
"array_position(ARRAY['sun','mon','tue','wed','thu','fri','sat'], 'mon')"

#: func.xml:12274(function)
msgid "array_positions"
msgstr "array_positions"

#: func.xml:12278(entry)
msgid ""
"returns an array of subscripts of all occurrences of the second argument in "
"the array given as first argument (array must be one-dimensional)"
msgstr ""
"возвращает массив с позициями всех вхождений второго аргумента в массиве, "
"задаваемым первым аргументом (массив должен быть одномерным)"

#: func.xml:12281(literal)
msgid "array_positions(ARRAY['A','A','B','A'], 'A')"
msgstr "array_positions(ARRAY['A','A','B','A'], 'A')"

#: func.xml:12282(literal)
msgid "{1,2,4}"
msgstr "{1,2,4}"

#: func.xml:12287(function)
msgid "array_prepend"
msgstr "array_prepend"

#: func.xml:12291(entry)
msgid "append an element to the beginning of an array"
msgstr "вставляет элемент в начало массива"

#: func.xml:12292(literal)
msgid "array_prepend(1, ARRAY[2,3])"
msgstr "array_prepend(1, ARRAY[2,3])"

#: func.xml:12298(function)
msgid "array_remove"
msgstr "array_remove"

#: func.xml:12302(entry)
msgid ""
"remove all elements equal to the given value from the array (array must be "
"one-dimensional)"
msgstr ""
"удаляет из массива все элементы, равные заданному значению (массив должен "
"быть одномерным)"

#: func.xml:12304(literal)
msgid "array_remove(ARRAY[1,2,3,2], 2)"
msgstr "array_remove(ARRAY[1,2,3,2], 2)"

#: func.xml:12305(literal)
msgid "{1,3}"
msgstr "{1,3}"

#: func.xml:12310(function)
msgid "array_replace"
msgstr "array_replace"

#: func.xml:12314(entry)
msgid "replace each array element equal to the given value with a new value"
msgstr ""
"заменяет в массиве все элементы, равные заданному значению, другим значением"

#: func.xml:12315(literal)
msgid "array_replace(ARRAY[1,2,5,4], 5, 3)"
msgstr "array_replace(ARRAY[1,2,5,4], 5, 3)"

#: func.xml:12316(literal)
msgid "{1,2,3,4}"
msgstr "{1,2,3,4}"

#: func.xml:12321(function)
msgid "array_to_string"
msgstr "array_to_string"

#: func.xml:12325(entry)
msgid ""
"concatenates array elements using supplied delimiter and optional null string"
msgstr ""
"выводит элементы массива через заданный разделитель и позволяет определить "
"замену для значения NULL"

#: func.xml:12327(literal)
msgid "array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')"
msgstr "array_to_string(ARRAY[1, 2, 3, NULL, 5], ',', '*')"

#: func.xml:12328(literal)
msgid "1,2,3,*,5"
msgstr "1,2,3,*,5"

#: func.xml:12333(function)
msgid "array_upper"
msgstr "array_upper"

#: func.xml:12337(entry)
msgid "returns upper bound of the requested array dimension"
msgstr "возвращает верхнюю границу указанной размерности массива"

#: func.xml:12338(literal)
msgid "array_upper(ARRAY[1,8,3,7], 1)"
msgstr "array_upper(ARRAY[1,8,3,7], 1)"

#: func.xml:12344(function)
msgid "cardinality"
msgstr "cardinality"

#: func.xml:12348(entry)
msgid ""
"returns the total number of elements in the array, or 0 if the array is empty"
msgstr "возвращает общее число элементов в массиве, либо 0, если массив пуст"

#: func.xml:12349(literal)
msgid "cardinality(ARRAY[[1,2],[3,4]])"
msgstr "cardinality(ARRAY[[1,2],[3,4]])"

#: func.xml:12355(function)
msgid "string_to_array"
msgstr "string_to_array"

#: func.xml:12359(entry)
msgid ""
"splits string into array elements using supplied delimiter and optional null "
"string"
msgstr ""
"разбивает строку на элементы массива, используя заданный разделитель и, "
"возможно, замену для значений NULL"

#: func.xml:12361(literal)
msgid "string_to_array('xx~^~yy~^~zz', '~^~', 'yy')"
msgstr "string_to_array('xx~^~yy~&zwsp;^~zz', '~^~', 'yy')"

#: func.xml:12362(literal)
msgid "{xx,NULL,zz}"
msgstr "{xx,NULL,zz}"

#: func.xml:12367(function) func.xml:12379(function)
msgid "unnest"
msgstr "unnest"

#: func.xml:12371(entry)
msgid "expand an array to a set of rows"
msgstr "разворачивает массив в набор строк"

#: func.xml:12372(literal)
msgid "unnest(ARRAY[1,2])"
msgstr "unnest(ARRAY[1,2])"

#: func.xml:12373(entry)
msgid ""
"<literallayout class=\"monospaced\">1\n"
"2</literallayout>(2 rows)"
msgstr ""
"<literallayout class=\"monospaced\">1\n"
"2</literallayout>(2 строки)"

#: func.xml:12378(literal)
msgid "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> [, ...])"
msgstr "<placeholder-1/>(<placeholder-2/>, <placeholder-3/> [, ...])"

#: func.xml:12382(type)
msgid "setof anyelement, anyelement [, ...]"
msgstr "setof anyelement, anyelement [, ...]"

#: func.xml:12383(entry)
msgid ""
"expand multiple arrays (possibly of different types) to a set of rows. This "
"is only allowed in the FROM clause; see <xref linkend=\"queries-"
"tablefunctions\"/>"
msgstr ""
"разворачивает массивы (возможно разных типов) в набор строк. Это допускается "
"только в предложении FROM; см. <xref remap=\"4\" linkend=\"queries-"
"tablefunctions\"/>"

#: func.xml:12386(literal)
msgid "unnest(ARRAY[1,2],ARRAY['foo','bar','baz'])"
msgstr "unnest(ARRAY[1,2],ARRAY['foo','bar','baz'])"

#: func.xml:12387(entry)
msgid ""
"<literallayout class=\"monospaced\">1    foo\n"
"2    bar\n"
"NULL baz</literallayout>(3 rows)"
msgstr ""
"<literallayout class=\"monospaced\">1    foo\n"
"2    bar\n"
"NULL baz</literallayout>(3 строки)"

#: func.xml:12395(para)
msgid ""
"In <function>array_position</function> and <function>array_positions</"
"function>, each array element is compared to the searched value using "
"<literal>IS NOT DISTINCT FROM</literal> semantics."
msgstr ""
"В функциях <function>array_position</function> и <function>array_positions</"
"function> каждый элемент массива сравнивается с искомым значением по "
"принципу <literal>IS NOT DISTINCT FROM</literal>."

#: func.xml:12401(para)
msgid ""
"In <function>array_position</function>, <literal>NULL</literal> is returned "
"if the value is not found."
msgstr ""
"Функция <function>array_position</function> возвращает <literal>NULL</"
"literal>, если искомое значение не находится."

#: func.xml:12406(para)
msgid ""
"In <function>array_positions</function>, <literal>NULL</literal> is returned "
"only if the array is <literal>NULL</literal>; if the value is not found in "
"the array, an empty array is returned instead."
msgstr ""
"Функция <function>array_positions</function> возвращает <literal>NULL</"
"literal>, только если в качестве массива передаётся <literal>NULL</literal>; "
"если же в массиве не находится значение, она возвращает пустой массив."

#: func.xml:12412(para)
msgid ""
"In <function>string_to_array</function>, if the delimiter parameter is NULL, "
"each character in the input string will become a separate element in the "
"resulting array. If the delimiter is an empty string, then the entire input "
"string is returned as a one-element array. Otherwise the input string is "
"split at each occurrence of the delimiter string."
msgstr ""
"Если для функции <function>string_to_array</function> в качестве разделителя "
"задан NULL, каждый символ входной строки станет отдельным элементов в "
"полученном массиве. Если разделитель пустая строка, строка будет возвращена "
"целиком в массиве из одного элемента. В противном случае входная строка "
"разбивается по вхождениям подстроки, указанной в качестве разделителя."

#: func.xml:12420(para)
msgid ""
"In <function>string_to_array</function>, if the null-string parameter is "
"omitted or NULL, none of the substrings of the input will be replaced by "
"NULL. In <function>array_to_string</function>, if the null-string parameter "
"is omitted or NULL, any null elements in the array are simply skipped and "
"not represented in the output string."
msgstr ""
"Если для функции <function>string_to_array</function> параметр замены "
"значения NULL опущен или равен NULL, никакие подстроки во входных данных не "
"будут заменяться на NULL. Если же параметр замены NULL опущен или равен NULL "
"для функции <function>array_to_string</function>, все значения NULL просто "
"пропускаются и никак не представляются в выходной строке."

#: func.xml:12430(para)
msgid ""
"There are two differences in the behavior of <function>string_to_array</"
"function> from pre-9.1 versions of <productname>PostgreSQL</productname>. "
"First, it will return an empty (zero-element) array rather than NULL when "
"the input string is of zero length. Second, if the delimiter string is NULL, "
"the function splits the input into individual characters, rather than "
"returning NULL as before."
msgstr ""
"В поведении <function>string_to_array</function> по сравнению с "
"<productname>PostgreSQL</productname> версий до 9.1 произошли два изменения. "
"Во-первых, эта функция возвращает пустой массив (содержащий 0 элементов), а "
"не NULL, когда входная строка имеет нулевую длину. Во-вторых, если в "
"качестве разделителя задан NULL, эта функция разбивает строку по символам, а "
"не просто возвращает NULL, как было раньше."

#: func.xml:12440(para)
msgid ""
"See also <xref linkend=\"functions-aggregate\"/> about the aggregate "
"function <function>array_agg</function> for use with arrays."
msgstr ""
"Вы также можете узнать об агрегатной функции, работающей с массивами, "
"<function>array_agg</function> в <xref remap=\"6\" linkend=\"functions-"
"aggregate\"/>."

#: func.xml:12447(title)
msgid "Range Functions and Operators"
msgstr "Диапазонные функции и операторы"

#: func.xml:12449(para)
msgid "See <xref linkend=\"rangetypes\"/> for an overview of range types."
msgstr ""
"Диапазонные типы данных рассматриваются в <xref remap=\"6\" linkend="
"\"rangetypes\"/>."

#: func.xml:12453(para)
msgid ""
"<xref linkend=\"range-operators-table\"/> shows the operators available for "
"range types."
msgstr ""
"В <xref remap=\"6\" linkend=\"range-operators-table\"/> показаны операторы, "
"предназначенные для работы с диапазонами."

#: func.xml:12459(title)
msgid "Range Operators"
msgstr "Диапазонные операторы"

#: func.xml:12473(literal)
msgid "int4range(1,5) = '[1,4]'::int4range"
msgstr "int4range(1,5) = '[1,4]'::int4range"

#: func.xml:12480(literal)
msgid "numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)"
msgstr "numrange(1.1,2.2) &lt;&gt; numrange(1.1,2.3)"

#: func.xml:12487(literal)
msgid "int4range(1,10) &lt; int4range(2,3)"
msgstr "int4range(1,10) &lt; int4range(2,3)"

#: func.xml:12494(literal)
msgid "int4range(1,10) &gt; int4range(1,5)"
msgstr "int4range(1,10) &gt; int4range(1,5)"

#: func.xml:12501(literal)
msgid "numrange(1.1,2.2) &lt;= numrange(1.1,2.2)"
msgstr "numrange(1.1,2.2) &lt;= numrange(1.1,2.2)"

#: func.xml:12508(literal)
msgid "numrange(1.1,2.2) &gt;= numrange(1.1,2.0)"
msgstr "numrange(1.1,2.2) &gt;= numrange(1.1,2.0)"

#: func.xml:12514(entry)
msgid "contains range"
msgstr "содержит диапазон"

#: func.xml:12515(literal)
msgid "int4range(2,4) @&gt; int4range(2,3)"
msgstr "int4range(2,4) @&gt; int4range(2,3)"

#: func.xml:12521(entry)
msgid "contains element"
msgstr "содержит элемент"

#: func.xml:12522(literal)
msgid "'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp"
msgstr "'[2011-01-01,2011-03-01)'::tsrange @&gt; '2011-01-10'::timestamp"

#: func.xml:12528(entry)
msgid "range is contained by"
msgstr "диапазон содержится в"

#: func.xml:12529(literal)
msgid "int4range(2,4) &lt;@ int4range(1,7)"
msgstr "int4range(2,4) &lt;@ int4range(1,7)"

#: func.xml:12535(entry)
msgid "element is contained by"
msgstr "элемент содержится в"

#: func.xml:12536(literal)
msgid "42 &lt;@ int4range(1,7)"
msgstr "42 &lt;@ int4range(1,7)"

#: func.xml:12542(entry)
msgid "overlap (have points in common)"
msgstr "пересекает (есть общие точки)"

#: func.xml:12543(literal)
msgid "int8range(3,7) &amp;&amp; int8range(4,12)"
msgstr "int8range(3,7) &amp;&amp; int8range(4,12)"

#: func.xml:12549(entry)
msgid "strictly left of"
msgstr "строго слева от"

#: func.xml:12550(literal)
msgid "int8range(1,10) &lt;&lt; int8range(100,110)"
msgstr "int8range(1,10) &lt;&lt; int8range(100,110)"

#: func.xml:12556(entry)
msgid "strictly right of"
msgstr "строго справа от"

#: func.xml:12557(literal)
msgid "int8range(50,60) &gt;&gt; int8range(20,30)"
msgstr "int8range(50,60) &gt;&gt; int8range(20,30)"

#: func.xml:12563(entry)
msgid "does not extend to the right of"
msgstr "не простирается правее"

#: func.xml:12564(literal)
msgid "int8range(1,20) &amp;&lt; int8range(18,20)"
msgstr "int8range(1,20) &amp;&lt; int8range(18,20)"

#: func.xml:12570(entry)
msgid "does not extend to the left of"
msgstr "не простирается левее"

#: func.xml:12571(literal)
msgid "int8range(7,20) &amp;&gt; int8range(5,10)"
msgstr "int8range(7,20) &amp;&gt; int8range(5,10)"

#: func.xml:12576(literal)
msgid "-|-"
msgstr "-|-"

#: func.xml:12577(entry)
msgid "is adjacent to"
msgstr "примыкает к"

#: func.xml:12578(literal)
msgid "numrange(1.1,2.2) -|- numrange(2.2,3.3)"
msgstr "numrange(1.1,2.2) -|- numrange(2.2,3.3)"

#: func.xml:12584(entry)
msgid "union"
msgstr "union"

#: func.xml:12585(literal)
msgid "numrange(5,15) + numrange(10,20)"
msgstr "numrange(5,15) + numrange(10,20)"

#: func.xml:12586(literal)
msgid "[5,20)"
msgstr "[5,20)"

#: func.xml:12591(entry)
msgid "intersection"
msgstr "пересечение"

#: func.xml:12592(literal)
msgid "int8range(5,15) * int8range(10,20)"
msgstr "int8range(5,15) * int8range(10,20)"

#: func.xml:12593(literal)
msgid "[10,15)"
msgstr "[10,15)"

#: func.xml:12598(entry)
msgid "difference"
msgstr "вычитание"

#: func.xml:12599(literal)
msgid "int8range(5,15) - int8range(10,20)"
msgstr "int8range(5,15) - int8range(10,20)"

#: func.xml:12600(literal)
msgid "[5,10)"
msgstr "[5,10)"

#: func.xml:12607(para)
msgid ""
"The simple comparison operators <literal>&lt;</literal>, <literal>&gt;</"
"literal>, <literal>&lt;=</literal>, and <literal>&gt;=</literal> compare the "
"lower bounds first, and only if those are equal, compare the upper bounds. "
"These comparisons are not usually very useful for ranges, but are provided "
"to allow B-tree indexes to be constructed on ranges."
msgstr ""
"Простые операторы сравнения <literal>&lt;</literal>, <literal>&gt;</"
"literal>, <literal>&lt;=</literal> и <literal>&gt;=</literal> сначала "
"сравнивают нижние границы, и только если они равны, сравнивают верхние. Эти "
"операторы сравнения обычно не очень полезны для диапазонов; основное их "
"предназначение &mdash; сделать возможным построение индексов-B-деревьев по "
"диапазонам."

#: func.xml:12616(para)
msgid ""
"The left-of/right-of/adjacent operators always return false when an empty "
"range is involved; that is, an empty range is not considered to be either "
"before or after any other range."
msgstr ""
"Операторы слева/справа/примыкает всегда возвращают false, если один из "
"диапазонов пуст; то есть, считается, что пустой диапазон находится не слева "
"и не справа от какого-либо другого диапазона."

#: func.xml:12622(para)
msgid ""
"The union and difference operators will fail if the resulting range would "
"need to contain two disjoint sub-ranges, as such a range cannot be "
"represented."
msgstr ""
"Операторы сложения и вычитания вызывают ошибку, если получающийся в "
"результате диапазон оказывается состоящим из двух разделённых поддиапазонов, "
"так как его нельзя представить в этом типе данных."

#: func.xml:12628(para)
msgid ""
"<xref linkend=\"range-functions-table\"/> shows the functions available for "
"use with range types."
msgstr ""
"В <xref remap=\"6\" linkend=\"range-functions-table\"/> перечислены функции, "
"предназначенные для работы с диапазонными типами."

#: func.xml:12639(indexterm)
msgid "<primary>isempty</primary>"
msgstr "<primary>isempty</primary>"

#: func.xml:12642(indexterm)
msgid "<primary>lower_inc</primary>"
msgstr "<primary>lower_inc</primary>"

#: func.xml:12645(indexterm)
msgid "<primary>upper_inc</primary>"
msgstr "<primary>upper_inc</primary>"

#: func.xml:12648(indexterm)
msgid "<primary>lower_inf</primary>"
msgstr "<primary>lower_inf</primary>"

#: func.xml:12651(indexterm)
msgid "<primary>upper_inf</primary>"
msgstr "<primary>upper_inf</primary>"

#: func.xml:12656(title)
msgid "Range Functions"
msgstr "Диапазонные функции"

#: func.xml:12671(function)
msgid "lower"
msgstr "lower"

#: func.xml:12671(type) func.xml:12682(type) func.xml:12693(type)
#: func.xml:12704(type) func.xml:12715(type) func.xml:12726(type)
#: func.xml:12737(type) func.xml:12748(type) func.xml:12751(type)
msgid "anyrange"
msgstr "anyrange"

#: func.xml:12674(entry) func.xml:12685(entry)
msgid "range's element type"
msgstr "тип элемента диапазона"

#: func.xml:12675(entry)
msgid "lower bound of range"
msgstr "нижняя граница диапазона"

#: func.xml:12676(literal)
msgid "lower(numrange(1.1,2.2))"
msgstr "lower(numrange(1.1, 2.2))"

#: func.xml:12677(literal)
msgid "1.1"
msgstr "1.1"

#: func.xml:12682(function)
msgid "upper"
msgstr "upper"

#: func.xml:12686(entry)
msgid "upper bound of range"
msgstr "верхняя граница диапазона"

#: func.xml:12687(literal)
msgid "upper(numrange(1.1,2.2))"
msgstr "upper(numrange(1.1, 2.2))"

#: func.xml:12688(literal)
msgid "2.2"
msgstr "2.2"

#: func.xml:12693(function)
msgid "isempty"
msgstr "isempty"

#: func.xml:12697(entry)
msgid "is the range empty?"
msgstr "диапазон пуст?"

#: func.xml:12698(literal)
msgid "isempty(numrange(1.1,2.2))"
msgstr "isempty(numrange(1.1,2.2))"

#: func.xml:12704(function)
msgid "lower_inc"
msgstr "lower_inc"

#: func.xml:12708(entry)
msgid "is the lower bound inclusive?"
msgstr "нижняя граница включается?"

#: func.xml:12709(literal)
msgid "lower_inc(numrange(1.1,2.2))"
msgstr "lower_inc(numrange(1.1, 2.2))"

#: func.xml:12715(function)
msgid "upper_inc"
msgstr "upper_inc"

#: func.xml:12719(entry)
msgid "is the upper bound inclusive?"
msgstr "верхняя граница включается?"

#: func.xml:12720(literal)
msgid "upper_inc(numrange(1.1,2.2))"
msgstr "upper_inc(numrange(1.1, 2.2))"

#: func.xml:12726(function)
msgid "lower_inf"
msgstr "lower_inf"

#: func.xml:12730(entry)
msgid "is the lower bound infinite?"
msgstr "нижняя граница равна бесконечности?"

#: func.xml:12731(literal)
msgid "lower_inf('(,)'::daterange)"
msgstr "lower_inf('(,)'::daterange)"

#: func.xml:12737(function)
msgid "upper_inf"
msgstr "upper_inf"

#: func.xml:12741(entry)
msgid "is the upper bound infinite?"
msgstr "верхняя граница равна бесконечности?"

#: func.xml:12742(literal)
msgid "upper_inf('(,)'::daterange)"
msgstr "upper_inf('(,)'::daterange)"

#: func.xml:12748(function)
msgid "range_merge"
msgstr "range_merge"

#: func.xml:12752(entry)
msgid "the smallest range which includes both of the given ranges"
msgstr "наименьший диапазон, включающий оба заданных диапазона"

#: func.xml:12753(literal)
msgid "range_merge('[1,2)'::int4range, '[3,4)'::int4range)"
msgstr "range_merge('[1,2)'::int4range, '[3,4)'::int4range)"

#: func.xml:12754(literal)
msgid "[1,4)"
msgstr "[1,4)"

#: func.xml:12760(para)
msgid ""
"The <function>lower</function> and <function>upper</function> functions "
"return null if the range is empty or the requested bound is infinite. The "
"<function>lower_inc</function>, <function>upper_inc</function>, "
"<function>lower_inf</function>, and <function>upper_inf</function> functions "
"all return false for an empty range."
msgstr ""
"Функции <function>lower</function> и <function>upper</function> возвращают "
"NULL, если диапазон пуст или указанная граница равна бесконечности. Если же "
"пустой диапазон передаётся функциям <function>lower_inc</function>, "
"<function>upper_inc</function>, <function>lower_inf</function> и "
"<function>upper_inf</function>, все они возвращают false."

#: func.xml:12770(title)
msgid "Aggregate Functions"
msgstr "Агрегатные функции"

#: func.xml:12772(indexterm)
msgid "<primary>aggregate function</primary> <secondary>built-in</secondary>"
msgstr ""
"<primary>агрегатные функции</primary> <secondary>встроенные</secondary>"

#: func.xml:12777(para)
msgid ""
"<firstterm>Aggregate functions</firstterm> compute a single result from a "
"set of input values. The built-in normal aggregate functions are listed in "
"<xref linkend=\"functions-aggregate-table\"/> and <xref linkend=\"functions-"
"aggregate-statistics-table\"/>. The built-in ordered-set aggregate functions "
"are listed in <xref linkend=\"functions-orderedset-table\"/> and <xref "
"linkend=\"functions-hypothetical-table\"/>. Grouping operations, which are "
"closely related to aggregate functions, are listed in <xref linkend="
"\"functions-grouping-table\"/>. The special syntax considerations for "
"aggregate functions are explained in <xref linkend=\"syntax-aggregates\"/>. "
"Consult <xref linkend=\"tutorial-agg\"/> for additional introductory "
"information."
msgstr ""
"<firstterm>Агрегатные функции</firstterm> получают единственный результат из "
"набора входных значений. Встроенные обычные агрегатные функции перечислены в "
"<xref remap=\"6\" linkend=\"functions-aggregate-table\"/> и <xref remap="
"\"6\" linkend=\"functions-aggregate-statistics-table\"/>, а сортирующие "
"агрегатные функции &mdash; в <xref remap=\"6\" linkend=\"functions-"
"orderedset-table\"/> и <xref remap=\"6\" linkend=\"functions-hypothetical-"
"table\"/>. Операции группирования, тесно связанные с агрегатными функциями, "
"перечислены в <xref remap=\"6\" linkend=\"functions-grouping-table\"/>. "
"Особенности синтаксиса агрегатных функций разъясняются в <xref remap=\"6\" "
"linkend=\"syntax-aggregates\"/>. За дополнительной вводной информацией "
"обратитесь к <xref remap=\"3\" linkend=\"tutorial-agg\"/>."

#: func.xml:12795(title)
msgid "General-Purpose Aggregate Functions"
msgstr "Агрегатные функции общего назначения"

#: func.xml:12801(entry)
msgid "Argument Type(s)"
msgstr "Типы аргумента"

#: func.xml:12803(entry) func.xml:13250(entry) func.xml:13667(entry)
#: func.xml:13829(entry)
msgid "Partial Mode"
msgstr "Частичный режим"

#: func.xml:12811(indexterm)
msgid "<primary>array_agg</primary>"
msgstr "<primary>array_agg</primary>"

#: func.xml:12814(function) func.xml:12828(function)
msgid "array_agg(<placeholder-1/>)"
msgstr "array_agg(<placeholder-1/>)"

#: func.xml:12816(entry)
msgid "any non-array type"
msgstr "любой тип не массива"

#: func.xml:12819(entry)
msgid "array of the argument type"
msgstr "массив элементов с типом аргумента"

#: func.xml:12822(entry) func.xml:12836(entry) func.xml:12990(entry)
#: func.xml:13007(entry) func.xml:13024(entry) func.xml:13041(entry)
#: func.xml:13097(entry) func.xml:13137(entry) func.xml:13690(entry)
#: func.xml:13717(entry) func.xml:13738(entry) func.xml:13763(entry)
#: func.xml:13783(entry) func.xml:13853(entry) func.xml:13876(entry)
#: func.xml:13899(entry) func.xml:13922(entry)
msgid "No"
msgstr "Нет"

#: func.xml:12823(entry)
msgid "input values, including nulls, concatenated into an array"
msgstr "входные значения, включая NULL, объединяются в массив"

#: func.xml:12830(entry)
msgid "any array type"
msgstr "любой тип массива"

#: func.xml:12833(entry) func.xml:12877(entry) func.xml:12895(entry)
msgid "same as argument data type"
msgstr "тот же, что и тип аргумента"

#: func.xml:12837(entry)
msgid ""
"input arrays concatenated into array of one higher dimension (inputs must "
"all have same dimensionality, and cannot be empty or NULL)"
msgstr ""
"входные массивы собираются в массив большей размерности (они должны иметь "
"одну размерность и не могут быть пустыми или равны NULL)"

#: func.xml:12844(indexterm)
msgid "<primary>average</primary>"
msgstr "<primary>среднее</primary>"

#: func.xml:12847(indexterm)
msgid "<primary>avg</primary>"
msgstr "<primary>avg</primary>"

#: func.xml:12850(function)
msgid "avg(<placeholder-1/>)"
msgstr "avg(<placeholder-1/>)"

#: func.xml:12852(entry)
msgid ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, <type>numeric</type>, or "
"<type>interval</type>"
msgstr ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, <type>numeric</type> или "
"<type>interval</type>"

#: func.xml:12857(entry)
msgid ""
"<type>numeric</type> for any integer-type argument, <type>double precision</"
"type> for a floating-point argument, otherwise the same as the argument data "
"type"
msgstr ""
"<type>numeric</type> для любых целочисленных аргументов, <type>double "
"precision</type> для аргументов с плавающей точкой, в противном случае тип "
"данных аргумента"

#: func.xml:12862(entry) func.xml:12880(entry) func.xml:12898(entry)
#: func.xml:12915(entry) func.xml:12932(entry) func.xml:12945(entry)
#: func.xml:12953(entry) func.xml:12973(entry) func.xml:13055(entry)
#: func.xml:13073(entry) func.xml:13120(entry) func.xml:13273(entry)
#: func.xml:13294(entry) func.xml:13315(entry) func.xml:13332(entry)
#: func.xml:13350(entry) func.xml:13368(entry) func.xml:13388(entry)
#: func.xml:13408(entry) func.xml:13428(entry) func.xml:13447(entry)
#: func.xml:13468(entry) func.xml:13492(entry) func.xml:13519(entry)
#: func.xml:13543(entry) func.xml:13567(entry) func.xml:13587(entry)
#: func.xml:13611(entry) func.xml:13635(entry)
msgid "Yes"
msgstr "Да"

#: func.xml:12863(entry)
msgid "the average (arithmetic mean) of all input values"
msgstr "арифметическое среднее для всех входных значений"

#: func.xml:12868(indexterm)
msgid "<primary>bit_and</primary>"
msgstr "<primary>bit_and</primary>"

#: func.xml:12871(function)
msgid "bit_and(<placeholder-1/>)"
msgstr "bit_and(<placeholder-1/>)"

#: func.xml:12873(entry) func.xml:12891(entry)
msgid ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, or <type>bit</"
"type>"
msgstr ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type> или <type>bit</"
"type>"

#: func.xml:12881(entry)
msgid "the bitwise AND of all non-null input values, or null if none"
msgstr ""
"побитовое И для всех входных значений, не равных NULL, или NULL, если таких "
"нет"

#: func.xml:12886(indexterm)
msgid "<primary>bit_or</primary>"
msgstr "<primary>bit_or</primary>"

#: func.xml:12889(function)
msgid "bit_or(<placeholder-1/>)"
msgstr "bit_or(<placeholder-1/>)"

#: func.xml:12899(entry)
msgid "the bitwise OR of all non-null input values, or null if none"
msgstr ""
"побитовое ИЛИ для всех входных значений, не равных NULL, или NULL, если "
"таких нет"

#: func.xml:12904(indexterm)
msgid "<primary>bool_and</primary>"
msgstr "<primary>bool_and</primary>"

#: func.xml:12907(function)
msgid "bool_and(<placeholder-1/>)"
msgstr "bool_and(<placeholder-1/>)"

#: func.xml:12910(type) func.xml:12913(type) func.xml:12927(type)
#: func.xml:12930(type) func.xml:12968(type) func.xml:12971(type)
#: func.xml:17756(type) func.xml:17950(type) func.xml:18030(type)
#: func.xml:18413(type) func.xml:18425(type) func.xml:18497(type)
#: func.xml:18515(type) func.xml:18534(type) func.xml:19529(type)
#: func.xml:19590(type) func.xml:19595(type) func.xml:19603(type)
msgid "bool"
msgstr "bool"

#: func.xml:12916(entry)
msgid "true if all input values are true, otherwise false"
msgstr "true, если все входные значения равны true, и false в противном случае"

#: func.xml:12921(indexterm)
msgid "<primary>bool_or</primary>"
msgstr "<primary>bool_or</primary>"

#: func.xml:12924(function)
msgid "bool_or(<placeholder-1/>)"
msgstr "bool_or(<placeholder-1/>)"

#: func.xml:12933(entry)
msgid "true if at least one input value is true, otherwise false"
msgstr ""
"true, если хотя бы одно входное значение равно true, и false в противном "
"случае"

#: func.xml:12938(indexterm)
msgid "<primary>count</primary>"
msgstr "<primary>count</primary>"

#: func.xml:12941(function)
msgid "count(*)"
msgstr "count(*)"

#: func.xml:12946(entry)
msgid "number of input rows"
msgstr "количество входных строк"

#: func.xml:12950(function)
msgid "count(<placeholder-1/>)"
msgstr "count(<placeholder-1/>)"

#: func.xml:12951(entry)
msgctxt "entry"
msgid "any"
msgstr "any"

#: func.xml:12954(entry)
msgid ""
"number of input rows for which the value of <replaceable class=\"parameter"
"\">expression</replaceable> is not null"
msgstr ""
"количество входных строк, для которых значение <replaceable class=\"parameter"
"\">выражения</replaceable> не равно NULL"

#: func.xml:12962(indexterm)
msgid "<primary>every</primary>"
msgstr "<primary>every</primary>"

#: func.xml:12965(function)
msgid "every(<placeholder-1/>)"
msgstr "every(<placeholder-1/>)"

#: func.xml:12974(entry)
msgid "equivalent to <function>bool_and</function>"
msgstr "синоним <function>bool_and</function>"

#: func.xml:12979(indexterm)
msgid "<primary>json_agg</primary>"
msgstr "<primary>json_agg</primary>"

#: func.xml:12982(function)
msgid "json_agg(<placeholder-1/>)"
msgstr "json_agg(<placeholder-1/>)"

#: func.xml:12985(type) func.xml:13002(type) func.xml:14197(type)
#: func.xml:14213(type) func.xml:14230(type) func.xml:18604(type)
msgctxt "type"
msgid "any"
msgstr "any"

#: func.xml:12991(entry) func.xml:13008(entry)
msgid "aggregates values as a JSON array"
msgstr "агрегирует значения в виде массива JSON"

#: func.xml:12996(indexterm)
msgid "<primary>jsonb_agg</primary>"
msgstr "<primary>jsonb_agg</primary>"

#: func.xml:12999(function)
msgid "jsonb_agg(<placeholder-1/>)"
msgstr "jsonb_agg(<placeholder-1/>)"

#: func.xml:13013(indexterm)
msgid "<primary>json_object_agg</primary>"
msgstr "<primary>json_object_agg</primary>"

#: func.xml:13016(function)
msgid "json_object_agg(<placeholder-1/>, <placeholder-2/>)"
msgstr "json_object_agg(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13019(type) func.xml:13036(type)
msgid "(any, any)"
msgstr "(any, any)"

#: func.xml:13025(entry) func.xml:13042(entry)
msgid "aggregates name/value pairs as a JSON object"
msgstr "агрегирует пары имя/значение в виде объекта JSON"

#: func.xml:13030(indexterm)
msgid "<primary>jsonb_object_agg</primary>"
msgstr "<primary>jsonb_object_agg</primary>"

#: func.xml:13033(function)
msgid "jsonb_object_agg(<placeholder-1/>, <placeholder-2/>)"
msgstr "jsonb_object_agg(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13047(indexterm)
msgid "<primary>max</primary>"
msgstr "<primary>max</primary>"

#: func.xml:13050(function)
msgid "max(<placeholder-1/>)"
msgstr "max(<placeholder-1/>)"

#: func.xml:13052(entry) func.xml:13070(entry)
msgid ""
"any numeric, string, date/time, network, or enum type, or arrays of these "
"types"
msgstr ""
"любой числовой, строковый, сетевой тип или тип даты/времени, либо массив "
"этих типов"

#: func.xml:13054(entry) func.xml:13072(entry)
msgid "same as argument type"
msgstr "тот же, что и тип аргумента"

#: func.xml:13056(entry)
msgid ""
"maximum value of <replaceable class=\"parameter\">expression</replaceable> "
"across all input values"
msgstr ""
"максимальное значение <replaceable class=\"parameter\">выражения</"
"replaceable> среди всех входных данных"

#: func.xml:13065(indexterm)
msgid "<primary>min</primary>"
msgstr "<primary>min</primary>"

#: func.xml:13068(function)
msgid "min(<placeholder-1/>)"
msgstr "min(<placeholder-1/>)"

#: func.xml:13074(entry)
msgid ""
"minimum value of <replaceable class=\"parameter\">expression</replaceable> "
"across all input values"
msgstr ""
"минимальное значение <replaceable class=\"parameter\">выражения</"
"replaceable> среди всех входных данных"

#: func.xml:13083(indexterm)
msgid "<primary>string_agg</primary>"
msgstr "<primary>string_agg</primary>"

#: func.xml:13088(replaceable)
msgctxt "replaceable"
msgid "delimiter"
msgstr "разделитель"

#: func.xml:13086(function)
msgid "string_agg(<placeholder-1/>, <placeholder-2/>)"
msgstr "string_agg(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13091(entry)
msgid ""
"(<type>text</type>, <type>text</type>) or (<type>bytea</type>, <type>bytea</"
"type>)"
msgstr ""
"(<type>text</type>, <type>text</type>) или (<type>bytea</type>, <type>bytea</"
"type>)"

#: func.xml:13094(entry)
msgid "same as argument types"
msgstr "тот же, что и типы аргументов"

#: func.xml:13098(entry)
msgid "input values concatenated into a string, separated by delimiter"
msgstr "входные данные складываются в строку через заданный разделитель"

#: func.xml:13103(indexterm)
msgid "<primary>sum</primary>"
msgstr "<primary>sum</primary>"

#: func.xml:13106(function)
msgid "sum(<placeholder-1/>)"
msgstr "sum(<placeholder-1/>)"

#: func.xml:13108(entry)
msgid ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, <type>numeric</type>, <type>interval</"
"type>, or <type>money</type>"
msgstr ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, <type>numeric</type>, <type>interval</"
"type> или <type>money</type>"

#: func.xml:13114(entry)
msgid ""
"<type>bigint</type> for <type>smallint</type> or <type>int</type> arguments, "
"<type>numeric</type> for <type>bigint</type> arguments, otherwise the same "
"as the argument data type"
msgstr ""
"<type>bigint</type> для аргументов <type>smallint</type> или <type>int</"
"type>, <type>numeric</type> для аргументов <type>bigint</type>, и тип "
"аргумента в остальных случаях"

#: func.xml:13121(entry)
msgid ""
"sum of <replaceable class=\"parameter\">expression</replaceable> across all "
"input values"
msgstr ""
"сумма значений <replaceable class=\"parameter\">выражения</replaceable> по "
"всем входным данным"

#: func.xml:13129(function)
msgid "xmlagg(<placeholder-1/>)"
msgstr "xmlagg(<placeholder-1/>)"

#: func.xml:13132(type) func.xml:13135(type)
msgctxt "type"
msgid "xml"
msgstr "xml"

#: func.xml:13138(entry)
msgid ""
"concatenation of XML values (see also <xref linkend=\"functions-xml-xmlagg\"/"
">)"
msgstr ""
"соединение XML-значений (см. также <xref remap=\"4\" linkend=\"functions-xml-"
"xmlagg\"/>)"

#: func.xml:13144(para)
msgid ""
"It should be noted that except for <function>count</function>, these "
"functions return a null value when no rows are selected. In particular, "
"<function>sum</function> of no rows returns null, not zero as one might "
"expect, and <function>array_agg</function> returns null rather than an empty "
"array when there are no input rows. The <function>coalesce</function> "
"function can be used to substitute zero or an empty array for null when "
"necessary."
msgstr ""
"Следует заметить, что за исключением <function>count</function>, все эти "
"функции возвращают NULL, если для них не была выбрана ни одна строка. В "
"частности, функция <function>sum</function>, не получив строк, возвращает "
"NULL, а не 0, как можно было бы ожидать, и <function>array_agg</function> в "
"этом случае возвращает NULL, а не пустой массив. Если необходимо, подставить "
"в результат 0 или пустой массив вместо NULL можно с помощью функции "
"<function>coalesce</function>."

#: func.xml:13154(para)
msgid ""
"Aggregate functions which support <firstterm>Partial Mode</firstterm> are "
"eligible to participate in various optimizations, such as parallel "
"aggregation."
msgstr ""
"Агрегатные функции, поддерживающие <firstterm>частичный режим</firstterm>, "
"являются кандидатами на участие в различных оптимизациях, например, в "
"параллельном агрегировании."

#: func.xml:13161(indexterm) func.xml:14312(indexterm)
#: func.xml:14659(indexterm)
msgid "<primary>ANY</primary>"
msgstr "<primary>ANY</primary>"

#: func.xml:13164(indexterm) func.xml:14320(indexterm)
#: func.xml:14667(indexterm)
msgid "<primary>SOME</primary>"
msgstr "<primary>SOME</primary>"

#: func.xml:13174(programlisting)
#, no-wrap
msgid "SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;"
msgstr "SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;"

#: func.xml:13167(para)
msgid ""
"Boolean aggregates <function>bool_and</function> and <function>bool_or</"
"function> correspond to standard SQL aggregates <function>every</function> "
"and <function>any</function> or <function>some</function>. As for "
"<function>any</function> and <function>some</function>, it seems that there "
"is an ambiguity built into the standard syntax: <placeholder-1/> Here "
"<function>ANY</function> can be considered either as introducing a subquery, "
"or as being an aggregate function, if the subquery returns one row with a "
"Boolean value. Thus the standard name cannot be given to these aggregates."
msgstr ""
"Булевы агрегатные функции <function>bool_and</function> и <function>bool_or</"
"function> соответствуют стандартным SQL-агрегатам <function>every</function> "
"и <function>any</function> или <function>some</function>. Что касается "
"<function>any</function> и <function>some</function>, по стандарту их "
"синтаксис допускает некоторую неоднозначность: <placeholder-1/> Здесь "
"<function>ANY</function> можно рассматривать и как объявление подзапроса, и "
"как агрегатную функцию, если этот подзапрос возвращает одну строку с булевым "
"значением. Таким образом, этим агрегатным функциям нельзя было дать "
"стандартные имена."

#: func.xml:13190(programlisting)
#, no-wrap
msgid "SELECT count(*) FROM sometable;"
msgstr "SELECT count(*) FROM sometable;"

#: func.xml:13185(para)
msgid ""
"Users accustomed to working with other SQL database management systems might "
"be disappointed by the performance of the <function>count</function> "
"aggregate when it is applied to the entire table. A query like: "
"<placeholder-1/> will require effort proportional to the size of the table: "
"<productname>PostgreSQL</productname> will need to scan either the entire "
"table or the entirety of an index which includes all rows in the table."
msgstr ""
"Пользователи с опытом использования других СУБД SQL могут быть недовольны "
"скоростью агрегатной функции <function>count</function>, когда она "
"применяется ко всей таблице. Подобный запрос: <placeholder-1/> потребует "
"затрат в количестве, пропорциональном размеру таблицы: "
"<productname>PostgreSQL</productname> придётся полностью просканировать либо "
"всю таблицу, либо один из индексов, включающий все её строки."

#: func.xml:13200(para)
msgid ""
"The aggregate functions <function>array_agg</function>, <function>json_agg</"
"function>, <function>jsonb_agg</function>, <function>json_object_agg</"
"function>, <function>jsonb_object_agg</function>, <function>string_agg</"
"function>, and <function>xmlagg</function>, as well as similar user-defined "
"aggregate functions, produce meaningfully different result values depending "
"on the order of the input values. This ordering is unspecified by default, "
"but can be controlled by writing an <literal>ORDER BY</literal> clause "
"within the aggregate call, as shown in <xref linkend=\"syntax-aggregates\"/"
">. Alternatively, supplying the input values from a sorted subquery will "
"usually work. For example: <screen><![CDATA[\n"
"SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;\n"
"]]></screen> Beware that this approach can fail if the outer query level "
"contains additional processing, such as a join, because that might cause the "
"subquery's output to be reordered before the aggregate is computed."
msgstr ""
"Агрегатные функции <function>array_agg</function>, <function>json_agg</"
"function>, <function>jsonb_agg</function>, <function>json_object_agg</"
"function>, <function>jsonb_object_agg</function>, <function>string_agg</"
"function> и <function>xmlagg</function> так же, как и подобные "
"пользовательские агрегатные функции, выдают разные по содержанию результаты "
"в зависимости от порядка входных значений. По умолчанию порядок не "
"определён, но его можно задать, дополнив вызов агрегатной функции "
"предложением <literal>ORDER BY</literal>, как описано в <xref remap=\"6\" "
"linkend=\"syntax-aggregates\"/>. Обычно нужного результата также можно "
"добиться, передав для агрегирования результат подзапроса с сортировкой. "
"Например: <screen><![CDATA[\n"
"SELECT xmlagg(x) FROM (SELECT x FROM test ORDER BY y DESC) AS tab;\n"
"]]></screen> Но учтите, что этот подход может не работать, если на внешнем "
"уровне запроса выполняется дополнительная обработка, например, соединение, "
"так как при этом результат подзапроса может быть переупорядочен перед "
"вычислением агрегатной функции."

#: func.xml:13223(para)
msgid ""
"<xref linkend=\"functions-aggregate-statistics-table\"/> shows aggregate "
"functions typically used in statistical analysis. (These are separated out "
"merely to avoid cluttering the listing of more-commonly-used aggregates.) "
"Where the description mentions <replaceable class=\"parameter\">N</"
"replaceable>, it means the number of input rows for which all the input "
"expressions are non-null. In all cases, null is returned if the computation "
"is meaningless, for example when <replaceable class=\"parameter\">N</"
"replaceable> is zero."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-aggregate-statistics-table\"/> "
"перечислены агрегатные функции, обычно применяемые в статистическом анализе. "
"(Они выделены просто для того, чтобы не загромождать список наиболее "
"популярных агрегатных функций.) В их описании под <replaceable class="
"\"parameter\">N</replaceable> подразумевается число входных строк, для "
"которых входные выражения не равны NULL. Все эти функции возвращают NULL во "
"всех случаях, когда вычисление бессмысленно, например, когда <replaceable "
"class=\"parameter\">N</replaceable> равно 0."

#: func.xml:13234(indexterm)
msgid "<primary>statistics</primary>"
msgstr "<primary>статистика</primary>"

#: func.xml:13237(indexterm)
msgid "<primary>linear regression</primary>"
msgstr "<primary>линейная регрессия</primary>"

#: func.xml:13242(title)
msgid "Aggregate Functions for Statistics"
msgstr "Агрегатные функции для статистических вычислений"

#: func.xml:13248(entry) func.xml:15027(entry)
msgid "Argument Type"
msgstr "Тип аргумента"

#: func.xml:13259(indexterm)
msgid "<primary>correlation</primary>"
msgstr "<primary>корреляция</primary>"

#: func.xml:13262(indexterm)
msgid "<primary>corr</primary>"
msgstr "<primary>corr</primary>"

#: func.xml:13265(replaceable) func.xml:13286(replaceable)
#: func.xml:13307(replaceable) func.xml:13324(replaceable)
#: func.xml:13342(replaceable) func.xml:13360(replaceable)
#: func.xml:13380(replaceable) func.xml:13400(replaceable)
#: func.xml:13420(replaceable) func.xml:13439(replaceable)
#: func.xml:13460(replaceable) func.xml:13484(replaceable)
msgctxt "replaceable"
msgid "Y"
msgstr "Y"

#: func.xml:13265(function)
msgid "corr(<placeholder-1/>, <placeholder-2/>)"
msgstr "corr(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13274(entry)
msgid "correlation coefficient"
msgstr "коэффициент корреляции"

#: func.xml:13279(indexterm)
msgid "<primary>covariance</primary> <secondary>population</secondary>"
msgstr "<primary>ковариация</primary> <secondary>совокупности</secondary>"

#: func.xml:13283(indexterm)
msgid "<primary>covar_pop</primary>"
msgstr "<primary>covar_pop</primary>"

#: func.xml:13286(function)
msgid "covar_pop(<placeholder-1/>, <placeholder-2/>)"
msgstr "covar_pop(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13295(entry)
msgid "population covariance"
msgstr "ковариация совокупности"

#: func.xml:13300(indexterm)
msgid "<primary>covariance</primary> <secondary>sample</secondary>"
msgstr "<primary>ковариация</primary> <secondary>выборки</secondary>"

#: func.xml:13304(indexterm)
msgid "<primary>covar_samp</primary>"
msgstr "<primary>covar_samp</primary>"

#: func.xml:13307(function)
msgid "covar_samp(<placeholder-1/>, <placeholder-2/>)"
msgstr "covar_samp(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13316(entry)
msgid "sample covariance"
msgstr "ковариация выборки"

#: func.xml:13321(indexterm)
msgid "<primary>regr_avgx</primary>"
msgstr "<primary>regr_avgx</primary>"

#: func.xml:13324(function)
msgid "regr_avgx(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_avgx(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13333(entry)
msgid ""
"average of the independent variable (<literal>sum(<replaceable class="
"\"parameter\">X</replaceable>)/<replaceable class=\"parameter\">N</"
"replaceable></literal>)"
msgstr ""
"среднее независимой переменной (<literal>sum(<replaceable class=\"parameter"
"\">X</replaceable>)/<replaceable class=\"parameter\">N</replaceable></"
"literal>)"

#: func.xml:13339(indexterm)
msgid "<primary>regr_avgy</primary>"
msgstr "<primary>regr_avgy</primary>"

#: func.xml:13342(function)
msgid "regr_avgy(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_avgy(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13351(entry)
msgid ""
"average of the dependent variable (<literal>sum(<replaceable class="
"\"parameter\">Y</replaceable>)/<replaceable class=\"parameter\">N</"
"replaceable></literal>)"
msgstr ""
"среднее зависимой переменной (<literal>sum(<replaceable class=\"parameter"
"\">Y</replaceable>)/<replaceable class=\"parameter\">N</replaceable></"
"literal>)"

#: func.xml:13357(indexterm)
msgid "<primary>regr_count</primary>"
msgstr "<primary>regr_count</primary>"

#: func.xml:13360(function)
msgid "regr_count(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_count(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13369(entry)
msgid "number of input rows in which both expressions are nonnull"
msgstr "число входных строк, в которых оба выражения не NULL"

#: func.xml:13374(indexterm)
msgid "<primary>regression intercept</primary>"
msgstr "<primary>пересечение линии регрессии</primary>"

#: func.xml:13377(indexterm)
msgid "<primary>regr_intercept</primary>"
msgstr "<primary>regr_intercept</primary>"

#: func.xml:13380(function)
msgid "regr_intercept(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_intercept(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13389(entry)
msgid ""
"y-intercept of the least-squares-fit linear equation determined by the "
"(<replaceable class=\"parameter\">X</replaceable>, <replaceable class="
"\"parameter\">Y</replaceable>) pairs"
msgstr ""
"пересечение с осью OY линии, полученной методом наименьших квадратов по "
"данным (<replaceable class=\"parameter\">X</replaceable>, <replaceable class="
"\"parameter\">Y</replaceable>)"

#: func.xml:13397(indexterm)
msgid "<primary>regr_r2</primary>"
msgstr "<primary>regr_r2</primary>"

#: func.xml:13400(function)
msgid "regr_r2(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_r2(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13409(entry)
msgid "square of the correlation coefficient"
msgstr "квадрат коэффициента корреляции"

#: func.xml:13414(indexterm)
msgid "<primary>regression slope</primary>"
msgstr "<primary>наклон линии регрессии</primary>"

#: func.xml:13417(indexterm)
msgid "<primary>regr_slope</primary>"
msgstr "<primary>regr_slope</primary>"

#: func.xml:13420(function)
msgid "regr_slope(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_slope(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13429(entry)
msgid ""
"slope of the least-squares-fit linear equation determined by the "
"(<replaceable class=\"parameter\">X</replaceable>, <replaceable class="
"\"parameter\">Y</replaceable>) pairs"
msgstr ""
"наклон линии, полученной методом наименьших квадратов по данным "
"(<replaceable class=\"parameter\">X</replaceable>, <replaceable class="
"\"parameter\">Y</replaceable>)"

#: func.xml:13436(indexterm)
msgid "<primary>regr_sxx</primary>"
msgstr "<primary>regr_sxx</primary>"

#: func.xml:13439(function)
msgid "regr_sxx(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_sxx(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13448(entry)
msgid ""
"<literal>sum(<replaceable class=\"parameter\">X</replaceable>^2) - "
"sum(<replaceable class=\"parameter\">X</replaceable>)^2/<replaceable class="
"\"parameter\">N</replaceable></literal> (<quote>sum of squares</quote> of "
"the independent variable)"
msgstr ""
"<literal>sum(<replaceable class=\"parameter\">X</replaceable>^2) - "
"sum(<replaceable class=\"parameter\">X</replaceable>)^2/<replaceable class="
"\"parameter\">N</replaceable></literal> (<quote>сумма квадратов</quote> "
"независимой переменной)"

#: func.xml:13457(indexterm)
msgid "<primary>regr_sxy</primary>"
msgstr "<primary>regr_sxy</primary>"

#: func.xml:13460(function)
msgid "regr_sxy(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_sxy(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13469(entry)
msgid ""
"<literal>sum(<replaceable class=\"parameter\">X</replaceable>*<replaceable "
"class=\"parameter\">Y</replaceable>) - sum(<replaceable class=\"parameter"
"\">X</replaceable>) * sum(<replaceable class=\"parameter\">Y</replaceable>)/"
"<replaceable class=\"parameter\">N</replaceable></literal> (<quote>sum of "
"products</quote> of independent times dependent variable)"
msgstr ""
"<literal>sum(<replaceable class=\"parameter\">X</replaceable>*<replaceable "
"class=\"parameter\">Y</replaceable>) - sum(<replaceable class=\"parameter"
"\">X</replaceable>) * sum(<replaceable class=\"parameter\">Y</replaceable>)/"
"<replaceable class=\"parameter\">N</replaceable></literal> (<quote>сумма "
"произведений</quote> независимых и зависимых переменных)"

#: func.xml:13481(indexterm)
msgid "<primary>regr_syy</primary>"
msgstr "<primary>regr_syy</primary>"

#: func.xml:13484(function)
msgid "regr_syy(<placeholder-1/>, <placeholder-2/>)"
msgstr "regr_syy(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:13493(entry)
msgid ""
"<literal>sum(<replaceable class=\"parameter\">Y</replaceable>^2) - "
"sum(<replaceable class=\"parameter\">Y</replaceable>)^2/<replaceable class="
"\"parameter\">N</replaceable></literal> (<quote>sum of squares</quote> of "
"the dependent variable)"
msgstr ""
"<literal>sum(<replaceable class=\"parameter\">Y</replaceable>^2) - "
"sum(<replaceable class=\"parameter\">Y</replaceable>)^2/<replaceable class="
"\"parameter\">N</replaceable></literal> (<quote>сумма квадратов</quote> "
"зависимой переменной)"

#: func.xml:13502(indexterm)
msgid "<primary>standard deviation</primary>"
msgstr "<primary>стандартное отклонение</primary>"

#: func.xml:13505(indexterm)
msgid "<primary>stddev</primary>"
msgstr "<primary>stddev</primary>"

#: func.xml:13508(function)
msgid "stddev(<placeholder-1/>)"
msgstr "stddev(<placeholder-1/>)"

#: func.xml:13510(entry) func.xml:13534(entry) func.xml:13558(entry)
#: func.xml:13578(entry) func.xml:13602(entry) func.xml:13626(entry)
msgid ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type>, or <type>numeric</type>"
msgstr ""
"<type>smallint</type>, <type>int</type>, <type>bigint</type>, <type>real</"
"type>, <type>double precision</type> или <type>numeric</type>"

#: func.xml:13515(entry) func.xml:13539(entry) func.xml:13563(entry)
#: func.xml:13583(entry) func.xml:13607(entry) func.xml:13631(entry)
msgid ""
"<type>double precision</type> for floating-point arguments, otherwise "
"<type>numeric</type>"
msgstr ""
"<type>double precision</type> для аргументов с плавающей точкой, "
"<type>numeric</type> для остальных"

#: func.xml:13520(entry)
msgid "historical alias for <function>stddev_samp</function>"
msgstr "сохранившийся синоним <function>stddev_samp</function>"

#: func.xml:13525(indexterm)
msgid "<primary>standard deviation</primary> <secondary>population</secondary>"
msgstr ""
"<primary>стандартное отклонение</primary> <secondary>по совокупности</"
"secondary>"

#: func.xml:13529(indexterm)
msgid "<primary>stddev_pop</primary>"
msgstr "<primary>stddev_pop</primary>"

#: func.xml:13532(function)
msgid "stddev_pop(<placeholder-1/>)"
msgstr "stddev_pop(<placeholder-1/>)"

#: func.xml:13544(entry)
msgid "population standard deviation of the input values"
msgstr "стандартное отклонение по генеральной совокупности входных значений"

#: func.xml:13549(indexterm)
msgid "<primary>standard deviation</primary> <secondary>sample</secondary>"
msgstr ""
"<primary>стандартное отклонение</primary> <secondary>по выборке</secondary>"

#: func.xml:13553(indexterm)
msgid "<primary>stddev_samp</primary>"
msgstr "<primary>stddev_samp</primary>"

#: func.xml:13556(function)
msgid "stddev_samp(<placeholder-1/>)"
msgstr "stddev_samp(<placeholder-1/>)"

#: func.xml:13568(entry)
msgid "sample standard deviation of the input values"
msgstr "стандартное отклонение по выборке входных значений"

#: func.xml:13573(indexterm)
msgid "<primary>variance</primary>"
msgstr "<primary>дисперсия</primary>"

#: func.xml:13572(entry)
msgid ""
"<placeholder-1/> <function>variance</function>(<replaceable class=\"parameter"
"\">expression</replaceable>)"
msgstr ""
"<placeholder-1/> <function>variance</function>(<replaceable class=\"parameter"
"\">выражение</replaceable>)"

#: func.xml:13588(entry)
msgid "historical alias for <function>var_samp</function>"
msgstr "сохранившийся синоним <function>var_samp</function>"

#: func.xml:13593(indexterm)
msgid "<primary>variance</primary> <secondary>population</secondary>"
msgstr "<primary>дисперсия</primary> <secondary>для совокупности</secondary>"

#: func.xml:13597(indexterm)
msgid "<primary>var_pop</primary>"
msgstr "<primary>var_pop</primary>"

#: func.xml:13592(entry)
msgid ""
"<placeholder-1/> <placeholder-2/> <function>var_pop</function>(<replaceable "
"class=\"parameter\">expression</replaceable>)"
msgstr ""
"<placeholder-1/> <placeholder-2/> <function>var_pop</function>(<replaceable "
"class=\"parameter\">выражение</replaceable>)"

#: func.xml:13612(entry)
msgid ""
"population variance of the input values (square of the population standard "
"deviation)"
msgstr ""
"дисперсия для генеральной совокупности входных значений (квадрат "
"стандартного отклонения)"

#: func.xml:13617(indexterm)
msgid "<primary>variance</primary> <secondary>sample</secondary>"
msgstr "<primary>дисперсия</primary> <secondary>по выборке</secondary>"

#: func.xml:13621(indexterm)
msgid "<primary>var_samp</primary>"
msgstr "<primary>var_samp</primary>"

#: func.xml:13616(entry)
msgid ""
"<placeholder-1/> <placeholder-2/> <function>var_samp</function>(<replaceable "
"class=\"parameter\">expression</replaceable>)"
msgstr ""
"<placeholder-1/> <placeholder-2/> <function>var_samp</function>(<replaceable "
"class=\"parameter\">выражение</replaceable>)"

#: func.xml:13636(entry)
msgid ""
"sample variance of the input values (square of the sample standard deviation)"
msgstr ""
"дисперсия по выборке для входных значений (квадрат отклонения по выборке)"

#: func.xml:13642(para)
msgid ""
"<xref linkend=\"functions-orderedset-table\"/> shows some aggregate "
"functions that use the <firstterm>ordered-set aggregate</firstterm> syntax. "
"These functions are sometimes referred to as <quote>inverse distribution</"
"quote> functions."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-orderedset-table\"/> показаны "
"некоторые агрегатные функции, использующие синтаксис <firstterm>сортирующих "
"агрегатных функций</firstterm>. Иногда такие функции функциями называют "
"функциями <quote>обратного распределения</quote>."

#: func.xml:13649(indexterm)
msgid ""
"<primary>ordered-set aggregate</primary> <secondary>built-in</secondary>"
msgstr ""
"<primary>сортирующие агрегатные функции</primary> <secondary>встроенные</"
"secondary>"

#: func.xml:13653(indexterm)
msgid "<primary>inverse distribution</primary>"
msgstr "<primary>обратное распределение</primary>"

#: func.xml:13658(title)
msgid "Ordered-Set Aggregate Functions"
msgstr "Сортирующие агрегатные функции"

#: func.xml:13664(entry) func.xml:13826(entry)
msgid "Direct Argument Type(s)"
msgstr "Тип непосредственного аргумента"

#: func.xml:13665(entry) func.xml:13827(entry)
msgid "Aggregated Argument Type(s)"
msgstr "Тип агрегированного аргумента"

#: func.xml:13676(indexterm)
msgid "<primary>mode</primary> <secondary>statistical</secondary>"
msgstr "<primary>мода</primary> <secondary>статистическая функция</secondary>"

#: func.xml:13680(replaceable) func.xml:13706(replaceable)
#: func.xml:13727(replaceable) func.xml:13752(replaceable)
#: func.xml:13772(replaceable)
msgid "sort_expression"
msgstr "выражение_сортировки"

#: func.xml:13680(function)
msgid "mode() WITHIN GROUP (ORDER BY <placeholder-1/>)"
msgstr "mode() WITHIN GROUP (ORDER BY <placeholder-1/>)"

#: func.xml:13684(entry) func.xml:13757(entry) func.xml:13777(entry)
msgid "any sortable type"
msgstr "любой сортируемый тип"

#: func.xml:13687(entry) func.xml:13714(entry) func.xml:13760(entry)
msgid "same as sort expression"
msgstr "тот же, что у выражения сортировки"

#: func.xml:13691(entry)
msgid ""
"returns the most frequent input value (arbitrarily choosing the first one if "
"there are multiple equally-frequent results)"
msgstr ""
"возвращает значение, наиболее часто встречающееся во входных данных (если "
"одинаково часто встречаются несколько значений, произвольно выбирается "
"первое из них)"

#: func.xml:13699(indexterm)
msgid "<primary>percentile</primary> <secondary>continuous</secondary>"
msgstr "<primary>перцентиль</primary> <secondary>непрерывный</secondary>"

#: func.xml:13703(indexterm)
msgid "<primary>median</primary>"
msgstr "<primary>медиана</primary>"

#: func.xml:13706(replaceable) func.xml:13752(replaceable)
msgid "fraction"
msgstr "дробь"

#: func.xml:13706(function) func.xml:13727(function)
msgid ""
"percentile_cont(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr ""
"percentile_cont(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#: func.xml:13711(entry) func.xml:13732(entry)
msgid "<type>double precision</type> or <type>interval</type>"
msgstr "<type>double precision</type> или <type>interval</type>"

#: func.xml:13718(entry)
msgid ""
"continuous percentile: returns a value corresponding to the specified "
"fraction in the ordering, interpolating between adjacent input items if "
"needed"
msgstr ""
"непрерывный перцентиль: возвращает значение, соответствующее заданной дроби "
"по порядку, интерполируя соседние входные значения, если необходимо"

#: func.xml:13727(replaceable) func.xml:13772(replaceable)
msgid "fractions"
msgstr "дроби"

#: func.xml:13730(type) func.xml:13775(type)
msgid "double precision[]"
msgstr "double precision[]"

#: func.xml:13735(entry) func.xml:13780(entry)
msgid "array of sort expression's type"
msgstr "массив типа выражения сортировки"

#: func.xml:13739(entry)
msgid ""
"multiple continuous percentile: returns an array of results matching the "
"shape of the <literal>fractions</literal> parameter, with each non-null "
"element replaced by the value corresponding to that percentile"
msgstr ""
"множественный непрерывный перцентиль: возвращает массив результатов, "
"соответствующих значениям в параметре <literal>дроби</literal> (для каждого "
"элемента не NULL подставляется значение, соответствующее данному перцентилю)"

#: func.xml:13748(indexterm)
msgid "<primary>percentile</primary> <secondary>discrete</secondary>"
msgstr "<primary>перцентиль</primary> <secondary>дискретный</secondary>"

#: func.xml:13752(function) func.xml:13772(function)
msgid ""
"percentile_disc(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr ""
"percentile_disc(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#: func.xml:13764(entry)
msgid ""
"discrete percentile: returns the first input value whose position in the "
"ordering equals or exceeds the specified fraction"
msgstr ""
"дискретный перцентиль: возвращает первое значение из входных данных, позиция "
"которого по порядку равна или превосходит указанную дробь"

#: func.xml:13784(entry)
msgid ""
"multiple discrete percentile: returns an array of results matching the shape "
"of the <literal>fractions</literal> parameter, with each non-null element "
"replaced by the input value corresponding to that percentile"
msgstr ""
"множественный дискретный перцентиль: возвращает массив результатов, "
"соответствующих значениям в параметре <literal>дроби</literal> (для каждого "
"элемента не NULL подставляется входное значение, соответствующее данному "
"перцентилю)"

#: func.xml:13795(para)
msgid ""
"All the aggregates listed in <xref linkend=\"functions-orderedset-table\"/> "
"ignore null values in their sorted input. For those that take a "
"<replaceable>fraction</replaceable> parameter, the fraction value must be "
"between 0 and 1; an error is thrown if not. However, a null fraction value "
"simply produces a null result."
msgstr ""
"Все агрегатные функции, перечисленные в <xref remap=\"6\" linkend="
"\"functions-orderedset-table\"/>, игнорируют значения NULL при сортировке "
"данных. Для функций, принимающих параметр <replaceable>дробь</replaceable>, "
"значение этого параметра должно быть от 0 до 1; в противном случае возникает "
"ошибка. Однако, если в этом параметре передаётся NULL, эти функции просто "
"выдают NULL."

#: func.xml:13803(indexterm)
msgid ""
"<primary>hypothetical-set aggregate</primary> <secondary>built-in</secondary>"
msgstr ""
"<primary>гипотезирующие агрегатные функции</primary> <secondary>встроенные</"
"secondary>"

#: func.xml:13808(para)
msgid ""
"Each of the aggregates listed in <xref linkend=\"functions-hypothetical-table"
"\"/> is associated with a window function of the same name defined in <xref "
"linkend=\"functions-window\"/>. In each case, the aggregate result is the "
"value that the associated window function would have returned for the "
"<quote>hypothetical</quote> row constructed from <replaceable>args</"
"replaceable>, if such a row had been added to the sorted group of rows "
"computed from the <replaceable>sorted_args</replaceable>."
msgstr ""
"Все агрегатные функции, перечисленные в <xref remap=\"6\" linkend="
"\"functions-hypothetical-table\"/>, связаны с одноимёнными оконными "
"функциями, определёнными в <xref remap=\"6\" linkend=\"functions-window\"/>. "
"В каждом случае их результат &mdash; значение, которое вернула бы связанная "
"оконная функция для <quote>гипотетической</quote> строки, полученной из "
"<replaceable>аргументов</replaceable>, если бы такая строка была добавлена в "
"сортированную группу строк, которую образуют "
"<replaceable>сортированные_аргументы</replaceable>."

#: func.xml:13820(title)
msgid "Hypothetical-Set Aggregate Functions"
msgstr "Гипотезирующие агрегатные функции"

#: func.xml:13838(indexterm)
msgid "<primary>rank</primary> <secondary>hypothetical</secondary>"
msgstr "<primary>rank</primary> <secondary>гипотезирующая функция</secondary>"

#: func.xml:13842(replaceable) func.xml:13865(replaceable)
#: func.xml:13888(replaceable) func.xml:13911(replaceable)
msgctxt "replaceable"
msgid "args"
msgstr "аргументы"

#: func.xml:13842(replaceable) func.xml:13865(replaceable)
#: func.xml:13888(replaceable) func.xml:13911(replaceable)
msgid "sorted_args"
msgstr "сортированные_аргументы"

#: func.xml:13842(function)
msgid "rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr "rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#: func.xml:13845(literal) func.xml:13848(literal) func.xml:13868(literal)
#: func.xml:13871(literal) func.xml:13891(literal) func.xml:13894(literal)
#: func.xml:13914(literal) func.xml:13917(literal)
msgid "VARIADIC"
msgstr "VARIADIC"

#: func.xml:13854(entry)
msgid "rank of the hypothetical row, with gaps for duplicate rows"
msgstr "ранг гипотетической строки, с пропусками повторяющихся строк"

#: func.xml:13861(indexterm)
msgid "<primary>dense_rank</primary> <secondary>hypothetical</secondary>"
msgstr ""
"<primary>dense_rank</primary> <secondary>гипотезирующая функция</secondary>"

#: func.xml:13865(function)
msgid "dense_rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr "dense_rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#: func.xml:13877(entry)
msgid "rank of the hypothetical row, without gaps"
msgstr "ранг гипотетической строки, без пропусков"

#: func.xml:13884(indexterm)
msgid "<primary>percent_rank</primary> <secondary>hypothetical</secondary>"
msgstr ""
"<primary>percent_rank</primary> <secondary>гипотезирующая функция</secondary>"

#: func.xml:13888(function)
msgid "percent_rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr ""
"percent_rank(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#: func.xml:13900(entry)
msgid "relative rank of the hypothetical row, ranging from 0 to 1"
msgstr "относительный ранг гипотетической строки, от 0 до 1"

#: func.xml:13907(indexterm)
msgid "<primary>cume_dist</primary> <secondary>hypothetical</secondary>"
msgstr ""
"<primary>cume_dist</primary> <secondary>гипотезирующая функция</secondary>"

#: func.xml:13911(function)
msgid "cume_dist(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"
msgstr "cume_dist(<placeholder-1/>) WITHIN GROUP (ORDER BY <placeholder-2/>)"

#: func.xml:13923(entry)
msgid ""
"relative rank of the hypothetical row, ranging from 1/<replaceable>N</"
"replaceable> to 1"
msgstr ""
"относительный ранг гипотетической строки, от 1/<replaceable>N</replaceable> "
"до 1"

#: func.xml:13933(para)
msgid ""
"For each of these hypothetical-set aggregates, the list of direct arguments "
"given in <replaceable>args</replaceable> must match the number and types of "
"the aggregated arguments given in <replaceable>sorted_args</replaceable>. "
"Unlike most built-in aggregates, these aggregates are not strict, that is "
"they do not drop input rows containing nulls. Null values sort according to "
"the rule specified in the <literal>ORDER BY</literal> clause."
msgstr ""
"Для всех этих гипотезирующих агрегатных функций непосредственные "
"<replaceable>аргументы</replaceable> должны соответствовать (по количеству и "
"типу) <replaceable>сортированным_аргументам</replaceable>. В отличие от "
"встроенных агрегатных функций, они не являются строгими, то есть не "
"отбрасывают входные строки, содержащие NULL. Значения NULL сортируются "
"согласно правилу, указанному в предложении <literal>ORDER BY</literal>."

#: func.xml:13943(title)
msgid "Grouping Operations"
msgstr "Операции группировки"

#: func.xml:13958(indexterm)
msgid "<primary>GROUPING</primary>"
msgstr "<primary>GROUPING</primary>"

#: func.xml:13961(replaceable)
msgid "args..."
msgstr "аргументы..."

#: func.xml:13961(function)
msgid "GROUPING(<placeholder-1/>)"
msgstr "GROUPING(<placeholder-1/>)"

#: func.xml:13966(entry)
msgid ""
"Integer bit mask indicating which arguments are not being included in the "
"current grouping set"
msgstr ""
"Целочисленная битовая маска, показывающая, какие аргументы не вошли в "
"текущий набор группирования"

#: func.xml:13975(para)
msgid ""
"Grouping operations are used in conjunction with grouping sets (see <xref "
"linkend=\"queries-grouping-sets\"/>) to distinguish result rows. The "
"arguments to the <literal>GROUPING</literal> operation are not actually "
"evaluated, but they must match exactly expressions given in the "
"<literal>GROUP BY</literal> clause of the associated query level. Bits are "
"assigned with the rightmost argument being the least-significant bit; each "
"bit is 0 if the corresponding expression is included in the grouping "
"criteria of the grouping set generating the result row, and 1 if it is not. "
"For example: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>\n"
" make  | model | sales\n"
"-------+-------+-------\n"
" Foo   | GT    |  10\n"
" Foo   | Tour  |  20\n"
" Bar   | City  |  15\n"
" Bar   | Sport |  5\n"
"(4 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), "
"sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>\n"
" make  | model | grouping | sum\n"
"-------+-------+----------+-----\n"
" Foo   | GT    |        0 | 10\n"
" Foo   | Tour  |        0 | 20\n"
" Bar   | City  |        0 | 15\n"
" Bar   | Sport |        0 | 5\n"
" Foo   |       |        1 | 30\n"
" Bar   |       |        1 | 20\n"
"       |       |        3 | 50\n"
"(7 rows)\n"
"</screen>"
msgstr ""
"Операции группировки применяются в сочетании с наборами группирования (см. "
"<xref remap=\"4\" linkend=\"queries-grouping-sets\"/>) для различения "
"результирующих строк. Аргументы операции <literal>GROUPING</literal> на "
"самом деле не вычисляются, но они должны в точности соответствовать "
"выражениям, заданным в предложении <literal>GROUP BY</literal> на их уровне "
"запроса. Биты назначаются справа налево (правый аргумент отражается в "
"младшем бите); бит равен 0, если соответствующее выражение вошло в критерий "
"группировки набора группирования, для которого сформирована строка "
"результата, или 1 в противном случае. Например: <screen>\n"
"<prompt>=&gt;</prompt> <userinput>SELECT * FROM items_sold;</userinput>\n"
" make  | model | sales\n"
"-------+-------+-------\n"
" Foo   | GT    |  10\n"
" Foo   | Tour  |  20\n"
" Bar   | City  |  15\n"
" Bar   | Sport |  5\n"
"(4 rows)\n"
"\n"
"<prompt>=&gt;</prompt> <userinput>SELECT make, model, GROUPING(make,model), "
"sum(sales) FROM items_sold GROUP BY ROLLUP(make,model);</userinput>\n"
" make  | model | grouping | sum\n"
"-------+-------+----------+-----\n"
" Foo   | GT    |        0 | 10\n"
" Foo   | Tour  |        0 | 20\n"
" Bar   | City  |        0 | 15\n"
" Bar   | Sport |        0 | 5\n"
" Foo   |       |        1 | 30\n"
" Bar   |       |        1 | 20\n"
"       |       |        3 | 50\n"
"(7 rows)\n"
"</screen>"

#: func.xml:14011(title)
msgid "Window Functions"
msgstr "Оконные функции"

#: func.xml:14013(indexterm)
msgid "<primary>window function</primary> <secondary>built-in</secondary>"
msgstr "<primary>оконные функции</primary> <secondary>встроенные</secondary>"

#: func.xml:14018(para)
msgid ""
"<firstterm>Window functions</firstterm> provide the ability to perform "
"calculations across sets of rows that are related to the current query row. "
"See <xref linkend=\"tutorial-window\"/> for an introduction to this feature, "
"and <xref linkend=\"syntax-window-functions\"/> for syntax details."
msgstr ""
"<firstterm>Оконные функции</firstterm> дают возможность выполнять вычисления "
"с набором строк, каким-либо образом связанным с текущей строкой запроса. "
"Вводную информацию об этом можно получить в <xref remap=\"6\" linkend="
"\"tutorial-window\"/>, а подробнее узнать о синтаксисе можно в <xref remap="
"\"6\" linkend=\"syntax-window-functions\"/>."

#: func.xml:14026(para)
msgid ""
"The built-in window functions are listed in <xref linkend=\"functions-window-"
"table\"/>. Note that these functions <emphasis>must</emphasis> be invoked "
"using window function syntax; that is an <literal>OVER</literal> clause is "
"required."
msgstr ""
"Встроенные оконные функции перечислены в <xref remap=\"6\" linkend="
"\"functions-window-table\"/>. Заметьте, что эти функции <emphasis>должны</"
"emphasis> вызываться именно как оконные, т. е. при вызове необходимо "
"использовать предложение <literal>OVER</literal>."

#: func.xml:14033(para)
msgid ""
"In addition to these functions, any built-in or user-defined normal "
"aggregate function (but not ordered-set or hypothetical-set aggregates) can "
"be used as a window function; see <xref linkend=\"functions-aggregate\"/> "
"for a list of the built-in aggregates. Aggregate functions act as window "
"functions only when an <literal>OVER</literal> clause follows the call; "
"otherwise they act as regular aggregates."
msgstr ""
"В дополнение к этим функциям в качестве оконных можно использовать любые "
"встроенные или пользовательские обычные (но не сортирующие и не "
"гипотезирующие) агрегатные функции (встроенные функции перечислены в <xref "
"remap=\"6\" linkend=\"functions-aggregate\"/>). Агрегатные функции работают "
"как оконные, только когда за их вызовом следует предложение <literal>OVER</"
"literal>; в противном случае они останутся обычными агрегатными."

#: func.xml:14043(title)
msgid "General-Purpose Window Functions"
msgstr "Оконные функции общего назначения"

#: func.xml:14057(indexterm)
msgid "<primary>row_number</primary>"
msgstr "<primary>row_number</primary>"

#: func.xml:14060(function)
msgid "row_number()"
msgstr "row_number()"

#: func.xml:14065(entry)
msgid "number of the current row within its partition, counting from 1"
msgstr "номер текущей строки в её разделе, начиная с 1"

#: func.xml:14070(indexterm)
msgid "<primary>rank</primary>"
msgstr "<primary>rank</primary>"

#: func.xml:14073(function)
msgid "rank()"
msgstr "rank()"

#: func.xml:14078(entry)
msgid ""
"rank of the current row with gaps; same as <function>row_number</function> "
"of its first peer"
msgstr ""
"ранг текущей строки с пропусками; то же, что и <function>row_number</"
"function> для первой родственной ей строки"

#: func.xml:14083(indexterm)
msgid "<primary>dense_rank</primary>"
msgstr "<primary>dense_rank</primary>"

#: func.xml:14086(function)
msgid "dense_rank()"
msgstr "dense_rank()"

#: func.xml:14091(entry)
msgid "rank of the current row without gaps; this function counts peer groups"
msgstr ""
"ранг текущей строки без пропусков; эта функция считает группы родственных "
"строк"

#: func.xml:14096(indexterm)
msgid "<primary>percent_rank</primary>"
msgstr "<primary>percent_rank</primary>"

#: func.xml:14099(function)
msgid "percent_rank()"
msgstr "percent_rank()"

#: func.xml:14104(entry)
msgid ""
"relative rank of the current row: (<function>rank</function> - 1) / (total "
"rows - 1)"
msgstr ""
"относительный ранг текущей строки: (<function>rank</function> - 1) / (общее "
"число строк - 1)"

#: func.xml:14109(indexterm)
msgid "<primary>cume_dist</primary>"
msgstr "<primary>cume_dist</primary>"

#: func.xml:14112(function)
msgid "cume_dist()"
msgstr "cume_dist()"

#: func.xml:14117(entry)
msgid ""
"relative rank of the current row: (number of rows preceding or peer with "
"current row) / (total rows)"
msgstr ""
"относительный ранг текущей строки: (число строк, предшествующих или "
"родственных текущей) / (общее число строк)"

#: func.xml:14122(indexterm)
msgid "<primary>ntile</primary>"
msgstr "<primary>ntile</primary>"

#: func.xml:14125(replaceable)
msgid "num_buckets"
msgstr "число_групп"

#: func.xml:14125(function)
msgid "ntile(<placeholder-1/> <placeholder-2/>)"
msgstr "ntile(<placeholder-1/> <placeholder-2/>)"

#: func.xml:14130(entry)
msgid ""
"integer ranging from 1 to the argument value, dividing the partition as "
"equally as possible"
msgstr ""
"ранжирование по целым числам от 1 до значения аргумента так, чтобы размеры "
"групп были максимально близки"

#: func.xml:14136(indexterm)
msgid "<primary>lag</primary>"
msgstr "<primary>lag</primary>"

#: func.xml:14141(replaceable) func.xml:14170(replaceable)
msgctxt "replaceable"
msgid "offset"
msgstr "смещение"

#: func.xml:14142(replaceable) func.xml:14171(replaceable)
msgid "default"
msgstr "по_умолчанию"

#: func.xml:14139(function)
msgid ""
"lag(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/> "
"[, <placeholder-5/> <placeholder-6/> ]])"
msgstr ""
"lag(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/> "
"[, <placeholder-5/> <placeholder-6/> ]])"

#: func.xml:14146(type) func.xml:14175(type) func.xml:14200(type)
#: func.xml:14216(type) func.xml:14234(type)
msgid "same type as <placeholder-1/>"
msgstr "тип аргумента <placeholder-1/>"

#: func.xml:14148(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is <replaceable class=\"parameter\">offset</replaceable> rows "
"before the current row within the partition; if there is no such row, "
"instead return <replaceable class=\"parameter\">default</replaceable> (which "
"must be of the same type as <replaceable class=\"parameter\">value</"
"replaceable>). Both <replaceable class=\"parameter\">offset</replaceable> "
"and <replaceable class=\"parameter\">default</replaceable> are evaluated "
"with respect to the current row. If omitted, <replaceable class=\"parameter"
"\">offset</replaceable> defaults to 1 and <replaceable class=\"parameter"
"\">default</replaceable> to null"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable> для "
"строки, положение которой задаётся <replaceable class=\"parameter"
"\">смещением</replaceable> от текущей строки к началу раздела; если такой "
"строки нет, возвращается значение <replaceable class=\"parameter"
"\">по_умолчанию</replaceable> (оно должно иметь тот же тип, что и "
"<replaceable class=\"parameter\">значение</replaceable>). Оба параметра "
"<replaceable class=\"parameter\">смещение</replaceable> и <replaceable class="
"\"parameter\">по_умолчанию</replaceable> вычисляются для текущей строки. "
"Если они не указываются, то <replaceable class=\"parameter\">смещение</"
"replaceable> считается равным 1, а <replaceable class=\"parameter"
"\">по_умолчанию</replaceable> &mdash; NULL"

#: func.xml:14165(indexterm)
msgid "<primary>lead</primary>"
msgstr "<primary>lead</primary>"

#: func.xml:14168(function)
msgid ""
"lead(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/> "
"[, <placeholder-5/> <placeholder-6/> ]])"
msgstr ""
"lead(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> <placeholder-4/> "
"[, <placeholder-5/> <placeholder-6/> ]])"

#: func.xml:14177(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is <replaceable class=\"parameter\">offset</replaceable> rows "
"after the current row within the partition; if there is no such row, instead "
"return <replaceable class=\"parameter\">default</replaceable> (which must be "
"of the same type as <replaceable class=\"parameter\">value</replaceable>). "
"Both <replaceable class=\"parameter\">offset</replaceable> and <replaceable "
"class=\"parameter\">default</replaceable> are evaluated with respect to the "
"current row. If omitted, <replaceable class=\"parameter\">offset</"
"replaceable> defaults to 1 and <replaceable class=\"parameter\">default</"
"replaceable> to null"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable> для "
"строки, положение которой задаётся <replaceable class=\"parameter"
"\">смещением</replaceable> от текущей строки к концу раздела; если такой "
"строки нет, возвращается значение <replaceable class=\"parameter"
"\">по_умолчанию</replaceable> (оно должно иметь тот же тип, что и "
"<replaceable class=\"parameter\">значение</replaceable>). Оба параметра "
"<replaceable class=\"parameter\">смещение</replaceable> и <replaceable class="
"\"parameter\">по_умолчанию</replaceable> вычисляются для текущей строки. "
"Если они не указываются, то <replaceable class=\"parameter\">смещение</"
"replaceable> считается равным 1, а <replaceable class=\"parameter"
"\">по_умолчанию</replaceable> &mdash; NULL"

#: func.xml:14194(indexterm)
msgid "<primary>first_value</primary>"
msgstr "<primary>first_value</primary>"

#: func.xml:14197(function)
msgid "first_value(<placeholder-1/> <placeholder-2/>)"
msgstr "first_value(<placeholder-1/> <placeholder-2/>)"

#: func.xml:14202(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is the first row of the window frame"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable>, "
"вычисленное для первой строки в рамке окна"

#: func.xml:14210(indexterm)
msgid "<primary>last_value</primary>"
msgstr "<primary>last_value</primary>"

#: func.xml:14213(function)
msgid "last_value(<placeholder-1/> <placeholder-2/>)"
msgstr "last_value(<placeholder-1/> <placeholder-2/>)"

#: func.xml:14218(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is the last row of the window frame"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable>, "
"вычисленное для последней строки в рамке окна"

#: func.xml:14226(indexterm)
msgid "<primary>nth_value</primary>"
msgstr "<primary>nth_value</primary>"

#: func.xml:14230(replaceable)
msgid "nth"
msgstr "n"

#: func.xml:14229(function)
msgid ""
"nth_value(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"
msgstr ""
"nth_value(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/"
">)"

#: func.xml:14236(entry)
msgid ""
"returns <replaceable class=\"parameter\">value</replaceable> evaluated at "
"the row that is the <replaceable class=\"parameter\">nth</replaceable> row "
"of the window frame (counting from 1); null if no such row"
msgstr ""
"возвращает <replaceable class=\"parameter\">значение</replaceable>, "
"вычисленное в <replaceable class=\"parameter\">н-ой</replaceable> строке в "
"рамке окна (считая с 1), или NULL, если такой строки нет"

#: func.xml:14246(para)
msgid ""
"All of the functions listed in <xref linkend=\"functions-window-table\"/> "
"depend on the sort ordering specified by the <literal>ORDER BY</literal> "
"clause of the associated window definition. Rows that are not distinct in "
"the <literal>ORDER BY</literal> ordering are said to be <firstterm>peers</"
"firstterm>; the four ranking functions are defined so that they give the "
"same answer for any two peer rows."
msgstr ""
"Результат всех функций, перечисленных в <xref remap=\"6\" linkend="
"\"functions-window-table\"/>, зависит от порядка сортировки, заданного "
"предложением <literal>ORDER BY</literal> в определении соответствующего "
"окна. Строки, которые являются одинаковыми с точки зрения сортировки "
"<literal>ORDER BY</literal>, считаются <firstterm>родственными</firstterm>; "
"четыре функции, вычисляющие ранг, реализованы так, что их результат будет "
"одинаковым для любых двух родственных строк."

#: func.xml:14255(para)
msgid ""
"Note that <function>first_value</function>, <function>last_value</function>, "
"and <function>nth_value</function> consider only the rows within the "
"<quote>window frame</quote>, which by default contains the rows from the "
"start of the partition through the last peer of the current row. This is "
"likely to give unhelpful results for <function>last_value</function> and "
"sometimes also <function>nth_value</function>. You can redefine the frame by "
"adding a suitable frame specification (<literal>RANGE</literal> or "
"<literal>ROWS</literal>) to the <literal>OVER</literal> clause. See <xref "
"linkend=\"syntax-window-functions\"/> for more information about frame "
"specifications."
msgstr ""
"Заметьте, что функции <function>first_value</function>, "
"<function>last_value</function> и <function>nth_value</function> "
"рассматривают только строки в <quote>рамке окна</quote>, которая по "
"умолчанию содержит строки от начала раздела до последней родственной строки "
"для текущей. Поэтому результаты <function>last_value</function> и иногда "
"<function>nth_value</function> могут быть не очень полезны. В таких случаях "
"можно переопределить рамку, добавив в предложение <literal>OVER</literal> "
"подходящее указание (<literal>RANGE</literal> или <literal>ROWS</literal>). "
"Подробнее эти указания описаны в <xref remap=\"6\" linkend=\"syntax-window-"
"functions\"/>."

#: func.xml:14268(para)
msgid ""
"When an aggregate function is used as a window function, it aggregates over "
"the rows within the current row's window frame. An aggregate used with "
"<literal>ORDER BY</literal> and the default window frame definition produces "
"a <quote>running sum</quote> type of behavior, which may or may not be "
"what's wanted. To obtain aggregation over the whole partition, omit "
"<literal>ORDER BY</literal> or use <literal>ROWS BETWEEN UNBOUNDED PRECEDING "
"AND UNBOUNDED FOLLOWING</literal>. Other frame specifications can be used to "
"obtain other effects."
msgstr ""
"Когда в качестве оконной функции используется агрегатная, она обрабатывает "
"строки в рамке текущей строки. Агрегатная функция с <literal>ORDER BY</"
"literal> и определением рамки окна по умолчанию будет вычисляться как "
"<quote>бегущая сумма</quote>, что может не соответствовать желаемому "
"результату. Чтобы агрегатная функция работала со всем разделом, следует "
"опустить <literal>ORDER BY</literal> или использовать <literal>ROWS BETWEEN "
"UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING</literal>. Используя другие "
"указания в определении рамки, можно получить и другие эффекты."

#: func.xml:14280(para)
msgid ""
"The SQL standard defines a <literal>RESPECT NULLS</literal> or "
"<literal>IGNORE NULLS</literal> option for <function>lead</function>, "
"<function>lag</function>, <function>first_value</function>, "
"<function>last_value</function>, and <function>nth_value</function>. This is "
"not implemented in <productname>PostgreSQL</productname>: the behavior is "
"always the same as the standard's default, namely <literal>RESPECT NULLS</"
"literal>. Likewise, the standard's <literal>FROM FIRST</literal> or "
"<literal>FROM LAST</literal> option for <function>nth_value</function> is "
"not implemented: only the default <literal>FROM FIRST</literal> behavior is "
"supported. (You can achieve the result of <literal>FROM LAST</literal> by "
"reversing the <literal>ORDER BY</literal> ordering.)"
msgstr ""
"В стандарте SQL определены параметры <literal>RESPECT NULLS</literal> или "
"<literal>IGNORE NULLS</literal> для функций <function>lead</function>, "
"<function>lag</function>, <function>first_value</function>, "
"<function>last_value</function> и <function>nth_value</function>. В "
"<productname>PostgreSQL</productname> такие параметры не реализованы: эти "
"функции ведут себя так, как положено в стандарте по умолчанию (или с "
"подразумеваемым параметром <literal>RESPECT NULLS</literal>). Также функция "
"<function>nth_value</function> не поддерживает предусмотренные стандартом "
"параметры <literal>FROM FIRST</literal> и <literal>FROM LAST</literal>: "
"реализовано только поведение по умолчанию (с подразумеваемым параметром "
"<literal>FROM FIRST</literal>). (Получить эффект параметра <literal>FROM "
"LAST</literal> можно, изменив порядок <literal>ORDER BY</literal> на "
"обратный.)"

#: func.xml:14298(title)
msgid "Subquery Expressions"
msgstr "Выражения подзапросов"

#: func.xml:14300(indexterm)
msgid "<primary>EXISTS</primary>"
msgstr "<primary>EXISTS</primary>"

#: func.xml:14304(indexterm) func.xml:14651(indexterm)
msgid "<primary>IN</primary>"
msgstr "<primary>IN</primary>"

#: func.xml:14308(indexterm) func.xml:14655(indexterm)
msgid "<primary>NOT IN</primary>"
msgstr "<primary>NOT IN</primary>"

#: func.xml:14316(indexterm) func.xml:14663(indexterm)
msgid "<primary>ALL</primary>"
msgstr "<primary>ALL</primary>"

#: func.xml:14324(indexterm)
msgid "<primary>subquery</primary>"
msgstr "<primary>подзапрос</primary>"

#: func.xml:14328(para)
msgid ""
"This section describes the <acronym>SQL</acronym>-compliant subquery "
"expressions available in <productname>PostgreSQL</productname>. All of the "
"expression forms documented in this section return Boolean (true/false) "
"results."
msgstr ""
"В этом разделе описаны выражения подзапросов, которые реализованы в "
"<productname>PostgreSQL</productname> в соответствии со стандартом "
"<acronym>SQL</acronym>. Все рассмотренные здесь формы выражений возвращает "
"булевы значения (true/false)."

#: func.xml:14336(literal)
msgid "EXISTS"
msgstr "EXISTS"

#: func.xml:14339(replaceable) func.xml:14389(replaceable)
#: func.xml:14415(replaceable) func.xml:14445(replaceable)
#: func.xml:14471(replaceable) func.xml:14501(replaceable)
#: func.xml:14502(replaceable) func.xml:14535(replaceable)
#: func.xml:14536(replaceable) func.xml:14566(replaceable)
#: func.xml:14592(replaceable) func.xml:14627(replaceable)
msgid "subquery"
msgstr "подзапрос"

#: func.xml:14338(synopsis)
#, no-wrap
msgid "EXISTS (<placeholder-1/>)"
msgstr "EXISTS (<placeholder-1/>)"

#: func.xml:14342(para)
msgid ""
"The argument of <token>EXISTS</token> is an arbitrary <command>SELECT</"
"command> statement, or <firstterm>subquery</firstterm>. The subquery is "
"evaluated to determine whether it returns any rows. If it returns at least "
"one row, the result of <token>EXISTS</token> is <quote>true</quote>; if the "
"subquery returns no rows, the result of <token>EXISTS</token> is "
"<quote>false</quote>."
msgstr ""
"Аргументом <token>EXISTS</token> является обычный оператор <command>SELECT</"
"command>, т. е. <firstterm>подзапрос</firstterm>. Выполнив запрос, система "
"проверяет, возвращает ли он строки в результате. Если он возвращает минимум "
"одну строку, результатом <token>EXISTS</token> будет <quote>true</quote>, а "
"если не возвращает ни одной &mdash; <quote>false</quote>."

#: func.xml:14351(para)
msgid ""
"The subquery can refer to variables from the surrounding query, which will "
"act as constants during any one evaluation of the subquery."
msgstr ""
"Подзапрос может обращаться к переменным внешнего запроса, которые в рамках "
"одного вычисления подзапроса считаются константами."

#: func.xml:14356(para)
msgid ""
"The subquery will generally only be executed long enough to determine "
"whether at least one row is returned, not all the way to completion. It is "
"unwise to write a subquery that has side effects (such as calling sequence "
"functions); whether the side effects occur might be unpredictable."
msgstr ""
"Вообще говоря, подзапрос может выполняться не полностью, а завершаться, как "
"только будет возвращена хотя бы одна строка. Поэтому в подзапросах следует "
"избегать побочных эффектов (например, обращений к генераторам "
"последовательностей); проявление побочного эффекта может быть "
"непредсказуемым."

#: func.xml:14364(para)
msgid ""
"Since the result depends only on whether any rows are returned, and not on "
"the contents of those rows, the output list of the subquery is normally "
"unimportant. A common coding convention is to write all <literal>EXISTS</"
"literal> tests in the form <literal>EXISTS(SELECT 1 WHERE ...)</literal>. "
"There are exceptions to this rule however, such as subqueries that use "
"<token>INTERSECT</token>."
msgstr ""
"Так как результат этого выражения зависит только от того, возвращаются "
"строки или нет, но не от их содержимого, список выходных значений подзапроса "
"обычно не имеет значения. Как следствие, широко распространена практика, "
"когда проверки <literal>EXISTS</literal> записываются в форме "
"<literal>EXISTS(SELECT 1 WHERE ...)</literal>. Однако из этого правила есть "
"и исключения, например с подзапросами с предложением <token>INTERSECT</"
"token>."

#: func.xml:14373(para)
msgid ""
"This simple example is like an inner join on <literal>col2</literal>, but it "
"produces at most one output row for each <literal>tab1</literal> row, even "
"if there are several matching <literal>tab2</literal> rows: <screen>\n"
"SELECT col1\n"
"FROM tab1\n"
"WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);\n"
"</screen>"
msgstr ""
"Этот простой пример похож на внутреннее соединение по столбцу <literal>col2</"
"literal>, но он выдаёт максимум одну строку для каждой строки в "
"<literal>tab1</literal>, даже если в <literal>tab2</literal> ей "
"соответствуют несколько строк: <screen>\n"
"SELECT col1\n"
"FROM tab1\n"
"WHERE EXISTS (SELECT 1 FROM tab2 WHERE col2 = tab1.col2);\n"
"</screen>"

#: func.xml:14386(literal) func.xml:14711(literal)
msgid "IN"
msgstr "IN"

#: func.xml:14388(synopsis) func.xml:14414(synopsis)
#, no-wrap
msgid "<placeholder-1/> IN (<placeholder-2/>)"
msgstr "<placeholder-1/> IN (<placeholder-2/>)"

#: func.xml:14392(para)
msgid ""
"The right-hand side is a parenthesized subquery, which must return exactly "
"one column. The left-hand expression is evaluated and compared to each row "
"of the subquery result. The result of <token>IN</token> is <quote>true</"
"quote> if any equal subquery row is found. The result is <quote>false</"
"quote> if no equal row is found (including the case where the subquery "
"returns no rows)."
msgstr ""
"В правой стороне этого выражения в скобках задаётся подзапрос, который "
"должен возвращать ровно один столбец. Вычисленное значение левого выражения "
"сравнивается со значениями во всех строках, возвращённых подзапросом. "
"Результатом всего выражения <token>IN</token> будет <quote>true</quote>, "
"если строка с таким значением находится, и <quote>false</quote> в противном "
"случае (в том числе, когда подзапрос вообще не возвращает строк)."

#: func.xml:14401(para)
msgid ""
"Note that if the left-hand expression yields null, or if there are no equal "
"right-hand values and at least one right-hand row yields null, the result of "
"the <token>IN</token> construct will be null, not false. This is in "
"accordance with SQL's normal rules for Boolean combinations of null values."
msgstr ""
"Заметьте, что если результатом выражения слева оказывается NULL или равных "
"значений справа не находится, а хотя бы одно из значений справа равно NULL, "
"конструкция <token>IN</token> возвращает NULL, а не false. Это соответствует "
"принятым в SQL правилам сравнения переменных со значениями NULL."

#: func.xml:14409(para) func.xml:14465(para) func.xml:14529(para)
#: func.xml:14586(para)
msgid ""
"As with <token>EXISTS</token>, it's unwise to assume that the subquery will "
"be evaluated completely."
msgstr ""
"Так же, как и с <token>EXISTS</token>, здесь не следует рассчитывать на то, "
"что подзапрос будет всегда выполняться полностью."

#: func.xml:14415(replaceable) func.xml:14471(replaceable)
#: func.xml:14535(replaceable) func.xml:14536(replaceable)
#: func.xml:14592(replaceable) func.xml:14627(replaceable)
#: func.xml:14855(replaceable) func.xml:14915(replaceable)
#: func.xml:14927(replaceable)
msgid "row_constructor"
msgstr "конструктор_строки"

#: func.xml:14418(para)
msgid ""
"The left-hand side of this form of <token>IN</token> is a row constructor, "
"as described in <xref linkend=\"sql-syntax-row-constructors\"/>. The right-"
"hand side is a parenthesized subquery, which must return exactly as many "
"columns as there are expressions in the left-hand row. The left-hand "
"expressions are evaluated and compared row-wise to each row of the subquery "
"result. The result of <token>IN</token> is <quote>true</quote> if any equal "
"subquery row is found. The result is <quote>false</quote> if no equal row is "
"found (including the case where the subquery returns no rows)."
msgstr ""
"В левой части этой формы <token>IN</token> записывается конструктор строки "
"(подробнее они рассматриваются в <xref remap=\"6\" linkend=\"sql-syntax-row-"
"constructors\"/>). Справа в скобках записывается подзапрос, который должен "
"вернуть ровно столько столбцов, сколько содержит строка в выражении слева. "
"Вычисленные значения левого выражения сравниваются построчно со значениями "
"во всех строках, возвращённых подзапросом. Результатом всего выражения "
"<token>IN</token> будет <quote>true</quote>, если строка с такими значениями "
"находится, и <quote>false</quote> в противном случае (в том числе, когда "
"подзапрос вообще не возвращает строк)."

#: func.xml:14430(para)
msgid ""
"As usual, null values in the rows are combined per the normal rules of SQL "
"Boolean expressions. Two rows are considered equal if all their "
"corresponding members are non-null and equal; the rows are unequal if any "
"corresponding members are non-null and unequal; otherwise the result of that "
"row comparison is unknown (null). If all the per-row results are either "
"unequal or null, with at least one null, then the result of <token>IN</"
"token> is null."
msgstr ""
"Как обычно, значения NULL в строках обрабатываются при этом по принятым в "
"SQL правилам сравнения. Две строки считаются равными, если все их "
"соответствующие элементы не равны NULL, но равны между собой; неравными они "
"считаются, когда в них находятся элементы, не равные NULL, и не равные друг "
"другу; в противном случае результат сравнения строк не определён (равен "
"NULL). Если в результатах сравнения строк нет ни одного положительного, но "
"есть хотя бы один NULL, результатом <token>IN</token> будет NULL."

#: func.xml:14442(literal) func.xml:14742(literal)
msgid "NOT IN"
msgstr "NOT IN"

#: func.xml:14444(synopsis) func.xml:14470(synopsis)
#, no-wrap
msgid "<placeholder-1/> NOT IN (<placeholder-2/>)"
msgstr "<placeholder-1/> NOT IN (<placeholder-2/>)"

#: func.xml:14448(para)
msgid ""
"The right-hand side is a parenthesized subquery, which must return exactly "
"one column. The left-hand expression is evaluated and compared to each row "
"of the subquery result. The result of <token>NOT IN</token> is <quote>true</"
"quote> if only unequal subquery rows are found (including the case where the "
"subquery returns no rows). The result is <quote>false</quote> if any equal "
"row is found."
msgstr ""
"Справа в скобках записывается подзапрос, который должен возвращать ровно "
"один столбец. Вычисленное значение левого выражения сравнивается со "
"значением во всех строках, возвращённых подзапросом. Результатом всего "
"выражения <token>NOT IN</token> будет <quote>true</quote>, если находятся "
"только несовпадающие строки (в том числе, когда подзапрос вообще не "
"возвращает строк). Если же находится хотя бы одна подходящая строка, "
"результатом будет <quote>false</quote>."

#: func.xml:14457(para)
msgid ""
"Note that if the left-hand expression yields null, or if there are no equal "
"right-hand values and at least one right-hand row yields null, the result of "
"the <token>NOT IN</token> construct will be null, not true. This is in "
"accordance with SQL's normal rules for Boolean combinations of null values."
msgstr ""
"Заметьте, что если результатом выражения слева оказывается NULL или равных "
"значений справа не находится, а хотя бы одно из значений справа равно NULL, "
"конструкция <token>NOT IN</token> возвращает NULL, а не true. Это "
"соответствует принятым в SQL правилам сравнения переменных со значениями "
"NULL."

#: func.xml:14474(para)
msgid ""
"The left-hand side of this form of <token>NOT IN</token> is a row "
"constructor, as described in <xref linkend=\"sql-syntax-row-constructors\"/"
">. The right-hand side is a parenthesized subquery, which must return "
"exactly as many columns as there are expressions in the left-hand row. The "
"left-hand expressions are evaluated and compared row-wise to each row of the "
"subquery result. The result of <token>NOT IN</token> is <quote>true</quote> "
"if only unequal subquery rows are found (including the case where the "
"subquery returns no rows). The result is <quote>false</quote> if any equal "
"row is found."
msgstr ""
"В левой части этой формы <token>NOT IN</token> записывается конструктор "
"строки (подробнее они описываются в <xref remap=\"6\" linkend=\"sql-syntax-"
"row-constructors\"/>). Справа в скобках записывается подзапрос, который "
"должен вернуть ровно столько столбцов, сколько содержит строка в выражении "
"слева. Вычисленные значения левого выражения сравниваются построчно со "
"значениями во всех строках, возвращённых подзапросом. Результатом всего "
"выражения <token>NOT IN</token> будет <quote>true</quote>, если равных строк "
"не найдётся (в том числе, и когда подзапрос не возвращает строк), и "
"<quote>false</quote>, если такие строки есть."

#: func.xml:14486(para)
msgid ""
"As usual, null values in the rows are combined per the normal rules of SQL "
"Boolean expressions. Two rows are considered equal if all their "
"corresponding members are non-null and equal; the rows are unequal if any "
"corresponding members are non-null and unequal; otherwise the result of that "
"row comparison is unknown (null). If all the per-row results are either "
"unequal or null, with at least one null, then the result of <token>NOT IN</"
"token> is null."
msgstr ""
"Как обычно, значения NULL в строках обрабатываются при этом по принятым в "
"SQL правилам сравнения. Две строки считаются равными, если все их "
"соответствующие элементы не равны NULL, но равны между собой; неравными они "
"считаются, когда в них находятся элементы, не равные NULL, и не равные друг "
"другу; в противном случае результат сравнения строк не определён (равен "
"NULL). Если в результатах сравнения строк нет ни одного положительного, но "
"есть хотя бы один NULL, результатом <token>NOT IN</token> будет NULL."

#: func.xml:14498(title)
msgid "<literal>ANY</literal>/<literal>SOME</literal>"
msgstr "<literal>ANY</literal>/<literal>SOME</literal>"

#: func.xml:14501(replaceable) func.xml:14502(replaceable)
#: func.xml:14535(replaceable) func.xml:14536(replaceable)
#: func.xml:14566(replaceable) func.xml:14592(replaceable)
#: func.xml:14627(replaceable) func.xml:14786(replaceable)
#: func.xml:14787(replaceable) func.xml:14823(replaceable)
#: func.xml:14855(replaceable) func.xml:14944(replaceable)
msgid "operator"
msgstr "оператор"

#: func.xml:14500(synopsis) func.xml:14534(synopsis) func.xml:14785(synopsis)
#, no-wrap
msgid ""
"<placeholder-1/> <placeholder-2/> ANY (<placeholder-3/>)\n"
"<placeholder-4/> <placeholder-5/> SOME (<placeholder-6/>)"
msgstr ""
"<placeholder-1/> <placeholder-2/> ANY (<placeholder-3/>)\n"
"<placeholder-4/> <placeholder-5/> SOME (<placeholder-6/>)"

#: func.xml:14505(para)
msgid ""
"The right-hand side is a parenthesized subquery, which must return exactly "
"one column. The left-hand expression is evaluated and compared to each row "
"of the subquery result using the given <replaceable>operator</replaceable>, "
"which must yield a Boolean result. The result of <token>ANY</token> is "
"<quote>true</quote> if any true result is obtained. The result is "
"<quote>false</quote> if no true result is found (including the case where "
"the subquery returns no rows)."
msgstr ""
"В правой части конструкции в скобках записывается подзапрос, который должен "
"возвращать ровно один столбец. Вычисленное значение левого выражения "
"сравнивается со значением в каждой строке результата подзапроса с помощью "
"заданного <replaceable>оператора</replaceable> условия, который должен "
"выдавать логическое значение. Результатом <token>ANY</token> будет "
"<quote>true</quote>, если хотя бы для одной строки условие истинно, и "
"<quote>false</quote> в противном случае (в том числе, и когда подзапрос не "
"возвращает строк)."

#: func.xml:14516(para)
msgid ""
"<token>SOME</token> is a synonym for <token>ANY</token>. <token>IN</token> "
"is equivalent to <literal>= ANY</literal>."
msgstr ""
"Ключевое слово <token>SOME</token> является синонимом <token>ANY</token>. "
"Конструкцию <token>IN</token> можно записать также записать как <literal>= "
"ANY</literal>."

#: func.xml:14521(para)
msgid ""
"Note that if there are no successes and at least one right-hand row yields "
"null for the operator's result, the result of the <token>ANY</token> "
"construct will be null, not false. This is in accordance with SQL's normal "
"rules for Boolean combinations of null values."
msgstr ""
"Заметьте, что если условие не выполняется ни для одной из строк, а хотя бы "
"для одной строки условный оператор выдаёт NULL, конструкция <token>ANY</"
"token> возвращает NULL, а не false. Это соответствует принятым в SQL "
"правилам сравнения переменных со значениями NULL."

#: func.xml:14539(para)
msgid ""
"The left-hand side of this form of <token>ANY</token> is a row constructor, "
"as described in <xref linkend=\"sql-syntax-row-constructors\"/>. The right-"
"hand side is a parenthesized subquery, which must return exactly as many "
"columns as there are expressions in the left-hand row. The left-hand "
"expressions are evaluated and compared row-wise to each row of the subquery "
"result, using the given <replaceable>operator</replaceable>. The result of "
"<token>ANY</token> is <quote>true</quote> if the comparison returns true for "
"any subquery row. The result is <quote>false</quote> if the comparison "
"returns false for every subquery row (including the case where the subquery "
"returns no rows). The result is NULL if the comparison does not return true "
"for any row, and it returns NULL for at least one row."
msgstr ""
"В левой части этой формы <token>ANY</token> записывается конструктор строки "
"(подробнее они описываются в <xref remap=\"6\" linkend=\"sql-syntax-row-"
"constructors\"/>). Справа в скобках записывается подзапрос, который должен "
"возвращать ровно столько столбцов, сколько содержит строка в выражении "
"слева. Вычисленные значения левого выражения сравниваются построчно со "
"значениями во всех строках, возвращённых подзапросом, с применением "
"заданного <replaceable>оператора</replaceable>. Результатом всего выражения "
"<token>ANY</token> будет <quote>true</quote>, если для какой-либо из строк "
"результатом сравнения будет true, и <quote>false</quote>, если для всех "
"строк результатом сравнения оказывается false (в том числе, и когда "
"подзапрос не возвращает строк). Результат будет равен NULL, если сравнение "
"не возвращает true ни для одной из строк, но как минимум для одной результат "
"сравнения NULL."

#: func.xml:14556(para) func.xml:14612(para) func.xml:14640(para)
msgid ""
"See <xref linkend=\"row-wise-comparison\"/> for details about the meaning of "
"a row constructor comparison."
msgstr ""
"Подробнее логика сравнения конструкторов строк описана в <xref remap=\"6\" "
"linkend=\"row-wise-comparison\"/>."

#: func.xml:14563(literal)
msgid "ALL"
msgstr "ALL"

#: func.xml:14565(synopsis) func.xml:14591(synopsis) func.xml:14822(synopsis)
#, no-wrap
msgid "<placeholder-1/> <placeholder-2/> ALL (<placeholder-3/>)"
msgstr "<placeholder-1/> <placeholder-2/> ALL (<placeholder-3/>)"

#: func.xml:14569(para)
msgid ""
"The right-hand side is a parenthesized subquery, which must return exactly "
"one column. The left-hand expression is evaluated and compared to each row "
"of the subquery result using the given <replaceable>operator</replaceable>, "
"which must yield a Boolean result. The result of <token>ALL</token> is "
"<quote>true</quote> if all rows yield true (including the case where the "
"subquery returns no rows). The result is <quote>false</quote> if any false "
"result is found. The result is NULL if the comparison does not return false "
"for any row, and it returns NULL for at least one row."
msgstr ""
"В правой части конструкции в скобках записывается подзапрос, который должен "
"возвращать ровно один столбец. Вычисленное значение левого выражения "
"сравнивается со значением в каждой строке результата подзапроса с помощью "
"заданного <replaceable>оператора</replaceable> условия, который должен "
"выдавать логическое значение. Результатом <token>ALL</token> будет "
"<quote>true</quote>, если условие истинно для всех строк (и когда подзапрос "
"не возвращает строк), и <quote>false</quote>, если находятся строки, для "
"которых оно ложно. Результат будет равен NULL, если сравнение не возвращает "
"false ни для одной из строк, но как минимум для одной результат сравнения "
"NULL."

#: func.xml:14582(para)
msgid "<token>NOT IN</token> is equivalent to <literal>&lt;&gt; ALL</literal>."
msgstr ""
"Конструкция <token>NOT IN</token> равнозначна <literal>&lt;&gt; ALL</"
"literal>."

#: func.xml:14595(para)
msgid ""
"The left-hand side of this form of <token>ALL</token> is a row constructor, "
"as described in <xref linkend=\"sql-syntax-row-constructors\"/>. The right-"
"hand side is a parenthesized subquery, which must return exactly as many "
"columns as there are expressions in the left-hand row. The left-hand "
"expressions are evaluated and compared row-wise to each row of the subquery "
"result, using the given <replaceable>operator</replaceable>. The result of "
"<token>ALL</token> is <quote>true</quote> if the comparison returns true for "
"all subquery rows (including the case where the subquery returns no rows). "
"The result is <quote>false</quote> if the comparison returns false for any "
"subquery row. The result is NULL if the comparison does not return false for "
"any subquery row, and it returns NULL for at least one row."
msgstr ""
"В левой части этой формы <token>ALL</token> записывается конструктор строки "
"(подробнее они описываются в <xref remap=\"6\" linkend=\"sql-syntax-row-"
"constructors\"/>). Справа в скобках записывается подзапрос, который должен "
"возвращать ровно столько столбцов, сколько содержит строка в выражении "
"слева. Вычисленные значения левого выражения сравниваются построчно со "
"значениями во всех строках, возвращённых подзапросом, с применением "
"заданного <replaceable>оператора</replaceable>. Результатом всего выражения "
"<token>ALL</token> будет <quote>true</quote>, если для всех строк подзапроса "
"результатом сравнения будет true (или если подзапрос не возвращает строк), и "
"<quote>false</quote>, если результат сравнения равен false для любой из "
"строк подзапроса. Результат будет равен NULL, если сравнение не возвращает "
"false ни для одной из строк, но как минимум для одной результат сравнения "
"NULL."

#: func.xml:14619(title)
msgid "Single-row Comparison"
msgstr "Сравнение единичных строк"

#: func.xml:14621(indexterm)
msgid ""
"<primary>comparison</primary> <secondary>subquery result row</secondary>"
msgstr ""
"<primary>сравнение</primary> <secondary>со строкой-результатом подзапроса</"
"secondary>"

#: func.xml:14626(synopsis)
#, no-wrap
msgid "<placeholder-1/> <placeholder-2/> (<placeholder-3/>)"
msgstr "<placeholder-1/> <placeholder-2/> (<placeholder-3/>)"

#: func.xml:14630(para)
msgid ""
"The left-hand side is a row constructor, as described in <xref linkend=\"sql-"
"syntax-row-constructors\"/>. The right-hand side is a parenthesized "
"subquery, which must return exactly as many columns as there are expressions "
"in the left-hand row. Furthermore, the subquery cannot return more than one "
"row. (If it returns zero rows, the result is taken to be null.) The left-"
"hand side is evaluated and compared row-wise to the single subquery result "
"row."
msgstr ""
"В левой части конструкции записывается конструктор строки (подробнее они "
"описываются в <xref remap=\"6\" linkend=\"sql-syntax-row-constructors\"/>). "
"Справа в скобках записывается подзапрос, который должен возвращать ровно "
"столько столбцов, сколько содержит строка в выражении слева. Более того, "
"подзапрос может вернуть максимум одну строку. (Если он не вернёт строк, "
"результатом будет NULL.) Конструкция возвращает результат сравнения строки "
"слева с этой одной строкой результата подзапроса."

#: func.xml:14649(title)
msgid "Row and Array Comparisons"
msgstr "Сравнение табличных строк и массивов"

#: func.xml:14671(indexterm)
msgid "<primary>composite type</primary> <secondary>comparison</secondary>"
msgstr "<primary>составной тип</primary> <secondary>сравнение</secondary>"

#: func.xml:14676(indexterm)
msgid "<primary>row-wise comparison</primary>"
msgstr "<primary>сравнение табличных строк</primary>"

#: func.xml:14680(indexterm)
msgid "<primary>comparison</primary> <secondary>composite type</secondary>"
msgstr "<primary>сравнение</primary> <secondary>составных типов</secondary>"

#: func.xml:14685(indexterm)
msgid "<primary>comparison</primary> <secondary>row constructor</secondary>"
msgstr ""
"<primary>сравнение</primary> <secondary>конструкторов строк</secondary>"

#: func.xml:14698(para)
msgid ""
"This section describes several specialized constructs for making multiple "
"comparisons between groups of values. These forms are syntactically related "
"to the subquery forms of the previous section, but do not involve "
"subqueries. The forms involving array subexpressions are "
"<productname>PostgreSQL</productname> extensions; the rest are <acronym>SQL</"
"acronym>-compliant. All of the expression forms documented in this section "
"return Boolean (true/false) results."
msgstr ""
"В этом разделе описываются несколько специальных конструкций, позволяющих "
"сравнивать группы значений. Синтаксис этих конструкций связан с формами "
"выражений с подзапросами, описанными в предыдущем разделе, а отличаются они "
"отсутствием подзапросов. Конструкции, в которых в качестве подвыражений "
"используются массивы, являются расширениями <productname>PostgreSQL</"
"productname>; все остальные формы соответствуют стандарту <acronym>SQL</"
"acronym>. Все описанные здесь выражения возвращают логические значения (true/"
"false)."

#: func.xml:14713(synopsis)
#, no-wrap
msgid "<placeholder-1/> IN (<placeholder-2/> <placeholder-3/>)"
msgstr "<placeholder-1/> IN (<placeholder-2/> <placeholder-3/>)"

#: func.xml:14717(para)
msgid ""
"The right-hand side is a parenthesized list of scalar expressions. The "
"result is <quote>true</quote> if the left-hand expression's result is equal "
"to any of the right-hand expressions. This is a shorthand notation for "
"<synopsis>\n"
"<replaceable>expression</replaceable> = <replaceable>value1</replaceable>\n"
"OR\n"
"<replaceable>expression</replaceable> = <replaceable>value2</replaceable>\n"
"OR\n"
"...\n"
"</synopsis>"
msgstr ""
"Справа в скобках записывается список скалярных выражений. Результатом будет "
"<quote>true</quote>, если значение левого выражения равняется одному из "
"значений выражений в правой части. Эту конструкцию можно считать краткой "
"записью условия <synopsis>\n"
"<replaceable>выражение</replaceable> = <replaceable>значение1</replaceable>\n"
"OR\n"
"<replaceable>выражение</replaceable> = <replaceable>значение2</replaceable>\n"
"OR\n"
"...\n"
"</synopsis>"

#: func.xml:14732(para)
msgid ""
"Note that if the left-hand expression yields null, or if there are no equal "
"right-hand values and at least one right-hand expression yields null, the "
"result of the <token>IN</token> construct will be null, not false. This is "
"in accordance with SQL's normal rules for Boolean combinations of null "
"values."
msgstr ""
"Заметьте, что если результатом выражения слева оказывается NULL или равных "
"значений справа не находится, а хотя бы одно из значений справа равно NULL, "
"конструкция <token>IN</token> возвращает NULL, а не false. Это соответствует "
"принятым в SQL правилам сравнения переменных со значениями NULL."

#: func.xml:14744(synopsis)
#, no-wrap
msgid "<placeholder-1/> NOT IN (<placeholder-2/> <placeholder-3/>)"
msgstr "<placeholder-1/> NOT IN (<placeholder-2/> <placeholder-3/>)"

#: func.xml:14748(para)
msgid ""
"The right-hand side is a parenthesized list of scalar expressions. The "
"result is <quote>true</quote> if the left-hand expression's result is "
"unequal to all of the right-hand expressions. This is a shorthand notation "
"for <synopsis>\n"
"<replaceable>expression</replaceable> &lt;&gt; <replaceable>value1</"
"replaceable>\n"
"AND\n"
"<replaceable>expression</replaceable> &lt;&gt; <replaceable>value2</"
"replaceable>\n"
"AND\n"
"...\n"
"</synopsis>"
msgstr ""
"Справа в скобках записывается список скалярных выражений. Результатом будет "
"<quote>true</quote>, если значение левого выражения не равно ни одному из "
"значений выражений в правой части. Эту конструкцию можно считать краткой "
"записью условия <synopsis>\n"
"<replaceable>выражение</replaceable> &lt;&gt; <replaceable>значение1</"
"replaceable>\n"
"AND\n"
"<replaceable>выражение</replaceable> &lt;&gt; <replaceable>значение2</"
"replaceable>\n"
"AND\n"
"...\n"
"</synopsis>"

#: func.xml:14763(para)
msgid ""
"Note that if the left-hand expression yields null, or if there are no equal "
"right-hand values and at least one right-hand expression yields null, the "
"result of the <token>NOT IN</token> construct will be null, not true as one "
"might naively expect. This is in accordance with SQL's normal rules for "
"Boolean combinations of null values."
msgstr ""
"Заметьте, что если результатом выражения слева оказывается NULL или равных "
"значений справа не находится, а хотя бы одно из значений справа равно NULL, "
"конструкция <token>NOT IN</token> возвращает NULL, а не true, как можно было "
"бы наивно полагать. Это соответствует принятым в SQL правилам сравнения "
"переменных со значениями NULL."

#: func.xml:14773(para)
msgid ""
"<literal>x NOT IN y</literal> is equivalent to <literal>NOT (x IN y)</"
"literal> in all cases. However, null values are much more likely to trip up "
"the novice when working with <token>NOT IN</token> than when working with "
"<token>IN</token>. It is best to express your condition positively if "
"possible."
msgstr ""
"Выражения <literal>x NOT IN y</literal> и <literal>NOT (x IN y)</literal> "
"полностью равнозначны. Учитывая, что значения NULL могут ввести в "
"заблуждение начинающих скорее в конструкции <token>NOT IN</token>, чем в "
"<token>IN</token>, лучше формулировать условия так, чтобы в них было как "
"можно меньше отрицаний."

#: func.xml:14783(title)
msgid "<literal>ANY</literal>/<literal>SOME</literal> (array)"
msgstr "<literal>ANY</literal>/<literal>SOME</literal> (с массивом)"

#: func.xml:14786(replaceable) func.xml:14787(replaceable)
#: func.xml:14823(replaceable)
msgid "array expression"
msgstr "выражение массива"

#: func.xml:14790(para)
msgid ""
"The right-hand side is a parenthesized expression, which must yield an array "
"value. The left-hand expression is evaluated and compared to each element of "
"the array using the given <replaceable>operator</replaceable>, which must "
"yield a Boolean result. The result of <token>ANY</token> is <quote>true</"
"quote> if any true result is obtained. The result is <quote>false</quote> if "
"no true result is found (including the case where the array has zero "
"elements)."
msgstr ""
"Справа в скобках записывается выражение, результатом которого является "
"массив. Вычисленное значение левого выражения сравнивается с каждым "
"элементом этого массива с применением заданного <replaceable>оператора</"
"replaceable> условия, который должен выдавать логическое значение. "
"Результатом <token>ANY</token> будет <quote>true</quote>, если для какого-"
"либо элемента условие истинно, и <quote>false</quote> в противном случае (в "
"том числе, и когда массив оказывается пустым)."

#: func.xml:14802(para)
msgid ""
"If the array expression yields a null array, the result of <token>ANY</"
"token> will be null. If the left-hand expression yields null, the result of "
"<token>ANY</token> is ordinarily null (though a non-strict comparison "
"operator could possibly yield a different result). Also, if the right-hand "
"array contains any null elements and no true comparison result is obtained, "
"the result of <token>ANY</token> will be null, not false (again, assuming a "
"strict comparison operator). This is in accordance with SQL's normal rules "
"for Boolean combinations of null values."
msgstr ""
"Если значением массива оказывается NULL, результатом <token>ANY</token> "
"также будет NULL. Если NULL получен в левой части, результатом <token>ANY</"
"token> обычно тоже будет NULL (хотя оператор нестрогого сравнения может "
"выдать другой результат). Кроме того, если массив в правой части содержит "
"элементы NULL и ни c одним из элементов условие не выполняется, результатом "
"<token>ANY</token> будет NULL, а не false (опять же, если используется "
"оператор строгого сравнения). Это соответствует принятым в SQL правилам "
"сравнения переменных со значениями NULL."

#: func.xml:14814(para)
msgid "<token>SOME</token> is a synonym for <token>ANY</token>."
msgstr ""
"Ключевое слово <token>SOME</token> является синонимом <token>ANY</token>."

#: func.xml:14820(title)
msgid "<literal>ALL</literal> (array)"
msgstr "<literal>ALL</literal> (с массивом)"

#: func.xml:14826(para)
msgid ""
"The right-hand side is a parenthesized expression, which must yield an array "
"value. The left-hand expression is evaluated and compared to each element of "
"the array using the given <replaceable>operator</replaceable>, which must "
"yield a Boolean result. The result of <token>ALL</token> is <quote>true</"
"quote> if all comparisons yield true (including the case where the array has "
"zero elements). The result is <quote>false</quote> if any false result is "
"found."
msgstr ""
"Справа в скобках записывается выражение, результатом которого является "
"массив. Вычисленное значение левого выражения сравнивается с каждым "
"элементом этого массива с применением заданного <replaceable>оператора</"
"replaceable> условия, который должен выдавать логическое значение. "
"Результатом <token>ALL</token> будет <quote>true</quote>, если для всех "
"элементов условие истинно (или массив не содержит элементов), и "
"<quote>false</quote>, если находятся строки, для которых оно ложно."

#: func.xml:14838(para)
msgid ""
"If the array expression yields a null array, the result of <token>ALL</"
"token> will be null. If the left-hand expression yields null, the result of "
"<token>ALL</token> is ordinarily null (though a non-strict comparison "
"operator could possibly yield a different result). Also, if the right-hand "
"array contains any null elements and no false comparison result is obtained, "
"the result of <token>ALL</token> will be null, not true (again, assuming a "
"strict comparison operator). This is in accordance with SQL's normal rules "
"for Boolean combinations of null values."
msgstr ""
"Если значением массива оказывается NULL, результатом <token>ALL</token> "
"также будет NULL. Если NULL получен в левой части, результатом <token>ALL</"
"token> обычно тоже будет NULL (хотя оператор нестрогого сравнения может "
"выдать другой результат). Кроме того, если массив в правой части содержит "
"элементы NULL и при этом нет элементов, с которыми условие не выполняется, "
"результатом <token>ALL</token> будет NULL, а не true (опять же, если "
"используется оператор строгого сравнения). Это соответствует принятым в SQL "
"правилам сравнения переменных со значениями NULL."

#: func.xml:14852(title)
msgid "Row Constructor Comparison"
msgstr "Сравнение конструкторов строк"

#: func.xml:14858(para)
msgid ""
"Each side is a row constructor, as described in <xref linkend=\"sql-syntax-"
"row-constructors\"/>. The two row values must have the same number of "
"fields. Each side is evaluated and they are compared row-wise. Row "
"constructor comparisons are allowed when the <replaceable>operator</"
"replaceable> is <literal>=</literal>, <literal>&lt;&gt;</literal>, "
"<literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> "
"or <literal>&gt;=</literal>. Every row element must be of a type which has a "
"default B-tree operator class or the attempted comparison may generate an "
"error."
msgstr ""
"С обеих сторон представлены конструкторы строк (они описываются в <xref "
"remap=\"6\" linkend=\"sql-syntax-row-constructors\"/>). При этом данные "
"строки должны содержать одинаковое число полей. После вычисления каждой "
"стороны они сравниваются по строкам. Сравнения конструкторов строк возможны "
"с <replaceable>оператором</replaceable> <literal>=</literal>, <literal>&lt;"
"&gt;</literal>, <literal>&lt;</literal>, <literal>&lt;=</literal>, "
"<literal>&gt;</literal> или <literal>&gt;=</literal>. Каждый элемент строки "
"должен иметь тип, для которого определён класс операторов B-дерева; в "
"противном случае при попытке сравнения может возникнуть ошибка."

#: func.xml:14875(para)
msgid ""
"Errors related to the number or types of elements might not occur if the "
"comparison is resolved using earlier columns."
msgstr ""
"Ошибок, связанных с числом или типов элементов, не должно быть, если "
"сравнение выполняется с ранее полученными столбцами."

#: func.xml:14881(para)
msgid ""
"The <literal>=</literal> and <literal>&lt;&gt;</literal> cases work slightly "
"differently from the others. Two rows are considered equal if all their "
"corresponding members are non-null and equal; the rows are unequal if any "
"corresponding members are non-null and unequal; otherwise the result of the "
"row comparison is unknown (null)."
msgstr ""
"Сравнения <literal>=</literal> и <literal>&lt;&gt;</literal> несколько "
"отличаются от других. С этими операторами две строки считаются равными, если "
"все их соответствующие поля не равны NULL и равны между собой, и неравными, "
"если какие-либо соответствующие их поля не NULL и не равны между собой. В "
"противном случае результатом сравнения будет неопределённость (NULL)."

#: func.xml:14889(para)
msgid ""
"For the <literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</"
"literal> and <literal>&gt;=</literal> cases, the row elements are compared "
"left-to-right, stopping as soon as an unequal or null pair of elements is "
"found. If either of this pair of elements is null, the result of the row "
"comparison is unknown (null); otherwise comparison of this pair of elements "
"determines the result. For example, <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</"
"literal> yields true, not null, because the third pair of elements are not "
"considered."
msgstr ""
"С операторами <literal>&lt;</literal>, <literal>&lt;=</literal>, "
"<literal>&gt;</literal> и <literal>&gt;=</literal> элементы строк "
"сравниваются слева направо до тех пор, пока не будет найдена пара неравных "
"элементов или значений NULL. Если любым из элементов пары оказывается NULL, "
"результатом сравнения будет неопределённость (NULL), в противном случае "
"результат всего выражения определяется результатом сравнения этих двух "
"элементов. Например, результатом <literal>ROW(1,2,NULL) &lt; ROW(1,3,0)</"
"literal> будет true, а не NULL, так как третья пара элементов не принимается "
"в рассмотрение."

#: func.xml:14902(para)
msgid ""
"Prior to <productname>PostgreSQL</productname> 8.2, the <literal>&lt;</"
"literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> and <literal>&gt;"
"=</literal> cases were not handled per SQL specification. A comparison like "
"<literal>ROW(a,b) &lt; ROW(c,d)</literal> was implemented as <literal>a &lt; "
"c AND b &lt; d</literal> whereas the correct behavior is equivalent to "
"<literal>a &lt; c OR (a = c AND b &lt; d)</literal>."
msgstr ""
"До версии 8.2 <productname>PostgreSQL</productname> обрабатывал условия "
"<literal>&lt;</literal>, <literal>&lt;=</literal>, <literal>&gt;</literal> и "
"<literal>&gt;=</literal> не так, как это описано в стандарте SQL. Сравнение "
"<literal>ROW(a,b) &lt; ROW(c,d)</literal> выполнялось как <literal>a &lt; c "
"AND b &lt; d</literal>, тогда как по стандарту должно быть <literal>a &lt; c "
"OR (a = c AND b &lt; d)</literal>."

#: func.xml:14914(synopsis)
#, no-wrap
msgid "<placeholder-1/> IS DISTINCT FROM <placeholder-2/>"
msgstr "<placeholder-1/> IS DISTINCT FROM <placeholder-2/>"

#: func.xml:14918(para)
msgid ""
"This construct is similar to a <literal>&lt;&gt;</literal> row comparison, "
"but it does not yield null for null inputs. Instead, any null value is "
"considered unequal to (distinct from) any non-null value, and any two nulls "
"are considered equal (not distinct). Thus the result will either be true or "
"false, never null."
msgstr ""
"Эта конструкция похожа на сравнение строк с оператором <literal>&lt;&gt;</"
"literal>, но со значениями NULL она выдаёт не NULL. Любое значение NULL для "
"неё считается неравным (отличным от) любому значению не NULL, а два NULL "
"считаются равными (не различными). Таким образом, результатом такого "
"выражения будет true или false, но не NULL."

#: func.xml:14926(synopsis)
#, no-wrap
msgid "<placeholder-1/> IS NOT DISTINCT FROM <placeholder-2/>"
msgstr "<placeholder-1/> IS NOT DISTINCT FROM <placeholder-2/>"

#: func.xml:14930(para)
msgid ""
"This construct is similar to a <literal>=</literal> row comparison, but it "
"does not yield null for null inputs. Instead, any null value is considered "
"unequal to (distinct from) any non-null value, and any two nulls are "
"considered equal (not distinct). Thus the result will always be either true "
"or false, never null."
msgstr ""
"Эта конструкция похожа на сравнение строк с оператором <literal>=</literal>, "
"но со значениями NULL она выдаёт не NULL. Любое значение NULL для неё "
"считается неравным (отличным от) любому значению не NULL, а два NULL "
"считаются равными (не различными). Таким образом, результатом такого "
"выражения всегда будет true или false, но не NULL."

#: func.xml:14941(title)
msgid "Composite Type Comparison"
msgstr "Сравнение составных типов"

#: func.xml:14944(replaceable)
msgctxt "replaceable"
msgid "record"
msgstr "запись"

#: func.xml:14947(para)
msgid ""
"The SQL specification requires row-wise comparison to return NULL if the "
"result depends on comparing two NULL values or a NULL and a non-NULL. "
"<productname>PostgreSQL</productname> does this only when comparing the "
"results of two row constructors (as in <xref linkend=\"row-wise-comparison\"/"
">) or comparing a row constructor to the output of a subquery (as in <xref "
"linkend=\"functions-subquery\"/>). In other contexts where two composite-"
"type values are compared, two NULL field values are considered equal, and a "
"NULL is considered larger than a non-NULL. This is necessary in order to "
"have consistent sorting and indexing behavior for composite types."
msgstr ""
"Стандарт SQL требует, чтобы при сравнении строк возвращался NULL, если "
"результат зависит от сравнения двух значений NULL или значения NULL и не "
"NULL. <productname>PostgreSQL</productname> выполняет это требование только "
"при сравнении строк, созданных конструкторами (как описано в <xref remap="
"\"6\" linkend=\"row-wise-comparison\"/>), или строки, созданной "
"конструктором, со строкой результата подзапроса (как было описано в <xref "
"remap=\"6\" linkend=\"functions-subquery\"/>). В других контекстах при "
"сравнении полей составных типов два значения NULL считаются равными, а любое "
"значение не NULL полагается меньшим NULL. Это отклонение от правила "
"необходимо для полноценной реализации сортировки и индексирования составных "
"типов."

#: func.xml:14960(para)
msgid ""
"Each side is evaluated and they are compared row-wise. Composite type "
"comparisons are allowed when the <replaceable>operator</replaceable> is "
"<literal>=</literal>, <literal>&lt;&gt;</literal>, <literal>&lt;</literal>, "
"<literal>&lt;=</literal>, <literal>&gt;</literal> or <literal>&gt;=</"
"literal>, or has semantics similar to one of these. (To be specific, an "
"operator can be a row comparison operator if it is a member of a B-tree "
"operator class, or is the negator of the <literal>=</literal> member of a B-"
"tree operator class.) The default behavior of the above operators is the "
"same as for <literal>IS [ NOT ] DISTINCT FROM</literal> for row constructors "
"(see <xref linkend=\"row-wise-comparison\"/>)."
msgstr ""
"После вычисления каждой стороны они сравниваются по строкам. Сравнения "
"составных типов возможны с <replaceable>оператором</replaceable> <literal>=</"
"literal>, <literal>&lt;&gt;</literal>, <literal>&lt;</literal>, <literal>&lt;"
"=</literal>, <literal>&gt;</literal> или <literal>&gt;=</literal>, либо "
"другим подобным. (Точнее, оператором сравнения строк может быть любой "
"оператор, входящий в класс операторов B-дерева, либо обратный к оператору "
"<literal>=</literal>, входящему в класс операторов B-дерева.) По умолчанию "
"вышеперечисленные операторы действуют так же, как выражение <literal>IS "
"[ NOT ] DISTINCT FROM</literal> для конструкторов строк (см. <xref remap="
"\"4\" linkend=\"row-wise-comparison\"/>)."

#: func.xml:14977(para)
msgid ""
"To support matching of rows which include elements without a default B-tree "
"operator class, the following operators are defined for composite type "
"comparison: <literal>*=</literal>, <literal>*&lt;&gt;</literal>, "
"<literal>*&lt;</literal>, <literal>*&lt;=</literal>, <literal>*&gt;</"
"literal>, and <literal>*&gt;=</literal>. These operators compare the "
"internal binary representation of the two rows. Two rows might have a "
"different binary representation even though comparisons of the two rows with "
"the equality operator is true. The ordering of rows under these comparison "
"operators is deterministic but not otherwise meaningful. These operators are "
"used internally for materialized views and might be useful for other "
"specialized purposes such as replication but are not intended to be "
"generally useful for writing queries."
msgstr ""
"Для поддержки сравнения строк с элементами, для которых не определён класс "
"операторов B-дерева по умолчанию, введены следующие операторы: <literal>*=</"
"literal>, <literal>*&lt;&gt;</literal>, <literal>*&lt;</literal>, "
"<literal>*&lt;=</literal>, <literal>*&gt;</literal> и <literal>*&gt;=</"
"literal>. Эти операторы сравнивают внутреннее двоичное представление двух "
"строк. Учтите, что две строки могут иметь различное двоичное представление, "
"даже когда при сравнении оператором равенства считаются равными. Порядок "
"строк с такими операторами детерминирован, но не несёт смысловой нагрузки. "
"Данные операторы применяются внутри системы для материализованных "
"представлений и могут быть полезны для других специальных целей (например, "
"репликации), но, вообще говоря, не предназначены для использования в обычных "
"запросах."

#: func.xml:15000(title)
msgid "Set Returning Functions"
msgstr "Функции, возвращающие множества"

#: func.xml:15002(indexterm)
msgid ""
"<primary>set returning functions</primary> <secondary>functions</secondary>"
msgstr ""
"<primary>функции, возвращающие множества</primary> <secondary>множества</"
"secondary>"

#: func.xml:15007(indexterm)
msgid "<primary>generate_series</primary>"
msgstr "<primary>generate_series</primary>"

#: func.xml:15011(para)
msgid ""
"This section describes functions that possibly return more than one row. The "
"most widely used functions in this class are series generating functions, as "
"detailed in <xref linkend=\"functions-srf-series\"/> and <xref linkend="
"\"functions-srf-subscripts\"/>. Other, more specialized set-returning "
"functions are described elsewhere in this manual. See <xref linkend="
"\"queries-tablefunctions\"/> for ways to combine multiple set-returning "
"functions."
msgstr ""
"В этом разделе описаны функции, которые могут возвращать не одну, а "
"множество строк. Чаще всего из их числа используются функции, генерирующие "
"ряды значений, которые перечислены в <xref remap=\"6\" linkend=\"functions-"
"srf-series\"/> и <xref remap=\"6\" linkend=\"functions-srf-subscripts\"/>. "
"Другие, более специализированные функции множеств описаны в других разделах "
"этой документации. Варианты комбинирования нескольких функций, возвращающих "
"множества строк, описаны в <xref remap=\"6\" linkend=\"queries-tablefunctions"
"\"/>."

#: func.xml:15022(title)
msgid "Series Generating Functions"
msgstr "Функции, генерирующие ряды значений"

#: func.xml:15035(parameter) func.xml:15045(parameter)
#: func.xml:15055(parameter)
msgid "start"
msgstr "start"

#: func.xml:15035(parameter) func.xml:15045(parameter)
#: func.xml:15055(parameter)
msgid "stop"
msgstr "stop"

#: func.xml:15035(function)
msgid "generate_series(<placeholder-1/>, <placeholder-2/>)"
msgstr "generate_series(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:15036(entry) func.xml:15046(entry)
msgid "<type>int</type>, <type>bigint</type> or <type>numeric</type>"
msgstr "<type>int</type>, <type>bigint</type> или <type>numeric</type>"

#: func.xml:15037(entry)
msgid ""
"<type>setof int</type>, <type>setof bigint</type>, or <type>setof numeric</"
"type> (same as argument type)"
msgstr ""
"<type>setof int</type>, <type>setof bigint</type> или <type>setof numeric</"
"type> (определяется типом аргумента)"

#: func.xml:15038(entry)
msgid ""
"Generate a series of values, from <parameter>start</parameter> to "
"<parameter>stop</parameter> with a step size of one"
msgstr ""
"Выдаёт ряд целых чисел от <parameter>start</parameter> до <parameter>stop</"
"parameter> с шагом 1"

#: func.xml:15045(parameter) func.xml:15055(parameter)
msgid "step"
msgstr "step"

#: func.xml:15045(function)
msgid "generate_series(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "generate_series(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:15047(entry)
msgid ""
"<type>setof int</type>, <type>setof bigint</type> or <type>setof numeric</"
"type> (same as argument type)"
msgstr ""
"<type>setof int</type>, <type>setof bigint</type> или <type>setof numeric</"
"type> (определяется типом аргумента)"

#: func.xml:15048(entry) func.xml:15058(entry)
msgid ""
"Generate a series of values, from <parameter>start</parameter> to "
"<parameter>stop</parameter> with a step size of <parameter>step</parameter>"
msgstr ""
"Выдаёт ряд значений от <parameter>start</parameter> до <parameter>stop</"
"parameter> с заданным шагом (<parameter>step</parameter>)"

#: func.xml:15055(function)
msgid ""
"generate_series(<placeholder-1/>, <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"generate_series(<placeholder-1/>, <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:15056(entry)
msgid "<type>timestamp</type> or <type>timestamp with time zone</type>"
msgstr "<type>timestamp</type> или <type>timestamp with time zone</type>"

#: func.xml:15057(entry)
msgid ""
"<type>setof timestamp</type> or <type>setof timestamp with time zone</type> "
"(same as argument type)"
msgstr ""
"<type>setof timestamp</type> или <type>setof timestamp with time zone</type> "
"(определяется типом аргумента)"

#: func.xml:15075(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM generate_series(2,4);\n"
" generate_series\n"
"-----------------\n"
"               2\n"
"               3\n"
"               4\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series(5,1,-2);\n"
" generate_series\n"
"-----------------\n"
"               5\n"
"               3\n"
"               1\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series(4,3);\n"
" generate_series\n"
"-----------------\n"
"(0 rows)\n"
"\n"
"SELECT generate_series(1.1, 4, 1.3);\n"
" generate_series \n"
"-----------------\n"
"             1.1\n"
"             2.4\n"
"             3.7\n"
"(3 rows)\n"
"\n"
"-- this example relies on the date-plus-integer operator\n"
"SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);\n"
"   dates\n"
"------------\n"
" 2004-02-05\n"
" 2004-02-12\n"
" 2004-02-19\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,\n"
"                              '2008-03-04 12:00', '10 hours');\n"
"   generate_series   \n"
"---------------------\n"
" 2008-03-01 00:00:00\n"
" 2008-03-01 10:00:00\n"
" 2008-03-01 20:00:00\n"
" 2008-03-02 06:00:00\n"
" 2008-03-02 16:00:00\n"
" 2008-03-03 02:00:00\n"
" 2008-03-03 12:00:00\n"
" 2008-03-03 22:00:00\n"
" 2008-03-04 08:00:00\n"
"(9 rows)"
msgstr ""
"SELECT * FROM generate_series(2,4);\n"
" generate_series\n"
"-----------------\n"
"               2\n"
"               3\n"
"               4\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series(5,1,-2);\n"
" generate_series\n"
"-----------------\n"
"               5\n"
"               3\n"
"               1\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series(4,3);\n"
" generate_series\n"
"-----------------\n"
"(0 rows)\n"
"\n"
"SELECT generate_series(1.1, 4, 1.3);\n"
" generate_series \n"
"-----------------\n"
"             1.1\n"
"             2.4\n"
"             3.7\n"
"(3 rows)\n"
"\n"
"-- этот пример задействует оператор прибавления к дате целого числа\n"
"SELECT current_date + s.a AS dates FROM generate_series(0,14,7) AS s(a);\n"
"   dates\n"
"------------\n"
" 2004-02-05\n"
" 2004-02-12\n"
" 2004-02-19\n"
"(3 rows)\n"
"\n"
"SELECT * FROM generate_series('2008-03-01 00:00'::timestamp,\n"
"                              '2008-03-04 12:00', '10 hours');\n"
"   generate_series   \n"
"---------------------\n"
" 2008-03-01 00:00:00\n"
" 2008-03-01 10:00:00\n"
" 2008-03-01 20:00:00\n"
" 2008-03-02 06:00:00\n"
" 2008-03-02 16:00:00\n"
" 2008-03-03 02:00:00\n"
" 2008-03-03 12:00:00\n"
" 2008-03-03 22:00:00\n"
" 2008-03-04 08:00:00\n"
"(9 rows)"

#: func.xml:15068(para)
msgid ""
"When <parameter>step</parameter> is positive, zero rows are returned if "
"<parameter>start</parameter> is greater than <parameter>stop</parameter>. "
"Conversely, when <parameter>step</parameter> is negative, zero rows are "
"returned if <parameter>start</parameter> is less than <parameter>stop</"
"parameter>. Zero rows are also returned for <literal>NULL</literal> inputs. "
"It is an error for <parameter>step</parameter> to be zero. Some examples "
"follow: <placeholder-1/>"
msgstr ""
"Если заданный шаг (<parameter>step</parameter>) положительный, а "
"<parameter>start</parameter> оказывается больше <parameter>stop</parameter>, "
"эти функции возвращают 0 строк. Тот же результат будет, если "
"<parameter>step</parameter> меньше 0, а <parameter>start</parameter> меньше "
"<parameter>stop</parameter>, или если какой-либо аргумент равен "
"<literal>NULL</literal>. Если же <parameter>step</parameter> будет равен 0, "
"произойдёт ошибка. Несколько примеров: <placeholder-1/>"

#: func.xml:15132(title)
msgid "Subscript Generating Functions"
msgstr "Функции, генерирующие индексы массивов"

#: func.xml:15144(parameter) func.xml:15152(parameter)
msgid "array anyarray"
msgstr "array anyarray"

#: func.xml:15144(parameter) func.xml:15152(parameter)
msgid "dim int"
msgstr "dim int"

#: func.xml:15144(function)
msgid "generate_subscripts(<placeholder-1/>, <placeholder-2/>)"
msgstr "generate_subscripts(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:15145(type) func.xml:15153(type)
msgid "setof int"
msgstr "setof int"

#: func.xml:15146(entry)
msgid "Generate a series comprising the given array's subscripts."
msgstr ""
"Выдаёт ряд значений для использования в качестве индекса данного массива."

#: func.xml:15152(parameter)
msgid "reverse boolean"
msgstr "reverse boolean"

#: func.xml:15152(function)
msgid ""
"generate_subscripts(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr ""
"generate_subscripts(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:15154(entry)
msgid ""
"Generate a series comprising the given array's subscripts. When "
"<parameter>reverse</parameter> is true, the series is returned in reverse "
"order."
msgstr ""
"Выдаёт ряд значений для использования в качестве индекса данного массива. "
"Если параметр <parameter>reverse</parameter> равен true, значения выдаются "
"от большего к меньшему."

#: func.xml:15165(indexterm)
msgid "<primary>generate_subscripts</primary>"
msgstr "<primary>generate_subscripts</primary>"

#: func.xml:15176(programlisting)
#, no-wrap
msgid ""
"-- basic usage\n"
"SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;\n"
" s \n"
"---\n"
" 1\n"
" 2\n"
" 3\n"
" 4\n"
"(4 rows)\n"
"\n"
"-- presenting an array, the subscript and the subscripted\n"
"-- value requires a subquery\n"
"SELECT * FROM arrays;\n"
"         a          \n"
"--------------------\n"
" {-1,-2}\n"
" {100,200,300}\n"
"(2 rows)\n"
"\n"
"SELECT a AS array, s AS subscript, a[s] AS value\n"
"FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;\n"
"     array     | subscript | value\n"
"---------------+-----------+-------\n"
" {-1,-2}       |         1 |    -1\n"
" {-1,-2}       |         2 |    -2\n"
" {100,200,300} |         1 |   100\n"
" {100,200,300} |         2 |   200\n"
" {100,200,300} |         3 |   300\n"
"(5 rows)\n"
"\n"
"-- unnest a 2D array\n"
"CREATE OR REPLACE FUNCTION unnest2(anyarray)\n"
"RETURNS SETOF anyelement AS $$\n"
"select $1[i][j]\n"
"   from generate_subscripts($1,1) g1(i),\n"
"        generate_subscripts($1,2) g2(j);\n"
"$$ LANGUAGE sql IMMUTABLE;\n"
"CREATE FUNCTION\n"
"SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);\n"
" unnest2 \n"
"---------\n"
"       1\n"
"       2\n"
"       3\n"
"       4\n"
"(4 rows)"
msgstr ""
"-- простой пример использования\n"
"SELECT generate_subscripts('{NULL,1,NULL,2}'::int[], 1) AS s;\n"
" s \n"
"---\n"
" 1\n"
" 2\n"
" 3\n"
" 4\n"
"(4 rows)\n"
"\n"
"-- для показанного массива получение индекса и обращение\n"
"-- к элементу по индексу выполняется с помощью подзапроса\n"
"SELECT * FROM arrays;\n"
"         a          \n"
"--------------------\n"
" {-1,-2}\n"
" {100,200,300}\n"
"(2 rows)\n"
"\n"
"SELECT a AS array, s AS subscript, a[s] AS value\n"
"FROM (SELECT generate_subscripts(a, 1) AS s, a FROM arrays) foo;\n"
"     array     | subscript | value\n"
"---------------+-----------+-------\n"
" {-1,-2}       |         1 |    -1\n"
" {-1,-2}       |         2 |    -2\n"
" {100,200,300} |         1 |   100\n"
" {100,200,300} |         2 |   200\n"
" {100,200,300} |         3 |   300\n"
"(5 rows)\n"
"\n"
"-- разворачивание двумерного массива\n"
"CREATE OR REPLACE FUNCTION unnest2(anyarray)\n"
"RETURNS SETOF anyelement AS $$\n"
"select $1[i][j]\n"
"   from generate_subscripts($1,1) g1(i),\n"
"        generate_subscripts($1,2) g2(j);\n"
"$$ LANGUAGE sql IMMUTABLE;\n"
"CREATE FUNCTION\n"
"SELECT * FROM unnest2(ARRAY[[1,2],[3,4]]);\n"
" unnest2 \n"
"---------\n"
"       1\n"
"       2\n"
"       3\n"
"       4\n"
"(4 rows)"

#: func.xml:15169(para)
msgid ""
"<function>generate_subscripts</function> is a convenience function that "
"generates the set of valid subscripts for the specified dimension of the "
"given array. Zero rows are returned for arrays that do not have the "
"requested dimension, or for NULL arrays (but valid subscripts are returned "
"for NULL array elements). Some examples follow: <placeholder-1/>"
msgstr ""
"Функция <function>generate_subscripts</function> позволяет упростить "
"получение всего набора индексов для указанной размерности заданного массива. "
"Она выдаёт 0 строк, если в массиве нет указанной размерности или сам массив "
"равен NULL (хотя для элементов, равных NULL, индексы будут выданы, как и для "
"любых других). Взгляните на следующие примеры: <placeholder-1/>"

#: func.xml:15226(indexterm)
msgid "<primary>ordinality</primary>"
msgstr "<primary>ordinality</primary>"

#: func.xml:15237(programlisting)
#, no-wrap
msgid ""
"-- set returning function WITH ORDINALITY\n"
"SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);\n"
"       ls        | n\n"
"-----------------+----\n"
" pg_serial       |  1\n"
" pg_twophase     |  2\n"
" postmaster.opts |  3\n"
" pg_notify       |  4\n"
" postgresql.conf |  5\n"
" pg_tblspc       |  6\n"
" logfile         |  7\n"
" base            |  8\n"
" postmaster.pid  |  9\n"
" pg_ident.conf   | 10\n"
" global          | 11\n"
" pg_clog         | 12\n"
" pg_snapshots    | 13\n"
" pg_multixact    | 14\n"
" PG_VERSION      | 15\n"
" pg_xlog         | 16\n"
" pg_hba.conf     | 17\n"
" pg_stat_tmp     | 18\n"
" pg_subtrans     | 19\n"
"(19 rows)"
msgstr ""
"-- функция, возвращающая множество, с нумерацией\n"
"SELECT * FROM pg_ls_dir('.') WITH ORDINALITY AS t(ls,n);\n"
"       ls        | n\n"
"-----------------+----\n"
" pg_serial       |  1\n"
" pg_twophase     |  2\n"
" postmaster.opts |  3\n"
" pg_notify       |  4\n"
" postgresql.conf |  5\n"
" pg_tblspc       |  6\n"
" logfile         |  7\n"
" base            |  8\n"
" postmaster.pid  |  9\n"
" pg_ident.conf   | 10\n"
" global          | 11\n"
" pg_clog         | 12\n"
" pg_snapshots    | 13\n"
" pg_multixact    | 14\n"
" PG_VERSION      | 15\n"
" pg_xlog         | 16\n"
" pg_hba.conf     | 17\n"
" pg_stat_tmp     | 18\n"
" pg_subtrans     | 19\n"
"(19 строк)"

#: func.xml:15230(para)
msgid ""
"When a function in the <literal>FROM</literal> clause is suffixed by "
"<literal>WITH ORDINALITY</literal>, a <type>bigint</type> column is appended "
"to the output which starts from 1 and increments by 1 for each row of the "
"function's output. This is most useful in the case of set returning "
"functions such as <function>unnest()</function>. <placeholder-1/>"
msgstr ""
"Когда после функции в предложении <literal>FROM</literal> добавляется "
"<literal>WITH ORDINALITY</literal>, в выходные данные добавляется столбец "
"типа <type>bigint</type>, числа в котором начинаются с 1 и увеличиваются на "
"1 для каждой строки, выданной функцией. В первую очередь это полезно для "
"функций, возвращающих множества, например, <function>unnest()</function>. "
"<placeholder-1/>"

#: func.xml:15268(title)
msgid "System Information Functions"
msgstr "Системные информационные функции"

#: func.xml:15270(para)
msgid ""
"<xref linkend=\"functions-info-session-table\"/> shows several functions "
"that extract session and system information."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-session-table\"/> перечислен "
"ряд функций, предназначенных для получения информации о текущем сеансе и "
"системе."

#: func.xml:15275(para)
msgid ""
"In addition to the functions listed in this section, there are a number of "
"functions related to the statistics system that also provide system "
"information. See <xref linkend=\"monitoring-stats-views\"/> for more "
"information."
msgstr ""
"В дополнение к перечисленным здесь функциям существуют также функции, "
"связанные с подсистемой статистики, которые тоже предоставляют системную "
"информацию. Подробнее они рассматриваются в <xref remap=\"6\" linkend="
"\"monitoring-stats-views\"/>."

#: func.xml:15283(title)
msgid "Session Information Functions"
msgstr "Функции получения информации о сеансе"

#: func.xml:15286(entry) func.xml:15667(entry) func.xml:16095(entry)
#: func.xml:16354(entry) func.xml:16727(entry) func.xml:16836(entry)
#: func.xml:16926(entry) func.xml:16980(entry) func.xml:17042(entry)
#: func.xml:17082(entry) func.xml:17445(entry) func.xml:17563(entry)
#: func.xml:17698(entry) func.xml:17941(entry) func.xml:18021(entry)
#: func.xml:18112(entry) func.xml:18598(entry) func.xml:18848(entry)
#: func.xml:18935(entry) func.xml:18997(entry) func.xml:19121(entry)
#: func.xml:19479(entry) func.xml:19566(entry) func.xml:19703(entry)
msgid "Name"
msgstr "Имя"

#: func.xml:15291(function)
msgid "current_catalog"
msgstr "current_catalog"

#: func.xml:15293(entry)
msgid ""
"name of current database (called <quote>catalog</quote> in the SQL standard)"
msgstr ""
"имя текущей базы данных (в стандарте SQL она называется <quote>каталогом</"
"quote>)"

#: func.xml:15297(function)
msgid "current_database()"
msgstr "current_database()"

#: func.xml:15299(entry)
msgid "name of current database"
msgstr "имя текущей базы данных"

#: func.xml:15303(function)
msgid "current_query()"
msgstr "current_query()"

#: func.xml:15305(entry)
msgid ""
"text of the currently executing query, as submitted by the client (might "
"contain more than one statement)"
msgstr ""
"текст запроса, выполняемого в данный момент, в том виде, в каком его передал "
"клиент (может состоять из нескольких операторов)"

#: func.xml:15310(function)
msgid "current_schema"
msgstr "current_schema"

#: func.xml:15310(literal)
msgid "<placeholder-1/>[()]"
msgstr "<placeholder-1/>[()]"

#: func.xml:15312(entry)
msgid "name of current schema"
msgstr "имя текущей схемы"

#: func.xml:15316(function)
msgid "current_schemas(<placeholder-1/>)"
msgstr "current_schemas(<placeholder-1/>)"

#: func.xml:15317(type)
msgid "name[]"
msgstr "name[]"

#: func.xml:15318(entry)
msgid "names of schemas in search path, optionally including implicit schemas"
msgstr ""
"имена схем в пути поиска, возможно включая схемы, добавляемые в него неявно"

#: func.xml:15322(function)
msgid "current_user"
msgstr "current_user"

#: func.xml:15324(entry)
msgid "user name of current execution context"
msgstr "имя пользователя в текущем контексте выполнения"

#: func.xml:15328(function)
msgid "inet_client_addr()"
msgstr "inet_client_addr()"

#: func.xml:15330(entry)
msgid "address of the remote connection"
msgstr "адрес удалённой стороны соединения"

#: func.xml:15334(function)
msgid "inet_client_port()"
msgstr "inet_client_port()"

#: func.xml:15336(entry)
msgid "port of the remote connection"
msgstr "порт удалённой стороны соединения"

#: func.xml:15340(function)
msgid "inet_server_addr()"
msgstr "inet_server_addr()"

#: func.xml:15342(entry)
msgid "address of the local connection"
msgstr "адрес локальной стороны соединения"

#: func.xml:15346(function)
msgid "inet_server_port()"
msgstr "inet_server_port()"

#: func.xml:15348(entry)
msgid "port of the local connection"
msgstr "порт локальной стороны соединения"

#: func.xml:15353(function)
msgid "pg_backend_pid()"
msgstr "pg_backend_pid()"

#: func.xml:15355(entry)
msgid "Process ID of the server process attached to the current session"
msgstr "код серверного процесса, обслуживающего текущий сеанс"

#: func.xml:15361(function)
msgid "pg_blocking_pids(<placeholder-1/>)"
msgstr "pg_blocking_pids(<placeholder-1/>)"

#: func.xml:15363(entry)
msgid "Process ID(s) that are blocking specified server process ID"
msgstr ""
"Идентификаторы процессов, блокирующих серверный процесс с определённым ID"

#: func.xml:15367(function)
msgid "pg_conf_load_time()"
msgstr "pg_conf_load_time()"

#: func.xml:15369(entry)
msgid "configuration load time"
msgstr "время загрузки конфигурации"

#: func.xml:15373(function)
msgid "pg_my_temp_schema()"
msgstr "pg_my_temp_schema()"

#: func.xml:15375(entry)
msgid "OID of session's temporary schema, or 0 if none"
msgstr "OID временной схемы этого сеанса или 0, если её нет"

#: func.xml:15379(function)
msgid "pg_is_other_temp_schema(<placeholder-1/>)"
msgstr "pg_is_other_temp_schema(<placeholder-1/>)"

#: func.xml:15381(entry)
msgid "is schema another session's temporary schema?"
msgstr "является ли заданная схема временной в другом сеансе?"

#: func.xml:15385(function)
msgid "pg_listening_channels()"
msgstr "pg_listening_channels()"

#: func.xml:15387(entry)
msgid "channel names that the session is currently listening on"
msgstr "имена каналов, по которым текущий сеанс принимает сигналы"

#: func.xml:15391(function)
msgid "pg_notification_queue_usage()"
msgstr "pg_notification_queue_usage()"

#: func.xml:15392(type)
msgid "double"
msgstr "double"

#: func.xml:15393(entry)
msgid ""
"fraction of the asynchronous notification queue currently occupied (0-1)"
msgstr "занятая доля очереди асинхронных уведомлений (0-1)"

#: func.xml:15397(function)
msgid "pg_postmaster_start_time()"
msgstr "pg_postmaster_start_time()"

#: func.xml:15399(entry)
msgid "server start time"
msgstr "время запуска сервера"

#: func.xml:15403(function)
msgid "pg_trigger_depth()"
msgstr "pg_trigger_depth()"

#: func.xml:15405(entry)
msgid ""
"current nesting level of <productname>PostgreSQL</productname> triggers (0 "
"if not called, directly or indirectly, from inside a trigger)"
msgstr ""
"текущий уровень вложенности в триггерах <productname>PostgreSQL</"
"productname> (0, если эта функция вызывается (прямо или косвенно) не из тела "
"триггера)"

#: func.xml:15410(function)
msgid "session_user"
msgstr "session_user"

#: func.xml:15412(entry)
msgid "session user name"
msgstr "имя пользователя сеанса"

#: func.xml:15416(function)
msgctxt "function"
msgid "user"
msgstr "user"

#: func.xml:15418(entry)
msgid "equivalent to <function>current_user</function>"
msgstr "синоним <function>current_user</function>"

#: func.xml:15422(function)
msgid "version()"
msgstr "version()"

#: func.xml:15424(entry)
msgid ""
"<productname>PostgreSQL</productname> version information. See also <xref "
"linkend=\"guc-server-version-num\"/> for a machine-readable version."
msgstr ""
"информация о версии <productname>PostgreSQL</productname>. Также можно "
"прочитать версию в машинно-ориентированном виде, обратившись к переменной "
"<xref linkend=\"guc-server-version-num\"/>."

#: func.xml:15431(para)
msgid ""
"<function>current_catalog</function>, <function>current_schema</function>, "
"<function>current_user</function>, <function>session_user</function>, and "
"<function>user</function> have special syntactic status in <acronym>SQL</"
"acronym>: they must be called without trailing parentheses. (In PostgreSQL, "
"parentheses can optionally be used with <function>current_schema</function>, "
"but not with the others.)"
msgstr ""
"Функции <function>current_catalog</function>, <function>current_schema</"
"function>, <function>current_user</function>, <function>session_user</"
"function> и <function>user</function> имеют особый синтаксический статус в "
"<acronym>SQL</acronym>: они должны вызываться без скобок после имени. "
"(PostgreSQL позволяет добавить скобки в вызове <function>current_schema</"
"function>, но не других функций.)"

#: func.xml:15441(indexterm)
msgid "<primary>current_catalog</primary>"
msgstr "<primary>current_catalog</primary>"

#: func.xml:15445(indexterm)
msgid "<primary>current_database</primary>"
msgstr "<primary>current_database</primary>"

#: func.xml:15449(indexterm)
msgid "<primary>current_query</primary>"
msgstr "<primary>current_query</primary>"

#: func.xml:15453(indexterm)
msgid "<primary>current_schema</primary>"
msgstr "<primary>current_schema</primary>"

#: func.xml:15457(indexterm)
msgid "<primary>current_schemas</primary>"
msgstr "<primary>current_schemas</primary>"

#: func.xml:15461(indexterm)
msgid "<primary>current_user</primary>"
msgstr "<primary>current_user</primary>"

#: func.xml:15465(indexterm)
msgid "<primary>pg_backend_pid</primary>"
msgstr "<primary>pg_backend_pid</primary>"

#: func.xml:15469(indexterm)
msgid "<primary>schema</primary> <secondary>current</secondary>"
msgstr "<primary>схема</primary> <secondary>текущая</secondary>"

#: func.xml:15474(indexterm)
msgid "<primary>search path</primary> <secondary>current</secondary>"
msgstr "<primary>путь поиска</primary> <secondary>текущий</secondary>"

#: func.xml:15479(indexterm)
msgid "<primary>session_user</primary>"
msgstr "<primary>session_user</primary>"

#: func.xml:15483(indexterm)
msgid "<primary>user</primary> <secondary>current</secondary>"
msgstr "<primary>пользователь</primary> <secondary>текущий</secondary>"

#: func.xml:15488(indexterm)
msgid "<primary>user</primary>"
msgstr "<primary>пользователь</primary>"

#: func.xml:15492(para)
msgid ""
"The <function>session_user</function> is normally the user who initiated the "
"current database connection; but superusers can change this setting with "
"<xref linkend=\"sql-set-session-authorization\"/>. The "
"<function>current_user</function> is the user identifier that is applicable "
"for permission checking. Normally it is equal to the session user, but it "
"can be changed with <xref linkend=\"sql-set-role\"/>. It also changes during "
"the execution of functions with the attribute <literal>SECURITY DEFINER</"
"literal>. In Unix parlance, the session user is the <quote>real user</quote> "
"and the current user is the <quote>effective user</quote>."
msgstr ""
"Функция <function>session_user</function> обычно возвращает имя "
"пользователя, установившего текущее соединение с базой данных, но "
"суперпользователи могут изменить это имя, выполнив команду <xref linkend="
"\"sql-set-session-authorization\"/>. Функция <function>current_user</"
"function> возвращает идентификатор пользователя, по которому будут "
"проверяться его права. Обычно это тот же пользователь, что и пользователь "
"сеанса, но его можно сменить с помощью <xref linkend=\"sql-set-role\"/>. "
"Этот идентификатор также меняется при выполнении функций с атрибутом "
"<literal>SECURITY DEFINER</literal>. На языке Unix пользователь сеанса "
"называется <quote>реальным</quote>, а текущий &mdash; <quote>эффективным</"
"quote>."

#: func.xml:15506(para)
msgid ""
"<function>current_schema</function> returns the name of the schema that is "
"first in the search path (or a null value if the search path is empty). This "
"is the schema that will be used for any tables or other named objects that "
"are created without specifying a target schema. "
"<function>current_schemas(boolean)</function> returns an array of the names "
"of all schemas presently in the search path. The Boolean option determines "
"whether or not implicitly included system schemas such as "
"<literal>pg_catalog</literal> are included in the returned search path."
msgstr ""
"Функция <function>current_schema</function> возвращает имя схемы, которая "
"стоит первой в пути поиска (или NULL, если путь поиска пуст). Эта схема "
"будет задействована при создании таблиц или других именованных объектов, "
"если целевая схема не указана явно. Функция "
"<function>current_schemas(boolean)</function> возвращает массив имён всех "
"схем, находящихся в пути поиска. Её логический параметр определяет, будут ли "
"включаться в результат неявно добавляемые в путь поиска системные схемы, "
"такие как <literal>pg_catalog</literal>."

#: func.xml:15520(programlisting)
#, no-wrap
msgid "SET search_path TO <replaceable>schema</replaceable> <optional>, <replaceable>schema</replaceable>, ...</optional>"
msgstr "SET search_path TO <replaceable>схема</replaceable> <optional>, <replaceable>схема</replaceable>, ...</optional>"

#: func.xml:15518(para)
msgid ""
"The search path can be altered at run time. The command is: <placeholder-1/>"
msgstr ""
"Путь поиска можно изменить во время выполнения следующей командой: "
"<placeholder-1/>"

#: func.xml:15526(indexterm)
msgid "<primary>inet_client_addr</primary>"
msgstr "<primary>inet_client_addr</primary>"

#: func.xml:15530(indexterm)
msgid "<primary>inet_client_port</primary>"
msgstr "<primary>inet_client_port</primary>"

#: func.xml:15534(indexterm)
msgid "<primary>inet_server_addr</primary>"
msgstr "<primary>inet_server_addr</primary>"

#: func.xml:15538(indexterm)
msgid "<primary>inet_server_port</primary>"
msgstr "<primary>inet_server_port</primary>"

#: func.xml:15542(para)
msgid ""
"<function>inet_client_addr</function> returns the IP address of the current "
"client, and <function>inet_client_port</function> returns the port number. "
"<function>inet_server_addr</function> returns the IP address on which the "
"server accepted the current connection, and <function>inet_server_port</"
"function> returns the port number. All these functions return NULL if the "
"current connection is via a Unix-domain socket."
msgstr ""
"Функция <function>inet_client_addr</function> возвращает IP-адрес текущего "
"клиента, <function>inet_client_port</function> &mdash; номер его порта, "
"<function>inet_server_addr</function> &mdash; IP-адрес сервера, по которому "
"он принял подключение клиента, а <function>inet_server_port</function> "
"&mdash; соответствующий номер порта. Все эти функции возвращают NULL, если "
"текущее соединение устанавливается через доменный сокет Unix."

#: func.xml:15553(indexterm)
msgid "<primary>pg_blocking_pids</primary>"
msgstr "<primary>pg_blocking_pids</primary>"

#: func.xml:15557(para)
msgid ""
"<function>pg_blocking_pids</function> returns an array of the process IDs of "
"the sessions that are blocking the server process with the specified process "
"ID, or an empty array if there is no such server process or it is not "
"blocked. One server process blocks another if it either holds a lock that "
"conflicts with the blocked process's lock request (hard block), or is "
"waiting for a lock that would conflict with the blocked process's lock "
"request and is ahead of it in the wait queue (soft block). When using "
"parallel queries the result always lists client-visible process IDs (that "
"is, <function>pg_backend_pid</function> results) even if the actual lock is "
"held or awaited by a child worker process. As a result of that, there may be "
"duplicated PIDs in the result. Also note that when a prepared transaction "
"holds a conflicting lock, it will be represented by a zero process ID in the "
"result of this function. Frequent calls to this function could have some "
"impact on database performance, because it needs exclusive access to the "
"lock manager's shared state for a short time."
msgstr ""
"Функция <function>pg_blocking_pids</function> возвращает массив "
"идентификаторов процессов сеансов, которые блокирует серверный процесс с "
"указанным идентификатором, либо пустой массив, если такой серверный процесс "
"не найден или не заблокирован. Один серверный процесс блокирует другой, если "
"он либо удерживает блокировку, конфликтующую с блокировкой, запрашиваемой "
"серверным процессом (жёсткая блокировка), либо ждёт блокировки, которая "
"вызвала бы конфликт с запросом блокировки заблокированного процесса и "
"находится перед ней в очереди ожидания (мягкая блокировка). При "
"распараллеливании запросов эта функция всегда выдаёт видимые клиентом "
"идентификаторы процессов (то есть, результаты <function>pg_backend_pid</"
"function>), даже если фактическая блокировка удерживается или ожидается "
"дочерним рабочим процессом. Вследствие этого, в результатах могут оказаться "
"дублирующиеся PID. Также заметьте, что когда конфликтующую блокировку "
"удерживает подготовленная транзакция, в выводе этой функции она будет "
"представлена нулевым ID процесса. Частые вызовы этой функции могут "
"отразиться на производительности базы данных, так как ей нужен монопольный "
"доступ к общему состоянию менеджера блокировок, хоть и на короткое время."

#: func.xml:15576(indexterm)
msgid "<primary>pg_conf_load_time</primary>"
msgstr "<primary>pg_conf_load_time</primary>"

#: func.xml:15580(para)
msgid ""
"<function>pg_conf_load_time</function> returns the <type>timestamp with time "
"zone</type> when the server configuration files were last loaded. (If the "
"current session was alive at the time, this will be the time when the "
"session itself re-read the configuration files, so the reading will vary a "
"little in different sessions. Otherwise it is the time when the postmaster "
"process re-read the configuration files.)"
msgstr ""
"Функция <function>pg_conf_load_time</function> возвращает время "
"(<type>timestamp with time zone</type>), когда в последний раз сервер "
"загружал файлы конфигурации. (Если текущий сеанс начался раньше, она "
"возвращает время, когда эти файлы были перезагружены для данного сеанса, так "
"что в разных сеансах это значение может немного различаться. В противном "
"случае это будет время, когда файлы конфигурации считал главный процесс.)"

#: func.xml:15590(indexterm)
msgid "<primary>pg_my_temp_schema</primary>"
msgstr "<primary>pg_my_temp_schema</primary>"

#: func.xml:15594(indexterm)
msgid "<primary>pg_is_other_temp_schema</primary>"
msgstr "<primary>pg_is_other_temp_schema</primary>"

#: func.xml:15598(para)
msgid ""
"<function>pg_my_temp_schema</function> returns the OID of the current "
"session's temporary schema, or zero if it has none (because it has not "
"created any temporary tables). <function>pg_is_other_temp_schema</function> "
"returns true if the given OID is the OID of another session's temporary "
"schema. (This can be useful, for example, to exclude other sessions' "
"temporary tables from a catalog display.)"
msgstr ""
"<function>pg_my_temp_schema</function> возвращает OID временной схемы "
"текущего сеанса или 0, если такой нет (в рамках сеанса не создавались "
"временные таблицы). <function>pg_is_other_temp_schema</function> возвращает "
"true, если заданный OID относится к временной схеме другого сеанса. (Это "
"может быть полезно, например для исключения временных таблиц других сеансов "
"из общего списка при просмотре таблиц базы данных.)"

#: func.xml:15608(indexterm)
msgid "<primary>pg_listening_channels</primary>"
msgstr "<primary>pg_listening_channels</primary>"

#: func.xml:15612(indexterm)
msgid "<primary>pg_notification_queue_usage</primary>"
msgstr "<primary>pg_notification_queue_usage</primary>"

#: func.xml:15616(para)
msgid ""
"<function>pg_listening_channels</function> returns a set of names of "
"asynchronous notification channels that the current session is listening to. "
"<function>pg_notification_queue_usage</function> returns the fraction of the "
"total available space for notifications currently occupied by notifications "
"that are waiting to be processed, as a <type>double</type> in the range 0-1. "
"See <xref linkend=\"sql-listen\"/> and <xref linkend=\"sql-notify\"/> for "
"more information."
msgstr ""
"Функция <function>pg_listening_channels</function> возвращает набор имён "
"каналов асинхронных уведомлений, на которые подписан текущий сеанс. Функция "
"<function>pg_notification_queue_usage</function> возвращает долю от всего "
"свободного пространства для уведомлений, в настоящее время занятую "
"уведомлениями, ожидающими обработки, в виде значения <type>double</type> в "
"диапазоне 0..1. За дополнительными сведениями обратитесь к <xref remap=\"3\" "
"linkend=\"sql-listen\"/> и <xref remap=\"3\" linkend=\"sql-notify\"/>."

#: func.xml:15627(indexterm)
msgid "<primary>pg_postmaster_start_time</primary>"
msgstr "<primary>pg_postmaster_start_time</primary>"

#: func.xml:15631(para)
msgid ""
"<function>pg_postmaster_start_time</function> returns the <type>timestamp "
"with time zone</type> when the server started."
msgstr ""
"<function>pg_postmaster_start_time</function> возвращает время "
"(<type>timestamp with time zone</type>), когда был запущен сервер."

#: func.xml:15637(indexterm)
msgid "<primary>version</primary>"
msgstr "<primary>версия</primary>"

#: func.xml:15641(para)
msgid ""
"<function>version</function> returns a string describing the "
"<productname>PostgreSQL</productname> server's version. You can also get "
"this information from <xref linkend=\"guc-server-version\"/> or for a "
"machine-readable version, <xref linkend=\"guc-server-version-num\"/>. "
"Software developers should use <literal>server_version_num</literal> "
"(available since 8.2) or <xref linkend=\"libpq-pqserverversion\"/> instead "
"of parsing the text version."
msgstr ""
"Функция <function>version</function> возвращает строку, описывающую версию "
"сервера <productname>PostgreSQL</productname>. Эту информацию также можно "
"получить из переменной <xref linkend=\"guc-server-version\"/> или, в более "
"машинно-ориентированном формате, из переменной <xref linkend=\"guc-server-"
"version-num\"/>. При разработке программ следует использовать "
"<literal>server_version_num</literal> (она появилась в версии 8.2) либо "
"<xref linkend=\"libpq-pqserverversion\"/>, а не разбирать текстовую версию."

#: func.xml:15651(indexterm)
msgid "<primary>privilege</primary> <secondary>querying</secondary>"
msgstr "<primary>права</primary> <secondary>проверка</secondary>"

#: func.xml:15656(para)
msgid ""
"<xref linkend=\"functions-info-access-table\"/> lists functions that allow "
"the user to query object access privileges programmatically. See <xref "
"linkend=\"ddl-priv\"/> for more information about privileges."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-access-table\"/> перечислены "
"функции, позволяющую пользователю программно проверить свои права доступа к "
"объектам. Подробнее о правах можно узнать в <xref remap=\"6\" linkend=\"ddl-"
"priv\"/>."

#: func.xml:15664(title)
msgid "Access Privilege Inquiry Functions"
msgstr "Функции для проверки прав доступа"

#: func.xml:15672(function) func.xml:15680(function)
msgid "has_any_column_privilege"
msgstr "has_any_column_privilege"

#: func.xml:15672(parameter) func.xml:15687(parameter)
#: func.xml:15704(parameter) func.xml:15719(parameter)
#: func.xml:15734(parameter) func.xml:15749(parameter)
#: func.xml:15764(parameter) func.xml:15779(parameter)
#: func.xml:15794(parameter) func.xml:15809(parameter)
#: func.xml:15824(parameter) func.xml:15839(parameter)
msgctxt "parameter"
msgid "user"
msgstr "user"

#: func.xml:15673(parameter) func.xml:15680(parameter)
#: func.xml:15688(parameter) func.xml:15696(parameter)
#: func.xml:15810(parameter) func.xml:15817(parameter)
#: func.xml:15854(parameter)
msgid "table"
msgstr "table"

#: func.xml:15674(parameter) func.xml:15681(parameter)
#: func.xml:15690(parameter) func.xml:15698(parameter)
#: func.xml:15706(parameter) func.xml:15713(parameter)
#: func.xml:15721(parameter) func.xml:15728(parameter)
#: func.xml:15736(parameter) func.xml:15743(parameter)
#: func.xml:15751(parameter) func.xml:15758(parameter)
#: func.xml:15766(parameter) func.xml:15773(parameter)
#: func.xml:15781(parameter) func.xml:15788(parameter)
#: func.xml:15796(parameter) func.xml:15803(parameter)
#: func.xml:15811(parameter) func.xml:15818(parameter)
#: func.xml:15826(parameter) func.xml:15833(parameter)
#: func.xml:15841(parameter) func.xml:15848(parameter)
msgid "privilege"
msgstr "privilege"

#: func.xml:15677(entry)
msgid "does user have privilege for any column of table"
msgstr "имеет ли пользователь указанное право для какого-либо столбца таблицы"

#: func.xml:15684(entry)
msgid "does current user have privilege for any column of table"
msgstr ""
"имеет ли текущий пользователь указанное право для какого-либо столбца таблицы"

#: func.xml:15687(function) func.xml:15696(function)
msgid "has_column_privilege"
msgstr "has_column_privilege"

#: func.xml:15689(parameter) func.xml:15697(parameter)
msgid "column"
msgstr "column"

#: func.xml:15687(literal)
msgid ""
"<placeholder-1/>(<placeholder-2/>, <placeholder-3/>, <placeholder-4/>, "
"<placeholder-5/>)"
msgstr ""
"<placeholder-1/>(<placeholder-2/>, <placeholder-3/>, <placeholder-4/>, "
"<placeholder-5/>)"

#: func.xml:15693(entry)
msgid "does user have privilege for column"
msgstr "имеет ли пользователь указанное право для столбца"

#: func.xml:15701(entry)
msgid "does current user have privilege for column"
msgstr "имеет ли текущий пользователь указанное право для столбца"

#: func.xml:15704(function) func.xml:15712(function)
msgid "has_database_privilege"
msgstr "has_database_privilege"

#: func.xml:15705(parameter) func.xml:15712(parameter)
msgid "database"
msgstr "database"

#: func.xml:15709(entry)
msgid "does user have privilege for database"
msgstr "имеет ли пользователь указанное право для базы данных"

#: func.xml:15716(entry)
msgid "does current user have privilege for database"
msgstr "имеет ли текущий пользователь указанное право для базы данных"

#: func.xml:15719(function) func.xml:15727(function)
msgid "has_foreign_data_wrapper_privilege"
msgstr "has_foreign_data_wrapper_privilege"

#: func.xml:15720(parameter) func.xml:15727(parameter)
msgid "fdw"
msgstr "fdw"

#: func.xml:15724(entry)
msgid "does user have privilege for foreign-data wrapper"
msgstr "имеет ли пользователь указанное право для обёртки сторонних данных"

#: func.xml:15731(entry)
msgid "does current user have privilege for foreign-data wrapper"
msgstr ""
"имеет ли текущий пользователь указанное право для обёртки сторонних данных"

#: func.xml:15734(function) func.xml:15742(function)
msgid "has_function_privilege"
msgstr "has_function_privilege"

#: func.xml:15735(parameter) func.xml:15742(parameter)
msgid "function"
msgstr "function"

#: func.xml:15739(entry)
msgid "does user have privilege for function"
msgstr "имеет ли пользователь указанное право для функции"

#: func.xml:15746(entry)
msgid "does current user have privilege for function"
msgstr "имеет ли текущий пользователь указанное право для функции"

#: func.xml:15749(function) func.xml:15757(function)
msgid "has_language_privilege"
msgstr "has_language_privilege"

#: func.xml:15750(parameter) func.xml:15757(parameter)
msgid "language"
msgstr "language"

#: func.xml:15754(entry)
msgid "does user have privilege for language"
msgstr "имеет ли пользователь указанное право для языка"

#: func.xml:15761(entry)
msgid "does current user have privilege for language"
msgstr "имеет ли текущий пользователь указанное право для языка"

#: func.xml:15764(function) func.xml:15772(function)
msgid "has_schema_privilege"
msgstr "has_schema_privilege"

#: func.xml:15765(parameter) func.xml:15772(parameter)
msgid "schema"
msgstr "schema"

#: func.xml:15769(entry)
msgid "does user have privilege for schema"
msgstr "имеет ли пользователь указанное право для схемы"

#: func.xml:15776(entry)
msgid "does current user have privilege for schema"
msgstr "имеет ли текущий пользователь указанное право для схемы"

#: func.xml:15779(function) func.xml:15787(function)
msgid "has_sequence_privilege"
msgstr "has_sequence_privilege"

#: func.xml:15780(parameter) func.xml:15787(parameter)
msgid "sequence"
msgstr "sequence"

#: func.xml:15784(entry)
msgid "does user have privilege for sequence"
msgstr "имеет ли пользователь указанное право для последовательности"

#: func.xml:15791(entry)
msgid "does current user have privilege for sequence"
msgstr "имеет ли текущий пользователь указанное право для последовательности"

#: func.xml:15794(function) func.xml:15802(function)
msgid "has_server_privilege"
msgstr "has_server_privilege"

#: func.xml:15795(parameter) func.xml:15802(parameter)
msgid "server"
msgstr "server"

#: func.xml:15799(entry)
msgid "does user have privilege for foreign server"
msgstr "имеет ли пользователь указанное право для стороннего сервера"

#: func.xml:15806(entry)
msgid "does current user have privilege for foreign server"
msgstr "имеет ли текущий пользователь указанное право для стороннего сервера"

#: func.xml:15809(function) func.xml:15817(function)
msgid "has_table_privilege"
msgstr "has_table_privilege"

#: func.xml:15814(entry)
msgid "does user have privilege for table"
msgstr "имеет ли пользователь указанное право для таблицы"

#: func.xml:15821(entry)
msgid "does current user have privilege for table"
msgstr "имеет ли текущий пользователь указанное право для таблицы"

#: func.xml:15824(function) func.xml:15832(function)
msgid "has_tablespace_privilege"
msgstr "has_tablespace_privilege"

#: func.xml:15825(parameter) func.xml:15832(parameter)
#: func.xml:18873(parameter)
msgid "tablespace"
msgstr "tablespace"

#: func.xml:15829(entry)
msgid "does user have privilege for tablespace"
msgstr "имеет ли пользователь указанное право для табличного пространства"

#: func.xml:15836(entry)
msgid "does current user have privilege for tablespace"
msgstr ""
"имеет ли текущий пользователь указанное право для табличного пространства"

#: func.xml:15839(function) func.xml:15847(function)
msgid "pg_has_role"
msgstr "pg_has_role"

#: func.xml:15840(parameter) func.xml:15847(parameter)
msgid "role"
msgstr "role"

#: func.xml:15844(entry)
msgid "does user have privilege for role"
msgstr "имеет ли пользователь указанное право для роли"

#: func.xml:15851(entry)
msgid "does current user have privilege for role"
msgstr "имеет ли текущий пользователь указанное право для роли"

#: func.xml:15854(function)
msgid "row_security_active"
msgstr "row_security_active"

#: func.xml:15857(entry)
msgid "does current user have row level security active for table"
msgstr ""
"включена ли для текущего пользователя защита на уровне строк для таблицы"

#: func.xml:15863(indexterm)
msgid "<primary>has_any_column_privilege</primary>"
msgstr "<primary>has_any_column_privilege</primary>"

#: func.xml:15866(indexterm)
msgid "<primary>has_column_privilege</primary>"
msgstr "<primary>has_column_privilege</primary>"

#: func.xml:15869(indexterm)
msgid "<primary>has_database_privilege</primary>"
msgstr "<primary>has_database_privilege</primary>"

#: func.xml:15872(indexterm)
msgid "<primary>has_function_privilege</primary>"
msgstr "<primary>has_function_privilege</primary>"

#: func.xml:15875(indexterm)
msgid "<primary>has_foreign_data_wrapper_privilege</primary>"
msgstr "<primary>has_foreign_data_wrapper_privilege</primary>"

#: func.xml:15878(indexterm)
msgid "<primary>has_language_privilege</primary>"
msgstr "<primary>has_language_privilege</primary>"

#: func.xml:15881(indexterm)
msgid "<primary>has_schema_privilege</primary>"
msgstr "<primary>has_schema_privilege</primary>"

#: func.xml:15884(indexterm)
msgid "<primary>has_server_privilege</primary>"
msgstr "<primary>has_server_privilege</primary>"

#: func.xml:15887(indexterm)
msgid "<primary>has_sequence_privilege</primary>"
msgstr "<primary>has_sequence_privilege</primary>"

#: func.xml:15890(indexterm)
msgid "<primary>has_table_privilege</primary>"
msgstr "<primary>has_table_privilege</primary>"

#: func.xml:15893(indexterm)
msgid "<primary>has_tablespace_privilege</primary>"
msgstr "<primary>has_tablespace_privilege</primary>"

#: func.xml:15896(indexterm)
msgid "<primary>pg_has_role</primary>"
msgstr "<primary>pg_has_role</primary>"

#: func.xml:15899(indexterm)
msgid "<primary>row_security_active</primary>"
msgstr "<primary>row_security_active</primary>"

#: func.xml:15926(programlisting)
#, no-wrap
msgid ""
"SELECT has_table_privilege('myschema.mytable', 'select');\n"
"SELECT has_table_privilege('joe', 'mytable', 'INSERT, SELECT WITH GRANT OPTION');"
msgstr ""
"SELECT has_table_privilege('myschema.mytable', 'select');\n"
"SELECT has_table_privilege('joe', 'mytable',\n"
"  'INSERT, SELECT WITH GRANT OPTION');"

#: func.xml:15903(para)
msgid ""
"<function>has_table_privilege</function> checks whether a user can access a "
"table in a particular way. The user can be specified by name, by OID "
"(<literal>pg_authid.oid</literal>), <literal>public</literal> to indicate "
"the PUBLIC pseudo-role, or if the argument is omitted "
"<function>current_user</function> is assumed. The table can be specified by "
"name or by OID. (Thus, there are actually six variants of "
"<function>has_table_privilege</function>, which can be distinguished by the "
"number and types of their arguments.) When specifying by name, the name can "
"be schema-qualified if necessary. The desired access privilege type is "
"specified by a text string, which must evaluate to one of the values "
"<literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</"
"literal>, <literal>DELETE</literal>, <literal>TRUNCATE</literal>, "
"<literal>REFERENCES</literal>, or <literal>TRIGGER</literal>. Optionally, "
"<literal>WITH GRANT OPTION</literal> can be added to a privilege type to "
"test whether the privilege is held with grant option. Also, multiple "
"privilege types can be listed separated by commas, in which case the result "
"will be <literal>true</literal> if any of the listed privileges is held. "
"(Case of the privilege string is not significant, and extra whitespace is "
"allowed between but not within privilege names.) Some examples: "
"<placeholder-1/>"
msgstr ""
"<function>has_table_privilege</function> проверяет, может ли пользователь "
"выполнять с таблицей заданные действия. В качестве идентификатора "
"пользователя можно задать его имя, OID (<literal>pg_authid.oid</literal>) "
"или <literal>public</literal> (это будет указывать на псевдороль PUBLIC). "
"Если этот аргумент опущен, подразумевается текущий пользователь "
"(<function>current_user</function>). Таблицу можно указать по имени или по "
"OID. (Таким образом, фактически есть шесть вариантов функции "
"<function>has_table_privilege</function>, различающихся по числу и типу "
"аргументов.) Когда указывается имя объекта, его можно дополнить именем "
"схемы, если это необходимо. Интересующее право доступа записывается в виде "
"текста и может быть одним из следующих: <literal>SELECT</literal>, "
"<literal>INSERT</literal>, <literal>UPDATE</literal>, <literal>DELETE</"
"literal>, <literal>TRUNCATE</literal>, <literal>REFERENCES</literal> и "
"<literal>TRIGGER</literal>. Дополнительно к названию права можно добавить "
"<literal>WITH GRANT OPTION</literal> и проверить, разрешено ли пользователю "
"передавать это право другим. Кроме того, в одном параметре можно перечислить "
"несколько названий прав через запятую, и тогда функция возвратит "
"<literal>true</literal>, если пользователь имеет одно из этих прав. (Регистр "
"в названии прав не имеет значения, а между ними (но не внутри) разрешены "
"пробельные символы.) Пара примеров: <placeholder-1/>"

#: func.xml:15932(para)
msgid ""
"<function>has_sequence_privilege</function> checks whether a user can access "
"a sequence in a particular way. The possibilities for its arguments are "
"analogous to <function>has_table_privilege</function>. The desired access "
"privilege type must evaluate to one of <literal>USAGE</literal>, "
"<literal>SELECT</literal>, or <literal>UPDATE</literal>."
msgstr ""
"<function>has_sequence_privilege</function> проверяет, может ли пользователь "
"выполнять заданные действия с последовательностью. В определении аргументов "
"эта функция аналогична <function>has_table_privilege</function>. Допустимые "
"для неё права складываются из <literal>USAGE</literal>, <literal>SELECT</"
"literal> и <literal>UPDATE</literal>."

#: func.xml:15942(para)
msgid ""
"<function>has_any_column_privilege</function> checks whether a user can "
"access any column of a table in a particular way. Its argument possibilities "
"are analogous to <function>has_table_privilege</function>, except that the "
"desired access privilege type must evaluate to some combination of "
"<literal>SELECT</literal>, <literal>INSERT</literal>, <literal>UPDATE</"
"literal>, or <literal>REFERENCES</literal>. Note that having any of these "
"privileges at the table level implicitly grants it for each column of the "
"table, so <function>has_any_column_privilege</function> will always return "
"<literal>true</literal> if <function>has_table_privilege</function> does for "
"the same arguments. But <function>has_any_column_privilege</function> also "
"succeeds if there is a column-level grant of the privilege for at least one "
"column."
msgstr ""
"<function>has_any_column_privilege</function> проверяет, может ли "
"пользователь выполнять заданные действия с каким-либо столбцом таблицы. В "
"определении аргументов эта функция аналогична <function>has_table_privilege</"
"function>, а допустимые права складываются из <literal>SELECT</literal>, "
"<literal>INSERT</literal>, <literal>UPDATE</literal> и <literal>REFERENCES</"
"literal>. Заметьте, что любое из этих прав, назначенное на уровне таблицы, "
"автоматически распространяется на все её столбцы, так что "
"<function>has_any_column_privilege</function> всегда возвращает "
"<literal>true</literal>, если <function>has_table_privilege</function> даёт "
"положительный ответ для тех же аргументов. Но "
"<function>has_any_column_privilege</function> возвращает <literal>true</"
"literal> ещё и тогда, когда право назначено только для некоторых столбцов."

#: func.xml:15960(para)
msgid ""
"<function>has_column_privilege</function> checks whether a user can access a "
"column in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>, with the addition that the column "
"can be specified either by name or attribute number. The desired access "
"privilege type must evaluate to some combination of <literal>SELECT</"
"literal>, <literal>INSERT</literal>, <literal>UPDATE</literal>, or "
"<literal>REFERENCES</literal>. Note that having any of these privileges at "
"the table level implicitly grants it for each column of the table."
msgstr ""
"<function>has_column_privilege</function> проверяет, может ли пользователь "
"выполнять заданные действия со столбцом таблицы. В определении аргументов "
"эта функция аналогична <function>has_table_privilege</function>, с небольшим "
"дополнением: столбец можно задать по имени или номеру атрибута. Для неё "
"допустимые права складываются из <literal>SELECT</literal>, <literal>INSERT</"
"literal>, <literal>UPDATE</literal> и <literal>REFERENCES</literal>. "
"Заметьте, что любое из этих прав, назначенное на уровне таблицы, "
"автоматически распространяется на все столбцы таблицы."

#: func.xml:15975(para)
msgid ""
"<function>has_database_privilege</function> checks whether a user can access "
"a database in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>. The desired access privilege type "
"must evaluate to some combination of <literal>CREATE</literal>, "
"<literal>CONNECT</literal>, <literal>TEMPORARY</literal>, or <literal>TEMP</"
"literal> (which is equivalent to <literal>TEMPORARY</literal>)."
msgstr ""
"<function>has_database_privilege</function> проверяет, может ли пользователь "
"выполнять заданные действия с базой данных. В определении аргументов эта "
"функция аналогична <function>has_table_privilege</function>. Для неё "
"допустимые права складываются из <literal>CREATE</literal>, "
"<literal>CONNECT</literal> и <literal>TEMPORARY</literal> (или "
"<literal>TEMP</literal>, что равносильно <literal>TEMPORARY</literal>)."

#: func.xml:15999(programlisting)
#, no-wrap
msgid "SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');"
msgstr "SELECT has_function_privilege('joeuser', 'myfunc(int, text)', 'execute');"

#: func.xml:15988(para)
msgid ""
"<function>has_function_privilege</function> checks whether a user can access "
"a function in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>. When specifying a function by a "
"text string rather than by OID, the allowed input is the same as for the "
"<type>regprocedure</type> data type (see <xref linkend=\"datatype-oid\"/>). "
"The desired access privilege type must evaluate to <literal>EXECUTE</"
"literal>. An example is: <placeholder-1/>"
msgstr ""
"<function>has_function_privilege</function> проверяет, может ли пользователь "
"обратиться к заданной функции. В определении аргументов эта функция "
"аналогична <function>has_table_privilege</function>. Когда функция "
"определяется не своим OID, а текстовой строкой, эта строка должна быть "
"допустимой для вводимого значения типа <type>regprocedure</type> (см. <xref "
"remap=\"4\" linkend=\"datatype-oid\"/>). Для этой функции допустимо только "
"право <literal>EXECUTE</literal>. Например: <placeholder-1/>"

#: func.xml:16004(para)
msgid ""
"<function>has_foreign_data_wrapper_privilege</function> checks whether a "
"user can access a foreign-data wrapper in a particular way. Its argument "
"possibilities are analogous to <function>has_table_privilege</function>. The "
"desired access privilege type must evaluate to <literal>USAGE</literal>."
msgstr ""
"<function>has_foreign_data_wrapper_privilege</function> проверяет, может ли "
"пользователь обращаться к обёртке сторонних данных. В определении аргументов "
"она аналогична <function>has_table_privilege</function>. Для неё допустимо "
"только право <literal>USAGE</literal>."

#: func.xml:16013(para)
msgid ""
"<function>has_language_privilege</function> checks whether a user can access "
"a procedural language in a particular way. Its argument possibilities are "
"analogous to <function>has_table_privilege</function>. The desired access "
"privilege type must evaluate to <literal>USAGE</literal>."
msgstr ""
"<function>has_language_privilege</function> проверяет, может ли пользователь "
"обращаться к процедурному языку. В определении аргументов эта функция "
"аналогична <function>has_table_privilege</function>. Для неё допустимо "
"только право <literal>USAGE</literal>."

#: func.xml:16022(para)
msgid ""
"<function>has_schema_privilege</function> checks whether a user can access a "
"schema in a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>. The desired access privilege type "
"must evaluate to some combination of <literal>CREATE</literal> or "
"<literal>USAGE</literal>."
msgstr ""
"<function>has_schema_privilege</function> проверяет, может ли пользователь "
"выполнять заданные действия со схемой. В определении аргументов эта функция "
"аналогична <function>has_table_privilege</function>. Для неё допустимые "
"права складываются из <literal>CREATE</literal> и <literal>USAGE</literal>."

#: func.xml:16032(para)
msgid ""
"<function>has_server_privilege</function> checks whether a user can access a "
"foreign server in a particular way. Its argument possibilities are analogous "
"to <function>has_table_privilege</function>. The desired access privilege "
"type must evaluate to <literal>USAGE</literal>."
msgstr ""
"<function>has_server_privilege</function> проверяет, может ли пользователь "
"обращаться к стороннему серверу. В определении аргументов она аналогична "
"<function>has_table_privilege</function>. Для неё допустимо только право "
"<literal>USAGE</literal>."

#: func.xml:16041(para)
msgid ""
"<function>has_tablespace_privilege</function> checks whether a user can "
"access a tablespace in a particular way. Its argument possibilities are "
"analogous to <function>has_table_privilege</function>. The desired access "
"privilege type must evaluate to <literal>CREATE</literal>."
msgstr ""
"<function>has_tablespace_privilege</function> проверяет, может ли "
"пользователь выполнять заданное действие в табличном пространстве. В "
"определении аргументов эта функция аналогична <function>has_table_privilege</"
"function>. Для неё допустимо только право <literal>CREATE</literal>."

#: func.xml:16050(para)
msgid ""
"<function>pg_has_role</function> checks whether a user can access a role in "
"a particular way. Its argument possibilities are analogous to "
"<function>has_table_privilege</function>, except that <literal>public</"
"literal> is not allowed as a user name. The desired access privilege type "
"must evaluate to some combination of <literal>MEMBER</literal> or "
"<literal>USAGE</literal>. <literal>MEMBER</literal> denotes direct or "
"indirect membership in the role (that is, the right to do <command>SET ROLE</"
"command>), while <literal>USAGE</literal> denotes whether the privileges of "
"the role are immediately available without doing <command>SET ROLE</command>."
msgstr ""
"<function>pg_has_role</function> проверяет, может ли пользователь выполнять "
"заданные действия с ролью. В определении аргументов эта функция аналогична "
"<function>has_table_privilege</function>, за исключением того, что именем "
"пользователя не может быть <literal>public</literal>. Для неё допустимые "
"права складываются из <literal>MEMBER</literal> и <literal>USAGE</literal>. "
"<literal>MEMBER</literal> обозначает прямое или косвенное членство в данной "
"роли (то есть наличие права выполнить команду <command>SET ROLE</command>), "
"тогда как <literal>USAGE</literal> показывает, что пользователь получает все "
"права роли сразу, без <command>SET ROLE</command>."

#: func.xml:16065(para)
msgid ""
"<function>row_security_active</function> checks whether row level security "
"is active for the specified table in the context of the "
"<function>current_user</function> and environment. The table can be "
"specified by name or by OID."
msgstr ""
"<function>row_security_active</function> проверяет, включена ли защита на "
"уровне строк для указанной таблицы в контексте и окружении текущего "
"пользователя (<function>current_user</function>). Таблицу можно задать по "
"имени или OID."

#: func.xml:16081(programlisting)
#, no-wrap
msgid "SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);"
msgstr "SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);"

#: func.xml:16072(para)
msgid ""
"<xref linkend=\"functions-info-schema-table\"/> shows functions that "
"determine whether a certain object is <firstterm>visible</firstterm> in the "
"current schema search path. For example, a table is said to be visible if "
"its containing schema is in the search path and no table of the same name "
"appears earlier in the search path. This is equivalent to the statement that "
"the table can be referenced by name without explicit schema qualification. "
"To list the names of all visible tables: <placeholder-1/>"
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-schema-table\"/> перечислены "
"функции, определяющие <firstterm>видимость</firstterm> объекта с текущим "
"путём поиска схем. К примеру, таблица считается видимой, если содержащая её "
"схема включена в путь поиска и нет другой таблицы с тем же именем, которая "
"была бы найдена по пути поиска раньше. Другими словами, к этой таблице можно "
"будет обратиться просто по её имени, без явного указания схемы. Просмотреть "
"список всех видимых таблиц можно так: <placeholder-1/>"

#: func.xml:16086(indexterm)
msgid "<primary>search path</primary> <secondary>object visibility</secondary>"
msgstr ""
"<primary>путь поиска</primary> <secondary>видимость объектов</secondary>"

#: func.xml:16092(title)
msgid "Schema Visibility Inquiry Functions"
msgstr "Функции для определения видимости"

#: func.xml:16100(parameter)
msgid "collation_oid"
msgstr "collation_oid"

#: func.xml:16100(function)
msgid "pg_collation_is_visible(<placeholder-1/>)"
msgstr "pg_collation_is_visible(<placeholder-1/>)"

#: func.xml:16103(entry)
msgid "is collation visible in search path"
msgstr "видимо ли правило сортировки"

#: func.xml:16106(parameter)
msgid "conversion_oid"
msgstr "conversion_oid"

#: func.xml:16106(function)
msgid "pg_conversion_is_visible(<placeholder-1/>)"
msgstr "pg_conversion_is_visible(<placeholder-1/>)"

#: func.xml:16109(entry)
msgid "is conversion visible in search path"
msgstr "видимо ли преобразование"

#: func.xml:16112(parameter)
msgid "function_oid"
msgstr "function_oid"

#: func.xml:16112(function)
msgid "pg_function_is_visible(<placeholder-1/>)"
msgstr "pg_function_is_visible(<placeholder-1/>)"

#: func.xml:16115(entry)
msgid "is function visible in search path"
msgstr "видима ли функция"

#: func.xml:16118(parameter) func.xml:16130(parameter)
msgid "opclass_oid"
msgstr "opclass_oid"

#: func.xml:16118(function)
msgid "pg_opclass_is_visible(<placeholder-1/>)"
msgstr "pg_opclass_is_visible(<placeholder-1/>)"

#: func.xml:16121(entry)
msgid "is operator class visible in search path"
msgstr "видим ли класс операторов"

#: func.xml:16124(parameter)
msgid "operator_oid"
msgstr "operator_oid"

#: func.xml:16124(function)
msgid "pg_operator_is_visible(<placeholder-1/>)"
msgstr "pg_operator_is_visible(<placeholder-1/>)"

#: func.xml:16127(entry)
msgid "is operator visible in search path"
msgstr "видим ли оператор"

#: func.xml:16130(function)
msgid "pg_opfamily_is_visible(<placeholder-1/>)"
msgstr "pg_opfamily_is_visible(<placeholder-1/>)"

#: func.xml:16133(entry)
msgid "is operator family visible in search path"
msgstr "видимо ли семейство операторов"

#: func.xml:16136(parameter) func.xml:16841(parameter)
msgid "table_oid"
msgstr "table_oid"

#: func.xml:16136(function)
msgid "pg_table_is_visible(<placeholder-1/>)"
msgstr "pg_table_is_visible(<placeholder-1/>)"

#: func.xml:16139(entry)
msgid "is table visible in search path"
msgstr "видима ли таблица"

#: func.xml:16142(parameter)
msgid "config_oid"
msgstr "config_oid"

#: func.xml:16142(function)
msgid "pg_ts_config_is_visible(<placeholder-1/>)"
msgstr "pg_ts_config_is_visible(<placeholder-1/>)"

#: func.xml:16145(entry)
msgid "is text search configuration visible in search path"
msgstr "видима ли конфигурация текстового поиска"

#: func.xml:16148(parameter)
msgid "dict_oid"
msgstr "dict_oid"

#: func.xml:16148(function)
msgid "pg_ts_dict_is_visible(<placeholder-1/>)"
msgstr "pg_ts_dict_is_visible(<placeholder-1/>)"

#: func.xml:16151(entry)
msgid "is text search dictionary visible in search path"
msgstr "видим ли словарь текстового поиска"

#: func.xml:16154(parameter)
msgctxt "parameter"
msgid "parser_oid"
msgstr "parser_oid"

#: func.xml:16154(function)
msgid "pg_ts_parser_is_visible(<placeholder-1/>)"
msgstr "pg_ts_parser_is_visible(<placeholder-1/>)"

#: func.xml:16157(entry)
msgid "is text search parser visible in search path"
msgstr "видим ли анализатор текстового поиска"

#: func.xml:16160(parameter)
msgid "template_oid"
msgstr "template_oid"

#: func.xml:16160(function)
msgid "pg_ts_template_is_visible(<placeholder-1/>)"
msgstr "pg_ts_template_is_visible(<placeholder-1/>)"

#: func.xml:16163(entry)
msgid "is text search template visible in search path"
msgstr "видим ли шаблон текстового поиска"

#: func.xml:16166(parameter) func.xml:16359(parameter)
msgid "type_oid"
msgstr "type_oid"

#: func.xml:16166(function)
msgid "pg_type_is_visible(<placeholder-1/>)"
msgstr "pg_type_is_visible(<placeholder-1/>)"

#: func.xml:16169(entry)
msgid "is type (or domain) visible in search path"
msgstr "видим ли тип (или домен)"

#: func.xml:16175(indexterm)
msgid "<primary>pg_collation_is_visible</primary>"
msgstr "<primary>pg_collation_is_visible</primary>"

#: func.xml:16178(indexterm)
msgid "<primary>pg_conversion_is_visible</primary>"
msgstr "<primary>pg_conversion_is_visible</primary>"

#: func.xml:16181(indexterm)
msgid "<primary>pg_function_is_visible</primary>"
msgstr "<primary>pg_function_is_visible</primary>"

#: func.xml:16184(indexterm)
msgid "<primary>pg_opclass_is_visible</primary>"
msgstr "<primary>pg_opclass_is_visible</primary>"

#: func.xml:16187(indexterm)
msgid "<primary>pg_operator_is_visible</primary>"
msgstr "<primary>pg_operator_is_visible</primary>"

#: func.xml:16190(indexterm)
msgid "<primary>pg_opfamily_is_visible</primary>"
msgstr "<primary>pg_opfamily_is_visible</primary>"

#: func.xml:16193(indexterm)
msgid "<primary>pg_table_is_visible</primary>"
msgstr "<primary>pg_table_is_visible</primary>"

#: func.xml:16196(indexterm)
msgid "<primary>pg_ts_config_is_visible</primary>"
msgstr "<primary>pg_ts_config_is_visible</primary>"

#: func.xml:16199(indexterm)
msgid "<primary>pg_ts_dict_is_visible</primary>"
msgstr "<primary>pg_ts_dict_is_visible</primary>"

#: func.xml:16202(indexterm)
msgid "<primary>pg_ts_parser_is_visible</primary>"
msgstr "<primary>pg_ts_parser_is_visible</primary>"

#: func.xml:16205(indexterm)
msgid "<primary>pg_ts_template_is_visible</primary>"
msgstr "<primary>pg_ts_template_is_visible</primary>"

#: func.xml:16208(indexterm)
msgid "<primary>pg_type_is_visible</primary>"
msgstr "<primary>pg_type_is_visible</primary>"

#: func.xml:16212(para)
msgid ""
"Each function performs the visibility check for one type of database object. "
"Note that <function>pg_table_is_visible</function> can also be used with "
"views, materialized views, indexes, sequences and foreign tables; "
"<function>pg_type_is_visible</function> can also be used with domains. For "
"functions and operators, an object in the search path is visible if there is "
"no object of the same name <emphasis>and argument data type(s)</emphasis> "
"earlier in the path. For operator classes, both name and associated index "
"access method are considered."
msgstr ""
"Каждая из этих функций проверяет видимость объектов определённого типа. "
"Заметьте, что <function>pg_table_is_visible</function> можно также "
"использовать для представлений, материализованных представлений, индексов, "
"последовательностей и сторонних таблиц; <function>pg_type_is_visible</"
"function> можно также использовать и для доменов. Для функций и операторов "
"объект считается видимым в пути поиска, если при просмотре пути не находится "
"предшествующий ему другой объект с тем же именем <emphasis>и типами "
"аргументов</emphasis>. Для классов операторов во внимание принимается и имя "
"оператора, и связанный с ним метод доступа к индексу."

#: func.xml:16230(programlisting)
#, no-wrap
msgid "SELECT pg_type_is_visible('myschema.widget'::regtype);"
msgstr "SELECT pg_type_is_visible('myschema.widget'::regtype);"

#: func.xml:16223(para)
msgid ""
"All these functions require object OIDs to identify the object to be "
"checked. If you want to test an object by name, it is convenient to use the "
"OID alias types (<type>regclass</type>, <type>regtype</type>, "
"<type>regprocedure</type>, <type>regoperator</type>, <type>regconfig</type>, "
"or <type>regdictionary</type>), for example: <placeholder-1/> Note that it "
"would not make much sense to test a non-schema-qualified type name in this "
"way &mdash; if the name can be recognized at all, it must be visible."
msgstr ""
"Всем этим функциям должен передаваться OID проверяемого объекта. Если вы "
"хотите проверить объект по имени, удобнее использовать типы-псевдонимы OID "
"(<type>regclass</type>, <type>regtype</type>, <type>regprocedure</type>, "
"<type>regoperator</type>, <type>regconfig</type> или <type>regdictionary</"
"type>), например: <placeholder-1/> Заметьте, что проверять таким способом "
"имена без указания схемы не имеет большого смысла &mdash; если имя удастся "
"распознать, значит и объект будет видимым."

#: func.xml:16237(indexterm)
msgid "<primary>format_type</primary>"
msgstr "<primary>format_type</primary>"

#: func.xml:16241(indexterm)
msgid "<primary>pg_get_constraintdef</primary>"
msgstr "<primary>pg_get_constraintdef</primary>"

#: func.xml:16245(indexterm)
msgid "<primary>pg_get_expr</primary>"
msgstr "<primary>pg_get_expr</primary>"

#: func.xml:16249(indexterm)
msgid "<primary>pg_get_functiondef</primary>"
msgstr "<primary>pg_get_functiondef</primary>"

#: func.xml:16253(indexterm)
msgid "<primary>pg_get_function_arguments</primary>"
msgstr "<primary>pg_get_function_arguments</primary>"

#: func.xml:16257(indexterm)
msgid "<primary>pg_get_function_identity_arguments</primary>"
msgstr "<primary>pg_get_function_identity_arguments</primary>"

#: func.xml:16261(indexterm)
msgid "<primary>pg_get_function_result</primary>"
msgstr "<primary>pg_get_function_result</primary>"

#: func.xml:16265(indexterm)
msgid "<primary>pg_get_indexdef</primary>"
msgstr "<primary>pg_get_indexdef</primary>"

#: func.xml:16269(indexterm)
msgid "<primary>pg_get_keywords</primary>"
msgstr "<primary>pg_get_keywords</primary>"

#: func.xml:16273(indexterm)
msgid "<primary>pg_get_ruledef</primary>"
msgstr "<primary>pg_get_ruledef</primary>"

#: func.xml:16277(indexterm)
msgid "<primary>pg_get_serial_sequence</primary>"
msgstr "<primary>pg_get_serial_sequence</primary>"

#: func.xml:16281(indexterm)
msgid "<primary>pg_get_triggerdef</primary>"
msgstr "<primary>pg_get_triggerdef</primary>"

#: func.xml:16285(indexterm)
msgid "<primary>pg_get_userbyid</primary>"
msgstr "<primary>pg_get_userbyid</primary>"

#: func.xml:16289(indexterm)
msgid "<primary>pg_get_viewdef</primary>"
msgstr "<primary>pg_get_viewdef</primary>"

#: func.xml:16293(indexterm)
msgid "<primary>pg_options_to_table</primary>"
msgstr "<primary>pg_options_to_table</primary>"

#: func.xml:16297(indexterm)
msgid "<primary>pg_tablespace_databases</primary>"
msgstr "<primary>pg_tablespace_databases</primary>"

#: func.xml:16301(indexterm)
msgid "<primary>pg_tablespace_location</primary>"
msgstr "<primary>pg_tablespace_location</primary>"

#: func.xml:16305(indexterm)
msgid "<primary>pg_typeof</primary>"
msgstr "<primary>pg_typeof</primary>"

#: func.xml:16309(indexterm)
msgid "<primary>collation for</primary>"
msgstr "<primary>collation for</primary>"

#: func.xml:16313(indexterm)
msgid "<primary>to_regclass</primary>"
msgstr "<primary>to_regclass</primary>"

#: func.xml:16317(indexterm)
msgid "<primary>to_regproc</primary>"
msgstr "<primary>to_regproc</primary>"

#: func.xml:16321(indexterm)
msgid "<primary>to_regprocedure</primary>"
msgstr "<primary>to_regprocedure</primary>"

#: func.xml:16325(indexterm)
msgid "<primary>to_regoper</primary>"
msgstr "<primary>to_regoper</primary>"

#: func.xml:16329(indexterm)
msgid "<primary>to_regoperator</primary>"
msgstr "<primary>to_regoperator</primary>"

#: func.xml:16333(indexterm)
msgid "<primary>to_regtype</primary>"
msgstr "<primary>to_regtype</primary>"

#: func.xml:16337(indexterm)
msgid "<primary>to_regnamespace</primary>"
msgstr "<primary>to_regnamespace</primary>"

#: func.xml:16341(indexterm)
msgid "<primary>to_regrole</primary>"
msgstr "<primary>to_regrole</primary>"

#: func.xml:16345(para)
msgid ""
"<xref linkend=\"functions-info-catalog-table\"/> lists functions that "
"extract information from the system catalogs."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-catalog-table\"/> перечислены "
"функции, извлекающие информацию из системных каталогов."

#: func.xml:16351(title)
msgid "System Catalog Information Functions"
msgstr "Функции для обращения к системным каталогам"

#: func.xml:16359(parameter)
msgid "typemod"
msgstr "typemod"

#: func.xml:16359(function)
msgid "format_type(<placeholder-1/>, <placeholder-2/>)"
msgstr "format_type(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16361(entry)
msgid "get SQL name of a data type"
msgstr "получает имя типа данных в формате SQL"

#: func.xml:16364(parameter) func.xml:16369(parameter)
msgid "constraint_oid"
msgstr "constraint_oid"

#: func.xml:16364(function)
msgid "pg_get_constraintdef(<placeholder-1/>)"
msgstr "pg_get_constraintdef(<placeholder-1/>)"

#: func.xml:16366(entry) func.xml:16371(entry)
msgid "get definition of a constraint"
msgstr "получает определение ограничения"

#: func.xml:16369(parameter) func.xml:16380(parameter)
#: func.xml:16411(parameter) func.xml:16428(parameter)
#: func.xml:16459(parameter) func.xml:16469(parameter)
msgid "pretty_bool"
msgstr "pretty_bool"

#: func.xml:16369(function)
msgid "pg_get_constraintdef(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_constraintdef(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16374(parameter) func.xml:16380(parameter)
msgid "pg_node_tree"
msgstr "pg_node_tree"

#: func.xml:16374(parameter) func.xml:16380(parameter)
msgid "relation_oid"
msgstr "relation_oid"

#: func.xml:16374(function)
msgid "pg_get_expr(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_expr(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16376(entry) func.xml:16382(entry)
msgid ""
"decompile internal form of an expression, assuming that any Vars in it refer "
"to the relation indicated by the second parameter"
msgstr ""
"декомпилирует внутреннюю форму выражения, в предположении, что все "
"переменные в нём ссылаются на таблицу или отношение, указанное вторым "
"параметром"

#: func.xml:16380(function)
msgid "pg_get_expr(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "pg_get_expr(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:16386(parameter) func.xml:16391(parameter)
#: func.xml:16396(parameter) func.xml:16401(parameter)
msgid "func_oid"
msgstr "func_oid"

#: func.xml:16386(function)
msgid "pg_get_functiondef(<placeholder-1/>)"
msgstr "pg_get_functiondef(<placeholder-1/>)"

#: func.xml:16388(entry)
msgid "get definition of a function"
msgstr "получает определение функции"

#: func.xml:16391(function)
msgid "pg_get_function_arguments(<placeholder-1/>)"
msgstr "pg_get_function_arguments(<placeholder-1/>)"

#: func.xml:16393(entry)
msgid "get argument list of function's definition (with default values)"
msgstr ""
"получает список аргументов из определения функции (со значениями по "
"умолчанию)"

#: func.xml:16396(function)
msgid "pg_get_function_identity_arguments(<placeholder-1/>)"
msgstr "pg_get_function_identity_arguments(<placeholder-1/>)"

#: func.xml:16398(entry)
msgid "get argument list to identify a function (without default values)"
msgstr ""
"получает список аргументов, идентифицирующий функцию (без значений по "
"умолчанию)"

#: func.xml:16401(function)
msgid "pg_get_function_result(<placeholder-1/>)"
msgstr "pg_get_function_result(<placeholder-1/>)"

#: func.xml:16403(entry)
msgid "get <literal>RETURNS</literal> clause for function"
msgstr "получает предложение <literal>RETURNS</literal> для функции"

#: func.xml:16406(parameter) func.xml:16411(parameter)
#: func.xml:18941(parameter)
msgid "index_oid"
msgstr "index_oid"

#: func.xml:16406(function)
msgid "pg_get_indexdef(<placeholder-1/>)"
msgstr "pg_get_indexdef(<placeholder-1/>)"

#: func.xml:16408(entry)
msgid "get <command>CREATE INDEX</command> command for index"
msgstr "получает команду <command>CREATE INDEX</command> для индекса"

#: func.xml:16411(parameter)
msgid "column_no"
msgstr "column_no"

#: func.xml:16411(function)
msgid "pg_get_indexdef(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "pg_get_indexdef(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:16413(entry)
msgid ""
"get <command>CREATE INDEX</command> command for index, or definition of just "
"one index column when <parameter>column_no</parameter> is not zero"
msgstr ""
"получает команду <command>CREATE INDEX</command> для индекса или определение "
"одного индексированного столбца, когда <parameter>column_no</parameter> не "
"равен 0"

#: func.xml:16418(function)
msgid "pg_get_keywords()"
msgstr "pg_get_keywords()"

#: func.xml:16420(entry)
msgid "get list of SQL keywords and their categories"
msgstr "получает список ключевых слов SQL по категориям"

#: func.xml:16423(parameter) func.xml:16428(parameter)
msgid "rule_oid"
msgstr "rule_oid"

#: func.xml:16423(function)
msgid "pg_get_ruledef(<placeholder-1/>)"
msgstr "pg_get_ruledef(<placeholder-1/>)"

#: func.xml:16425(entry) func.xml:16430(entry)
msgid "get <command>CREATE RULE</command> command for rule"
msgstr "получает команду <command>CREATE RULE</command> для правила"

#: func.xml:16428(function)
msgid "pg_get_ruledef(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_ruledef(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16433(parameter)
msgid "table_name"
msgstr "table_name"

#: func.xml:16433(parameter)
msgid "column_name"
msgstr "column_name"

#: func.xml:16433(function)
msgid "pg_get_serial_sequence(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_serial_sequence(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16435(entry)
msgid ""
"get name of the sequence that a <type>serial</type>, <type>smallserial</"
"type> or <type>bigserial</type> column uses"
msgstr ""
"получает имя последовательности, связанной со столбцом типа <type>serial</"
"type>, <type>smallserial</type> или <type>bigserial</type>"

#: func.xml:16439(entry)
msgid ""
"<function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)"
msgstr ""
"<function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>)"

#: func.xml:16441(entry) func.xml:16446(entry)
msgid ""
"get <command>CREATE [ CONSTRAINT ] TRIGGER</command> command for trigger"
msgstr ""
"получает команду <command>CREATE [ CONSTRAINT ] TRIGGER</command> для "
"триггера"

#: func.xml:16444(entry)
msgid ""
"<function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, "
"<parameter>pretty_bool</parameter>)"
msgstr ""
"<function>pg_get_triggerdef</function>(<parameter>trigger_oid</parameter>, "
"<parameter>pretty_bool</parameter>)"

#: func.xml:16449(parameter)
msgid "role_oid"
msgstr "role_oid"

#: func.xml:16449(function)
msgid "pg_get_userbyid(<placeholder-1/>)"
msgstr "pg_get_userbyid(<placeholder-1/>)"

#: func.xml:16451(entry)
msgid "get role name with given OID"
msgstr "получает имя роли по заданному OID"

#: func.xml:16454(parameter) func.xml:16459(parameter)
msgid "view_name"
msgstr "view_name"

#: func.xml:16454(function) func.xml:16464(function)
msgid "pg_get_viewdef(<placeholder-1/>)"
msgstr "pg_get_viewdef(<placeholder-1/>)"

#: func.xml:16456(entry) func.xml:16461(entry)
msgid ""
"get underlying <command>SELECT</command> command for view or materialized "
"view (<emphasis>deprecated</emphasis>)"
msgstr ""
"получает команду <command>SELECT</command>, определяющую представление или "
"материализованное представление (<emphasis>устаревшая</emphasis> функция)"

#: func.xml:16459(function) func.xml:16469(function) func.xml:16474(function)
msgid "pg_get_viewdef(<placeholder-1/>, <placeholder-2/>)"
msgstr "pg_get_viewdef(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16464(parameter) func.xml:16469(parameter)
#: func.xml:16474(parameter)
msgid "view_oid"
msgstr "view_oid"

#: func.xml:16466(entry) func.xml:16471(entry)
msgid ""
"get underlying <command>SELECT</command> command for view or materialized "
"view"
msgstr ""
"получает команду <command>SELECT</command>, определяющую представление или "
"материализованное представление"

#: func.xml:16474(parameter)
msgid "wrap_column_int"
msgstr "wrap_column_int"

#: func.xml:16476(entry)
msgid ""
"get underlying <command>SELECT</command> command for view or materialized "
"view; lines with fields are wrapped to specified number of columns, pretty-"
"printing is implied"
msgstr ""
"получает команду <command>SELECT</command>, определяющую представление или "
"материализованное представление; при необходимости разбивает строки с "
"полями, выходящие за wrap_int символов, подразумевая форматированный вывод"

#: func.xml:16481(parameter)
msgid "reloptions"
msgstr "reloptions"

#: func.xml:16481(function)
msgid "pg_options_to_table(<placeholder-1/>)"
msgstr "pg_options_to_table(<placeholder-1/>)"

#: func.xml:16483(entry)
msgid "get the set of storage option name/value pairs"
msgstr "получает набор параметров хранилища в виде имя/значение"

#: func.xml:16486(parameter) func.xml:16491(parameter)
msgid "tablespace_oid"
msgstr "tablespace_oid"

#: func.xml:16486(function)
msgid "pg_tablespace_databases(<placeholder-1/>)"
msgstr "pg_tablespace_databases(<placeholder-1/>)"

#: func.xml:16487(type)
msgid "setof oid"
msgstr "setof oid"

#: func.xml:16488(entry)
msgid "get the set of database OIDs that have objects in the tablespace"
msgstr ""
"получает или устанавливает OID баз данных, объекты которых содержатся в "
"заданном табличном пространстве"

#: func.xml:16491(function)
msgid "pg_tablespace_location(<placeholder-1/>)"
msgstr "pg_tablespace_location(<placeholder-1/>)"

#: func.xml:16493(entry)
msgid "get the path in the file system that this tablespace is located in"
msgstr ""
"получает путь в файловой системе к местоположению заданного табличного "
"пространства"

#: func.xml:16496(parameter) func.xml:16501(parameter)
msgctxt "parameter"
msgid "any"
msgstr "any"

#: func.xml:16496(function)
msgid "pg_typeof(<placeholder-1/>)"
msgstr "pg_typeof(<placeholder-1/>)"

#: func.xml:16497(type) func.xml:16532(type)
msgid "regtype"
msgstr "regtype"

#: func.xml:16498(entry)
msgid "get the data type of any value"
msgstr "получает тип данных любого значения"

#: func.xml:16501(function)
msgid "collation for (<placeholder-1/>)"
msgstr "collation for (<placeholder-1/>)"

#: func.xml:16503(entry)
msgid "get the collation of the argument"
msgstr "получает правило сортировки для аргумента"

#: func.xml:16506(parameter)
msgid "rel_name"
msgstr "rel_name"

#: func.xml:16506(function)
msgid "to_regclass(<placeholder-1/>)"
msgstr "to_regclass(<placeholder-1/>)"

#: func.xml:16508(entry)
msgid "get the OID of the named relation"
msgstr "получает OID указанного отношения"

#: func.xml:16511(parameter) func.xml:16516(parameter)
msgid "func_name"
msgstr "func_name"

#: func.xml:16511(function)
msgid "to_regproc(<placeholder-1/>)"
msgstr "to_regproc(<placeholder-1/>)"

#: func.xml:16512(type)
msgid "regproc"
msgstr "regproc"

#: func.xml:16513(entry) func.xml:16518(entry)
msgid "get the OID of the named function"
msgstr "получает OID указанной функции"

#: func.xml:16516(function)
msgid "to_regprocedure(<placeholder-1/>)"
msgstr "to_regprocedure(<placeholder-1/>)"

#: func.xml:16517(type)
msgid "regprocedure"
msgstr "regprocedure"

#: func.xml:16521(parameter) func.xml:16526(parameter)
msgid "operator_name"
msgstr "имя_оператора"

#: func.xml:16521(function)
msgid "to_regoper(<placeholder-1/>)"
msgstr "to_regoper(<placeholder-1/>)"

#: func.xml:16522(type)
msgid "regoper"
msgstr "regoper"

#: func.xml:16523(entry) func.xml:16528(entry)
msgid "get the OID of the named operator"
msgstr "получает OID указанного оператора"

#: func.xml:16526(function)
msgid "to_regoperator(<placeholder-1/>)"
msgstr "to_regoperator(<placeholder-1/>)"

#: func.xml:16527(type)
msgid "regoperator"
msgstr "regoperator"

#: func.xml:16531(parameter)
msgid "type_name"
msgstr "type_name"

#: func.xml:16531(function)
msgid "to_regtype(<placeholder-1/>)"
msgstr "to_regtype(<placeholder-1/>)"

#: func.xml:16533(entry)
msgid "get the OID of the named type"
msgstr "получает OID указанного типа"

#: func.xml:16536(parameter)
msgctxt "parameter"
msgid "schema_name"
msgstr "schema_name"

#: func.xml:16536(function)
msgid "to_regnamespace(<placeholder-1/>)"
msgstr "to_regnamespace(<placeholder-1/>)"

#: func.xml:16537(type)
msgid "regnamespace"
msgstr "relnamespace"

#: func.xml:16538(entry)
msgid "get the OID of the named schema"
msgstr "получает OID указанной схемы"

#: func.xml:16541(parameter)
msgid "role_name"
msgstr "role_name"

#: func.xml:16541(function)
msgid "to_regrole(<placeholder-1/>)"
msgstr "to_regrole(<placeholder-1/>)"

#: func.xml:16542(type)
msgid "regrole"
msgstr "role"

#: func.xml:16543(entry)
msgid "get the OID of the named role"
msgstr "получает OID указанной роли"

#: func.xml:16549(para)
msgid ""
"<function>format_type</function> returns the SQL name of a data type that is "
"identified by its type OID and possibly a type modifier. Pass NULL for the "
"type modifier if no specific modifier is known."
msgstr ""
"<function>format_type</function> возвращает в формате SQL имя типа данных, "
"определяемого по OID и, возможно, модификатору типа. Если модификатор "
"неизвестен, вместо него можно передать NULL."

#: func.xml:16555(para)
msgid ""
"<function>pg_get_keywords</function> returns a set of records describing the "
"SQL keywords recognized by the server. The <structfield>word</structfield> "
"column contains the keyword. The <structfield>catcode</structfield> column "
"contains a category code: <literal>U</literal> for unreserved, <literal>C</"
"literal> for column name, <literal>T</literal> for type or function name, or "
"<literal>R</literal> for reserved. The <structfield>catdesc</structfield> "
"column contains a possibly-localized string describing the category."
msgstr ""
"<function>pg_get_keywords</function> возвращает таблицу с ключевыми словами "
"SQL, которые воспринимает сервер. Столбец <structfield>word</structfield> "
"содержит ключевое слово, а <structfield>catcode</structfield> &mdash; код "
"категории: <literal>U</literal> &mdash; не зарезервировано, <literal>C</"
"literal> &mdash; имя столбца, <literal>T</literal> &mdash; имя типа или "
"функции, <literal>R</literal> &mdash; зарезервировано. Столбец "
"<structfield>catdesc</structfield> содержит возможно локализованное описание "
"категории."

#: func.xml:16565(para)
msgid ""
"<function>pg_get_constraintdef</function>, <function>pg_get_indexdef</"
"function>, <function>pg_get_ruledef</function>, and "
"<function>pg_get_triggerdef</function>, respectively reconstruct the "
"creating command for a constraint, index, rule, or trigger. (Note that this "
"is a decompiled reconstruction, not the original text of the command.) "
"<function>pg_get_expr</function> decompiles the internal form of an "
"individual expression, such as the default value for a column. It can be "
"useful when examining the contents of system catalogs. If the expression "
"might contain Vars, specify the OID of the relation they refer to as the "
"second parameter; if no Vars are expected, zero is sufficient. "
"<function>pg_get_viewdef</function> reconstructs the <command>SELECT</"
"command> query that defines a view. Most of these functions come in two "
"variants, one of which can optionally <quote>pretty-print</quote> the "
"result. The pretty-printed format is more readable, but the default format "
"is more likely to be interpreted the same way by future versions of "
"<productname>PostgreSQL</productname>; avoid using pretty-printed output for "
"dump purposes. Passing <literal>false</literal> for the pretty-print "
"parameter yields the same result as the variant that does not have the "
"parameter at all."
msgstr ""
"<function>pg_get_constraintdef</function>, <function>pg_get_indexdef</"
"function>, <function>pg_get_ruledef</function> и "
"<function>pg_get_triggerdef</function> восстанавливают команду, создававшую "
"заданное ограничение, индекс, правило или триггер, соответственно. (Учтите, "
"что они возвращают не изначальный текст команды, а результат декомпиляции.) "
"<function>pg_get_expr</function> декомпилирует внутреннюю форму отдельного "
"выражения, например значения по умолчанию для столбца. Это может быть "
"полезно для изучения содержимого системных каталогов. Если выражение может "
"содержать переменные, укажите во втором параметре OID отношения, на который "
"они ссылаются; если таких переменных нет, вместо OID можно передать 0. "
"<function>pg_get_viewdef</function> восстанавливает запрос <command>SELECT</"
"command>, определяющий представление. Многие из этих функций имеют две "
"версии, одна из которых позволяет получить форматированный вывод (параметр "
"pretty_bool). Форматированный текст легче читается, но нет гарантии, что он "
"будет всегда восприниматься одинаково будущими версиями "
"<productname>PostgreSQL</productname>, поэтому не следует применять "
"форматирование при выгрузке метаданных. Если параметр pretty_bool равен "
"<literal>false</literal>, эта версия функции выдаёт тот же результат, что и "
"версия без параметров."

#: func.xml:16586(para)
msgid ""
"<function>pg_get_functiondef</function> returns a complete <command>CREATE "
"OR REPLACE FUNCTION</command> statement for a function. "
"<function>pg_get_function_arguments</function> returns the argument list of "
"a function, in the form it would need to appear in within <command>CREATE "
"FUNCTION</command>. <function>pg_get_function_result</function> similarly "
"returns the appropriate <literal>RETURNS</literal> clause for the function. "
"<function>pg_get_function_identity_arguments</function> returns the argument "
"list necessary to identify a function, in the form it would need to appear "
"in within <command>ALTER FUNCTION</command>, for instance. This form omits "
"default values."
msgstr ""
"<function>pg_get_functiondef</function> возвращает полный оператор "
"<command>CREATE OR REPLACE FUNCTION</command> для заданной функции. "
"<function>pg_get_function_arguments</function> возвращает список аргументов "
"функции, в виде достаточном для включения в команду <command>CREATE "
"FUNCTION</command>. <function>pg_get_function_result</function> в дополнение "
"возвращает готовое предложение <literal>RETURNS</literal> для функции. "
"<function>pg_get_function_identity_arguments</function> возвращает список "
"аргументов, достаточный для однозначной идентификации функции, в форме, "
"допустимой, например для команды <command>ALTER FUNCTION</command>. Значения "
"по умолчанию в этой форме опускаются."

#: func.xml:16600(para)
msgid ""
"<function>pg_get_serial_sequence</function> returns the name of the sequence "
"associated with a column, or NULL if no sequence is associated with the "
"column. The first input parameter is a table name with optional schema, and "
"the second parameter is a column name. Because the first parameter is "
"potentially a schema and table, it is not treated as a double-quoted "
"identifier, meaning it is lower cased by default, while the second "
"parameter, being just a column name, is treated as double-quoted and has its "
"case preserved. The function returns a value suitably formatted for passing "
"to sequence functions (see <xref linkend=\"functions-sequence\"/>). This "
"association can be modified or removed with <command>ALTER SEQUENCE OWNED "
"BY</command>. (The function probably should have been called "
"<function>pg_get_owned_sequence</function>; its current name reflects the "
"fact that it's typically used with <type>serial</type> or <type>bigserial</"
"type> columns.)"
msgstr ""
"<function>pg_get_serial_sequence</function> возвращает имя "
"последовательности, связанной со столбцом, и NULL, если такой "
"последовательности нет. В первом параметре функции указывается имя таблицы, "
"возможно дополненное схемой, а во втором имя столбца. Так как первый "
"параметр может содержать имя схемы и таблицы, он воспринимается не как "
"идентификатор в кавычках и поэтому по умолчанию приводится к нижнему "
"регистру, тогда как имя столбца воспринимается как заключённое в кавычки и в "
"нём регистр символов сохраняется. Это функция возвращает имя в виде, "
"пригодном для передачи функциям, работающим с последовательностями (см. "
"<xref remap=\"4\" linkend=\"functions-sequence\"/>). Связь "
"последовательности со столбцом можно изменить или удалить с помощью команды "
"<command>ALTER SEQUENCE OWNED BY</command>. (Данную функцию можно было бы "
"назвать <function>pg_get_owned_sequence</function>; настоящее её имя "
"отражает то, что она обычно используется со столбцами <type>serial</type> и "
"<type>bigserial</type>.)"

#: func.xml:16618(para)
msgid ""
"<function>pg_get_userbyid</function> extracts a role's name given its OID."
msgstr "<function>pg_get_userbyid</function> получает имя роли по её OID."

#: func.xml:16623(para)
msgid ""
"<function>pg_options_to_table</function> returns the set of storage option "
"name/value pairs (<literal>option_name</literal>/<literal>option_value</"
"literal>) when passed <structname>pg_class</structname>."
"<structfield>reloptions</structfield> or <structname>pg_attribute</"
"structname>.<structfield>attoptions</structfield>."
msgstr ""
"<function>pg_options_to_table</function> возвращает набор параметров "
"хранилища в виде (<literal>имя_параметра</literal>/"
"<literal>значение_параметра</literal>), когда ей передаётся "
"<structname>pg_class</structname>.<structfield>reloptions</structfield> или "
"<structname>pg_attribute</structname>.<structfield>attoptions</structfield>."

#: func.xml:16631(para)
msgid ""
"<function>pg_tablespace_databases</function> allows a tablespace to be "
"examined. It returns the set of OIDs of databases that have objects stored "
"in the tablespace. If this function returns any rows, the tablespace is not "
"empty and cannot be dropped. To display the specific objects populating the "
"tablespace, you will need to connect to the databases identified by "
"<function>pg_tablespace_databases</function> and query their "
"<structname>pg_class</structname> catalogs."
msgstr ""
"<function>pg_tablespace_databases</function> позволяет изучить содержимое "
"табличного пространства. Она возвращает набор OID баз данных, объекты "
"которых размещены в этом табличном пространстве. Если эта функция возвращает "
"строки, это означает, что табличное пространство не пустое и удалить его "
"нельзя. Какие именно объекты находятся в табличном пространстве, можно "
"узнать, подключаясь к базам данных, OID которых сообщила "
"<function>pg_tablespace_databases</function>, и анализируя их каталоги "
"<structname>pg_class</structname>."

#: func.xml:16648(programlisting)
#, no-wrap
msgid ""
"SELECT pg_typeof(33);\n"
"\n"
" pg_typeof \n"
"-----------\n"
" integer\n"
"(1 row)\n"
"\n"
"SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);\n"
" typlen \n"
"--------\n"
"      4\n"
"(1 row)"
msgstr ""
"SELECT pg_typeof(33);\n"
"\n"
" pg_typeof \n"
"-----------\n"
" integer\n"
"(1 row)\n"
"\n"
"SELECT typlen FROM pg_type WHERE oid = pg_typeof(33);\n"
" typlen \n"
"--------\n"
"      4\n"
"(1 row)"

#: func.xml:16641(para)
msgid ""
"<function>pg_typeof</function> returns the OID of the data type of the value "
"that is passed to it. This can be helpful for troubleshooting or dynamically "
"constructing SQL queries. The function is declared as returning "
"<type>regtype</type>, which is an OID alias type (see <xref linkend="
"\"datatype-oid\"/>); this means that it is the same as an OID for comparison "
"purposes but displays as a type name. For example: <placeholder-1/>"
msgstr ""
"<function>pg_typeof</function> возвращает OID типа данных для переданного "
"значения. Это может быть полезно для разрешения проблем или динамического "
"создания SQL-запросов. Эта функция объявлена как возвращающая тип "
"<type>regtype</type>, который является псевдонимом типа OID (см. <xref remap="
"\"4\" linkend=\"datatype-oid\"/>); это означает, что значение этого типа "
"можно сравнивать как OID, но выводится оно как название типа. Например: "
"<placeholder-1/>"

#: func.xml:16667(programlisting)
#, no-wrap
msgid ""
"SELECT collation for (description) FROM pg_description LIMIT 1;\n"
" pg_collation_for \n"
"------------------\n"
" \"default\"\n"
"(1 row)\n"
"\n"
"SELECT collation for ('foo' COLLATE \"de_DE\");\n"
" pg_collation_for \n"
"------------------\n"
" \"de_DE\"\n"
"(1 row)"
msgstr ""
"SELECT collation for (description) FROM pg_description LIMIT 1;\n"
" pg_collation_for \n"
"------------------\n"
" \"default\"\n"
"(1 row)\n"
"\n"
"SELECT collation for ('foo' COLLATE \"de_DE\");\n"
" pg_collation_for \n"
"------------------\n"
" \"de_DE\"\n"
"(1 row)"

#: func.xml:16664(para)
msgid ""
"The expression <literal>collation for</literal> returns the collation of the "
"value that is passed to it. Example: <placeholder-1/> The value might be "
"quoted and schema-qualified. If no collation is derived for the argument "
"expression, then a null value is returned. If the argument is not of a "
"collatable data type, then an error is raised."
msgstr ""
"Выражение <literal>collation for</literal> возвращает правило сортировки для "
"переданного значения. Например: <placeholder-1/> Это значение может быть "
"заключено в кавычки и дополнено схемой. Если для выражения аргумента нет "
"правила сортировки, возвращается значение NULL. Если же правила сортировки "
"не применимы для типа аргумента, происходит ошибка."

#: func.xml:16685(para)
msgid ""
"The <function>to_regclass</function>, <function>to_regproc</function>, "
"<function>to_regprocedure</function>, <function>to_regoper</function>, "
"<function>to_regoperator</function>, <function>to_regtype</function>, "
"<function>to_regnamespace</function>, and <function>to_regrole</function> "
"functions translate relation, function, operator, type, schema, and role "
"names (given as <type>text</type>) to objects of type <type>regclass</type>, "
"<type>regproc</type>, <type>regprocedure</type>, <type>regoper</type>, "
"<type>regoperator</type>, <type>regtype</type>, <type>regnamespace</type>, "
"and <type>regrole</type> respectively. These functions differ from a cast "
"from text in that they don't accept a numeric OID, and that they return null "
"rather than throwing an error if the name is not found (or, for "
"<function>to_regproc</function> and <function>to_regoper</function>, if the "
"given name matches multiple objects)."
msgstr ""
"Функции <function>to_regclass</function>, <function>to_regproc</function>, "
"<function>to_regprocedure</function>, <function>to_regoper</function>, "
"<function>to_regoperator</function>, <function>to_regtype</function>, "
"<function>to_regnamespace</function> и <function>to_regrole</function> "
"преобразуют имена отношений, функций, операторов, типов, схем и ролей "
"(заданных значением <type>text</type>) в объекты типа <type>regclass</type>, "
"<type>regproc</type>, <type>regprocedure</type>, <type>regoper</type>, "
"<type>regoperator</type>, <type>regtype</type>, <type>regnamespace</type> и "
"<type>regrole</type>, соответственно. Перечисленные функции отличаются от "
"явных приведений к этим типам тем, что они не принимают числовые OID и "
"возвращают NULL вместо ошибки, если имя не найдено (или, в случае с "
"<function>to_regproc</function> и <function>to_regoper</function>, если "
"данному имени соответствуют несколько объектов)."

#: func.xml:16702(indexterm)
msgid "<primary>pg_describe_object</primary>"
msgstr "<primary>pg_describe_object</primary>"

#: func.xml:16706(indexterm)
msgid "<primary>pg_identify_object</primary>"
msgstr "<primary>pg_identify_object</primary>"

#: func.xml:16710(indexterm)
msgid "<primary>pg_identify_object_as_address</primary>"
msgstr "<primary>pg_identify_object_as_address</primary>"

#: func.xml:16714(indexterm)
msgid "<primary>pg_get_object_address</primary>"
msgstr "<primary>pg_get_object_address</primary>"

#: func.xml:16718(para)
msgid ""
"<xref linkend=\"functions-info-object-table\"/> lists functions related to "
"database object identification and addressing."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-info-object-table\"/> перечислены "
"функции, связанные с идентификацией и адресацией объектов баз данных."

#: func.xml:16724(title)
msgid "Object Information and Addressing Functions"
msgstr "Функции получения информации и адресации объектов"

#: func.xml:16732(parameter) func.xml:16737(parameter)
#: func.xml:16742(parameter)
msgid "catalog_id"
msgstr "catalog_id"

#: func.xml:16732(parameter) func.xml:16737(parameter)
#: func.xml:16742(parameter)
msgid "object_id"
msgstr "object_id"

#: func.xml:16732(parameter) func.xml:16737(parameter)
#: func.xml:16742(parameter)
msgid "object_sub_id"
msgstr "object_sub_id"

#: func.xml:16732(function)
msgid ""
"pg_describe_object(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr ""
"pg_describe_object(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:16734(entry)
msgid "get description of a database object"
msgstr "получает описание объекта базы данных"

#: func.xml:16737(function)
msgid ""
"pg_identify_object(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"pg_identify_object(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:16738(entry)
msgid ""
"<parameter>type</parameter> <type>text</type>, <parameter>schema</parameter> "
"<type>text</type>, <parameter>name</parameter> <type>text</type>, "
"<parameter>identity</parameter> <type>text</type>"
msgstr ""
"<parameter>type</parameter> <type>text</type>, <parameter>schema</parameter> "
"<type>text</type>, <parameter>name</parameter> <type>text</type>, "
"<parameter>identity</parameter> <type>text</type>"

#: func.xml:16739(entry)
msgid "get identity of a database object"
msgstr "получает идентификатор объекта базы данных"

#: func.xml:16742(function)
msgid ""
"pg_identify_object_as_address(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"pg_identify_object_as_address(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:16743(entry)
msgid ""
"<parameter>type</parameter> <type>text</type>, <parameter>name</parameter> "
"<type>text[]</type>, <parameter>args</parameter> <type>text[]</type>"
msgstr ""
"<parameter>type</parameter> <type>text</type>, <parameter>name</parameter> "
"<type>text[]</type>, <parameter>args</parameter> <type>text[]</type>"

#: func.xml:16744(entry)
msgid "get external representation of a database object's address"
msgstr "получает внешнее представление адреса объекта базы данных"

#: func.xml:16747(parameter)
msgid "type"
msgstr "type"

#: func.xml:16747(parameter) func.xml:17705(parameter)
msgctxt "parameter"
msgid "name"
msgstr "name"

#: func.xml:16747(parameter)
msgctxt "parameter"
msgid "args"
msgstr "аргументы"

#: func.xml:16747(function)
msgid ""
"pg_get_object_address(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"pg_get_object_address(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:16748(entry)
msgid ""
"<parameter>catalog_id</parameter> <type>oid</type>, <parameter>object_id</"
"parameter> <type>oid</type>, <parameter>object_sub_id</parameter> "
"<type>int32</type>"
msgstr ""
"<parameter>catalog_id</parameter> <type>oid</type>, <parameter>object_id</"
"parameter> <type>oid</type>, <parameter>object_sub_id</parameter> "
"<type>int32</type>"

#: func.xml:16749(entry)
msgid "get address of a database object, from its external representation"
msgstr "получает адрес объекта базы данных из его внешнего представления"

#: func.xml:16755(para)
msgid ""
"<function>pg_describe_object</function> returns a textual description of a "
"database object specified by catalog OID, object OID and a (possibly zero) "
"sub-object ID. This description is intended to be human-readable, and might "
"be translated, depending on server configuration. This is useful to "
"determine the identity of an object as stored in the <structname>pg_depend</"
"structname> catalog."
msgstr ""
"<function>pg_describe_object</function> возвращает текстовое описание "
"объекта БД, идентифицируемого по OID каталога, OID объекта и ID подобъекта "
"(может быть нулевым). Это описание предназначено для человека и может "
"переводиться, в зависимости от конфигурации сервера. С помощью этой функции, "
"например, можно узнать, что за объект хранится в каталоге "
"<structname>pg_depend</structname>."

#: func.xml:16764(para)
msgid ""
"<function>pg_identify_object</function> returns a row containing enough "
"information to uniquely identify the database object specified by catalog "
"OID, object OID and a (possibly zero) sub-object ID. This information is "
"intended to be machine-readable, and is never translated. <parameter>type</"
"parameter> identifies the type of database object; <parameter>schema</"
"parameter> is the schema name that the object belongs in, or <literal>NULL</"
"literal> for object types that do not belong to schemas; <parameter>name</"
"parameter> is the name of the object, quoted if necessary, only present if "
"it can be used (alongside schema name, if pertinent) as a unique identifier "
"of the object, otherwise <literal>NULL</literal>; <parameter>identity</"
"parameter> is the complete object identity, with the precise format "
"depending on object type, and each part within the format being schema-"
"qualified and quoted as necessary."
msgstr ""
"<function>pg_identify_object</function> возвращает запись, содержащую "
"достаточно информации для однозначной идентификации объекта БД по OID "
"каталога, OID объекта и ID подобъекта (может быть нулевым). Эта информация "
"предназначена для машины и поэтому никогда не переводится. Столбец "
"<parameter>type</parameter> содержит тип объекта БД; <parameter>schema</"
"parameter> &mdash; имя схемы, к которой относится объект (либо "
"<literal>NULL</literal> для объектов, не относящихся к схемам); "
"<parameter>name</parameter> &mdash; имя объекта, при необходимости в "
"кавычках, которое присутствует только если оно (возможно, вместе со схемой) "
"однозначно идентифицирует объект (в противном случае <literal>NULL</"
"literal>); <parameter>identity</parameter> &mdash; полный идентификатор "
"объекта, точный формат которого зависит от типа объекта, а каждая его часть "
"дополняется схемой и заключается в кавычки, если требуется."

#: func.xml:16780(para)
msgid ""
"<function>pg_identify_object_as_address</function> returns a row containing "
"enough information to uniquely identify the database object specified by "
"catalog OID, object OID and a (possibly zero) sub-object ID. The returned "
"information is independent of the current server, that is, it could be used "
"to identify an identically named object in another server. <parameter>type</"
"parameter> identifies the type of database object; <parameter>name</"
"parameter> and <parameter>args</parameter> are text arrays that together "
"form a reference to the object. These three columns can be passed to "
"<function>pg_get_object_address</function> to obtain the internal address of "
"the object. This function is the inverse of <function>pg_get_object_address</"
"function>."
msgstr ""
"<function>pg_identify_object_as_address</function> возвращает строку, "
"содержащую достаточно информации для однозначной идентификации объекта БД по "
"OID каталога, OID объекта и ID подобъекта (может быть нулевым). Выдаваемая "
"информация не зависит от текущего сервера, то есть по ней можно "
"идентифицировать одноимённый объект на другом сервере. Столбец "
"<parameter>type</parameter> содержит тип объекта БД, а <parameter>name</"
"parameter> и <parameter>args</parameter> — текстовые массивы, в совокупности "
"формирующие ссылку на объект. Эти три столбца можно передать функции "
"<function>pg_get_object_address</function>, чтобы получить внутренний адрес "
"объекта. Данная функция является обратной к <function>pg_get_object_address</"
"function>."

#: func.xml:16794(para)
msgid ""
"<function>pg_get_object_address</function> returns a row containing enough "
"information to uniquely identify the database object specified by its type "
"and object name and argument arrays. The returned values are the ones that "
"would be used in system catalogs such as <structname>pg_depend</structname> "
"and can be passed to other system functions such as "
"<function>pg_identify_object</function> or <function>pg_describe_object</"
"function>. <parameter>catalog_id</parameter> is the OID of the system "
"catalog containing the object; <parameter>object_id</parameter> is the OID "
"of the object itself, and <parameter>object_sub_id</parameter> is the object "
"sub-ID, or zero if none. This function is the inverse of "
"<function>pg_identify_object_as_address</function>."
msgstr ""
"<function>pg_get_object_address</function> возвращает запись, содержащую "
"достаточно информации для уникальной идентификации объекта БД по его типу и "
"массивам имён и аргументов. В ней возвращаются значения, которые "
"используются в системных каталогах, например <structname>pg_depend</"
"structname>, и могут передаваться в другие системные функции, например "
"<function>pg_identify_object</function> или <function>pg_describe_object</"
"function>. Столбец <parameter>catalog_id</parameter> содержит OID системного "
"каталога, к которому относится объект; <parameter>object_id</parameter> — "
"OID самого объекта, а <parameter>object_sub_id</parameter> — идентификатор "
"подобъекта, или 0 в случае его отсутствия. Эта функция является обратной к "
"<function>pg_identify_object_as_address</function>."

#: func.xml:16808(indexterm)
msgid "<primary>col_description</primary>"
msgstr "<primary>col_description</primary>"

#: func.xml:16812(indexterm)
msgid "<primary>obj_description</primary>"
msgstr "<primary>obj_description</primary>"

#: func.xml:16816(indexterm)
msgid "<primary>shobj_description</primary>"
msgstr "<primary>shobj_description</primary>"

#: func.xml:16820(indexterm)
msgid ""
"<primary>comment</primary> <secondary sortas=\"database objects\">about "
"database objects</secondary>"
msgstr ""
"<primary>комментарии</primary> <secondary sortas=\"database objects\">к "
"объектам баз данных</secondary>"

#: func.xml:16825(para)
msgid ""
"The functions shown in <xref linkend=\"functions-info-comment-table\"/> "
"extract comments previously stored with the <xref linkend=\"sql-comment\"/> "
"command. A null value is returned if no comment could be found for the "
"specified parameters."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-info-comment-"
"table\"/>, извлекают комментарии, заданные для объектов с помощью команды "
"<xref linkend=\"sql-comment\"/>. Если найти комментарий для заданных "
"параметров не удаётся, они возвращают NULL."

#: func.xml:16833(title)
msgid "Comment Information Functions"
msgstr "Функции получения комментариев"

#: func.xml:16841(parameter)
msgid "column_number"
msgstr "column_number"

#: func.xml:16841(function)
msgid "col_description(<placeholder-1/>, <placeholder-2/>)"
msgstr "col_description(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16843(entry)
msgid "get comment for a table column"
msgstr "получает комментарий для столбца таблицы"

#: func.xml:16846(parameter) func.xml:16851(parameter)
#: func.xml:16856(parameter)
msgid "object_oid"
msgstr "object_oid"

#: func.xml:16846(parameter) func.xml:16856(parameter)
msgid "catalog_name"
msgstr "catalog_name"

#: func.xml:16846(function)
msgid "obj_description(<placeholder-1/>, <placeholder-2/>)"
msgstr "obj_description(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16848(entry)
msgid "get comment for a database object"
msgstr "получает комментарий для объекта базы данных"

#: func.xml:16851(function)
msgid "obj_description(<placeholder-1/>)"
msgstr "obj_description(<placeholder-1/>)"

#: func.xml:16853(entry)
msgid "get comment for a database object (<emphasis>deprecated</emphasis>)"
msgstr ""
"получает комментарий для объекта базы данных (<emphasis>устаревшая</"
"emphasis> форма)"

#: func.xml:16856(function)
msgid "shobj_description(<placeholder-1/>, <placeholder-2/>)"
msgstr "shobj_description(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16858(entry)
msgid "get comment for a shared database object"
msgstr "получает комментарий для разделяемого объекта баз данных"

#: func.xml:16864(para)
msgid ""
"<function>col_description</function> returns the comment for a table column, "
"which is specified by the OID of its table and its column number. "
"(<function>obj_description</function> cannot be used for table columns since "
"columns do not have OIDs of their own.)"
msgstr ""
"<function>col_description</function> возвращает комментарий для столбца с "
"заданным номером в таблице с указанным OID. (<function>obj_description</"
"function> нельзя использовать для столбцов таблицы, так столбцы не имеют "
"собственных OID.)"

#: func.xml:16871(para)
msgid ""
"The two-parameter form of <function>obj_description</function> returns the "
"comment for a database object specified by its OID and the name of the "
"containing system catalog. For example, "
"<literal>obj_description(123456,'pg_class')</literal> would retrieve the "
"comment for the table with OID 123456. The one-parameter form of "
"<function>obj_description</function> requires only the object OID. It is "
"deprecated since there is no guarantee that OIDs are unique across different "
"system catalogs; therefore, the wrong comment might be returned."
msgstr ""
"Функция <function>obj_description</function> с двумя параметрами возвращает "
"комментарий для объекта, имеющего заданный OID и находящегося в указанном "
"системном каталоге. Например, <literal>obj_description(123456,'pg_class')</"
"literal> вернёт комментарий для таблицы с OID 123456. Форма "
"<function>obj_description</function> с одним параметром принимает только "
"OID. Она является устаревшей, так как значения OID могут повторяться в "
"разных системных каталогах, и поэтому она может возвращать комментарий для "
"другого объекта."

#: func.xml:16883(para)
msgid ""
"<function>shobj_description</function> is used just like "
"<function>obj_description</function> except it is used for retrieving "
"comments on shared objects. Some system catalogs are global to all databases "
"within each cluster, and the descriptions for objects in them are stored "
"globally as well."
msgstr ""
"<function>shobj_description</function> работает подобно "
"<function>obj_description</function>, но она получает комментарии для "
"разделяемых объектов. Некоторые системные каталоги являются глобальными для "
"всех баз данных в кластере и описания объектов в них также хранятся "
"глобально."

#: func.xml:16891(indexterm)
msgid "<primary>txid_current</primary>"
msgstr "<primary>txid_current</primary>"

#: func.xml:16895(indexterm)
msgid "<primary>txid_current_snapshot</primary>"
msgstr "<primary>txid_current_snapshot</primary>"

#: func.xml:16899(indexterm)
msgid "<primary>txid_snapshot_xip</primary>"
msgstr "<primary>txid_snapshot_xip</primary>"

#: func.xml:16903(indexterm)
msgid "<primary>txid_snapshot_xmax</primary>"
msgstr "<primary>txid_snapshot_xmax</primary>"

#: func.xml:16907(indexterm)
msgid "<primary>txid_snapshot_xmin</primary>"
msgstr "<primary>txid_snapshot_xmin</primary>"

#: func.xml:16911(indexterm)
msgid "<primary>txid_visible_in_snapshot</primary>"
msgstr "<primary>txid_visible_in_snapshot</primary>"

#: func.xml:16915(para)
msgid ""
"The functions shown in <xref linkend=\"functions-txid-snapshot\"/> provide "
"server transaction information in an exportable form. The main use of these "
"functions is to determine which transactions were committed between two "
"snapshots."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-txid-snapshot"
"\"/>, выдают информацию о транзакциях сервера в форме во внешнем "
"представлении. В основном эти функции используются, чтобы определить, какие "
"транзакции были зафиксированы между двумя снимками состояния."

#: func.xml:16923(title)
msgid "Transaction IDs and Snapshots"
msgstr "Идентификаторы транзакций и снимков состояния"

#: func.xml:16931(function)
msgid "txid_current()"
msgstr "txid_current()"

#: func.xml:16933(entry)
msgid ""
"get current transaction ID, assigning a new one if the current transaction "
"does not have one"
msgstr ""
"получает идентификатор текущей транзакции и присваивает новый, если текущая "
"транзакция его не имеет"

#: func.xml:16936(function)
msgid "txid_current_snapshot()"
msgstr "txid_current_snapshot()"

#: func.xml:16937(type)
msgctxt "type"
msgid "txid_snapshot"
msgstr "txid_snapshot"

#: func.xml:16938(entry)
msgid "get current snapshot"
msgstr "получает код текущего снимка"

#: func.xml:16941(parameter) func.xml:16946(parameter)
#: func.xml:16951(parameter) func.xml:16956(parameter)
msgctxt "parameter"
msgid "txid_snapshot"
msgstr "txid_snapshot"

#: func.xml:16941(function)
msgid "txid_snapshot_xip(<placeholder-1/>)"
msgstr "txid_snapshot_xip(<placeholder-1/>)"

#: func.xml:16942(type)
msgid "setof bigint"
msgstr "setof bigint"

#: func.xml:16943(entry)
msgid "get in-progress transaction IDs in snapshot"
msgstr "возвращает идентификаторы выполняющихся транзакций в снимке"

#: func.xml:16946(function)
msgid "txid_snapshot_xmax(<placeholder-1/>)"
msgstr "txid_snapshot_xmax(<placeholder-1/>)"

#: func.xml:16948(entry)
msgid "get <literal>xmax</literal> of snapshot"
msgstr "возвращает значение <literal>xmax</literal> для заданного снимка"

#: func.xml:16951(function)
msgid "txid_snapshot_xmin(<placeholder-1/>)"
msgstr "txid_snapshot_xmin(<placeholder-1/>)"

#: func.xml:16953(entry)
msgid "get <literal>xmin</literal> of snapshot"
msgstr "возвращает значение <literal>xmin</literal> для заданного снимка"

#: func.xml:16956(parameter)
msgctxt "parameter"
msgid "bigint"
msgstr "bigint"

#: func.xml:16956(function)
msgid "txid_visible_in_snapshot(<placeholder-1/>, <placeholder-2/>)"
msgstr "txid_visible_in_snapshot(<placeholder-1/>, <placeholder-2/>)"

#: func.xml:16958(entry)
msgid ""
"is transaction ID visible in snapshot? (do not use with subtransaction ids)"
msgstr ""
"видима ли транзакция с указанным идентификатором в данном снимке? (коды "
"подтранзакций не поддерживаются)"

#: func.xml:16964(para)
msgid ""
"The internal transaction ID type (<type>xid</type>) is 32 bits wide and "
"wraps around every 4 billion transactions. However, these functions export a "
"64-bit format that is extended with an <quote>epoch</quote> counter so it "
"will not wrap around during the life of an installation. The data type used "
"by these functions, <type>txid_snapshot</type>, stores information about "
"transaction ID visibility at a particular moment in time. Its components are "
"described in <xref linkend=\"functions-txid-snapshot-parts\"/>."
msgstr ""
"Внутренний тип идентификаторов транзакций (<type>xid</type>) имеет размер 32 "
"бита, поэтому они повторяются через 4 миллиарда транзакций. Однако эти "
"функции выдают 64-битные значения, дополненные счётчиком <quote>эпохи</"
"quote>, так что эти значения останутся уникальными на протяжении всей жизни "
"сервера. Используемый этими функциями тип данных <type>txid_snapshot</type> "
"сохраняет информацию о видимости транзакций в определённый момент времени. "
"Его состав описан в <xref remap=\"6\" linkend=\"functions-txid-snapshot-parts"
"\"/>."

#: func.xml:16976(title)
msgid "Snapshot Components"
msgstr "Состав информации о снимке"

#: func.xml:16988(type)
msgid "xmin"
msgstr "xmin"

#: func.xml:16989(entry)
msgid ""
"Earliest transaction ID (txid) that is still active. All earlier "
"transactions will either be committed and visible, or rolled back and dead."
msgstr ""
"Идентификатор самой ранней транзакции (txid) из активных. Все предыдущие "
"транзакции либо зафиксированы и видимы, либо отменены и мертвы."

#: func.xml:16997(type)
msgid "xmax"
msgstr "xmax"

#: func.xml:16998(entry)
msgid ""
"First as-yet-unassigned txid. All txids greater than or equal to this are "
"not yet started as of the time of the snapshot, and thus invisible."
msgstr ""
"Первый txid из ещё не назначенных. На момент снимка не было запущенных (а "
"значит и видимых) транзакций с идентификатором, большим или равным данному."

#: func.xml:17005(type)
msgid "xip_list"
msgstr "xip_list"

#: func.xml:17006(entry)
msgid ""
"Active txids at the time of the snapshot. The list includes only those "
"active txids between <literal>xmin</literal> and <literal>xmax</literal>; "
"there might be active txids higher than <literal>xmax</literal>. A txid that "
"is <literal>xmin &lt;= txid &lt; xmax</literal> and not in this list was "
"already completed at the time of the snapshot, and thus either visible or "
"dead according to its commit status. The list does not include txids of "
"subtransactions."
msgstr ""
"Список идентификаторов транзакций, активных в момент снимка. Он включает "
"только идентификаторы с номерами от <literal>xmin</literal> до "
"<literal>xmax</literal>; хотя уже могут быть транзакции с идентификаторами "
"больше <literal>xmax</literal>. Если в этом списке не оказывается "
"идентификатора транзакции <literal>xmin &lt;= txid &lt; xmax</literal>, это "
"означает, что она уже не выполнялась к моменту снимка и, таким образом, "
"видима или мертва, в зависимости от типа завершения. Идентификаторы "
"подтранзакций в этот список не включаются."

#: func.xml:17022(para)
msgid ""
"<type>txid_snapshot</type>'s textual representation is "
"<literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:"
"<replaceable>xip_list</replaceable></literal>. For example "
"<literal>10:20:10,14,15</literal> means <literal>xmin=10, xmax=20, "
"xip_list=10, 14, 15</literal>."
msgstr ""
"В текстовом виде <type>txid_snapshot</type> представляется как "
"<literal><replaceable>xmin</replaceable>:<replaceable>xmax</replaceable>:"
"<replaceable>xip_list</replaceable></literal>. Например, "
"<literal>10:20:10,14,15</literal> означает <literal>xmin=10, xmax=20, "
"xip_list=10, 14, 15</literal>."

#: func.xml:17029(para)
msgid ""
"The functions shown in <xref linkend=\"functions-commit-timestamp\"/> "
"provide information about transactions that have been already committed. "
"These functions mainly provide information about when the transactions were "
"committed. They only provide useful data when <xref linkend=\"guc-track-"
"commit-timestamp\"/> configuration option is enabled and only for "
"transactions that were committed after it was enabled."
msgstr ""
"Функции, показанные в <xref remap=\"6\" linkend=\"functions-commit-timestamp"
"\"/>, выдают информацию об уже зафиксированных транзакциях. Они возвращают "
"полезные данные, только когда включён параметр конфигурации <xref linkend="
"\"guc-track-commit-timestamp\"/> и только для транзакций, зафиксированных "
"после его включения."

#: func.xml:17039(title)
msgid "Committed transaction information"
msgstr "Информация о фиксации транзакций"

#: func.xml:17048(indexterm)
msgid "<primary>pg_xact_commit_timestamp</primary>"
msgstr "<primary>pg_xact_commit_timestamp</primary>"

#: func.xml:17049(parameter)
msgctxt "parameter"
msgid "xid"
msgstr "xid"

#: func.xml:17049(function)
msgid "pg_xact_commit_timestamp(<placeholder-1/>)"
msgstr "pg_xact_commit_timestamp(<placeholder-1/>)"

#: func.xml:17052(entry)
msgid "get commit timestamp of a transaction"
msgstr "выдаёт время фиксации транзакции"

#: func.xml:17057(indexterm)
msgid "<primary>pg_last_committed_xact</primary>"
msgstr "<primary>pg_last_committed_xact</primary>"

#: func.xml:17058(function)
msgid "pg_last_committed_xact()"
msgstr "pg_last_committed_xact()"

#: func.xml:17060(entry)
msgid ""
"<parameter>xid</parameter> <type>xid</type>, <parameter>timestamp</"
"parameter> <type>timestamp with time zone</type>"
msgstr ""
"<parameter>xid</parameter> <type>xid</type>, <parameter>timestamp</"
"parameter> <type>timestamp with time zone</type>"

#: func.xml:17061(entry)
msgid "get transaction ID and commit timestamp of latest committed transaction"
msgstr ""
"выдаёт идентификатор и время фиксации транзакции, зафиксированной последней"

#: func.xml:17067(para)
msgid ""
"The functions shown in <xref linkend=\"functions-controldata\"/> print "
"information initialized during <command>initdb</command>, such as the "
"catalog version. They also show information about write-ahead logging and "
"checkpoint processing. This information is cluster-wide, and not specific to "
"any one database. They provide most of the same information, from the same "
"source, as <xref linkend=\"app-pgcontroldata\"/>, although in a form better "
"suited to <acronym>SQL</acronym> functions."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-controldata\"/"
">, выводят свойства, установленные командой <command>initdb</command>, "
"например, версию каталога. Они также выводят сведения о работе журнала "
"упреждающей записи и контрольных точках. Эта информация относится ко всему "
"кластеру, а не к отдельной базе данных. Данные функции выдают практически "
"всю ту же информацию, и из того же источника, что и <xref linkend=\"app-"
"pgcontroldata\"/>, но в форме, более подходящей для функций <acronym>SQL</"
"acronym>."

#: func.xml:17079(title)
msgid "Control Data Functions"
msgstr "Функции управления данными"

#: func.xml:17088(indexterm)
msgid "<primary>pg_control_checkpoint</primary>"
msgstr "<primary>pg_control_checkpoint</primary>"

#: func.xml:17089(function)
msgid "pg_control_checkpoint()"
msgstr "pg_control_checkpoint()"

#: func.xml:17092(entry)
msgid "Returns information about current checkpoint state."
msgstr "Возвращает информацию о состоянии текущей контрольной точки."

#: func.xml:17099(indexterm)
msgid "<primary>pg_control_system</primary>"
msgstr "<primary>pg_control_system</primary>"

#: func.xml:17100(function)
msgid "pg_control_system()"
msgstr "pg_control_system()"

#: func.xml:17103(entry)
msgid "Returns information about current control file state."
msgstr "Возвращает информацию о текущем состоянии управляющего файла."

#: func.xml:17110(indexterm)
msgid "<primary>pg_control_init</primary>"
msgstr "<primary>pg_control_init</primary>"

#: func.xml:17111(function)
msgid "pg_control_init()"
msgstr "pg_control_init()"

#: func.xml:17114(entry)
msgid "Returns information about cluster initialization state."
msgstr "Возвращает информацию о состоянии инициализации кластера."

#: func.xml:17121(indexterm)
msgid "<primary>pg_control_recovery</primary>"
msgstr "<primary>pg_control_recovery</primary>"

#: func.xml:17122(function)
msgid "pg_control_recovery()"
msgstr "pg_control_recovery()"

#: func.xml:17125(entry)
msgid "Returns information about recovery state."
msgstr "Возвращает информацию о состоянии восстановления."

#: func.xml:17134(para)
msgid ""
"<function>pg_control_checkpoint</function> returns a record, shown in <xref "
"linkend=\"functions-pg-control-checkpoint\"/>"
msgstr ""
"Функция <function>pg_control_checkpoint</function> возвращает запись, "
"показанную в <xref remap=\"6\" linkend=\"functions-pg-control-checkpoint\"/>."

#: func.xml:17140(title)
msgid "<function>pg_control_checkpoint</function> Columns"
msgstr "Столбцы результата <function>pg_control_checkpoint</function>"

#: func.xml:17144(entry) func.xml:17260(entry) func.xml:17301(entry)
#: func.xml:17387(entry)
msgid "Column Name"
msgstr "Имя столбца"

#: func.xml:17145(entry) func.xml:17261(entry) func.xml:17302(entry)
#: func.xml:17388(entry)
msgid "Data Type"
msgstr "Тип данных"

#: func.xml:17152(literal)
msgid "checkpoint_location"
msgstr "checkpoint_location"

#: func.xml:17153(type) func.xml:17158(type) func.xml:17163(type)
#: func.xml:17396(type) func.xml:17406(type) func.xml:17411(type)
#: func.xml:17707(type) func.xml:17714(type) func.xml:17721(type)
#: func.xml:17728(type) func.xml:17735(type) func.xml:17742(type)
#: func.xml:17770(type) func.xml:17775(type) func.xml:17782(type)
#: func.xml:17789(type) func.xml:17958(type) func.xml:17972(type)
#: func.xml:18249(type) func.xml:18274(type) func.xml:18292(type)
#: func.xml:18309(type) func.xml:18428(type) func.xml:18443(type)
#: func.xml:18478(type) func.xml:18500(type) func.xml:18518(type)
#: func.xml:18537(type)
msgid "pg_lsn"
msgstr "pg_lsn"

#: func.xml:17157(literal)
msgid "prior_location"
msgstr "prior_location"

#: func.xml:17162(literal)
msgid "redo_location"
msgstr "redo_location"

#: func.xml:17167(literal)
msgid "redo_wal_file"
msgstr "redo_wal_file"

#: func.xml:17172(literal)
msgid "timeline_id"
msgstr "timeline_id"

#: func.xml:17177(literal)
msgid "prev_timeline_id"
msgstr "prev_timeline_id"

#: func.xml:17182(literal)
msgid "full_page_writes"
msgstr "full_page_writes"

#: func.xml:17187(literal)
msgid "next_xid"
msgstr "next_xid"

#: func.xml:17192(literal)
msgid "next_oid"
msgstr "next_oid"

#: func.xml:17197(literal)
msgid "next_multixact_id"
msgstr "next_multixact_id"

#: func.xml:17198(type) func.xml:17203(type) func.xml:17208(type)
#: func.xml:17218(type) func.xml:17223(type) func.xml:17233(type)
#: func.xml:17238(type)
msgctxt "type"
msgid "xid"
msgstr "xid"

#: func.xml:17202(literal)
msgid "next_multi_offset"
msgstr "next_multi_offset"

#: func.xml:17207(literal)
msgid "oldest_xid"
msgstr "oldest_xid"

#: func.xml:17212(literal)
msgid "oldest_xid_dbid"
msgstr "oldest_xid_dbid"

#: func.xml:17217(literal)
msgid "oldest_active_xid"
msgstr "oldest_active_xid"

#: func.xml:17222(literal)
msgid "oldest_multi_xid"
msgstr "oldest_multi_xid"

#: func.xml:17227(literal)
msgid "oldest_multi_dbid"
msgstr "oldest_multi_dbid"

#: func.xml:17232(literal)
msgid "oldest_commit_ts_xid"
msgstr "oldest_commit_ts_xid"

#: func.xml:17237(literal)
msgid "newest_commit_ts_xid"
msgstr "newest_commit_ts_xid"

#: func.xml:17242(literal)
msgid "checkpoint_time"
msgstr "checkpoint_time"

#: func.xml:17250(para)
msgid ""
"<function>pg_control_system</function> returns a record, shown in <xref "
"linkend=\"functions-pg-control-system\"/>"
msgstr ""
"Функция <function>pg_control_system</function> возвращает запись, показанную "
"в <xref remap=\"6\" linkend=\"functions-pg-control-system\"/>."

#: func.xml:17256(title)
msgid "<function>pg_control_system</function> Columns"
msgstr "Столбцы результата <function>pg_control_system</function>"

#: func.xml:17268(literal)
msgid "pg_control_version"
msgstr "pg_control_version"

#: func.xml:17273(literal)
msgid "catalog_version_no"
msgstr "catalog_version_no"

#: func.xml:17278(literal)
msgid "system_identifier"
msgstr "system_identifier"

#: func.xml:17283(literal)
msgid "pg_control_last_modified"
msgstr "pg_control_last_modified"

#: func.xml:17291(para)
msgid ""
"<function>pg_control_init</function> returns a record, shown in <xref "
"linkend=\"functions-pg-control-init\"/>"
msgstr ""
"Функция <function>pg_control_init</function> возвращает запись, показанную в "
"<xref remap=\"6\" linkend=\"functions-pg-control-init\"/>."

#: func.xml:17297(title)
msgid "<function>pg_control_init</function> Columns"
msgstr "Столбцы результата <function>pg_control_init</function>"

#: func.xml:17309(literal)
msgid "max_data_alignment"
msgstr "max_data_alignment"

#: func.xml:17314(literal)
msgid "database_block_size"
msgstr "database_block_size"

#: func.xml:17319(literal)
msgid "blocks_per_segment"
msgstr "blocks_per_segment"

#: func.xml:17324(literal)
msgid "wal_block_size"
msgstr "wal_block_size"

#: func.xml:17329(literal)
msgid "bytes_per_wal_segment"
msgstr "bytes_per_wal_segment"

#: func.xml:17334(literal)
msgid "max_identifier_length"
msgstr "max_identifier_length"

#: func.xml:17339(literal)
msgid "max_index_columns"
msgstr "max_index_columns"

#: func.xml:17344(literal)
msgid "max_toast_chunk_size"
msgstr "max_toast_chunk_size"

#: func.xml:17349(literal)
msgid "large_object_chunk_size"
msgstr "large_object_chunk_size"

#: func.xml:17354(literal)
msgid "bigint_timestamps"
msgstr "bigint_timestamps"

#: func.xml:17359(literal)
msgid "float4_pass_by_value"
msgstr "float4_pass_by_value"

#: func.xml:17364(literal)
msgid "float8_pass_by_value"
msgstr "float8_pass_by_value"

#: func.xml:17369(literal)
msgid "data_page_checksum_version"
msgstr "data_page_checksum_version"

#: func.xml:17377(para)
msgid ""
"<function>pg_control_recovery</function> returns a record, shown in <xref "
"linkend=\"functions-pg-control-recovery\"/>"
msgstr ""
"Функция <function>pg_control_recovery</function> возвращает запись, "
"показанную в <xref remap=\"6\" linkend=\"functions-pg-control-recovery\"/>"

#: func.xml:17383(title)
msgid "<function>pg_control_recovery</function> Columns"
msgstr "Столбцы результата <function>pg_control_recovery</function>"

#: func.xml:17395(literal)
msgid "min_recovery_end_location"
msgstr "min_recovery_end_location"

#: func.xml:17400(literal)
msgid "min_recovery_end_timeline"
msgstr "min_recovery_end_timeline"

#: func.xml:17405(literal)
msgid "backup_start_location"
msgstr "backup_start_location"

#: func.xml:17410(literal)
msgid "backup_end_location"
msgstr "backup_end_location"

#: func.xml:17415(literal)
msgid "end_of_backup_record_required"
msgstr "end_of_backup_record_required"

#: func.xml:17426(title)
msgid "System Administration Functions"
msgstr "Функции для системного администрирования"

#: func.xml:17428(para)
msgid ""
"The functions described in this section are used to control and monitor a "
"<productname>PostgreSQL</productname> installation."
msgstr ""
"Функции, описанные в этом разделе, предназначены для контроля и управления "
"сервером <productname>PostgreSQL</productname>."

#: func.xml:17434(title) func.xml:17442(title)
msgid "Configuration Settings Functions"
msgstr "Функции для управления конфигурацией"

#: func.xml:17436(para)
msgid ""
"<xref linkend=\"functions-admin-set-table\"/> shows the functions available "
"to query and alter run-time configuration parameters."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-admin-set-table\"/> показаны "
"функции, позволяющие получить и изменить значения параметров конфигурации "
"выполнения."

#: func.xml:17451(indexterm)
msgid "<primary>current_setting</primary>"
msgstr "<primary>current_setting</primary>"

#: func.xml:17454(parameter) func.xml:17464(parameter)
msgid "setting_name"
msgstr "setting_name"

#: func.xml:17454(parameter) func.xml:19004(parameter)
#: func.xml:19013(parameter) func.xml:19022(parameter)
#: func.xml:19031(parameter)
msgid "missing_ok"
msgstr "missing_ok"

#: func.xml:17454(function)
msgid "current_setting(<placeholder-1/> [, <placeholder-2/> ])"
msgstr "current_setting(<placeholder-1/> [, <placeholder-2/> ])"

#: func.xml:17457(entry)
msgid "get current value of setting"
msgstr "получает текущее значение параметра"

#: func.xml:17461(indexterm)
msgid "<primary>set_config</primary>"
msgstr "<primary>set_config</primary>"

#: func.xml:17465(parameter)
msgid "new_value"
msgstr "new_value"

#: func.xml:17466(parameter)
msgid "is_local"
msgstr "is_local"

#: func.xml:17464(function)
msgid "set_config(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"
msgstr "set_config(<placeholder-1/>, <placeholder-2/>, <placeholder-3/>)"

#: func.xml:17469(entry)
msgid "set parameter and return new value"
msgstr "устанавливает новое значение параметра и возвращает его"

#: func.xml:17475(indexterm)
msgid "<primary>SET</primary>"
msgstr "<primary>SET</primary>"

#: func.xml:17479(indexterm)
msgid "<primary>SHOW</primary>"
msgstr "<primary>SHOW</primary>"

#: func.xml:17483(indexterm)
msgid ""
"<primary>configuration</primary> <secondary sortas=\"server\">of the server</"
"secondary> <tertiary>functions</tertiary>"
msgstr ""
"<primary>конфигурация</primary> <secondary sortas=\"сервера\">сервера</"
"secondary> <tertiary>функции</tertiary>"

#: func.xml:17494(programlisting)
#, no-wrap
msgid ""
"SELECT current_setting('datestyle');\n"
"\n"
" current_setting\n"
"-----------------\n"
" ISO, MDY\n"
"(1 row)"
msgstr ""
"SELECT current_setting('datestyle');\n"
"\n"
" current_setting\n"
"-----------------\n"
" ISO, MDY\n"
"(1 row)"

#: func.xml:17489(para)
msgid ""
"The function <function>current_setting</function> yields the current value "
"of the setting <parameter>setting_name</parameter>. It corresponds to the "
"<acronym>SQL</acronym> command <command>SHOW</command>. An example: "
"<placeholder-1/> If there is no setting named <parameter>setting_name</"
"parameter>, <function>current_setting</function> throws an error unless "
"<parameter>missing_ok</parameter> is supplied and is <literal>true</literal>."
msgstr ""
"Функция <function>current_setting</function> выдаёт текущее значение "
"параметра <parameter>setting_name</parameter>. Она соответствует стандартной "
"<acronym>SQL</acronym>-команде <command>SHOW</command>. Пример "
"использования: <placeholder-1/> Если параметра с именем "
"<parameter>setting_name</parameter> нет, функция <function>current_setting</"
"function> выдаёт ошибку, если только дополнительно не передан параметр "
"<parameter>missing_ok</parameter> со значением <literal>true</literal>."

#: func.xml:17518(programlisting)
#, no-wrap
msgid ""
"SELECT set_config('log_statement_stats', 'off', false);\n"
"\n"
" set_config\n"
"------------\n"
" off\n"
"(1 row)"
msgstr ""
"SELECT set_config('log_statement_stats', 'off', false);\n"
"\n"
" set_config\n"
"------------\n"
" off\n"
"(1 row)"

#: func.xml:17509(para)
msgid ""
"<function>set_config</function> sets the parameter <parameter>setting_name</"
"parameter> to <parameter>new_value</parameter>. If <parameter>is_local</"
"parameter> is <literal>true</literal>, the new value will only apply to the "
"current transaction. If you want the new value to apply for the current "
"session, use <literal>false</literal> instead. The function corresponds to "
"the SQL command <command>SET</command>. An example: <placeholder-1/>"
msgstr ""
"<function>set_config</function> устанавливает для параметра "
"<parameter>setting_name</parameter> значение <parameter>new_value</"
"parameter>. Если параметр <parameter>is_local</parameter> равен "
"<literal>true</literal>, новое значение будет действовать только в рамках "
"текущей транзакции. Чтобы это значение действовало на протяжении текущего "
"сеанса, ему нужно присвоить <literal>false</literal>. Эта функция "
"соответствует SQL-команде <command>SET</command>. Пример использования: "
"<placeholder-1/>"

#: func.xml:17531(title) func.xml:17560(title)
msgid "Server Signaling Functions"
msgstr "Функции для передачи сигналов серверу"

#: func.xml:17533(indexterm)
msgid "<primary>pg_cancel_backend</primary>"
msgstr "<primary>pg_cancel_backend</primary>"

#: func.xml:17536(indexterm)
msgid "<primary>pg_reload_conf</primary>"
msgstr "<primary>pg_reload_conf</primary>"

#: func.xml:17539(indexterm)
msgid "<primary>pg_rotate_logfile</primary>"
msgstr "<primary>pg_rotate_logfile</primary>"

#: func.xml:17542(indexterm)
msgid "<primary>pg_terminate_backend</primary>"
msgstr "<primary>pg_terminate_backend</primary>"

#: func.xml:17546(indexterm)
msgid ""
"<primary>signal</primary> <secondary sortas=\"backend\">backend processes</"
"secondary>"
msgstr ""
"<primary>сигнал</primary> <secondary sortas=\"сервер\">серверные процессы</"
"secondary>"

#: func.xml:17551(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-signal-table\"/> send "
"control signals to other server processes. Use of these functions is "
"restricted to superusers by default but access may be granted to others with "
"the <command>GRANT</command>, with noted exceptions."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-signal-"
"table\"/>, позволяют передавать управляющие сигналы другим серверным "
"процессам. Вызывать эти функции по умолчанию разрешено только "
"суперпользователям, но доступ к ним можно дать и другим пользователям "
"командой <command>GRANT</command>, кроме явно отмеченных исключений."

#: func.xml:17570(parameter) func.xml:17595(parameter)
msgid "pid"
msgstr "pid"

#: func.xml:17570(function)
msgid "pg_cancel_backend(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_cancel_backend(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17573(entry)
msgid ""
"Cancel a backend's current query. This is also allowed if the calling role "
"is a member of the role whose backend is being canceled or the calling role "
"has been granted <literal>pg_signal_backend</literal>, however only "
"superusers can cancel superuser backends."
msgstr ""
"Отменяет текущий запрос в обслуживающем процессе. Это действие разрешается и "
"ролям, являющимся членами роли, обслуживающий процесс которой затрагивается, "
"и ролям, которым дано право <literal>pg_signal_backend</literal>; однако "
"только суперпользователям разрешено воздействовать на обслуживающие процессы "
"других суперпользователей."

#: func.xml:17581(function)
msgid "pg_reload_conf()"
msgstr "pg_reload_conf()"

#: func.xml:17584(entry)
msgid "Cause server processes to reload their configuration files"
msgstr "Даёт команду серверным процессам перегрузить конфигурацию"

#: func.xml:17588(function)
msgid "pg_rotate_logfile()"
msgstr "pg_rotate_logfile()"

#: func.xml:17591(entry)
msgid "Rotate server's log file"
msgstr "Прокручивает журнал сообщений сервера"

#: func.xml:17595(function)
msgid "pg_terminate_backend(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_terminate_backend(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17598(entry)
msgid ""
"Terminate a backend. This is also allowed if the calling role is a member of "
"the role whose backend is being terminated or the calling role has been "
"granted <literal>pg_signal_backend</literal>, however only superusers can "
"terminate superuser backends."
msgstr ""
"Завершает обслуживающий процесс. Это действие разрешается и ролям, "
"являющимся членами роли, обслуживающий процесс которой прерывается, и ролям, "
"которым дано право <literal>pg_signal_backend</literal>; однако только "
"суперпользователям разрешено прерывать обслуживающие процессы других "
"суперпользователей."

#: func.xml:17608(para)
msgid ""
"Each of these functions returns <literal>true</literal> if successful and "
"<literal>false</literal> otherwise."
msgstr ""
"Каждая из этих функций возвращает <literal>true</literal> при успешном "
"завершении и <literal>false</literal> в противном случае."

#: func.xml:17613(para)
msgid ""
"<function>pg_cancel_backend</function> and <function>pg_terminate_backend</"
"function> send signals (<systemitem>SIGINT</systemitem> or "
"<systemitem>SIGTERM</systemitem> respectively) to backend processes "
"identified by process ID. The process ID of an active backend can be found "
"from the <structfield>pid</structfield> column of the "
"<structname>pg_stat_activity</structname> view, or by listing the "
"<command>postgres</command> processes on the server (using <application>ps</"
"application> on Unix or the <application>Task Manager</application> on "
"<productname>Windows</productname>). The role of an active backend can be "
"found from the <structfield>usename</structfield> column of the "
"<structname>pg_stat_activity</structname> view."
msgstr ""
"<function>pg_cancel_backend</function> и <function>pg_terminate_backend</"
"function> передают сигналы (<systemitem>SIGINT</systemitem> и "
"<systemitem>SIGTERM</systemitem>, соответственно) серверному процессу с "
"заданным кодом PID. Код активного процесса можно получить из столбца "
"<structfield>pid</structfield> представления <structname>pg_stat_activity</"
"structname> или просмотрев на сервере процессы с именем <command>postgres</"
"command> (используя <application>ps</application> в Unix или "
"<application>Диспетчер задач</application> в <productname>Windows</"
"productname>). Роль пользователя активного процесса можно узнать в столбце "
"<structfield>usename</structfield> представления "
"<structname>pg_stat_activity</structname>."

#: func.xml:17628(para)
msgid ""
"<function>pg_reload_conf</function> sends a <systemitem>SIGHUP</systemitem> "
"signal to the server, causing configuration files to be reloaded by all "
"server processes."
msgstr ""
"<function>pg_reload_conf</function> отправляет сигнал <systemitem>SIGHUP</"
"systemitem> главному серверному процессу, который командует всем подчинённым "
"процессам перезагрузить файлы конфигурации."

#: func.xml:17634(para)
msgid ""
"<function>pg_rotate_logfile</function> signals the log-file manager to "
"switch to a new output file immediately. This works only when the built-in "
"log collector is running, since otherwise there is no log-file manager "
"subprocess."
msgstr ""
"<function>pg_rotate_logfile</function> указывает менеджеру журнала сообщений "
"немедленно переключиться на новый файл. Это имеет смысл, только когда "
"работает встроенный сборщик сообщений, так как без него подпроцесс менеджера "
"журнала не запускается."

#: func.xml:17644(title) func.xml:17695(title)
msgid "Backup Control Functions"
msgstr "Функции управления резервным копированием"

#: func.xml:17646(indexterm)
msgid "<primary>backup</primary>"
msgstr "<primary>резервная копия</primary>"

#: func.xml:17649(indexterm)
msgid "<primary>pg_create_restore_point</primary>"
msgstr "<primary>pg_create_restore_point</primary>"

#: func.xml:17652(indexterm)
msgid "<primary>pg_current_xlog_flush_location</primary>"
msgstr "<primary>pg_current_xlog_flush_location</primary>"

#: func.xml:17655(indexterm)
msgid "<primary>pg_current_xlog_insert_location</primary>"
msgstr "<primary>pg_current_xlog_insert_location</primary>"

#: func.xml:17658(indexterm)
msgid "<primary>pg_current_xlog_location</primary>"
msgstr "<primary>pg_current_xlog_location</primary>"

#: func.xml:17661(indexterm)
msgid "<primary>pg_start_backup</primary>"
msgstr "<primary>pg_start_backup</primary>"

#: func.xml:17664(indexterm)
msgid "<primary>pg_stop_backup</primary>"
msgstr "<primary>pg_stop_backup</primary>"

#: func.xml:17667(indexterm)
msgid "<primary>pg_is_in_backup</primary>"
msgstr "<primary>pg_is_in_backup</primary>"

#: func.xml:17670(indexterm)
msgid "<primary>pg_backup_start_time</primary>"
msgstr "<primary>pg_backup_start_time</primary>"

#: func.xml:17673(indexterm)
msgid "<primary>pg_switch_xlog</primary>"
msgstr "<primary>pg_switch_xlog</primary>"

#: func.xml:17676(indexterm)
msgid "<primary>pg_xlogfile_name</primary>"
msgstr "<primary>pg_xlogfile_name</primary>"

#: func.xml:17679(indexterm)
msgid "<primary>pg_xlogfile_name_offset</primary>"
msgstr "<primary>pg_xlogfile_name_offset</primary>"

#: func.xml:17682(indexterm)
msgid "<primary>pg_xlog_location_diff</primary>"
msgstr "<primary>pg_xlog_location_diff</primary>"

#: func.xml:17686(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-backup-table\"/> "
"assist in making on-line backups. These functions cannot be executed during "
"recovery (except <function>pg_is_in_backup</function>, "
"<function>pg_backup_start_time</function> and "
"<function>pg_xlog_location_diff</function>)."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-backup-"
"table\"/>, предназначены для выполнения резервного копирования &laquo;на "
"ходу&raquo;. Эти функции нельзя выполнять во время восстановления (за "
"исключением <function>pg_is_in_backup</function>, "
"<function>pg_backup_start_time</function> и <function>pg_xlog_location_diff</"
"function>)."

#: func.xml:17705(function)
msgid "pg_create_restore_point(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_create_restore_point(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17708(entry)
msgid ""
"Create a named point for performing restore (restricted to superusers by "
"default, but other users can be granted EXECUTE to run the function)"
msgstr ""
"Создаёт именованную точку для восстановления (по умолчанию разрешено только "
"суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим "
"пользователям)"

#: func.xml:17712(function)
msgid "pg_current_xlog_flush_location()"
msgstr "pg_current_xlog_flush_location()"

#: func.xml:17715(entry)
msgid "Get current transaction log flush location"
msgstr "Получает текущую позицию сброса данных в журнале транзакций"

#: func.xml:17719(function)
msgid "pg_current_xlog_insert_location()"
msgstr "pg_current_xlog_insert_location()"

#: func.xml:17722(entry)
msgid "Get current transaction log insert location"
msgstr "Получает текущую позицию добавления в журнале транзакций"

#: func.xml:17726(function)
msgid "pg_current_xlog_location()"
msgstr "pg_current_xlog_location()"

#: func.xml:17729(entry)
msgid "Get current transaction log write location"
msgstr "Получает текущую позицию записи в журнале транзакций"

#: func.xml:17733(parameter)
msgid "label"
msgstr "label"

#: func.xml:17733(parameter)
msgid "fast"
msgstr "fast"

#: func.xml:17733(parameter) func.xml:17747(parameter)
msgid "exclusive"
msgstr "exclusive"

#: func.xml:17733(optional)
msgid ", <placeholder-1/> <placeholder-2/> <placeholder-3/>"
msgstr ", <placeholder-1/> <placeholder-2/> <placeholder-3/>"

#: func.xml:17733(function)
msgid "pg_start_backup(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"
msgstr "pg_start_backup(<placeholder-1/> <placeholder-2/> <placeholder-3/>)"

#: func.xml:17736(entry)
msgid ""
"Prepare for performing on-line backup (restricted to superusers by default, "
"but other users can be granted EXECUTE to run the function)"
msgstr ""
"Подготавливает сервер к резервному копированию (по умолчанию разрешено "
"только суперпользователям, но право на её выполнение (EXECUTE) можно дать и "
"другим пользователям)"

#: func.xml:17740(function)
msgid "pg_stop_backup()"
msgstr "pg_stop_backup()"

#: func.xml:17743(entry)
msgid ""
"Finish performing exclusive on-line backup (restricted to superusers by "
"default, but other users can be granted EXECUTE to run the function)"
msgstr ""
"Завершает монопольное резервное копирование (по умолчанию разрешено только "
"суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим "
"пользователям)"

#: func.xml:17747(function)
msgid "pg_stop_backup(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_stop_backup(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17750(entry)
msgid ""
"Finish performing exclusive or non-exclusive on-line backup (restricted to "
"superusers by default, but other users can be granted EXECUTE to run the "
"function)"
msgstr ""
"Завершает монопольное или немонопольное резервное копирование (по умолчанию "
"разрешено только суперпользователям, но право на её выполнение (EXECUTE) "
"можно дать и другим пользователям)"

#: func.xml:17754(function)
msgid "pg_is_in_backup()"
msgstr "pg_is_in_backup()"

#: func.xml:17757(entry)
msgid "True if an on-line exclusive backup is still in progress."
msgstr "Возвращает true в процессе исключительного резервного копирования"

#: func.xml:17761(function)
msgid "pg_backup_start_time()"
msgstr "pg_backup_start_time()"

#: func.xml:17764(entry)
msgid "Get start time of an on-line exclusive backup in progress."
msgstr ""
"Получает время запуска выполняющегося исключительного резервного копирования"

#: func.xml:17768(function)
msgid "pg_switch_xlog()"
msgstr "pg_switch_xlog()"

#: func.xml:17771(entry)
msgid ""
"Force switch to a new transaction log file (restricted to superusers by "
"default, but other users can be granted EXECUTE to run the function)"
msgstr ""
"Инициирует переключение на новый файл журнала транзакций (по умолчанию "
"разрешено только суперпользователям, но право на её выполнение (EXECUTE) "
"можно дать и другим пользователям)"

#: func.xml:17775(parameter) func.xml:17782(parameter)
#: func.xml:17789(parameter)
msgid "location"
msgstr "location"

#: func.xml:17775(function)
msgid "pg_xlogfile_name(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_xlogfile_name(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17778(entry)
msgid "Convert transaction log location string to file name"
msgstr ""
"Получает из строки позиции в журнале транзакций имя соответствующего файла"

#: func.xml:17782(function)
msgid "pg_xlogfile_name_offset(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_xlogfile_name_offset(<placeholder-1/> <placeholder-2/>)"

#: func.xml:17784(entry)
msgid "<type>text</type>, <type>integer</type>"
msgstr "<type>text</type>, <type>integer</type>"

#: func.xml:17785(entry)
msgid ""
"Convert transaction log location string to file name and decimal byte offset "
"within file"
msgstr ""
"Получает из строки позиции в журнале транзакций имя соответствующего файла и "
"десятичное смещение в нём"

#: func.xml:17789(function)
msgid ""
"pg_xlog_location_diff(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_xlog_location_diff(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:17792(entry)
msgid "Calculate the difference between two transaction log locations"
msgstr "Вычисляет разницу между двумя позициями в журнале транзакций"

#: func.xml:17812(programlisting)
#, no-wrap
msgid ""
"postgres=# select pg_start_backup('label_goes_here');\n"
" pg_start_backup\n"
"-----------------\n"
" 0/D4445B8\n"
"(1 row)"
msgstr ""
"postgres=# select pg_start_backup('label_goes_here');\n"
" pg_start_backup\n"
"-----------------\n"
" 0/D4445B8\n"
"(1 row)"

#: func.xml:17798(para)
msgid ""
"<function>pg_start_backup</function> accepts an arbitrary user-defined label "
"for the backup. (Typically this would be the name under which the backup "
"dump file will be stored.) When used in exclusive mode, the function writes "
"a backup label file (<filename>backup_label</filename>) and, if there are "
"any links in the <filename>pg_tblspc/</filename> directory, a tablespace map "
"file (<filename>tablespace_map</filename>) into the database cluster's data "
"directory, performs a checkpoint, and then returns the backup's starting "
"transaction log location as text. The user can ignore this result value, but "
"it is provided in case it is useful. When used in non-exclusive mode, the "
"contents of these files are instead returned by the "
"<function>pg_stop_backup</function> function, and should be written to the "
"backup by the caller. <placeholder-1/> There is an optional second parameter "
"of type <type>boolean</type>. If <literal>true</literal>, it specifies "
"executing <function>pg_start_backup</function> as quickly as possible. This "
"forces an immediate checkpoint which will cause a spike in I/O operations, "
"slowing any concurrently executing queries."
msgstr ""
"<function>pg_start_backup</function> принимает произвольную заданную "
"пользователем метку резервной копии. (Обычно это имя файла, в котором будет "
"сохранена резервная копия.) При копировании в монопольном режиме эта функция "
"записывает файл метки (<filename>backup_label</filename>) и, если есть "
"ссылки в каталоге <filename>pg_tblspc/</filename>, файл карты табличных "
"пространств (<filename>tablespace_map</filename>) в каталог данных кластера "
"БД, выполняет процедуру контрольной точки, а затем возвращает в текстовом "
"виде начальную позицию в журнале транзакций для данной резервной копии. "
"Результат этой функции может быть полезен, но если он не нужен, его можно "
"просто игнорировать. При копировании в немонопольном режиме содержимое этих "
"файлов выдаётся функцией <function>pg_stop_backup</function> и должно быть "
"записано в архивную копию вызывающим субъектом. <placeholder-1/> У этой "
"функции есть также второй, необязательный параметр типа <type>boolean</"
"type>. Если он равен <literal>true</literal>, <function>pg_start_backup</"
"function> начнёт работу максимально быстро. При этом будет немедленно "
"выполнена процедура контрольной точки, что может повлечь массу операций "
"ввода/вывода и затормозить параллельные запросы."

#: func.xml:17825(para)
msgid ""
"In an exclusive backup, <function>pg_stop_backup</function> removes the "
"label file and, if it exists, the <filename>tablespace_map</filename> file "
"created by <function>pg_start_backup</function>. In a non-exclusive backup, "
"the contents of the <filename>backup_label</filename> and "
"<filename>tablespace_map</filename> are returned in the result of the "
"function, and should be written to files in the backup (and not in the data "
"directory)."
msgstr ""
"При монопольном копировании функция <function>pg_stop_backup</function> "
"удаляет файл метки (и, если существует, файл <filename>tablespace_map</"
"filename>), созданный функцией <function>pg_start_backup</function>. При "
"немонопольном копировании содержимое <filename>backup_label</filename> и "
"<filename>tablespace_map</filename> возвращается в результате функции, и "
"должно быть записано в файлы в архиве (а не в каталоге данных)."

#: func.xml:17834(para)
msgid ""
"The function also creates a backup history file in the transaction log "
"archive area. The history file includes the label given to "
"<function>pg_start_backup</function>, the starting and ending transaction "
"log locations for the backup, and the starting and ending times of the "
"backup. The return value is the backup's ending transaction log location "
"(which again can be ignored). After recording the ending location, the "
"current transaction log insertion point is automatically advanced to the "
"next transaction log file, so that the ending transaction log file can be "
"archived immediately to complete the backup."
msgstr ""
"Эта функция также создаёт файл истории резервного копирования в области "
"архива журнала транзакций. В этом файле для данной резервной копии "
"сохраняется метка, заданная при вызове <function>pg_start_backup</function>, "
"начальная и конечная позиция в журнале транзакций, а также время начала и "
"окончания. Возвращает данная функция позицию окончания резервной копии в "
"журнале транзакций (которую тоже можно игнорировать). После записи конечной "
"позиции текущая позиция записи автоматически перемещается к следующему файлу "
"журнала транзакций, чтобы файл конечной позиции можно было немедленно "
"архивировать для завершения резервного копирования."

#: func.xml:17846(para)
msgid ""
"<function>pg_switch_xlog</function> moves to the next transaction log file, "
"allowing the current file to be archived (assuming you are using continuous "
"archiving). The return value is the ending transaction log location + 1 "
"within the just-completed transaction log file. If there has been no "
"transaction log activity since the last transaction log switch, "
"<function>pg_switch_xlog</function> does nothing and returns the start "
"location of the transaction log file currently in use."
msgstr ""
"<function>pg_switch_xlog</function> производит переключение на следующий "
"файл журнала транзакций, что позволяет архивировать текущий (в ситуации, "
"когда архивация выполняется непрерывно). Эта функция возвращает конечную "
"позицию + 1 в только что законченном файле журнала транзакций. Если с "
"момента последнего переключения файлов не было активности, отражающейся в "
"журнале транзакций, <function>pg_switch_xlog</function> ничего не делает и "
"возвращает начальную позицию в файле журнала транзакций, используемом в "
"данный момент."

#: func.xml:17855(para)
msgid ""
"<function>pg_create_restore_point</function> creates a named transaction log "
"record that can be used as recovery target, and returns the corresponding "
"transaction log location. The given name can then be used with <xref linkend="
"\"recovery-target-name\"/> to specify the point up to which recovery will "
"proceed. Avoid creating multiple restore points with the same name, since "
"recovery will stop at the first one whose name matches the recovery target."
msgstr ""
"<function>pg_create_restore_point</function> создаёт именованную запись в "
"журнале транзакций, которую можно использовать как цель при восстановлении, "
"и возвращает соответствующую позицию в журнале транзакций. Затем полученное "
"имя можно присвоить параметру <xref linkend=\"recovery-target-name\"/>, "
"указав тем самым точку, до которой будет выполняться восстановление. Учтите, "
"что если вы создадите несколько точек восстановления с одним именем, "
"восстановление будет остановлено на первой точке с этим именем."

#: func.xml:17865(para)
msgid ""
"<function>pg_current_xlog_location</function> displays the current "
"transaction log write location in the same format used by the above "
"functions. Similarly, <function>pg_current_xlog_insert_location</function> "
"displays the current transaction log insertion point and "
"<function>pg_current_xlog_flush_location</function> displays the current "
"transaction log flush point. The insertion point is the <quote>logical</"
"quote> end of the transaction log at any instant, while the write location "
"is the end of what has actually been written out from the server's internal "
"buffers and flush location is the location guaranteed to be written to "
"durable storage. The write location is the end of what can be examined from "
"outside the server, and is usually what you want if you are interested in "
"archiving partially-complete transaction log files. The insertion and flush "
"points are made available primarily for server debugging purposes. These are "
"both read-only operations and do not require superuser permissions."
msgstr ""
"<function>pg_current_xlog_location</function> выводит текущую позицию записи "
"в журнале транзакций в том же формате, что и вышеописанные функции. "
"<function>pg_current_xlog_insert_location</function> подобным образом "
"выводит текущую позицию добавления, а "
"<function>pg_current_xlog_flush_location</function> — позицию сброса данных "
"журнала. Позицией добавления называется <quote>логический</quote> конец "
"журнала транзакций в любой момент времени, тогда как позиция записи "
"указывает на конец данных, фактически вынесённых из внутренних буферов "
"сервера, а позиция сброса показывает, до какого места данные гарантированно "
"сохранены в надёжном хранилище. Позиция записи отмечает конец данных, "
"которые может видеть снаружи внешний процесс, и именно она представляет "
"интерес при копировании частично заполненных файлов журнала транзакций. "
"Позиция добавления и позиция сброса выводятся в основном для отладки "
"серверной части. Все эти операции выполняются в режиме &laquo;только "
"чтение&raquo; и не требуют прав суперпользователя."

#: func.xml:17885(programlisting)
#, no-wrap
msgid ""
"postgres=# SELECT * FROM pg_xlogfile_name_offset(pg_stop_backup());\n"
"        file_name         | file_offset \n"
"--------------------------+-------------\n"
" 00000001000000000000000D |     4039624\n"
"(1 row)"
msgstr ""
"postgres=# SELECT * FROM pg_xlogfile_name_offset(pg_stop_backup());\n"
"        file_name         | file_offset \n"
"--------------------------+-------------\n"
" 00000001000000000000000D |     4039624\n"
"(1 row)"

#: func.xml:17881(para)
msgid ""
"You can use <function>pg_xlogfile_name_offset</function> to extract the "
"corresponding transaction log file name and byte offset from the results of "
"any of the above functions. For example: <placeholder-1/> Similarly, "
"<function>pg_xlogfile_name</function> extracts just the transaction log file "
"name. When the given transaction log location is exactly at a transaction "
"log file boundary, both these functions return the name of the preceding "
"transaction log file. This is usually the desired behavior for managing "
"transaction log archiving behavior, since the preceding file is the last one "
"that currently needs to be archived."
msgstr ""
"Из результатов всех описанных выше функций можно получить соответствующее "
"имя файла журнала транзакций и смещение в нём, используя функцию "
"<function>pg_xlogfile_name_offset</function>. Например: <placeholder-1/> "
"Подобная ей функция <function>pg_xlogfile_name</function> извлекает только "
"имя файла журнала транзакций. Когда позиция в журнале транзакций находится "
"ровно на границе файлов, обе эти функции возвращают имя предыдущего файла. "
"Обычно это поведение предпочтительно при архивировании журнала, так как "
"именно предыдущий файл является последним подлежащим архивации."

#: func.xml:17900(para)
msgid ""
"<function>pg_xlog_location_diff</function> calculates the difference in "
"bytes between two transaction log locations. It can be used with "
"<structname>pg_stat_replication</structname> or some functions shown in "
"<xref linkend=\"functions-admin-backup-table\"/> to get the replication lag."
msgstr ""
"<function>pg_xlog_location_diff</function> вычисляет разницу в байтах между "
"двумя позициями в журнале транзакций. Полученный результат можно "
"использовать с <structname>pg_stat_replication</structname> или другими "
"функциями, перечисленными в <xref remap=\"6\" linkend=\"functions-admin-"
"backup-table\"/>, для определения задержки репликации."

#: func.xml:17907(para)
msgid ""
"For details about proper usage of these functions, see <xref linkend="
"\"continuous-archiving\"/>."
msgstr ""
"Подробнее практическое применение этих функций описывается в <xref remap="
"\"6\" linkend=\"continuous-archiving\"/>."

#: func.xml:17915(title) func.xml:18018(title)
msgid "Recovery Control Functions"
msgstr "Функции управления восстановлением"

#: func.xml:17917(indexterm)
msgid "<primary>pg_is_in_recovery</primary>"
msgstr "<primary>pg_is_in_recovery</primary>"

#: func.xml:17920(indexterm)
msgid "<primary>pg_last_xlog_receive_location</primary>"
msgstr "<primary>pg_last_xlog_receive_location</primary>"

#: func.xml:17923(indexterm)
msgid "<primary>pg_last_xlog_replay_location</primary>"
msgstr "<primary>pg_last_xlog_replay_location</primary>"

#: func.xml:17926(indexterm)
msgid "<primary>pg_last_xact_replay_timestamp</primary>"
msgstr "<primary>pg_last_xact_replay_timestamp</primary>"

#: func.xml:17930(para)
msgid ""
"The functions shown in <xref linkend=\"functions-recovery-info-table\"/> "
"provide information about the current status of the standby. These functions "
"may be executed both during recovery and in normal running."
msgstr ""
"Функции, приведённые в <xref remap=\"6\" linkend=\"functions-recovery-info-"
"table\"/>, предоставляют сведения о текущем состоянии резервного сервера. "
"Эти функции могут выполняться, как во время восстановления, так и в обычном "
"режиме работы."

#: func.xml:17938(title)
msgid "Recovery Information Functions"
msgstr "Функции для получения информации о восстановлении"

#: func.xml:17948(function)
msgid "pg_is_in_recovery()"
msgstr "pg_is_in_recovery()"

#: func.xml:17951(entry)
msgid "True if recovery is still in progress."
msgstr "Возвращает true в процессе восстановления."

#: func.xml:17956(function)
msgid "pg_last_xlog_receive_location()"
msgstr "pg_last_xlog_receive_location()"

#: func.xml:17959(entry)
msgid ""
"Get last transaction log location received and synced to disk by streaming "
"replication. While streaming replication is in progress this will increase "
"monotonically. If recovery has completed this will remain static at the "
"value of the last WAL record received and synced to disk during recovery. If "
"streaming replication is disabled, or if it has not yet started, the "
"function returns NULL."
msgstr ""
"Получает позицию последней записи журнала транзакций, полученной и "
"записанной на диск в процессе потоковой репликации. Пока выполняется "
"потоковая репликация, эта позиция постоянно увеличивается. По окончании "
"восстановления она останавливается на записи WAL, полученной и записанной на "
"диск последней. Если потоковая репликация отключена или ещё не запускалась, "
"функция возвращает NULL."

#: func.xml:17970(function)
msgid "pg_last_xlog_replay_location()"
msgstr "pg_last_xlog_replay_location()"

#: func.xml:17973(entry)
msgid ""
"Get last transaction log location replayed during recovery. If recovery is "
"still in progress this will increase monotonically. If recovery has "
"completed then this value will remain static at the value of the last WAL "
"record applied during that recovery. When the server has been started "
"normally without recovery the function returns NULL."
msgstr ""
"Получает позицию последней записи журнала транзакций, воспроизведённой при "
"восстановлении. В процессе восстановления эта позиция постоянно "
"увеличивается. По окончании восстановления она останавливается на записи "
"WAL, которая была восстановлена последней. Если сервер был запущен не в "
"режиме восстановления, эта функция возвращает NULL."

#: func.xml:17983(function)
msgid "pg_last_xact_replay_timestamp()"
msgstr "pg_last_xact_replay_timestamp()"

#: func.xml:17986(entry)
msgid ""
"Get time stamp of last transaction replayed during recovery. This is the "
"time at which the commit or abort WAL record for that transaction was "
"generated on the primary. If no transactions have been replayed during "
"recovery, this function returns NULL. Otherwise, if recovery is still in "
"progress this will increase monotonically. If recovery has completed then "
"this value will remain static at the value of the last transaction applied "
"during that recovery. When the server has been started normally without "
"recovery the function returns NULL."
msgstr ""
"Получает отметку времени последней транзакции, воспроизведённой при "
"восстановлении. Это время, когда на главном сервере произошла фиксация или "
"откат записи WAL для этой транзакции. Если в процессе восстановления не была "
"воспроизведена ни одна транзакция, эта функция возвращает NULL. В противном "
"случае это значение постоянно увеличивается в процессе восстановления. По "
"окончании восстановления оно останавливается на транзакции, которая была "
"восстановлена последней. Если сервер был запущен не в режиме восстановления, "
"эта функция возвращает NULL."

#: func.xml:18001(indexterm)
msgid "<primary>pg_is_xlog_replay_paused</primary>"
msgstr "<primary>pg_is_xlog_replay_paused</primary>"

#: func.xml:18004(indexterm)
msgid "<primary>pg_xlog_replay_pause</primary>"
msgstr "<primary>pg_xlog_replay_pause</primary>"

#: func.xml:18007(indexterm)
msgid "<primary>pg_xlog_replay_resume</primary>"
msgstr "<primary>pg_xlog_replay_resume</primary>"

#: func.xml:18011(para)
msgid ""
"The functions shown in <xref linkend=\"functions-recovery-control-table\"/> "
"control the progress of recovery. These functions may be executed only "
"during recovery."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-recovery-"
"control-table\"/> управляют процессом восстановления. Вызывать их в другое "
"время нельзя."

#: func.xml:18028(function)
msgid "pg_is_xlog_replay_paused()"
msgstr "pg_is_xlog_replay_paused()"

#: func.xml:18031(entry)
msgid "True if recovery is paused."
msgstr "Возвращает true, если восстановление приостановлено."

#: func.xml:18036(function)
msgid "pg_xlog_replay_pause()"
msgstr "pg_xlog_replay_pause()"

#: func.xml:18039(entry)
msgid ""
"Pauses recovery immediately (restricted to superusers by default, but other "
"users can be granted EXECUTE to run the function)."
msgstr ""
"Немедленно приостанавливает восстановление (по умолчанию разрешено только "
"суперпользователям, но право на её выполнение (EXECUTE) можно дать и другим "
"пользователям)."

#: func.xml:18044(function)
msgid "pg_xlog_replay_resume()"
msgstr "pg_xlog_replay_resume()"

#: func.xml:18047(entry)
msgid ""
"Restarts recovery if it was paused (restricted to superusers by default, but "
"other users can be granted EXECUTE to run the function)."
msgstr ""
"Перезапускает восстановление, если оно было приостановлено (по умолчанию "
"разрешено только суперпользователям, но право на её выполнение (EXECUTE) "
"можно дать и другим пользователям)."

#: func.xml:18054(para)
msgid ""
"While recovery is paused no further database changes are applied. If in hot "
"standby, all new queries will see the same consistent snapshot of the "
"database, and no further query conflicts will be generated until recovery is "
"resumed."
msgstr ""
"Когда восстановление приостановлено, запись изменений в базу не "
"производится. Если она находится в &laquo;горячем резерве&raquo;, все "
"последующие запросы будут видеть один согласованный снимок базы данных и до "
"продолжения восстановления конфликты запросов исключаются."

#: func.xml:18061(para)
msgid ""
"If streaming replication is disabled, the paused state may continue "
"indefinitely without problem. While streaming replication is in progress WAL "
"records will continue to be received, which will eventually fill available "
"disk space, depending upon the duration of the pause, the rate of WAL "
"generation and available disk space."
msgstr ""
"Когда потоковая репликация выключена, пауза при восстановлении может длиться "
"сколь угодно долго без каких-либо проблем. Если же запущена потоковая "
"репликация, новые записи WAL продолжат поступать и заполнят весь диск рано "
"или поздно, в зависимости от длительности паузы, интенсивности записи в WAL "
"и объёма свободного пространства."

#: func.xml:18072(title) func.xml:18109(title)
msgid "Snapshot Synchronization Functions"
msgstr "Функции синхронизации снимков"

#: func.xml:18074(indexterm)
msgid "<primary>pg_export_snapshot</primary>"
msgstr "<primary>pg_export_snapshot</primary>"

#: func.xml:18078(para)
msgid ""
"<productname>PostgreSQL</productname> allows database sessions to "
"synchronize their snapshots. A <firstterm>snapshot</firstterm> determines "
"which data is visible to the transaction that is using the snapshot. "
"Synchronized snapshots are necessary when two or more sessions need to see "
"identical content in the database. If two sessions just start their "
"transactions independently, there is always a possibility that some third "
"transaction commits between the executions of the two <command>START "
"TRANSACTION</command> commands, so that one session sees the effects of that "
"transaction and the other does not."
msgstr ""
"<productname>PostgreSQL</productname> позволяет синхронизировать снимки "
"состояния между сеансами баз данных. <firstterm>Снимок состояния</firstterm> "
"определяет, какие данные видны транзакции, работающей с этим снимком. "
"Синхронизация снимков необходима, когда в двух или более сеансах нужно "
"видеть одно и то же содержимое базы данных. Если в двух сеансах транзакции "
"запускаются независимо, всегда есть вероятность, что некая третья транзакция "
"будет зафиксирована между командами <command>START TRANSACTION</command> для "
"первых двух, и в результате в одном сеансе будет виден результат третьей, а "
"в другом &mdash; нет."

#: func.xml:18090(para)
msgid ""
"To solve this problem, <productname>PostgreSQL</productname> allows a "
"transaction to <firstterm>export</firstterm> the snapshot it is using. As "
"long as the exporting transaction remains open, other transactions can "
"<firstterm>import</firstterm> its snapshot, and thereby be guaranteed that "
"they see exactly the same view of the database that the first transaction "
"sees. But note that any database changes made by any one of these "
"transactions remain invisible to the other transactions, as is usual for "
"changes made by uncommitted transactions. So the transactions are "
"synchronized with respect to pre-existing data, but act normally for changes "
"they make themselves."
msgstr ""
"Для решения этой проблемы <productname>PostgreSQL</productname> позволяет "
"транзакции <firstterm>экспортировать</firstterm> снимок состояния, с которым "
"она работает. Пока экспортирующая этот снимок транзакция выполняется, другие "
"транзакции могут <firstterm>импортировать</firstterm> его и, таким образом, "
"увидеть абсолютно то же состояние базы данных, что видит первая транзакция. "
"Но учтите, что любые изменения, произведённые этими транзакциями, будут не "
"видны для других, как это и должно быть с изменениями в незафиксированных "
"транзакциях. Таким образом, транзакции синхронизируют только начальное "
"состояние данных, а последующие производимые в них изменения изолируются как "
"обычно."

#: func.xml:18102(para)
msgid ""
"Snapshots are exported with the <function>pg_export_snapshot</function> "
"function, shown in <xref linkend=\"functions-snapshot-synchronization-table"
"\"/>, and imported with the <xref linkend=\"sql-set-transaction\"/> command."
msgstr ""
"Снимки состояния экспортируются с помощью функции "
"<function>pg_export_snapshot</function>, показанной в <xref remap=\"6\" "
"linkend=\"functions-snapshot-synchronization-table\"/>, и импортируются "
"командой <xref linkend=\"sql-set-transaction\"/>."

#: func.xml:18119(function)
msgid "pg_export_snapshot()"
msgstr "pg_export_snapshot()"

#: func.xml:18122(entry)
msgid "Save the current snapshot and return its identifier"
msgstr "Сохраняет снимок текущего состояния и возвращает его идентификатор"

#: func.xml:18128(para)
msgid ""
"The function <function>pg_export_snapshot</function> saves the current "
"snapshot and returns a <type>text</type> string identifying the snapshot. "
"This string must be passed (outside the database) to clients that want to "
"import the snapshot. The snapshot is available for import only until the end "
"of the transaction that exported it. A transaction can export more than one "
"snapshot, if needed. Note that doing so is only useful in <literal>READ "
"COMMITTED</literal> transactions, since in <literal>REPEATABLE READ</"
"literal> and higher isolation levels, transactions use the same snapshot "
"throughout their lifetime. Once a transaction has exported any snapshots, it "
"cannot be prepared with <xref linkend=\"sql-prepare-transaction\"/>."
msgstr ""
"Функция <function>pg_export_snapshot</function> создаёт снимок текущего "
"состояния и возвращает его идентификатор в строке типа <type>text</type>. "
"Данная строка должна передаваться (за рамками базы данных) клиентам, которые "
"будут импортировать этот снимок. При этом импортировать его нужно раньше, "
"чем завершится транзакция, которая его экспортировала. Если необходимо, "
"транзакция может экспортировать несколько снимков. Заметьте, что это имеет "
"смысл только для транзакций уровня <literal>READ COMMITTED</literal>, так "
"как транзакции <literal>REPEATABLE READ</literal> и более высоких уровней "
"изоляции работают с одним снимком состояния. После того, как транзакция "
"экспортировала снимок, её нельзя подготовить с помощью <xref linkend=\"sql-"
"prepare-transaction\"/>."

#: func.xml:18141(para)
msgid ""
"See <xref linkend=\"sql-set-transaction\"/> for details of how to use an "
"exported snapshot."
msgstr ""
"Подробнее использование экспортированных снимков рассматривается в описании "
"<xref linkend=\"sql-set-transaction\"/>."

#: func.xml:18148(title)
msgid "Replication Functions"
msgstr "Функции репликации"

#: func.xml:18150(para)
msgid ""
"The functions shown in <xref linkend=\"functions-replication-table\"/> are "
"for controlling and interacting with replication features. See <xref linkend="
"\"streaming-replication\"/>, <xref linkend=\"streaming-replication-slots\"/"
">, and <xref linkend=\"replication-origins\"/> for information about the "
"underlying features. Use of these functions is restricted to superusers."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-replication-table\"/> перечислены "
"функции, предназначенные для управления и взаимодействия с механизмом "
"репликации. Чтобы изучить этот механизм детальнее, обратитесь к <xref remap="
"\"3\" linkend=\"streaming-replication\"/>, <xref remap=\"3\" linkend="
"\"streaming-replication-slots\"/> и <xref remap=\"3\" linkend=\"replication-"
"origins\"/>. Использовать эти функции разрешено только суперпользователям."

#: func.xml:18161(para)
msgid ""
"Many of these functions have equivalent commands in the replication "
"protocol; see <xref linkend=\"protocol-replication\"/>."
msgstr ""
"Многие из этих функций соответствуют командам в протоколе репликации; см. "
"<xref remap=\"4\" linkend=\"protocol-replication\"/>."

#: func.xml:18166(para)
msgid ""
"The functions described in <xref linkend=\"functions-admin-backup\"/>, <xref "
"linkend=\"functions-recovery-control\"/>, and <xref linkend=\"functions-"
"snapshot-synchronization\"/> are also relevant for replication."
msgstr ""
"Функции, описанные в <xref remap=\"6\" linkend=\"functions-admin-backup\"/>, "
"<xref linkend=\"functions-recovery-control\"/> и <xref remap=\"6\" linkend="
"\"functions-snapshot-synchronization\"/> также имеют отношение к репликации."

#: func.xml:18175(title)
msgid "Replication <acronym>SQL</acronym> Functions"
msgstr "Функции репликации <acronym>SQL</acronym>"

#: func.xml:18187(indexterm)
msgid "<primary>pg_create_physical_replication_slot</primary>"
msgstr "<primary>pg_create_physical_replication_slot</primary>"

#: func.xml:18190(parameter) func.xml:18213(parameter)
#: func.xml:18230(parameter) func.xml:18249(parameter)
#: func.xml:18274(parameter) func.xml:18292(parameter)
#: func.xml:18309(parameter)
msgid "slot_name"
msgstr "slot_name"

#: func.xml:18190(parameter)
msgid "immediately_reserve"
msgstr "immediately_reserve"

#: func.xml:18190(function)
msgid ""
"pg_create_physical_replication_slot(<placeholder-1/> <placeholder-2/> "
"<placeholder-3/>)"
msgstr ""
"pg_create_physical_replication_slot(<placeholder-1/> <placeholder-2/> "
"<placeholder-3/>)"

#: func.xml:18192(entry) func.xml:18232(entry)
msgid ""
"(<parameter>slot_name</parameter> <type>name</type>, "
"<parameter>xlog_position</parameter> <type>pg_lsn</type>)"
msgstr ""
"(<parameter>slot_name</parameter> <type>name</type>, "
"<parameter>xlog_position</parameter> <type>pg_lsn</type>)"

#: func.xml:18195(entry)
msgid ""
"Creates a new physical replication slot named <parameter>slot_name</"
"parameter>. The optional second parameter, when <literal>true</literal>, "
"specifies that the <acronym>LSN</acronym> for this replication slot be "
"reserved immediately; otherwise the <acronym>LSN</acronym> is reserved on "
"first connection from a streaming replication client. Streaming changes from "
"a physical slot is only possible with the streaming-replication protocol "
"&mdash; see <xref linkend=\"protocol-replication\"/>. This function "
"corresponds to the replication protocol command "
"<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>."
msgstr ""
"Создаёт новый физический слот репликации с именем <parameter>slot_name</"
"parameter>. Необязательный второй параметр, когда он равен <literal>true</"
"literal>, указывает, что <acronym>LSN</acronym> для этого слота репликации "
"должен быть зарезервирован немедленно; в противном случае <acronym>LSN</"
"acronym> резервируется при первом подключении клиента потоковой репликации. "
"Передача изменений из физического слота возможна только по протоколу "
"потоковой репликации &mdash; см. <xref remap=\"4\" linkend=\"protocol-"
"replication\"/>. Эта функция соответствует команде протокола репликации "
"<literal>CREATE_REPLICATION_SLOT ... PHYSICAL</literal>."

#: func.xml:18210(indexterm)
msgid "<primary>pg_drop_replication_slot</primary>"
msgstr "<primary>pg_drop_replication_slot</primary>"

#: func.xml:18213(function)
msgid "pg_drop_replication_slot(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_drop_replication_slot(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18218(entry)
msgid ""
"Drops the physical or logical replication slot named <parameter>slot_name</"
"parameter>. Same as replication protocol command "
"<literal>DROP_REPLICATION_SLOT</literal>."
msgstr ""
"Удаляет физический или логический слот репликации с именем "
"<parameter>slot_name</parameter>. Соответствует команде протокола репликации "
"<literal>DROP_REPLICATION_SLOT</literal>."

#: func.xml:18227(indexterm)
msgid "<primary>pg_create_logical_replication_slot</primary>"
msgstr "<primary>pg_create_logical_replication_slot</primary>"

#: func.xml:18230(parameter)
msgid "plugin"
msgstr "plugin"

#: func.xml:18230(function)
msgid ""
"pg_create_logical_replication_slot(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_create_logical_replication_slot(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#: func.xml:18235(entry)
msgid ""
"Creates a new logical (decoding) replication slot named "
"<parameter>slot_name</parameter> using the output plugin <parameter>plugin</"
"parameter>. A call to this function has the same effect as the replication "
"protocol command <literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>."
msgstr ""
"Создаёт новый логический (декодирующий) слот репликации с именем "
"<parameter>slot_name</parameter>, используя модуль вывода <parameter>plugin</"
"parameter>. Эта функция работает так же, как и команда протокола репликации "
"<literal>CREATE_REPLICATION_SLOT ... LOGICAL</literal>."

#: func.xml:18246(indexterm)
msgid "<primary>pg_logical_slot_get_changes</primary>"
msgstr "<primary>pg_logical_slot_get_changes</primary>"

#: func.xml:18249(parameter) func.xml:18274(parameter)
#: func.xml:18292(parameter) func.xml:18309(parameter)
msgid "upto_lsn"
msgstr "upto_lsn"

#: func.xml:18249(parameter) func.xml:18274(parameter)
#: func.xml:18292(parameter) func.xml:18309(parameter)
msgid "upto_nchanges"
msgstr "upto_nchanges"

#: func.xml:18249(parameter) func.xml:18274(parameter)
#: func.xml:18292(parameter) func.xml:18309(parameter)
msgctxt "parameter"
msgid "options"
msgstr "options"

#: func.xml:18249(function)
msgid ""
"pg_logical_slot_get_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"
msgstr ""
"pg_logical_slot_get_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"

#: func.xml:18251(entry)
msgid ""
"(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)"
msgstr ""
"(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)"

#: func.xml:18254(entry)
msgid ""
"Returns changes in the slot <parameter>slot_name</parameter>, starting from "
"the point at which since changes have been consumed last. If "
"<parameter>upto_lsn</parameter> and <parameter>upto_nchanges</parameter> are "
"NULL, logical decoding will continue until end of WAL. If "
"<parameter>upto_lsn</parameter> is non-NULL, decoding will include only "
"those transactions which commit prior to the specified LSN. If "
"<parameter>upto_nchanges</parameter> is non-NULL, decoding will stop when "
"the number of rows produced by decoding exceeds the specified value. Note, "
"however, that the actual number of rows returned may be larger, since this "
"limit is only checked after adding the rows produced when decoding each new "
"transaction commit."
msgstr ""
"Возвращает изменения в слоте <parameter>slot_name</parameter> с позиции, до "
"которой ранее были получены изменения. Если параметры <parameter>upto_lsn</"
"parameter> и <parameter>upto_nchanges</parameter> равны NULL, логическое "
"декодирование продолжится до конца журнала транзакций. Если "
"<parameter>upto_lsn</parameter> не NULL, декодироваться будут только "
"транзакции, зафиксированные до заданного LSN. Если <parameter>upto_nchanges</"
"parameter> не NULL, декодирование остановится, когда число строк, полученных "
"при декодировании, превысит заданное значение. Заметьте, однако, что "
"фактическое число возвращённых строк может быть больше, так как это "
"ограничение проверяется только после добавления строк, декодированных для "
"очередной транзакции."

#: func.xml:18271(indexterm)
msgid "<primary>pg_logical_slot_peek_changes</primary>"
msgstr "<primary>pg_logical_slot_peek_changes</primary>"

#: func.xml:18274(function)
msgid ""
"pg_logical_slot_peek_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"
msgstr ""
"pg_logical_slot_peek_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"

#: func.xml:18276(entry)
msgid ""
"(<parameter>location</parameter> <type>text</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)"
msgstr ""
"(<parameter>location</parameter> <type>text</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>text</type>)"

#: func.xml:18279(entry)
msgid ""
"Behaves just like the <function>pg_logical_slot_get_changes()</function> "
"function, except that changes are not consumed; that is, they will be "
"returned again on future calls."
msgstr ""
"Работает так же, как функция <function>pg_logical_slot_get_changes()</"
"function>, но не забирает изменения; то есть, они будут получены снова при "
"следующих вызовах."

#: func.xml:18289(indexterm)
msgid "<primary>pg_logical_slot_get_binary_changes</primary>"
msgstr "<primary>pg_logical_slot_get_binary_changes</primary>"

#: func.xml:18292(function)
msgid ""
"pg_logical_slot_get_binary_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"
msgstr ""
"pg_logical_slot_get_binary_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"

#: func.xml:18294(entry) func.xml:18311(entry)
msgid ""
"(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)"
msgstr ""
"(<parameter>location</parameter> <type>pg_lsn</type>, <parameter>xid</"
"parameter> <type>xid</type>, <parameter>data</parameter> <type>bytea</type>)"

#: func.xml:18297(entry)
msgid ""
"Behaves just like the <function>pg_logical_slot_get_changes()</function> "
"function, except that changes are returned as <type>bytea</type>."
msgstr ""
"Работает так же, как функция <function>pg_logical_slot_get_changes()</"
"function>, но выдаёт изменения в типе <type>bytea</type>."

#: func.xml:18306(indexterm)
msgid "<primary>pg_logical_slot_peek_binary_changes</primary>"
msgstr "<primary>pg_logical_slot_peek_binary_changes</primary>"

#: func.xml:18309(function)
msgid ""
"pg_logical_slot_peek_binary_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"
msgstr ""
"pg_logical_slot_peek_binary_changes(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>, <placeholder-5/> <placeholder-6/>, "
"VARIADIC <placeholder-7/> <placeholder-8/>)"

#: func.xml:18314(entry)
msgid ""
"Behaves just like the <function>pg_logical_slot_get_changes()</function> "
"function, except that changes are returned as <type>bytea</type> and that "
"changes are not consumed; that is, they will be returned again on future "
"calls."
msgstr ""
"Работает так же, как функция <function>pg_logical_slot_get_changes()</"
"function>, но выдаёт изменения в типе <type>bytea</type> и не забирает их; "
"то есть, они будут получены снова при следующих вызовах."

#: func.xml:18325(indexterm)
msgid "<primary>pg_replication_origin_create</primary>"
msgstr "<primary>pg_replication_origin_create</primary>"

#: func.xml:18328(parameter) func.xml:18344(parameter)
#: func.xml:18360(parameter) func.xml:18376(parameter)
#: func.xml:18478(parameter) func.xml:18497(parameter)
msgid "node_name"
msgstr "node_name"

#: func.xml:18328(function)
msgid "pg_replication_origin_create(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_replication_origin_create(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18333(entry)
msgid ""
"Create a replication origin with the given external name, and return the "
"internal id assigned to it."
msgstr ""
"Создаёт источник репликации с заданным внешним именем и возвращает "
"назначенный ему внутренний идентификатор."

#: func.xml:18341(indexterm)
msgid "<primary>pg_replication_origin_drop</primary>"
msgstr "<primary>pg_replication_origin_drop</primary>"

#: func.xml:18344(function)
msgid "pg_replication_origin_drop(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_replication_origin_drop(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18346(entry) func.xml:18378(entry) func.xml:18396(entry)
#: func.xml:18445(entry) func.xml:18464(entry) func.xml:18480(entry)
msgctxt "entry"
msgid "void"
msgstr "void"

#: func.xml:18349(entry)
msgid ""
"Delete a previously created replication origin, including any associated "
"replay progress."
msgstr ""
"Удаляет ранее созданный источник репликации, в том числе связанную "
"информацию о воспроизведении."

#: func.xml:18357(indexterm)
msgid "<primary>pg_replication_origin_oid</primary>"
msgstr "<primary>pg_replication_origin_oid</primary>"

#: func.xml:18360(function)
msgid "pg_replication_origin_oid(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_replication_origin_oid(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18365(entry)
msgid ""
"Lookup a replication origin by name and return the internal id. If no "
"corresponding replication origin is found an error is thrown."
msgstr ""
"Ищет источник репликации по имени и возвращает внутренний идентификатор. "
"Если такой источник не находится, выдаётся ошибка."

#: func.xml:18373(indexterm)
msgid "<primary>pg_replication_origin_session_setup</primary>"
msgstr "<primary>pg_replication_origin_session_setup</primary>"

#: func.xml:18376(function)
msgid "pg_replication_origin_session_setup(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_replication_origin_session_setup(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18381(entry)
msgid ""
"Mark the current session as replaying from the given origin, allowing replay "
"progress to be tracked. Use <function>pg_replication_origin_session_reset</"
"function> to revert. Can only be used if no previous origin is configured."
msgstr ""
"Помечает текущий сеанс, как воспроизводящий журнал из указанного источника, "
"что позволяет отслеживать положение воспроизведения. Чтобы отменить это "
"действие, вызовите <function>pg_replication_origin_session_reset</function>. "
"Может использоваться, только если не был настроен предыдущий источник."

#: func.xml:18391(indexterm)
msgid "<primary>pg_replication_origin_session_reset</primary>"
msgstr "<primary>pg_replication_origin_session_reset</primary>"

#: func.xml:18394(function)
msgid "pg_replication_origin_session_reset()"
msgstr "pg_replication_origin_session_reset()"

#: func.xml:18399(entry)
msgid ""
"Cancel the effects of <function>pg_replication_origin_session_setup()</"
"function>."
msgstr ""
"Отменяет действие <function>pg_replication_origin_session_setup()</function>."

#: func.xml:18407(indexterm)
msgid "<primary>pg_replication_origin_session_is_setup</primary>"
msgstr "<primary>pg_replication_origin_session_is_setup</primary>"

#: func.xml:18410(function)
msgid "pg_replication_origin_session_is_setup()"
msgstr "pg_replication_origin_session_is_setup()"

#: func.xml:18415(entry)
msgid "Has a replication origin been configured in the current session?"
msgstr "В текущем сеансе настроен источник репликации?"

#: func.xml:18422(indexterm)
msgid "<primary>pg_replication_origin_session_progress</primary>"
msgstr "<primary>pg_replication_origin_session_progress</primary>"

#: func.xml:18425(parameter) func.xml:18497(parameter)
msgid "flush"
msgstr "flush"

#: func.xml:18425(function)
msgid ""
"pg_replication_origin_session_progress(<placeholder-1/> <placeholder-2/>)"
msgstr ""
"pg_replication_origin_session_progress(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18430(entry)
msgid ""
"Return the replay position for the replication origin configured in the "
"current session. The parameter <parameter>flush</parameter> determines "
"whether the corresponding local transaction will be guaranteed to have been "
"flushed to disk or not."
msgstr ""
"Возвращает позицию воспроизведения для источника репликации, настроенного в "
"текущем сеансе. Параметр <parameter>flush</parameter> определяет, будет ли "
"гарантироваться сохранение локальной транзакции на диске."

#: func.xml:18440(indexterm)
msgid "<primary>pg_replication_origin_xact_setup</primary>"
msgstr "<primary>pg_replication_origin_xact_setup</primary>"

#: func.xml:18443(parameter)
msgid "origin_lsn"
msgstr "origin_lsn"

#: func.xml:18443(parameter)
msgid "origin_timestamp"
msgstr "origin_timestamp"

#: func.xml:18443(type)
msgid "timestamptz"
msgstr "timestamptz"

#: func.xml:18443(function)
msgid ""
"pg_replication_origin_xact_setup(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_replication_origin_xact_setup(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#: func.xml:18448(entry)
msgid ""
"Mark the current transaction as replaying a transaction that has committed "
"at the given <acronym>LSN</acronym> and timestamp. Can only be called when a "
"replication origin has previously been configured using "
"<function>pg_replication_origin_session_setup()</function>."
msgstr ""
"Помечает текущую транзакцию как воспроизводящую транзакцию, зафиксированную "
"с указанным <acronym>LSN</acronym> и временем. Может вызываться только после "
"того, как был настроен источник репликации в результате вызова "
"<function>pg_replication_origin_session_setup()</function>."

#: func.xml:18459(indexterm)
msgid "<primary>pg_replication_origin_xact_reset</primary>"
msgstr "<primary>pg_replication_origin_xact_reset</primary>"

#: func.xml:18462(function)
msgid "pg_replication_origin_xact_reset()"
msgstr "pg_replication_origin_xact_reset()"

#: func.xml:18467(entry)
msgid ""
"Cancel the effects of <function>pg_replication_origin_xact_setup()</"
"function>."
msgstr ""
"Отменяет действие <function>pg_replication_origin_xact_setup()</function>."

#: func.xml:18475(indexterm)
msgid "<primary>pg_replication_origin_advance</primary>"
msgstr "<primary>pg_replication_origin_advance</primary>"

#: func.xml:18478(parameter)
msgid "pos"
msgstr "pos"

#: func.xml:18478(function)
msgid "(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
msgstr "(<placeholder-1/> <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#: func.xml:18478(literal)
msgid "pg_replication_origin_advance<placeholder-1/>"
msgstr "pg_replication_origin_advance<placeholder-1/>"

#: func.xml:18483(entry)
msgid ""
"Set replication progress for the given node to the given position. This "
"primarily is useful for setting up the initial position or a new position "
"after configuration changes and similar. Be aware that careless use of this "
"function can lead to inconsistently replicated data."
msgstr ""
"Устанавливает положение репликации для заданного узла в указанную позицию. "
"Это в основном полезно для установки начальной позиции или новой позиции "
"после изменения конфигурации и подобных действий. Но учтите, что "
"неосторожное использование этой функции может привести к несогласованности "
"реплицированных данных."

#: func.xml:18494(indexterm)
msgid "<primary>pg_replication_origin_progress</primary>"
msgstr "<primary>pg_replication_origin_progress</primary>"

#: func.xml:18497(function)
msgid ""
"pg_replication_origin_progress(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_replication_origin_progress(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#: func.xml:18502(entry)
msgid ""
"Return the replay position for the given replication origin. The parameter "
"<parameter>flush</parameter> determines whether the corresponding local "
"transaction will be guaranteed to have been flushed to disk or not."
msgstr ""
"Возвращает позицию воспроизведения для заданного источника репликации. "
"Параметр <parameter>flush</parameter> определяет, будет ли гарантироваться "
"сохранение локальной транзакции на диске."

#: func.xml:18512(indexterm)
msgid "<primary>pg_logical_emit_message</primary>"
msgstr "<primary>pg_logical_emit_message</primary>"

#: func.xml:18515(parameter) func.xml:18534(parameter)
msgid "transactional"
msgstr "transactional"

#: func.xml:18515(parameter) func.xml:18534(parameter)
msgid "prefix"
msgstr "prefix"

#: func.xml:18515(parameter) func.xml:18534(parameter)
msgctxt "parameter"
msgid "content"
msgstr "content"

#: func.xml:18515(function) func.xml:18534(function)
msgid ""
"pg_logical_emit_message(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"
msgstr ""
"pg_logical_emit_message(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>)"

#: func.xml:18520(entry)
msgid ""
"Emit text logical decoding message. This can be used to pass generic "
"messages to logical decoding plugins through WAL. The parameter "
"<parameter>transactional</parameter> specifies if the message should be part "
"of current transaction or if it should be written immediately and decoded as "
"soon as the logical decoding reads the record. The <parameter>prefix</"
"parameter> is textual prefix used by the logical decoding plugins to easily "
"recognize interesting messages for them. The <parameter>content</parameter> "
"is the text of the message."
msgstr ""
"Выдаёт текстовое сообщение логического декодирования. Её можно использовать "
"для передачи произвольных сообщений через WAL модулям логического "
"декодирования. Параметр <parameter>transactional</parameter> устанавливает, "
"должно ли сообщение быть частью текущей транзакции или оно должно "
"записываться немедленно и декодироваться сразу, как только эта запись будет "
"прочитана при логическом декодировании. Параметр <parameter>prefix</"
"parameter> задаёт текстовый префикс, по которому модули логического "
"декодирования могут легко распознать интересующие их сообщения. В параметре "
"<parameter>content</parameter> передаётся текст сообщения."

#: func.xml:18539(entry)
msgid ""
"Emit binary logical decoding message. This can be used to pass generic "
"messages to logical decoding plugins through WAL. The parameter "
"<parameter>transactional</parameter> specifies if the message should be part "
"of current transaction or if it should be written immediately and decoded as "
"soon as the logical decoding reads the record. The <parameter>prefix</"
"parameter> is textual prefix used by the logical decoding plugins to easily "
"recognize interesting messages for them. The <parameter>content</parameter> "
"is the binary content of the message."
msgstr ""
"Выдаёт двоичное сообщение логического декодирования. Её можно использовать "
"для передачи произвольных сообщений через WAL модулям логического "
"декодирования. Параметр <parameter>transactional</parameter> устанавливает, "
"должно ли сообщение быть частью текущей транзакции или оно должно "
"записываться немедленно и декодироваться сразу, как только эта запись будет "
"прочитана при логическом декодировании. Параметр <parameter>prefix</"
"parameter> задаёт текстовый префикс, по которому модули логического "
"декодирования могут легко распознать интересующие их сообщения. В параметре "
"<parameter>content</parameter> передаётся двоичное содержание сообщения."

#: func.xml:18559(title)
msgid "Database Object Management Functions"
msgstr "Функции управления объектами баз данных"

#: func.xml:18561(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-dbsize\"/> calculate "
"the disk space usage of database objects."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-dbsize"
"\"/>, вычисляют объём, который занимают на диске различные объекты баз "
"данных."

#: func.xml:18566(indexterm)
msgid "<primary>pg_column_size</primary>"
msgstr "<primary>pg_column_size</primary>"

#: func.xml:18569(indexterm)
msgid "<primary>pg_database_size</primary>"
msgstr "<primary>pg_database_size</primary>"

#: func.xml:18572(indexterm)
msgid "<primary>pg_indexes_size</primary>"
msgstr "<primary>pg_indexes_size</primary>"

#: func.xml:18575(indexterm)
msgid "<primary>pg_relation_size</primary>"
msgstr "<primary>pg_relation_size</primary>"

#: func.xml:18578(indexterm)
msgid "<primary>pg_size_bytes</primary>"
msgstr "<primary>pg_size_bytes</primary>"

#: func.xml:18581(indexterm)
msgid "<primary>pg_size_pretty</primary>"
msgstr "<primary>pg_size_pretty</primary>"

#: func.xml:18584(indexterm)
msgid "<primary>pg_table_size</primary>"
msgstr "<primary>pg_table_size</primary>"

#: func.xml:18587(indexterm)
msgid "<primary>pg_tablespace_size</primary>"
msgstr "<primary>pg_tablespace_size</primary>"

#: func.xml:18590(indexterm)
msgid "<primary>pg_total_relation_size</primary>"
msgstr "<primary>pg_total_relation_size</primary>"

#: func.xml:18595(title)
msgid "Database Object Size Functions"
msgstr "Функции получения размера объектов БД"

#: func.xml:18604(function)
msgid "pg_column_size(<placeholder-1/>)"
msgstr "pg_column_size(<placeholder-1/>)"

#: func.xml:18606(entry)
msgid "Number of bytes used to store a particular value (possibly compressed)"
msgstr ""
"Число байт, необходимых для хранения заданного значения (возможно, в сжатом "
"виде)"

#: func.xml:18610(function) func.xml:18617(function)
msgid "pg_database_size(<placeholder-1/>)"
msgstr "pg_database_size(<placeholder-1/>)"

#: func.xml:18613(entry)
msgid "Disk space used by the database with the specified OID"
msgstr "Объём, который занимает на диске база данных с заданным OID"

#: func.xml:18620(entry)
msgid "Disk space used by the database with the specified name"
msgstr "Объём, который занимает на диске база данных с заданным именем"

#: func.xml:18624(function)
msgid "pg_indexes_size(<placeholder-1/>)"
msgstr "pg_indexes_size(<placeholder-1/>)"

#: func.xml:18627(entry)
msgid "Total disk space used by indexes attached to the specified table"
msgstr "Общий объём индексов, связанных с указанной таблицей"

#: func.xml:18633(parameter) func.xml:18644(parameter)
#: func.xml:18855(parameter) func.xml:18864(parameter)
msgid "relation"
msgstr "relation"

#: func.xml:18633(parameter)
msgid "fork"
msgstr "fork"

#: func.xml:18633(function)
msgid ""
"pg_relation_size(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_relation_size(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:18636(entry)
msgid ""
"Disk space used by the specified fork (<literal>'main'</literal>, "
"<literal>'fsm'</literal>, <literal>'vm'</literal>, or <literal>'init'</"
"literal>) of the specified table or index"
msgstr ""
"Объём, который занимает на диске указанный слой (<literal>'main'</literal>, "
"<literal>'fsm'</literal>, <literal>'vm'</literal> или <literal>'init'</"
"literal>) заданной таблицы или индекса"

#: func.xml:18644(function)
msgid "pg_relation_size(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_relation_size(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18647(entry)
msgid "Shorthand for <literal>pg_relation_size(..., 'main')</literal>"
msgstr "Краткая форма <literal>pg_relation_size(..., 'main')</literal>"

#: func.xml:18653(function)
msgid "pg_size_bytes(<placeholder-1/>)"
msgstr "pg_size_bytes(<placeholder-1/>)"

#: func.xml:18656(entry)
msgid "Converts a size in human-readable format with size units into bytes"
msgstr ""
"Преобразует размер в понятном человеку формате с единицами измерения в число "
"байт"

#: func.xml:18662(function) func.xml:18672(function)
msgid "pg_size_pretty(<placeholder-1/>)"
msgstr "pg_size_pretty(<placeholder-1/>)"

#: func.xml:18665(entry)
msgid ""
"Converts a size in bytes expressed as a 64-bit integer into a human-readable "
"format with size units"
msgstr ""
"Преобразует размер в байтах, представленный в 64-битном целом, в понятный "
"человеку формат с единицами измерения"

#: func.xml:18675(entry)
msgid ""
"Converts a size in bytes expressed as a numeric value into a human-readable "
"format with size units"
msgstr ""
"Преобразует размер в байтах, представленный в значении числового типа, в "
"понятный человеку формат с единицами измерения"

#: func.xml:18682(function)
msgid "pg_table_size(<placeholder-1/>)"
msgstr "pg_table_size(<placeholder-1/>)"

#: func.xml:18685(entry)
msgid ""
"Disk space used by the specified table, excluding indexes (but including "
"TOAST, free space map, and visibility map)"
msgstr ""
"Объём, который занимает на диске данная таблица, за исключением индексов (но "
"включая TOAST, карту свободного места и карту видимости)"

#: func.xml:18692(function) func.xml:18699(function)
msgid "pg_tablespace_size(<placeholder-1/>)"
msgstr "pg_tablespace_size(<placeholder-1/>)"

#: func.xml:18695(entry)
msgid "Disk space used by the tablespace with the specified OID"
msgstr ""
"Объём, который занимает на диске табличное пространство с указанным OID"

#: func.xml:18702(entry)
msgid "Disk space used by the tablespace with the specified name"
msgstr ""
"Объём, который занимает на диске табличное пространство с заданным именем"

#: func.xml:18706(function)
msgid "pg_total_relation_size(<placeholder-1/>)"
msgstr "pg_total_relation_size(<placeholder-1/>)"

#: func.xml:18709(entry)
msgid ""
"Total disk space used by the specified table, including all indexes and "
"<acronym>TOAST</acronym> data"
msgstr ""
"Общий объём, который занимает на диске заданная таблица, включая все индексы "
"и данные <acronym>TOAST</acronym>"

#: func.xml:18718(para)
msgid ""
"<function>pg_column_size</function> shows the space used to store any "
"individual data value."
msgstr ""
"<function>pg_column_size</function> показывает, какой объём требуется для "
"хранения данного значения."

#: func.xml:18723(para)
msgid ""
"<function>pg_total_relation_size</function> accepts the OID or name of a "
"table or toast table, and returns the total on-disk space used for that "
"table, including all associated indexes. This function is equivalent to "
"<function>pg_table_size</function> <literal>+</literal> "
"<function>pg_indexes_size</function>."
msgstr ""
"<function>pg_total_relation_size</function> принимает OID или имя таблицы "
"или данных TOAST и возвращает общий объём, который занимает на диске эта "
"таблица, включая все связанные с ней индексы. Результат этой функции "
"равняется <function>pg_table_size</function> <literal>+</literal> "
"<function>pg_indexes_size</function>."

#: func.xml:18731(para)
msgid ""
"<function>pg_table_size</function> accepts the OID or name of a table and "
"returns the disk space needed for that table, exclusive of indexes. (TOAST "
"space, free space map, and visibility map are included.)"
msgstr ""
"<function>pg_table_size</function> принимает OID или имя таблицы и "
"возвращает объём, который занимает на диске эта таблица без индексов. (При "
"этом учитывается размер TOAST, карты свободного места и карты видимости.)"

#: func.xml:18737(para)
msgid ""
"<function>pg_indexes_size</function> accepts the OID or name of a table and "
"returns the total disk space used by all the indexes attached to that table."
msgstr ""
"<function>pg_indexes_size</function> принимает OID или имя таблицы и "
"возвращает общий объём, который занимают все индексы таблицы."

#: func.xml:18743(para)
msgid ""
"<function>pg_database_size</function> and <function>pg_tablespace_size</"
"function> accept the OID or name of a database or tablespace, and return the "
"total disk space used therein. To use <function>pg_database_size</function>, "
"you must have <literal>CONNECT</literal> permission on the specified "
"database (which is granted by default). To use <function>pg_tablespace_size</"
"function>, you must have <literal>CREATE</literal> permission on the "
"specified tablespace, unless it is the default tablespace for the current "
"database."
msgstr ""
"<function>pg_database_size</function> и <function>pg_tablespace_size</"
"function> принимают OID или имя базы данных либо табличного пространства и "
"возвращают общий объём, который они занимают на диске. Для использования "
"<function>pg_database_size</function> требуется право <literal>CONNECT</"
"literal> для указанной базы данных (оно имеется по умолчанию). Для "
"использования <function>pg_tablespace_size</function> необходимо иметь право "
"<literal>CREATE</literal> в указанном табличном пространстве, если только "
"это не табличное пространство по умолчанию для текущей базы данных."

#: func.xml:18764(para)
msgid ""
"<literal>'main'</literal> returns the size of the main data fork of the "
"relation."
msgstr ""
"<literal>'main'</literal> возвращает размер основного слоя данных заданного "
"отношения."

#: func.xml:18770(para)
msgid ""
"<literal>'fsm'</literal> returns the size of the Free Space Map (see <xref "
"linkend=\"storage-fsm\"/>) associated with the relation."
msgstr ""
"<literal>'fsm'</literal> возвращает размер карты свободного места (см. <xref "
"remap=\"4\" linkend=\"storage-fsm\"/>), связанной с заданным отношением."

#: func.xml:18776(para)
msgid ""
"<literal>'vm'</literal> returns the size of the Visibility Map (see <xref "
"linkend=\"storage-vm\"/>) associated with the relation."
msgstr ""
"<literal>'vm'</literal> возвращает размер карты видимости (см. <xref remap="
"\"4\" linkend=\"storage-vm\"/>), связанной с заданным отношением."

#: func.xml:18782(para)
msgid ""
"<literal>'init'</literal> returns the size of the initialization fork, if "
"any, associated with the relation."
msgstr ""
"<literal>'init'</literal> возвращает размер слоя инициализации для заданного "
"отношения, если он имеется."

#: func.xml:18753(para)
msgid ""
"<function>pg_relation_size</function> accepts the OID or name of a table, "
"index or toast table, and returns the on-disk size in bytes of one fork of "
"that relation. (Note that for most purposes it is more convenient to use the "
"higher-level functions <function>pg_total_relation_size</function> or "
"<function>pg_table_size</function>, which sum the sizes of all forks.) With "
"one argument, it returns the size of the main data fork of the relation. The "
"second argument can be provided to specify which fork to examine: "
"<placeholder-1/>"
msgstr ""
"<function>pg_relation_size</function> принимает OID или имя таблицы, индекса "
"или TOAST-таблицы и возвращает размер одного слоя этого отношения (в "
"байтах). (Заметьте, что в большинстве случае удобнее использовать более "
"высокоуровневые функции <function>pg_total_relation_size</function> и "
"<function>pg_table_size</function>, которые суммируют размер всех слоёв.) С "
"одним аргументом она возвращает размер основного слоя для данных заданного "
"отношения. Название другого интересующего слоя можно передать во втором "
"аргументе: <placeholder-1/>"

#: func.xml:18790(para)
msgid ""
"<function>pg_size_pretty</function> can be used to format the result of one "
"of the other functions in a human-readable way, using bytes, kB, MB, GB or "
"TB as appropriate."
msgstr ""
"<function>pg_size_pretty</function> можно использовать для форматирования "
"результатов других функций в виде, более понятном человеку, с единицами "
"измерения bytes, kB, MB, GB и TB."

#: func.xml:18796(para)
msgid ""
"<function>pg_size_bytes</function> can be used to get the size in bytes from "
"a string in human-readable format. The input may have units of bytes, kB, "
"MB, GB or TB, and is parsed case-insensitively. If no units are specified, "
"bytes are assumed."
msgstr ""
"<function>pg_size_bytes</function> можно использовать для получения размера "
"в байтах из строки в формате, понятном человеку. Входная строка может "
"содержать единицы bytes, kB, MB, GB и TB, и разбирается без учёта регистра. "
"Если единицы не указываются, подразумеваются байты."

#: func.xml:18804(para)
msgid ""
"The units kB, MB, GB and TB used by the functions <function>pg_size_pretty</"
"function> and <function>pg_size_bytes</function> are defined using powers of "
"2 rather than powers of 10, so 1kB is 1024 bytes, 1MB is 1024<superscript>2</"
"superscript> = 1048576 bytes, and so on."
msgstr ""
"Единицы kB, MB, GB и TB, фигурирующие в функциях <function>pg_size_pretty</"
"function> и <function>pg_size_bytes</function>, определяются как степени 2, "
"а не 10, так что 1kB равен 1024 байтам, 1MB равен 1024<superscript>2</"
"superscript> = 1048576 байтов и т. д."

#: func.xml:18812(para)
msgid ""
"The functions above that operate on tables or indexes accept a "
"<type>regclass</type> argument, which is simply the OID of the table or "
"index in the <structname>pg_class</structname> system catalog. You do not "
"have to look up the OID by hand, however, since the <type>regclass</type> "
"data type's input converter will do the work for you. Just write the table "
"name enclosed in single quotes so that it looks like a literal constant. For "
"compatibility with the handling of ordinary <acronym>SQL</acronym> names, "
"the string will be converted to lower case unless it contains double quotes "
"around the table name."
msgstr ""
"Вышеописанные функции, работающие с таблицами или индексами, принимают "
"аргумент типа <type>regclass</type>, который представляет собой просто OID "
"таблицы или индекса в системном каталоге <structname>pg_class</structname>. "
"Однако вам не нужно вручную вычислять OID, так как процедура ввода значения "
"<type>regclass</type> может сделать это за вас. Для этого достаточно "
"записать имя таблицы в апострофах, как обычную текстовую константу. В "
"соответствии с правилами обработки обычных имён <acronym>SQL</acronym>, если "
"имя таблицы не заключено в кавычки, эта строка будет переведена в нижний "
"регистр."

#: func.xml:18824(para)
msgid ""
"If an OID that does not represent an existing object is passed as argument "
"to one of the above functions, NULL is returned."
msgstr ""
"Если переданному значению OID не соответствуют существующий объект, эти "
"функции возвращают NULL."

#: func.xml:18829(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-dblocation\"/> assist "
"in identifying the specific disk files associated with database objects."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-"
"dblocation\"/>, помогают определить, в каких файлах на диске хранятся "
"объекты базы данных."

#: func.xml:18834(indexterm)
msgid "<primary>pg_relation_filenode</primary>"
msgstr "<primary>pg_relation_filenode</primary>"

#: func.xml:18837(indexterm)
msgid "<primary>pg_relation_filepath</primary>"
msgstr "<primary>pg_relation_filepath</primary>"

#: func.xml:18840(indexterm)
msgid "<primary>pg_filenode_relation</primary>"
msgstr "<primary>pg_filenode_relation</primary>"

#: func.xml:18845(title)
msgid "Database Object Location Functions"
msgstr "Функции определения расположения объектов"

#: func.xml:18855(function)
msgid "pg_relation_filenode(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_relation_filenode(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18858(entry)
msgid "Filenode number of the specified relation"
msgstr "Номер файлового узла для указанного отношения"

#: func.xml:18864(function)
msgid "pg_relation_filepath(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_relation_filepath(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18867(entry)
msgid "File path name of the specified relation"
msgstr "Путь к файлу, в котором хранится указанное отношение"

#: func.xml:18873(parameter)
msgid "filenode"
msgstr "filenode"

#: func.xml:18873(function)
msgid ""
"pg_filenode_relation(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_filenode_relation(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:18876(entry)
msgid "Find the relation associated with a given tablespace and filenode"
msgstr ""
"Находит отношение, связанное с данным табличным пространством и файловым "
"узлом"

#: func.xml:18884(para)
msgid ""
"<function>pg_relation_filenode</function> accepts the OID or name of a "
"table, index, sequence, or toast table, and returns the <quote>filenode</"
"quote> number currently assigned to it. The filenode is the base component "
"of the file name(s) used for the relation (see <xref linkend=\"storage-file-"
"layout\"/> for more information). For most tables the result is the same as "
"<structname>pg_class</structname>.<structfield>relfilenode</structfield>, "
"but for certain system catalogs <structfield>relfilenode</structfield> is "
"zero and this function must be used to get the correct value. The function "
"returns NULL if passed a relation that does not have storage, such as a view."
msgstr ""
"<function>pg_relation_filenode</function> принимает OID или имя таблицы, "
"индекса, последовательности или таблицы TOAST и возвращает номер "
"<quote>файлового узла</quote>, связанным с этим объектом. Файловым узлом "
"называется основной компонент имени файла, используемого для хранения данных "
"(подробнее это описано в <xref remap=\"6\" linkend=\"storage-file-layout\"/"
">). Для большинства таблиц этот номер совпадает со значением "
"<structname>pg_class</structname>.<structfield>relfilenode</structfield>, но "
"для некоторых системных каталогов <structfield>relfilenode</structfield> "
"равен 0, и нужно использовать эту функцию, чтобы узнать действительное "
"значение. Если указанное отношение не хранится на диске, как например "
"представление, данная функция возвращает NULL."

#: func.xml:18896(para)
msgid ""
"<function>pg_relation_filepath</function> is similar to "
"<function>pg_relation_filenode</function>, but it returns the entire file "
"path name (relative to the database cluster's data directory "
"<varname>PGDATA</varname>) of the relation."
msgstr ""
"<function>pg_relation_filepath</function> подобна "
"<function>pg_relation_filenode</function>, но возвращает полный путь к файлу "
"(относительно каталога данных <varname>PGDATA</varname>) отношения."

#: func.xml:18903(para)
msgid ""
"<function>pg_filenode_relation</function> is the reverse of "
"<function>pg_relation_filenode</function>. Given a <quote>tablespace</quote> "
"OID and a <quote>filenode</quote>, it returns the associated relation's OID. "
"For a table in the database's default tablespace, the tablespace can be "
"specified as 0."
msgstr ""
"Функция <function>pg_filenode_relation</function> является обратной к "
"<function>pg_relation_filenode</function>. Она возвращает OID отношения по "
"заданному OID <quote>табличного пространства</quote> и <quote>файловому "
"узлу</quote>. Для таблицы в табличном пространстве по умолчанию в первом "
"параметре можно передать 0."

#: func.xml:18913(title) func.xml:18932(title)
msgid "Index Maintenance Functions"
msgstr "Функции обслуживания индексов"

#: func.xml:18915(indexterm)
msgid "<primary>brin_summarize_new_values</primary>"
msgstr "<primary>brin_summarize_new_values</primary>"

#: func.xml:18919(indexterm)
msgid "<primary>gin_clean_pending_list</primary>"
msgstr "<primary>gin_clean_pending_list</primary>"

#: func.xml:18923(para)
msgid ""
"<xref linkend=\"functions-admin-index-table\"/> shows the functions "
"available for index maintenance tasks. These functions cannot be executed "
"during recovery. Use of these functions is restricted to superusers and the "
"owner of the given index."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-admin-index-table\"/> перечислены "
"функции, предназначенные для обслуживания индексов. Эти функции нельзя "
"вызывать в процессе восстановления. Использовать эти функции разрешено "
"только суперпользователям и владельцу определённого индекса."

#: func.xml:18941(function)
msgid "brin_summarize_new_values(<placeholder-1/> <placeholder-2/>)"
msgstr "brin_summarize_new_values(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18944(entry)
msgid "summarize page ranges not already summarized"
msgstr "обобщает ещё не обобщённые диапазоны страниц"

#: func.xml:18948(parameter)
msgid "index"
msgstr "index"

#: func.xml:18948(function)
msgid "gin_clean_pending_list(<placeholder-1/> <placeholder-2/>)"
msgstr "gin_clean_pending_list(<placeholder-1/> <placeholder-2/>)"

#: func.xml:18951(entry)
msgid "move GIN pending list entries into main index structure"
msgstr ""
"перемещает элементы из списка записей GIN, ожидающих обработки, в основную "
"структуру индекса"

#: func.xml:18957(para)
msgid ""
"<function>brin_summarize_new_values</function> receives a BRIN index OID as "
"argument and inspects the index to find page ranges in the base table that "
"are not currently summarized by the index; for any such range it creates a "
"new summary index tuple by scanning the table pages. It returns the number "
"of new page range summaries that were inserted into the index."
msgstr ""
"Функция <function>brin_summarize_new_values</function> получает в качестве "
"аргумента идентификатор индекса BRIN и просматривает индекс в поисках зон "
"страниц в базовой таблице, ещё не обобщённых в индексе; для каждой такой "
"зоны в результате сканирования таблиц страницы создаётся новый обобщённый "
"кортеж в индексе. Возвращает эта функция число вставленных в индекс "
"обобщённых записей о зонах страниц."

#: func.xml:18966(para)
msgid ""
"<function>gin_clean_pending_list</function> accepts the OID or name of a GIN "
"index and cleans up the pending list of the specified GIN index by moving "
"entries in it to the main GIN data structure in bulk. It returns the number "
"of pages cleaned up from the pending list. Note that if the argument is a "
"GIN index built with <literal>fastupdate</literal> option disabled, the "
"cleanup does not happen and the return value is 0 because the index doesn't "
"have a pending list. Please see <xref linkend=\"gin-fast-update\"/> and "
"<xref linkend=\"gin-tips\"/> for details of the pending list and "
"<literal>fastupdate</literal> option."
msgstr ""
"Функция <function>gin_clean_pending_list</function> принимает OID или имя "
"индекса GIN и очищает очередь указанного индекса GIN, массово перемещая "
"элементы из неё в основную структуру данных GIN. Возвращает она число "
"страниц, убранных из очереди. Заметьте, что если для обработки ей передаётся "
"индекс GIN, построенный с отключённым параметром <literal>fastupdate</"
"literal>, очистка не производится и возвращается значение 0, так как у "
"такого индекса нет очереди записей. Подробнее об очереди записей и параметре "
"<literal>fastupdate</literal> рассказывается в <xref remap=\"6\" linkend="
"\"gin-fast-update\"/> и <xref remap=\"6\" linkend=\"gin-tips\"/>."

#: func.xml:18981(title) func.xml:18994(title)
msgid "Generic File Access Functions"
msgstr "Функции для работы с обычными файлами"

#: func.xml:18983(para)
msgid ""
"The functions shown in <xref linkend=\"functions-admin-genfile-table\"/> "
"provide native access to files on the machine hosting the server. Only files "
"within the database cluster directory and the <varname>log_directory</"
"varname> can be accessed. Use a relative path for files in the cluster "
"directory, and a path matching the <varname>log_directory</varname> "
"configuration setting for log files. Use of these functions is restricted to "
"superusers."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-admin-genfile-"
"table\"/>, предоставляют прямой доступ к файлам, находящимся на сервере. Они "
"позволяют обращаться только к файлам в каталоге кластера баз данных (по "
"относительному пути) или в каталоге <varname>log_directory</varname> (по "
"пути, заданному в параметре конфигурации <varname>log_directory</varname>). "
"Использовать эти функции могут только суперпользователи."

#: func.xml:19004(parameter)
msgid "dirname"
msgstr "dirname"

#: func.xml:19004(parameter)
msgid "include_dot_dirs"
msgstr "include_dot_dirs"

#: func.xml:19004(function)
msgid ""
"pg_ls_dir(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>])"
msgstr ""
"pg_ls_dir(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/>])"

#: func.xml:19007(entry)
msgid "List the contents of a directory."
msgstr "Возвращает список содержимого каталога."

#: func.xml:19013(parameter) func.xml:19022(parameter)
#: func.xml:19031(parameter)
msgid "filename"
msgstr "filename"

#: func.xml:19013(function)
msgid ""
"pg_read_file(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>] ])"
msgstr ""
"pg_read_file(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>] ])"

#: func.xml:19016(entry)
msgid "Return the contents of a text file."
msgstr "Возвращает содержимое текстового файла."

#: func.xml:19022(function)
msgid ""
"pg_read_binary_file(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>] ])"
msgstr ""
"pg_read_binary_file(<placeholder-1/> <placeholder-2/> [, <placeholder-3/> "
"<placeholder-4/>, <placeholder-5/> <placeholder-6/> [, <placeholder-7/> "
"<placeholder-8/>] ])"

#: func.xml:19025(entry)
msgid "Return the contents of a file."
msgstr "Возвращает содержимое файла."

#: func.xml:19031(function)
msgid ""
"pg_stat_file(<placeholder-1/> <placeholder-2/>[, <placeholder-3/> "
"<placeholder-4/>])"
msgstr ""
"pg_stat_file(<placeholder-1/> <placeholder-2/>[, <placeholder-3/> "
"<placeholder-4/>])"

#: func.xml:19034(entry)
msgid "Return information about a file."
msgstr "Возвращает информацию о файле."

#: func.xml:19042(para)
msgid ""
"All of these functions take an optional <parameter>missing_ok</parameter> "
"parameter, which specifies the behavior when the file or directory does not "
"exist. If <literal>true</literal>, the function returns NULL (except "
"<function>pg_ls_dir</function>, which returns an empty result set). If "
"<literal>false</literal>, an error is raised. The default is <literal>false</"
"literal>."
msgstr ""
"Все эти функции принимают необязательный параметр <parameter>missing_ok</"
"parameter>, который определяет их поведение в случае отсутствия файла или "
"каталога. Если он равен <literal>true</literal>, функция возвращает NULL (за "
"исключением <function>pg_ls_dir</function>, которая возвращает пустое "
"множество). Если он равен <literal>false</literal>, возникает ошибка. "
"Значение по умолчанию — <literal>false</literal>."

#: func.xml:19050(indexterm)
msgid "<primary>pg_ls_dir</primary>"
msgstr "<primary>pg_ls_dir</primary>"

#: func.xml:19053(para)
msgid ""
"<function>pg_ls_dir</function> returns the names of all files (and "
"directories and other special files) in the specified directory. The "
"<parameter> include_dot_dirs</parameter> indicates whether <quote>.</quote> "
"and <quote>..</quote> are included in the result set. The default is to "
"exclude them (<literal>false</literal>), but including them can be useful "
"when <parameter>missing_ok</parameter> is <literal>true</literal>, to "
"distinguish an empty directory from an non-existent directory."
msgstr ""
"<function>pg_ls_dir</function> возвращает имена всех файлов (а также "
"каталогов и других специальных файлов) в заданном каталоге. Параметр "
"<parameter>include_dot_dirs</parameter> определяет, будут ли в "
"результирующий набор включаться каталоги <quote>.</quote> и <quote>..</"
"quote>. По умолчанию они не включаются (<literal>false</literal>), но их "
"можно включить, чтобы с параметром <parameter>missing_ok</parameter> равным "
"<literal>true</literal>, пустой каталог можно было отличить от "
"несуществующего."

#: func.xml:19063(indexterm)
msgid "<primary>pg_read_file</primary>"
msgstr "<primary>pg_read_file</primary>"

#: func.xml:19066(para)
msgid ""
"<function>pg_read_file</function> returns part of a text file, starting at "
"the given <parameter>offset</parameter>, returning at most "
"<parameter>length</parameter> bytes (less if the end of file is reached "
"first). If <parameter>offset</parameter> is negative, it is relative to the "
"end of the file. If <parameter>offset</parameter> and <parameter>length</"
"parameter> are omitted, the entire file is returned. The bytes read from the "
"file are interpreted as a string in the server encoding; an error is thrown "
"if they are not valid in that encoding."
msgstr ""
"<function>pg_read_file</function> возвращает фрагмент текстового файла с "
"заданного смещения (<parameter>offset</parameter>), размером не больше "
"<parameter>length</parameter> байт (размер может быть меньше, если файл "
"кончится раньше). Если смещение <parameter>offset</parameter> отрицательно, "
"оно отсчитывается от конца файла. Если параметры <parameter>offset</"
"parameter> и <parameter>length</parameter> опущены, возвращается всё "
"содержимое файла. Прочитанные из файла байты обрабатываются как символы в "
"серверной кодировке; если они оказываются недопустимыми для этой кодировки, "
"возникает ошибка."

#: func.xml:19077(indexterm)
msgid "<primary>pg_read_binary_file</primary>"
msgstr "<primary>pg_read_binary_file</primary>"

#: func.xml:19086(programlisting)
#, no-wrap
msgid "SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');"
msgstr "SELECT convert_from(pg_read_binary_file('file_in_utf8.txt'), 'UTF8');"

#: func.xml:19080(para)
msgid ""
"<function>pg_read_binary_file</function> is similar to "
"<function>pg_read_file</function>, except that the result is a <type>bytea</"
"type> value; accordingly, no encoding checks are performed. In combination "
"with the <function>convert_from</function> function, this function can be "
"used to read a file in a specified encoding: <placeholder-1/>"
msgstr ""
"<function>pg_read_binary_file</function> подобна <function>pg_read_file</"
"function>, но её результат имеет тип <type>bytea</type>; как следствие, "
"никакие проверки кодировки не выполняются. В сочетании с "
"<function>convert_from</function> эту функцию можно применять для чтения "
"файлов в произвольной кодировке: <placeholder-1/>"

#: func.xml:19091(indexterm)
msgid "<primary>pg_stat_file</primary>"
msgstr "<primary>pg_stat_file</primary>"

#: func.xml:19100(programlisting)
#, no-wrap
msgid ""
"SELECT * FROM pg_stat_file('filename');\n"
"SELECT (pg_stat_file('filename')).modification;"
msgstr ""
"SELECT * FROM pg_stat_file('filename');\n"
"SELECT (pg_stat_file('filename')).modification;"

#: func.xml:19094(para)
msgid ""
"<function>pg_stat_file</function> returns a record containing the file size, "
"last accessed time stamp, last modified time stamp, last file status change "
"time stamp (Unix platforms only), file creation time stamp (Windows only), "
"and a <type>boolean</type> indicating if it is a directory. Typical usages "
"include: <placeholder-1/>"
msgstr ""
"<function>pg_stat_file</function> возвращает запись, содержащую размер "
"файла, время последнего обращения и последнего изменения, а также время "
"последнего изменения состояния (только в Unix-системах), время создания "
"(только в Windows) и признак типа <type>boolean</type>, показывающий, что "
"это каталог. Примеры использования: <placeholder-1/>"

#: func.xml:19109(title) func.xml:19118(title)
msgid "Advisory Lock Functions"
msgstr "Функции управления рекомендательными блокировками"

#: func.xml:19111(para)
msgid ""
"The functions shown in <xref linkend=\"functions-advisory-locks-table\"/> "
"manage advisory locks. For details about proper use of these functions, see "
"<xref linkend=\"advisory-locks\"/>."
msgstr ""
"Функции, перечисленные в <xref remap=\"6\" linkend=\"functions-advisory-"
"locks-table\"/>, предназначены для управления рекомендательными "
"блокировками. Подробнее об их использовании можно узнать в <xref remap=\"6\" "
"linkend=\"advisory-locks\"/>."

#: func.xml:19128(parameter) func.xml:19142(parameter)
#: func.xml:19156(parameter) func.xml:19177(parameter)
#: func.xml:19191(parameter) func.xml:19205(parameter)
#: func.xml:19219(parameter) func.xml:19233(parameter)
#: func.xml:19247(parameter) func.xml:19261(parameter)
msgid "key"
msgstr "key"

#: func.xml:19128(function)
msgid "pg_advisory_lock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_lock(<placeholder-1/> <placeholder-2/>)"

#: func.xml:19131(entry) func.xml:19138(entry)
msgid "Obtain exclusive session level advisory lock"
msgstr "Получает исключительную блокировку на уровне сеанса"

#: func.xml:19135(parameter) func.xml:19149(parameter)
#: func.xml:19163(parameter) func.xml:19184(parameter)
#: func.xml:19198(parameter) func.xml:19212(parameter)
#: func.xml:19226(parameter) func.xml:19240(parameter)
#: func.xml:19254(parameter) func.xml:19268(parameter)
msgid "key1"
msgstr "key1"

#: func.xml:19135(parameter) func.xml:19149(parameter)
#: func.xml:19163(parameter) func.xml:19184(parameter)
#: func.xml:19198(parameter) func.xml:19212(parameter)
#: func.xml:19226(parameter) func.xml:19240(parameter)
#: func.xml:19254(parameter) func.xml:19268(parameter)
msgid "key2"
msgstr "key2"

#: func.xml:19135(function)
msgid ""
"pg_advisory_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_advisory_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:19142(function)
msgid "pg_advisory_lock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_lock_shared(<placeholder-1/> <placeholder-2/>)"

#: func.xml:19145(entry) func.xml:19152(entry)
msgid "Obtain shared session level advisory lock"
msgstr "Получает разделяемую блокировку на уровне сеанса"

#: func.xml:19149(function)
msgid ""
"pg_advisory_lock_shared(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_advisory_lock_shared(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:19156(function)
msgid "pg_advisory_unlock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_unlock(<placeholder-1/> <placeholder-2/>)"

#: func.xml:19159(entry) func.xml:19166(entry)
msgid "Release an exclusive session level advisory lock"
msgstr "Освобождает исключительную блокировку на уровне сеанса"

#: func.xml:19163(function)
msgid ""
"pg_advisory_unlock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_advisory_unlock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:19170(function)
msgid "pg_advisory_unlock_all()"
msgstr "pg_advisory_unlock_all()"

#: func.xml:19173(entry)
msgid "Release all session level advisory locks held by the current session"
msgstr ""
"Освобождает все блокировки на уровне сеанса, удерживаемые в данном сеансе"

#: func.xml:19177(function)
msgid "pg_advisory_unlock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_unlock_shared(<placeholder-1/> <placeholder-2/>)"

#: func.xml:19180(entry) func.xml:19187(entry)
msgid "Release a shared session level advisory lock"
msgstr "Освобождает разделяемую блокировку на уровне сеанса"

#: func.xml:19184(function)
msgid ""
"pg_advisory_unlock_shared(<placeholder-1/> <placeholder-2/>, <placeholder-3/"
"> <placeholder-4/>)"
msgstr ""
"pg_advisory_unlock_shared(<placeholder-1/> <placeholder-2/>, <placeholder-3/"
"> <placeholder-4/>)"

#: func.xml:19191(function)
msgid "pg_advisory_xact_lock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_xact_lock(<placeholder-1/> <placeholder-2/>)"

#: func.xml:19194(entry) func.xml:19201(entry)
msgid "Obtain exclusive transaction level advisory lock"
msgstr "Получает исключительную блокировку на уровне транзакции"

#: func.xml:19198(function)
msgid ""
"pg_advisory_xact_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_advisory_xact_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:19205(function)
msgid "pg_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>)"

#: func.xml:19208(entry) func.xml:19215(entry)
msgid "Obtain shared transaction level advisory lock"
msgstr "Получает разделяемую блокировку на уровне транзакции"

#: func.xml:19212(function)
msgid ""
"pg_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#: func.xml:19219(function)
msgid "pg_try_advisory_lock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_try_advisory_lock(<placeholder-1/> <placeholder-2/>)"

#: func.xml:19222(entry) func.xml:19229(entry)
msgid "Obtain exclusive session level advisory lock if available"
msgstr "Получает исключительную блокировку на уровне сеанса, если это возможно"

#: func.xml:19226(function)
msgid ""
"pg_try_advisory_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"
msgstr ""
"pg_try_advisory_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/> "
"<placeholder-4/>)"

#: func.xml:19233(function)
msgid "pg_try_advisory_lock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_try_advisory_lock_shared(<placeholder-1/> <placeholder-2/>)"

#: func.xml:19236(entry) func.xml:19243(entry)
msgid "Obtain shared session level advisory lock if available"
msgstr "Получает разделяемую блокировку на уровне сеанса, если это возможно"

#: func.xml:19240(function)
msgid ""
"pg_try_advisory_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_try_advisory_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#: func.xml:19247(function)
msgid "pg_try_advisory_xact_lock(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_try_advisory_xact_lock(<placeholder-1/> <placeholder-2/>)"

#: func.xml:19250(entry) func.xml:19257(entry)
msgid "Obtain exclusive transaction level advisory lock if available"
msgstr ""
"Получает исключительную блокировку на уровне транзакции, если это возможно"

#: func.xml:19254(function)
msgid ""
"pg_try_advisory_xact_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/"
"> <placeholder-4/>)"
msgstr ""
"pg_try_advisory_xact_lock(<placeholder-1/> <placeholder-2/>, <placeholder-3/"
"> <placeholder-4/>)"

#: func.xml:19261(function)
msgid "pg_try_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>)"
msgstr "pg_try_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>)"

#: func.xml:19264(entry) func.xml:19271(entry)
msgid "Obtain shared transaction level advisory lock if available"
msgstr ""
"Получает разделяемую блокировку на уровне транзакции, если это возможно"

#: func.xml:19268(function)
msgid ""
"pg_try_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"
msgstr ""
"pg_try_advisory_xact_lock_shared(<placeholder-1/> <placeholder-2/>, "
"<placeholder-3/> <placeholder-4/>)"

#: func.xml:19277(indexterm)
msgid "<primary>pg_advisory_lock</primary>"
msgstr "<primary>pg_advisory_lock</primary>"

#: func.xml:19280(para)
msgid ""
"<function>pg_advisory_lock</function> locks an application-defined resource, "
"which can be identified either by a single 64-bit key value or two 32-bit "
"key values (note that these two key spaces do not overlap). If another "
"session already holds a lock on the same resource identifier, this function "
"will wait until the resource becomes available. The lock is exclusive. "
"Multiple lock requests stack, so that if the same resource is locked three "
"times it must then be unlocked three times to be released for other "
"sessions' use."
msgstr ""
"<function>pg_advisory_lock</function> блокирует определённый приложением "
"ресурс, задаваемый одним 64-битным или двумя 32-битными ключами (заметьте, "
"что их значения не пересекаются). Если идентификатор этого ресурса "
"удерживает другой сеанс, эта функция не завершится, пока ресурс не станет "
"доступным. Данная функция устанавливает блокировку в исключительном режиме. "
"Если поступает сразу несколько запросов на блокировку, они накапливаются, "
"так что если один ресурс был заблокирован три раза, его необходимо три раза "
"разблокировать, чтобы он был доступен в других сеансах."

#: func.xml:19291(indexterm)
msgid "<primary>pg_advisory_lock_shared</primary>"
msgstr "<primary>pg_advisory_lock_shared</primary>"

#: func.xml:19294(para)
msgid ""
"<function>pg_advisory_lock_shared</function> works the same as "
"<function>pg_advisory_lock</function>, except the lock can be shared with "
"other sessions requesting shared locks. Only would-be exclusive lockers are "
"locked out."
msgstr ""
"<function>pg_advisory_lock_shared</function> работает подобно "
"<function>pg_advisory_lock</function>, но позволяет разделять блокировку с "
"другими сеансами, запрашивающими её как разделяемую. Выполнение может быть "
"приостановлено, только если другой сеанс запросил её в исключительном режиме."

#: func.xml:19301(indexterm)
msgid "<primary>pg_try_advisory_lock</primary>"
msgstr "<primary>pg_try_advisory_lock</primary>"

#: func.xml:19304(para)
msgid ""
"<function>pg_try_advisory_lock</function> is similar to "
"<function>pg_advisory_lock</function>, except the function will not wait for "
"the lock to become available. It will either obtain the lock immediately and "
"return <literal>true</literal>, or return <literal>false</literal> if the "
"lock cannot be acquired immediately."
msgstr ""
"<function>pg_try_advisory_lock</function> работает подобно "
"<function>pg_advisory_lock</function>, но не ждёт освобождения ресурса. Эта "
"функция либо немедленно получает блокировку и возвращает <literal>true</"
"literal>, либо сразу возвращает <literal>false</literal>, если получить её "
"не удаётся."

#: func.xml:19312(indexterm)
msgid "<primary>pg_try_advisory_lock_shared</primary>"
msgstr "<primary>pg_try_advisory_lock_shared</primary>"

#: func.xml:19315(para)
msgid ""
"<function>pg_try_advisory_lock_shared</function> works the same as "
"<function>pg_try_advisory_lock</function>, except it attempts to acquire a "
"shared rather than an exclusive lock."
msgstr ""
"<function>pg_try_advisory_lock_shared</function> работает как "
"<function>pg_try_advisory_lock</function>, но пытается получить разделяемую, "
"а не исключительную блокировку."

#: func.xml:19321(indexterm)
msgid "<primary>pg_advisory_unlock</primary>"
msgstr "<primary>pg_advisory_unlock</primary>"

#: func.xml:19324(para)
msgid ""
"<function>pg_advisory_unlock</function> will release a previously-acquired "
"exclusive session level advisory lock. It returns <literal>true</literal> if "
"the lock is successfully released. If the lock was not held, it will return "
"<literal>false</literal>, and in addition, an SQL warning will be reported "
"by the server."
msgstr ""
"<function>pg_advisory_unlock</function> освобождает ранее полученную "
"исключительную блокировку на уровне сеанса. Если блокировка освобождена "
"успешна, эта функция возвращает <literal>true</literal>, а если она не была "
"занята &mdash; <literal>false</literal>, при этом сервер выдаёт "
"предупреждение SQL."

#: func.xml:19332(indexterm)
msgid "<primary>pg_advisory_unlock_shared</primary>"
msgstr "<primary>pg_advisory_unlock_shared</primary>"

#: func.xml:19335(para)
msgid ""
"<function>pg_advisory_unlock_shared</function> works the same as "
"<function>pg_advisory_unlock</function>, except it releases a shared session "
"level advisory lock."
msgstr ""
"<function>pg_advisory_unlock_shared</function> работает подобно "
"<function>pg_advisory_unlock</function>, но освобождает разделяемую "
"блокировку на уровне сеанса."

#: func.xml:19341(indexterm)
msgid "<primary>pg_advisory_unlock_all</primary>"
msgstr "<primary>pg_advisory_unlock_all</primary>"

#: func.xml:19344(para)
msgid ""
"<function>pg_advisory_unlock_all</function> will release all session level "
"advisory locks held by the current session. (This function is implicitly "
"invoked at session end, even if the client disconnects ungracefully.)"
msgstr ""
"<function>pg_advisory_unlock_all</function> освобождает все блокировки на "
"уровне сеанса, закреплённые за текущим сеансом. (Эта функция неявно "
"вызывается в конце любого сеанса, даже при нештатном отключении клиента.)"

#: func.xml:19350(indexterm)
msgid "<primary>pg_advisory_xact_lock</primary>"
msgstr "<primary>pg_advisory_xact_lock</primary>"

#: func.xml:19353(para)
msgid ""
"<function>pg_advisory_xact_lock</function> works the same as "
"<function>pg_advisory_lock</function>, except the lock is automatically "
"released at the end of the current transaction and cannot be released "
"explicitly."
msgstr ""
"<function>pg_advisory_xact_lock</function> работает подобно "
"<function>pg_advisory_lock</function>, но её блокировка автоматически "
"освобождается в конце текущей транзакции и не может быть освобождена явным "
"образом."

#: func.xml:19359(indexterm)
msgid "<primary>pg_advisory_xact_lock_shared</primary>"
msgstr "<primary>pg_advisory_xact_lock_shared</primary>"

#: func.xml:19362(para)
msgid ""
"<function>pg_advisory_xact_lock_shared</function> works the same as "
"<function>pg_advisory_lock_shared</function>, except the lock is "
"automatically released at the end of the current transaction and cannot be "
"released explicitly."
msgstr ""
"<function>pg_advisory_xact_lock_shared</function> подобна функции "
"<function>pg_advisory_lock_shared</function>, но её блокировка автоматически "
"освобождается в конце текущей транзакции и не может быть освобождена явным "
"образом."

#: func.xml:19368(indexterm)
msgid "<primary>pg_try_advisory_xact_lock</primary>"
msgstr "<primary>pg_try_advisory_xact_lock</primary>"

#: func.xml:19371(para)
msgid ""
"<function>pg_try_advisory_xact_lock</function> works the same as "
"<function>pg_try_advisory_lock</function>, except the lock, if acquired, is "
"automatically released at the end of the current transaction and cannot be "
"released explicitly."
msgstr ""
"<function>pg_try_advisory_xact_lock</function> работает подобно "
"<function>pg_try_advisory_lock</function>, но её блокировка (если она была "
"получена) автоматически освобождается в конце текущей транзакции и не может "
"быть освобождена явным образом."

#: func.xml:19378(indexterm)
msgid "<primary>pg_try_advisory_xact_lock_shared</primary>"
msgstr "<primary>pg_try_advisory_xact_lock_shared</primary>"

#: func.xml:19381(para)
msgid ""
"<function>pg_try_advisory_xact_lock_shared</function> works the same as "
"<function>pg_try_advisory_lock_shared</function>, except the lock, if "
"acquired, is automatically released at the end of the current transaction "
"and cannot be released explicitly."
msgstr ""
"<function>pg_try_advisory_xact_lock_shared</function> работает подобно "
"<function>pg_try_advisory_lock_shared</function>, но её блокировка (если она "
"была получена) автоматически освобождается в конце текущей транзакции и не "
"может быть освобождена явным образом."

#: func.xml:19393(title)
msgid "Trigger Functions"
msgstr "Триггерные функции"

#: func.xml:19395(indexterm)
msgid "<primary>suppress_redundant_updates_trigger</primary>"
msgstr "<primary>suppress_redundant_updates_trigger</primary>"

#: func.xml:19399(para)
msgid ""
"Currently <productname>PostgreSQL</productname> provides one built in "
"trigger function, <function>suppress_redundant_updates_trigger</function>, "
"which will prevent any update that does not actually change the data in the "
"row from taking place, in contrast to the normal behavior which always "
"performs the update regardless of whether or not the data has changed. (This "
"normal behavior makes updates run faster, since no checking is required, and "
"is also useful in certain cases.)"
msgstr ""
"В настоящее время в <productname>PostgreSQL</productname> есть единственная "
"встроенная триггерная функция, <function>suppress_redundant_updates_trigger</"
"function>, которая предотвращает изменения, фактически не влияющие на данные "
"в строке, тогда как обычно изменения выполняются вне зависимости от того, "
"были ли изменены данные. (Обычное поведение не предполагает сравнения "
"данных, поэтому изменения выполняются быстрее, и в ряде случаев именно это "
"поведение желательно.)"

#: func.xml:19410(para)
msgid ""
"Ideally, you should normally avoid running updates that don't actually "
"change the data in the record. Redundant updates can cost considerable "
"unnecessary time, especially if there are lots of indexes to alter, and "
"space in dead rows that will eventually have to be vacuumed. However, "
"detecting such situations in client code is not always easy, or even "
"possible, and writing expressions to detect them can be error-prone. An "
"alternative is to use <function>suppress_redundant_updates_trigger</"
"function>, which will skip updates that don't change the data. You should "
"use this with care, however. The trigger takes a small but non-trivial time "
"for each record, so if most of the records affected by an update are "
"actually changed, use of this trigger will actually make the update run "
"slower."
msgstr ""
"В идеале, следует избегать операций изменения, которые фактически не меняют "
"данные в записях. Подобные ненужные изменения могут обходиться дорого, "
"особенно когда требуется обновлять множество индексов, к тому же "
"впоследствии базу данных придётся очищать от &laquo;мёртвых&raquo; строк. "
"Однако выявить такие изменения в клиентском коде бывает сложно, если вообще "
"возможно, а при составлении соответствующих проверочных выражений легко "
"допустить ошибку. В качестве альтернативного решения можно использовать "
"функцию <function>suppress_redundant_updates_trigger</function>, которая "
"опускает изменения, не меняющие данные. Однако использовать её следует с "
"осторожностью. Данный триггер выполняется не большое, но значительное время "
"для каждой записи, так что если большинство записей всё-таки фактически "
"изменяются, этот триггер скорее замедлит операцию изменения."

#: func.xml:19428(programlisting)
#, no-wrap
msgid ""
"CREATE TRIGGER z_min_update\n"
"BEFORE UPDATE ON tablename\n"
"FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();"
msgstr ""
"CREATE TRIGGER z_min_update\n"
"BEFORE UPDATE ON tablename\n"
"FOR EACH ROW EXECUTE PROCEDURE suppress_redundant_updates_trigger();"

#: func.xml:19425(para)
msgid ""
"The <function>suppress_redundant_updates_trigger</function> function can be "
"added to a table like this: <placeholder-1/> In most cases, you would want "
"to fire this trigger last for each row. Bearing in mind that triggers fire "
"in name order, you would then choose a trigger name that comes after the "
"name of any other trigger you might have on the table."
msgstr ""
"Функцию <function>suppress_redundant_updates_trigger</function> можно "
"привязать к таблице так: <placeholder-1/> В большинстве случаев этот триггер "
"должен вызываться для каждой строки последним. А так как триггеры вызываются "
"по порядку сортировки их имён, имя для него нужно выбирать таким, чтобы оно "
"было последним среди имён всех триггеров, которые могут быть в таблице."

#: func.xml:19438(para)
msgid ""
"For more information about creating triggers, see <xref linkend=\"sql-"
"createtrigger\"/>."
msgstr ""
"Подробнее о создании триггеров можно узнать в описании <xref linkend=\"sql-"
"createtrigger\"/>."

#: func.xml:19445(title)
msgid "Event Trigger Functions"
msgstr "Функции событийных триггеров"

#: func.xml:19447(para)
msgid ""
"<productname>PostgreSQL</productname> provides these helper functions to "
"retrieve information from event triggers."
msgstr ""
"<productname>PostgreSQL</productname> предоставляет следующие "
"вспомогательные функции для получения информации в событийных триггерах."

#: func.xml:19452(para)
msgid ""
"For more information about event triggers, see <xref linkend=\"event-triggers"
"\"/>."
msgstr ""
"Подробнее о событийных триггерах можно узнать в <xref remap=\"6\" linkend="
"\"event-triggers\"/>."

#: func.xml:19458(title)
msgid "Capturing Changes at Command End"
msgstr "Получение изменений в конце команды"

#: func.xml:19460(indexterm)
msgid "<primary>pg_event_trigger_ddl_commands</primary>"
msgstr "<primary>pg_event_trigger_ddl_commands</primary>"

#: func.xml:19480(entry) func.xml:19567(entry)
msgid "Type"
msgstr "Тип"

#: func.xml:19487(literal) func.xml:19574(literal)
msgid "classid"
msgstr "classid"

#: func.xml:19488(type) func.xml:19493(type) func.xml:19575(type)
#: func.xml:19580(type) func.xml:19712(type)
msgid "Oid"
msgstr "Oid"

#: func.xml:19489(entry)
msgid "OID of catalog the object belongs in"
msgstr "OID каталога, к которому относится объект"

#: func.xml:19492(literal) func.xml:19579(literal)
msgid "objid"
msgstr "objid"

#: func.xml:19494(entry)
msgid "OID of the object in the catalog"
msgstr "OID объекта в каталоге"

#: func.xml:19497(literal) func.xml:19584(literal)
msgid "objsubid"
msgstr "objsubid"

#: func.xml:19499(entry) func.xml:19586(entry)
msgid "Object sub-id (e.g. attribute number for columns)"
msgstr "Идентификатор подобъекта (например, номер для столбцов)"

#: func.xml:19502(literal)
msgid "command_tag"
msgstr "command_tag"

#: func.xml:19504(entry)
msgid "command tag"
msgstr "Тег команды"

#: func.xml:19507(literal) func.xml:19609(literal)
msgid "object_type"
msgstr "object_type"

#: func.xml:19509(entry) func.xml:19611(entry)
msgid "Type of the object"
msgstr "Тип объекта"

#: func.xml:19512(literal) func.xml:19614(literal)
msgctxt "literal"
msgid "schema_name"
msgstr "schema_name"

#: func.xml:19514(entry)
msgid ""
"Name of the schema the object belongs in, if any; otherwise <literal>NULL</"
"literal>. No quoting is applied."
msgstr ""
"Имя схемы, к которой относится объект; если объект не относится ни к какой "
"схеме &mdash; <literal>NULL</literal>. В кавычки имя не заключается."

#: func.xml:19520(literal) func.xml:19631(literal)
msgid "object_identity"
msgstr "object_identity"

#: func.xml:19522(entry) func.xml:19633(entry)
msgid ""
"Text rendering of the object identity, schema-qualified. Each and every "
"identifier present in the identity is quoted if necessary."
msgstr ""
"Текстовое представление идентификатора объекта, дополненного схемой. "
"Компоненты этого идентификаторы могут заключаться в кавычки, если требуется."

#: func.xml:19528(literal)
msgid "in_extension"
msgstr "in_extension"

#: func.xml:19530(entry)
msgid "whether the command is part of an extension script"
msgstr "является ли команда частью скрипта расширения"

#: func.xml:19533(literal)
msgid "command"
msgstr "command"

#: func.xml:19534(type)
msgid "pg_ddl_command"
msgstr "pg_ddl_command"

#: func.xml:19535(entry)
msgid ""
"A complete representation of the command, in internal format. This cannot be "
"output directly, but it can be passed to other functions to obtain different "
"pieces of information about the command."
msgstr ""
"Полное представление команды, во внутреннем формате. Его нельзя вывести "
"непосредственно, но можно передать другим функциям, чтобы получить различные "
"сведения о команде."

#: func.xml:19464(para)
msgid ""
"<function>pg_event_trigger_ddl_commands</function> returns a list of "
"<acronym>DDL</acronym> commands executed by each user action, when invoked "
"in a function attached to a <literal>ddl_command_end</literal> event "
"trigger. If called in any other context, an error is raised. "
"<function>pg_event_trigger_ddl_commands</function> returns one row for each "
"base command executed; some commands that are a single SQL sentence may "
"return more than one row. This function returns the following columns: "
"<placeholder-1/>"
msgstr ""
"Функция <function>pg_event_trigger_ddl_commands</function> возвращает список "
"команд <acronym>DDL</acronym>, выполняемых в результате действия "
"пользователя. Вызывать её можно только в функции, реализующей событийный "
"триггер <literal>ddl_command_end</literal>. При попытке вызвать её в любом "
"другом контексте возникнет ошибка. Функция "
"<function>pg_event_trigger_ddl_commands</function> возвращает одну строку "
"для каждой базовой команды; для некоторых команд, записываемых в виде одного "
"предложения SQL, может возвращаться несколько строк. Эта функция возвращает "
"следующие столбцы: <placeholder-1/>"

#: func.xml:19549(title)
msgid "Processing Objects Dropped by a DDL Command"
msgstr "Обработка объектов, удалённых командой DDL"

#: func.xml:19551(indexterm)
msgid "<primary>pg_event_trigger_dropped_objects</primary>"
msgstr "<primary>pg_event_trigger_dropped_objects</primary>"

#: func.xml:19576(entry)
msgid "OID of catalog the object belonged in"
msgstr "OID каталога, к которому относился объект"

#: func.xml:19581(entry)
msgid "OID the object had within the catalog"
msgstr "OID, который имел объект в каталоге"

#: func.xml:19585(type)
msgid "int32"
msgstr "int32"

#: func.xml:19589(literal)
msgid "original"
msgstr "original"

#: func.xml:19591(entry)
msgid "Flag used to identify the root object(s) of the deletion"
msgstr "Флаг, обозначающий исходный удаляемый объект(ы)"

#: func.xml:19594(literal)
msgid "normal"
msgstr "normal"

#: func.xml:19596(entry)
msgid ""
"Flag indicating that there's a normal dependency relationship in the "
"dependency graph leading to this object"
msgstr ""
"Флаг, обозначающий, что к этому объекту в графе зависимостей привело "
"отношение обычной зависимости"

#: func.xml:19602(literal)
msgid "is_temporary"
msgstr "is_temporary"

#: func.xml:19604(entry)
msgid "Flag indicating that the object was a temporary object."
msgstr "Флаг, обозначающий, что объект был временным."

#: func.xml:19616(entry)
msgid ""
"Name of the schema the object belonged in, if any; otherwise <literal>NULL</"
"literal>. No quoting is applied."
msgstr ""
"Имя схемы, к которой относился объект; если объект не относился ни к какой "
"схеме &mdash; <literal>NULL</literal>. В кавычки имя не заключается."

#: func.xml:19622(literal)
msgid "object_name"
msgstr "object_name"

#: func.xml:19624(entry)
msgid ""
"Name of the object, if the combination of schema and name can be used as a "
"unique identifier for the object; otherwise <literal>NULL</literal>. No "
"quoting is applied, and name is never schema-qualified."
msgstr ""
"Имя объекта, если сочетание схемы и имени позволяет уникально "
"идентифицировать объект; в противном случае &mdash; <literal>NULL</literal>. "
"Имя не заключается в кавычки и не дополняется именем схемы."

#: func.xml:19639(literal)
msgid "address_names"
msgstr "address_names"

#: func.xml:19641(entry)
msgid ""
"An array that, together with <literal>object_type</literal> and "
"<literal>address_args</literal>, can be used by the "
"<function>pg_get_object_address()</function> to recreate the object address "
"in a remote server containing an identically named object of the same kind."
msgstr ""
"Массив, который в сочетании с <literal>object_type</literal> и массивом "
"<literal>address_args</literal> можно передать функции "
"<function>pg_get_object_address()</function> и воссоздать адрес объекта на "
"удалённом сервере, содержащем одноимённый объект того же рода."

#: func.xml:19650(literal)
msgid "address_args"
msgstr "address_args"

#: func.xml:19652(entry)
msgid "Complement for <literal>address_names</literal> above."
msgstr "Дополнение предшествующего массива <literal>address_names</literal>."

#: func.xml:19555(para)
msgid ""
"<function>pg_event_trigger_dropped_objects</function> returns a list of all "
"objects dropped by the command in whose <literal>sql_drop</literal> event it "
"is called. If called in any other context, "
"<function>pg_event_trigger_dropped_objects</function> raises an error. "
"<function>pg_event_trigger_dropped_objects</function> returns the following "
"columns: <placeholder-1/>"
msgstr ""
"Функция <function>pg_event_trigger_dropped_objects</function> возвращает "
"список всех объектов, удалённых командой, вызвавшей событие "
"<literal>sql_drop</literal>. При вызове в другом контексте "
"<function>pg_event_trigger_dropped_objects</function> выдаёт ошибку. "
"<function>pg_event_trigger_dropped_objects</function> возвращает следующие "
"столбцы: <placeholder-1/>"

#: func.xml:19664(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION test_event_trigger_for_drops()\n"
"        RETURNS event_trigger LANGUAGE plpgsql AS $$\n"
"DECLARE\n"
"    obj record;\n"
"BEGIN\n"
"    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n"
"    LOOP\n"
"        RAISE NOTICE '% dropped object: % %.% %',\n"
"                     tg_tag,\n"
"                     obj.object_type,\n"
"                     obj.schema_name,\n"
"                     obj.object_name,\n"
"                     obj.object_identity;\n"
"    END LOOP;\n"
"END\n"
"$$;\n"
"CREATE EVENT TRIGGER test_event_trigger_for_drops\n"
"   ON sql_drop\n"
"   EXECUTE PROCEDURE test_event_trigger_for_drops();"
msgstr ""
"CREATE FUNCTION test_event_trigger_for_drops()\n"
"        RETURNS event_trigger LANGUAGE plpgsql AS $$\n"
"DECLARE\n"
"    obj record;\n"
"BEGIN\n"
"    FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()\n"
"    LOOP\n"
"        RAISE NOTICE '% dropped object: % %.% %',\n"
"                     tg_tag,\n"
"                     obj.object_type,\n"
"                     obj.schema_name,\n"
"                     obj.object_name,\n"
"                     obj.object_identity;\n"
"    END LOOP;\n"
"END\n"
"$$;\n"
"CREATE EVENT TRIGGER test_event_trigger_for_drops\n"
"   ON sql_drop\n"
"   EXECUTE PROCEDURE test_event_trigger_for_drops();"

#: func.xml:19661(para)
msgid ""
"The <function>pg_event_trigger_dropped_objects</function> function can be "
"used in an event trigger like this: <placeholder-1/>"
msgstr ""
"Функцию <function>pg_event_trigger_dropped_objects</function> можно "
"использовать в событийном триггере так: <placeholder-1/>"

#: func.xml:19689(title)
msgid "Handling a Table Rewrite Event"
msgstr "Обработка события перезаписи таблицы"

#: func.xml:19691(para)
msgid ""
"The functions shown in <xref linkend=\"functions-event-trigger-table-rewrite"
"\"/> provide information about a table for which a <literal>table_rewrite</"
"literal> event has just been called. If called in any other context, an "
"error is raised."
msgstr ""
"В <xref remap=\"6\" linkend=\"functions-event-trigger-table-rewrite\"/> "
"показаны функции, выдающие информацию о таблице, для которой произошло "
"событие перезаписи таблицы (<literal>table_rewrite</literal>). При попытке "
"вызвать их в другом контексте возникнет ошибка."

#: func.xml:19700(title)
msgid "Table Rewrite information"
msgstr "Информация о перезаписи таблицы"

#: func.xml:19709(indexterm)
msgid "<primary>pg_event_trigger_table_rewrite_oid</primary>"
msgstr "<primary>pg_event_trigger_table_rewrite_oid</primary>"

#: func.xml:19710(function)
msgid "pg_event_trigger_table_rewrite_oid()"
msgstr "pg_event_trigger_table_rewrite_oid()"

#: func.xml:19713(entry)
msgid "The OID of the table about to be rewritten."
msgstr "OID таблицы, которая будет перезаписана."

#: func.xml:19718(indexterm)
msgid "<primary>pg_event_trigger_table_rewrite_reason</primary>"
msgstr "<primary>pg_event_trigger_table_rewrite_reason</primary>"

#: func.xml:19719(function)
msgid "pg_event_trigger_table_rewrite_reason()"
msgstr "pg_event_trigger_table_rewrite_reason()"

#: func.xml:19722(entry)
msgid ""
"The reason code(s) explaining the reason for rewriting. The exact meaning of "
"the codes is release dependent."
msgstr ""
"Код причины, показывающий, чем вызвана перезапись. Точное значение кодов "
"зависит от выпуска (версии)."

#: func.xml:19734(programlisting)
#, no-wrap
msgid ""
"CREATE FUNCTION test_event_trigger_table_rewrite_oid()\n"
" RETURNS event_trigger\n"
" LANGUAGE plpgsql AS\n"
"$$\n"
"BEGIN\n"
"  RAISE NOTICE 'rewriting table % for reason %',\n"
"                pg_event_trigger_table_rewrite_oid()::regclass,\n"
"                pg_event_trigger_table_rewrite_reason();\n"
"END;\n"
"$$;\n"
"\n"
"CREATE EVENT TRIGGER test_table_rewrite_oid\n"
"                  ON table_rewrite\n"
"   EXECUTE PROCEDURE test_event_trigger_table_rewrite_oid();"
msgstr ""
"CREATE FUNCTION test_event_trigger_table_rewrite_oid()\n"
" RETURNS event_trigger\n"
" LANGUAGE plpgsql AS\n"
"$$\n"
"BEGIN\n"
"  RAISE NOTICE 'rewriting table % for reason %',\n"
"                pg_event_trigger_table_rewrite_oid()::regclass,\n"
"                pg_event_trigger_table_rewrite_reason();\n"
"END;\n"
"$$;\n"
"\n"
"CREATE EVENT TRIGGER test_table_rewrite_oid\n"
"                  ON table_rewrite\n"
"   EXECUTE PROCEDURE test_event_trigger_table_rewrite_oid();"

#: func.xml:19731(para)
msgid ""
"The <function>pg_event_trigger_table_rewrite_oid</function> function can be "
"used in an event trigger like this: <placeholder-1/>"
msgstr ""
"Функцию <function>pg_event_trigger_table_rewrite_oid</function> можно "
"использовать в событийном триггере так: <placeholder-1/>"

#. Put one translator per line, in the form of NAME <EMAIL>, YEAR1, YEAR2
#: func.xml:0(None)
msgid "translator-credits"
msgstr "translator-credits"

#~ msgid ""
#~ "trim(<placeholder-1/> <placeholder-2/>\n"
#~ "        <placeholder-3/>\n"
#~ "        <optional><placeholder-4/></optional> )"
#~ msgstr ""
#~ "trim(<placeholder-1/> <placeholder-2/>\n"
#~ "        <placeholder-3/>\n"
#~ "        <optional><placeholder-4/></optional> )"

#~ msgid ""
#~ "btrim(<placeholder-1/> <placeholder-2/>\n"
#~ "        <placeholder-3/>)"
#~ msgstr ""
#~ "btrim(<placeholder-1/> <placeholder-2/>\n"
#~ "        <placeholder-3/>)"

#~ msgid ""
#~ "ltrim(<placeholder-1/> <placeholder-2/>\n"
#~ "        <placeholder-3/>)"
#~ msgstr ""
#~ "ltrim(<placeholder-1/> <placeholder-2/>\n"
#~ "        <placeholder-3/>)"

#~ msgid ""
#~ "rtrim(<placeholder-1/> <placeholder-2/>\n"
#~ "         <placeholder-3/>)"
#~ msgstr ""
#~ "rtrim(<placeholder-1/> <placeholder-2/>\n"
#~ "         <placeholder-3/>)"

#~ msgid ""
#~ "trim(<placeholder-1/>\n"
#~ "        <placeholder-2/> from <placeholder-3/>)"
#~ msgstr ""
#~ "trim(<placeholder-1/>\n"
#~ "        <placeholder-2/> from <placeholder-3/>)"

#~ msgid ""
#~ "btrim(<placeholder-1/>\n"
#~ "        <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"
#~ msgstr ""
#~ "btrim(<placeholder-1/>\n"
#~ "        <placeholder-2/>, <placeholder-3/> <placeholder-4/>)"

#~ msgid "'fat' 'cat' 'rat'"
#~ msgstr "'fat' 'cat' 'rat'"

#~ msgid "replace target with substitute within query"
#~ msgstr "заменяет целевой подзапрос подстановкой"
