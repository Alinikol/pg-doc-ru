<!-- doc/src/sgml/plpgsql.sgml -->

<!-- en
<chapter id="plpgsql">
  <title><application>PL/pgSQL</application> - <acronym>SQL</acronym> Procedural Language</title>
-->
<chapter id="plpgsql">
  <title><application>PL/pgSQL</application> - процедурный язык <acronym>SQL</acronym></title>

 <indexterm zone="plpgsql">
  <primary>PL/pgSQL</primary>
 </indexterm>

 <sect1 id="plpgsql-overview">
 <!-- en
  <title>Overview</title>
 -->
  <title>Обзор</title>

 <para>
  <application>PL/pgSQL</application> это процедурный язык для СУБД 
  <productname>PostgreSQL</productname>.  
  Целью проектирования <application>PL/pgSQL</> было создание загружаемого процедурного языка, который:

    <itemizedlist>
     <listitem>
      <para>
       используется для создания функций и триггеров,
      </para>
     </listitem>
     <listitem>
      <para>
       добавляет управляющие структуры к языку <acronym>SQL</acronym>,
      </para>
     </listitem>
     <listitem>
      <para>
       может выполнять сложные вычисления,
      </para>
     </listitem>
     <listitem>
      <para>
       наследует все пользовательские типы, функции и операторы,
      </para>
     </listitem>
     <listitem>
      <para>
       может быть определен как доверенный язык,
      </para>
     </listitem>
     <listitem>
      <para>
       прост в использовании.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    Функции <application>PL/pgSQL</application> могут использоваться везде, где допустимы встроенные функции.
    Например, можно создать функции со сложными вычислениями и условной логикой, 
    а затем использовать их при определении операторов или в индексных выражениях.
   </para>

   <para>
    В версии <productname>PostgreSQL</> 9.0 и выше, <application>PL/pgSQL</application> устанавливается по умолчанию.
    Тем не менее, это по-прежнему загружаемый модуль и администраторы, особо заботящиеся о безопасности, могут удалить его при необходимости.
   </para>


  <sect2 id="plpgsql-advantages">
<!-- en
   <title>Advantages of Using <application>PL/pgSQL</application></title>
-->
   <title>Преимущества использования <application>PL/pgSQL</application></title>

    <para>
     <productname>PostgreSQL</> и большинство других СУБД используют <acronym>SQL</acronym> в качестве языка запросов.
     <acronym>SQL</acronym> хорошо переносим и прост в изучении. 
     Однако каждый оператор <acronym>SQL</acronym> выполняется индивидуально на сервере базы данных.
    </para>

    <para>
     Это значит, что ваше клиентское приложение должно каждый запрос отправлять на сервер, ждать пока он будет обработан, 
     получать результат, делать некоторые вычисления, затем отправлять последующие запросы на сервер.
     Всё это требует межпроцессного взаимодействия, а также несет нагрузку на сеть, если
     клиент и сервер базы данных расположены на разных компьютерах.
    </para>


    <para>
     <application>PL/pgSQL</application> позволяет сгруппировать блок вычислений и последовательность запросов
     <emphasis>внутри</emphasis> сервера базы данных, таким образом, мы получаем силу процедурного языка и простоту 
     использования <acronym>SQL</acronym> при значительной экономии накладных расходов на клиент-серверное взаимодействие.
    </para>
    <itemizedlist>

     <listitem><para> 
     Исключаются дополнительные обращения между клиентом и сервером
     </para></listitem>

     <listitem><para>
     Промежуточные ненужные результаты не передаются между сервером и клиентом
     </para></listitem>

     <listitem><para> 
     Есть возможность избежать многочисленных разборов одного запроса
     </para></listitem>

    </itemizedlist>

    <para> 
     В результате это приводит к значительному увеличению производительности по сравнению с приложением, 
     которое не использует хранимых функций.
    </para>

    <para>
     Кроме того, <application>PL/pgSQL</application> позволяет использовать все типы данных, операторы и функции <acronym>SQL</acronym>.
    </para>

  </sect2>

  <sect2 id="plpgsql-args-results">
<!-- en
   <title>Supported Argument and Result Data Types</title>
-->
   <title>Поддерживаемые типы данных аргументов и возвращаемых значений</title>

    <para>
     <application>PL/pgSQL</application> функции могут принимать в качестве 
     аргументов все поддерживаемые сервером скалярные типы данных или массивы
     и возвращать в качестве результата любой из этих типов. Они могут принимать
     и возвращать именованные составные типы (строковый тип). Также есть возможность
     объявить <application>PL/pgSQL</application> функцию, возвращающую 
     <type>record</>, это означает, что результатом является строковый тип,
     чьи столбцы будут определены в спецификации вызывающего запроса, как описано в 
     <xref linkend="queries-tablefunctions">.
    </para>

    <para>
     Использование маркера <literal>VARIADIC</> позволяет объявлять 
     <application>PL/pgSQL</> функции с переменным числом аргументов.
     Это работает точно так же, как и для SQL функций, как описано в
     <xref linkend="xfunc-sql-variadic-functions">.
    </para>

    <para>
     <application>PL/pgSQL</> функции могут принимать и возвращать полиморфные
     типы <type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>,
     <type>anyenum</> и <type>anyrange</type>. В таких случаях фактические типы данных
     могут меняться от вызова к вызову, как описано в
     <xref linkend="extend-types-polymorphic">.
     Пример показан в <xref linkend="plpgsql-declaration-parameters">.
    </para>

    <para>
     <application>PL/pgSQL</> функции могут возвращать <quote>set</> (или таблицу)
     любого типа, который может быть возвращен в качестве одного экземпляра.
     Такие функции генерируют вывод, выполняя команду <command>RETURN NEXT</> 
     для каждого элемента результирующего набора или <command>RETURN QUERY</>
     для вывода результата запроса.
    </para>

    <para>
     Наконец, при отсутствии полезного возвращаемого значения
     <application>PL/pgSQL</> функция может возвращать <type>void</>.
    </para>

    <para>
     <application>PL/pgSQL</> функции можно объявить с выходными параметрами
     вместо явного задания типа возвращаемого значения.
     Это не добавляет никаких фундаментальных возможностей языку, но часто бывает удобно,
     особенно для возвращения нескольких значений.
     Нотация <literal>RETURNS TABLE</> может использоваться вместо <literal>RETURNS SETOF</>.
    </para>

    <para>
     Конкретные примеры рассматриваются в 
     <xref linkend="plpgsql-declaration-parameters"> и
     <xref linkend="plpgsql-statements-returning">.
    </para>
  </sect2>
 </sect1>

 <sect1 id="plpgsql-structure">
<!-- en
  <title>Structure of <application>PL/pgSQL</application></title>
-->
  <title>Структура <application>PL/pgSQL</application></title>

  <para>
   <application>PL/pgSQL</application> это блочно-структурированный язык.
   Текст определения функции должен быть <firstterm>блоком</>. 
   Структура блока:

<synopsis>
<optional> &lt;&lt;<replaceable>метка</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>объявления</replaceable> </optional>
BEGIN
    <replaceable>операторы</replaceable>
END <optional> <replaceable>метка</replaceable> </optional>;
</synopsis>
    </para>

    <para>
     Каждое объявление и каждый оператор в блоке должны завершаться
     символом ";"(точка с запятой). Блок, вложенный в другой блок, должен
     иметь точку с запятой после <literal>END</literal>, как показано выше.
     Однако финальный <literal>END</literal>, завершающий тело функции,
     не требует точки с запятой.
    </para>

    <tip>
     <para>
      Распространенной ошибкой является добавление точки с запятой сразу после
      <literal>BEGIN</>.  Это неправильно и приведет к синтаксической ошибке.
     </para>
    </tip>

    <para>
     <replaceable>Метка</replaceable> требуется только тогда, когда нужно
     идентифицировать блок в операторе <literal>EXIT</>, или квалифицировать
     имена переменных, объявленных в этом блоке. Если метка указана после 
     <literal>END</>, то она должна совпадать с меткой в начале блока.
    </para>

    <para>
     Ключевые слова не чувствительны к регистру символов.
     Как и в обычных SQL командах, идентификаторы неявно преобразуются 
     к нижнему регистру, если они не взяты в двойные кавычки.
    </para>

    <para>
     Комментарии в <application>PL/pgSQL</> коде работают так же, как и в обычном SQL.
     Двойное тире (<literal>--</literal>) начинает комментарий, который завершается 
     в конце строки. Блочный комментарий начинается с <literal>/*</literal> 
     и завершается <literal>*/</literal>. Блочные комментарии могут быть вложенными.
    </para>

    <para>
     Любой оператор в выполняемой секции блока может быть <firstterm>вложенным блоком</>.
     Вложенные блоки используются для логической группировки нескольких операторов или
     локализации области действия переменных для группы операторов. 
     Во время выполнения вложенного блока переменные, объявленные в нем, 
     скрывают переменные внешних блоков с такими же именами.
     Чтобы получить доступ к внешним переменным, нужно квалифицировать их имена меткой блока.
     Например:
<programlisting>
CREATE FUNCTION somefunc() RETURNS integer AS $$
&lt;&lt; outerblock &gt;&gt;
DECLARE
    quantity integer := 30;
BEGIN
    RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 30
    quantity := 50;
    --
    -- Создаем вложенный блок
    --
    DECLARE
        quantity integer := 80;
    BEGIN
        RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 80
        RAISE NOTICE 'Во внешнем блоке quantity = %', outerblock.quantity;  -- Выводится 50
    END;

    RAISE NOTICE 'Сейчас quantity = %', quantity;  -- Выводится 50

    RETURN quantity;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

    <note>
     <para>
      Существует скрытый <quote>внешний блок</>, окружающий тело каждой 
      <application>PL/pgSQL</> функции. Этот блок содержит объявления параметров
      функции (если они есть), а также некоторые специальные переменные, такие как 
      <literal>FOUND</literal> (смотри <xref linkend="plpgsql-statements-diagnostics">).
      Этот блок имеет метку, совпадающую с именем функции, таким образом, параметры и 
      специальные переменные могут быть квалифицированы именем функции.
     </para>
    </note>

    <para>
     Важно не путать использование <command>BEGIN</>/<command>END</> 
     для группировки операторов в <application>PL/pgSQL</> с одноименными
     SQL командами для управления транзакциями.
     <command>BEGIN</>/<command>END</> в <application>PL/pgSQL</> служат только
     для группировки предложений; они не начинают и не заканчивают транзакции.
     Функции и триггерные процедуры всегда выполняются в рамках транзакции, начатой
     во внешнем запросе - они не могут начать или завершить эту транзакцию, т.к.
     у них внутри нет контекста для выполнения таких действий. 
     Однако блок содержащий секцию <literal>EXCEPTION</> создает вложенную 
     транзакцию, которая может быть отменена, не затрагивая внешней транзакции.
     Дополнительно об этом смотри <xref linkend="plpgsql-error-trapping">.
    </para>
  </sect1>

  <sect1 id="plpgsql-declarations">
<!-- en
    <title>Declarations</title>
-->
    <title>Объявления</title>

    <para>
     Все переменные, используемые в блоке, должны быть определены в секции объявления.
     (За исключением переменной-счетчика цикла <literal>FOR</>, которая
     объявляется автоматически. 
     Для цикла по диапазону чисел автоматически объявляется целочисленная переменная, 
     а для цикла по результатам курсора - переменная типа <literal>record</>.)
    </para>

    <para>
     <application>PL/pgSQL</> переменные могут иметь любой тип данных SQL, такой как
     <type>integer</type>, <type>varchar</type>,  <type>char</type>.
    </para>

    <para>
     Примеры объявления переменных:
<programlisting>
user_id integer;
quantity numeric(5);
url varchar;
myrow tablename%ROWTYPE;
myfield tablename.columnname%TYPE;
arow RECORD;
</programlisting>
    </para>

    <para>
     Общий синтаксис объявления переменной:
<synopsis>
<replaceable>name</replaceable> <optional> CONSTANT </optional> <replaceable>type</replaceable> <optional> COLLATE <replaceable>collation_name</replaceable> </optional> <optional> NOT NULL </optional> <optional> { DEFAULT | := | = } <replaceable>expression</replaceable> </optional>;
</synopsis>
      Фраза <literal>DEFAULT</>, если присутствует, задает начальное значение, которое 
      присваивается переменной при входе в блок. Если отсутствует, то переменная 
      инициализируется SQL значением <literal>NULL</>.
      Опция <literal>CONSTANT</> предотвращает изменение значения переменной 
      после инициализации, таким образом, значение остается постоянным в течение всего блока.
      Опция <literal>COLLATE</> определяет схему упорядочения, которая будет использоваться 
      для этой переменной (смотри <xref linkend="plpgsql-declaration-collation">).
      Если указано <literal>NOT NULL</>, то попытка присвоить <literal>NULL</>
      во время выполнения приведет к ошибке. Все переменные, объявленные как
      <literal>NOT NULL</>, должны иметь не пустые значения по умолчанию.
      Можно использовать знак равенства (<literal>=</>) вместо совместимого 
      с PL/SQL <literal>:=</>.
     </para>

     <para>
      Значение по умолчанию вычисляется и присваивается переменной каждый раз
      при входе в блок (не только при первом вызове функции).
      Так, например, если переменная типа <type>timestamp</> имеет функцию <literal>now()</> 
      в качестве значения по умолчанию, это приведет к тому, что переменная всегда 
      будет содержать время текущего вызова функции, а не время, 
      когда функция была предварительно скомпилирована.
     </para>

     <para>
      Примеры:
<programlisting>
quantity integer DEFAULT 32;
url varchar := 'http://mysite.com';
user_id CONSTANT integer := 10;
</programlisting>
     </para>

    <sect2 id="plpgsql-declaration-parameters">
<!-- en
     <title>Declaring Function Parameters</title>
-->
     <title>Объявление параметров функции</title>

     <para>
      Переданные в функцию параметры именуются идентификаторами 
      <literal>$1</literal>, <literal>$2</literal>, и т.д.  
      Дополнительно, для улучшения читаемости, можно объявить псевдонимы для параметров
      <literal>$<replaceable>n</replaceable></literal>.
      Либо псевдоним, либо цифровой идентификатор используются для 
      обозначения параметра.
     </para>

     <para>
      Создать псевдоним можно двумя способами.
      Предпочтительный способ это дать имя параметру в команде
      <command>CREATE FUNCTION</command>, например:
<programlisting>
CREATE FUNCTION sales_tax(subtotal real) RETURNS real AS $$
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
      Другой способ это явное объявление псевдонима при помощи синтаксиса:
<synopsis>
<replaceable>name</replaceable> ALIAS FOR $<replaceable>n</replaceable>;
</synopsis>

      Предыдущий пример для этого стиля выглядит так:
<programlisting>
CREATE FUNCTION sales_tax(real) RETURNS real AS $$
DECLARE
    subtotal ALIAS FOR $1;
BEGIN
    RETURN subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

    <note>
     <para>
      Эти два примера не полностью эквивалентны. В первом случае,
      на <literal>subtotal</> можно ссылаться как <literal>sales_tax.subtotal</>, 
      а во втором случае такая ссылка невозможна.
      (Если бы к внутреннему блоку была добавлена метка, то <literal>subtotal</>
      можно было бы квалифицировать этой меткой.)
     </para>
    </note>

     <para>
      Еще несколько примеров:
<programlisting>
CREATE FUNCTION instr(varchar, integer) RETURNS integer AS $$
DECLARE
    v_string ALIAS FOR $1;
    index ALIAS FOR $2;
BEGIN
    -- здесь вычисления, использующие v_string и index
END;
$$ LANGUAGE plpgsql;


CREATE FUNCTION concat_selected_fields(in_t sometablename) RETURNS text AS $$
BEGIN
    RETURN in_t.f1 || in_t.f3 || in_t.f5 || in_t.f7;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     <para>
      Когда <application>PL/pgSQL</application> функция объявляется 
      с выходными параметрами, им выдаются цифровые идентификаторы 
      <literal>$<replaceable>n</replaceable></literal> и 
      для них можно создавать псевдонимы точно таким же способом, как и 
      для обычных входных параметров.
      Выходной параметр это фактически переменная, стартующая с NULL
      и которой присваивается значение во время выполнения функции.
      Возвращается последнее присвоенное значение.
      Например, функция sales_tax может быть переписана так:

<programlisting>
CREATE FUNCTION sales_tax(subtotal real, OUT tax real) AS $$
BEGIN
    tax := subtotal * 0.06;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      Обратите внимание, что мы опустили <literal>RETURNS real</> &mdash;
      хотя можно было и включить, но это было бы излишним.
     </para>

     <para>
      Выходные параметры наиболее полезны для возвращения нескольких значений.
      Простейший пример:

<programlisting>
CREATE FUNCTION sum_n_product(x int, y int, OUT sum int, OUT prod int) AS $$
BEGIN
    sum := x + y;
    prod := x * y;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      Как обсуждалось в <xref linkend="xfunc-output-parameters">, 
      здесь фактически создается анонимный тип <literal>record</>
      для возвращения результата функции. Если используется фраза
      <literal>RETURNS</>, то она должна выглядеть как <literal>RETURNS record</>.
     </para>

     <para>
      Есть еще способ объявить <application>PL/pgSQL</application>
      функцию с использованием <literal>RETURNS TABLE</>, например:

<programlisting>
CREATE FUNCTION extended_sales(p_itemno int)
RETURNS TABLE(quantity int, total numeric) AS $$
BEGIN
    RETURN QUERY SELECT s.quantity, s.quantity * s.price FROM sales s
                 WHERE s.itemno = p_itemno;
END;
$$ LANGUAGE plpgsql;
</programlisting>

      Это в точности соответствует объявлению одного или нескольких
      <literal>OUT</> параметров и указанию 
      <literal>RETURNS SETOF <replaceable>sometype</></literal>.
     </para>

     <para>
      Для <application>PL/pgSQL</application> функции, возвращающей полиморфный тип
      (<type>anyelement</type>, <type>anyarray</type>, <type>anynonarray</type>,
      <type>anyenum</type>, <type>anyrange</type>), 
      создается специальный параметр <literal>$0</literal>.
      Его тип данных соответствует типу, фактически возвращаемому функцией, и который
      устанавливается на основании фактических типов входных параметров
      (смотри <xref linkend="extend-types-polymorphic">).
      Это позволяет функции получить доступ к фактически возвращаемому типу данных,
      как показано в <xref linkend="plpgsql-declaration-type">.
      Параметр <literal>$0</literal> инициализируется в <literal>NULL</> 
      и его можно изменять внутри функции. Таким образом, его можно использовать
      для хранения возвращаемого значения, хотя это необязательно.
      Параметру <literal>$0</literal> можно дать псевдоним.
      В следующем примере функция работает с любым типом данных, поддерживающим
      оператор <literal>+</>:

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement)
RETURNS anyelement AS $$
DECLARE
    result ALIAS FOR $0;
BEGIN
    result := v1 + v2 + v3;
    RETURN result;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>

     <para>
      Такой же эффект получается при объявлении одного или нескольких
      выходных параметров полиморфного типа. При этом <literal>$0</literal> не создается; 
      выходные параметры сами используются для этой цели. Например:

<programlisting>
CREATE FUNCTION add_three_values(v1 anyelement, v2 anyelement, v3 anyelement,
                                 OUT sum anyelement)
AS $$
BEGIN
    sum := v1 + v2 + v3;
END;
$$ LANGUAGE plpgsql;
</programlisting>
     </para>
    </sect2>

  <sect2 id="plpgsql-declaration-alias">
<!-- en
   <title><literal>ALIAS</></title>
-->
   <title>Псевдонимы (<literal>ALIAS</>)</title>

<synopsis>
<replaceable>newname</> ALIAS FOR <replaceable>oldname</>;
</synopsis>

   <para>
    Синтаксис <literal>ALIAS</> более общий, чем предполагалось в предыдущем разделе:
    псевдонимы можно объявлять для любых переменных, а не только для параметров функции.
    Основная практическая польза в том, чтобы назначить другие имена переменным
    с предопределенными названиями, таким как <varname>NEW</varname> 
    или <varname>OLD</varname> в триггерной процедуре.
   </para>

   <para>
    Примеры:
<programlisting>
DECLARE
  prior ALIAS FOR old;
  updated ALIAS FOR new;
</programlisting>
   </para>

   <para>
    Поскольку <literal>ALIAS</> дает два различных способа именования одних 
    и тех же объектов, то его неограниченное использование может привести к путанице.
    Лучше всего использовать <literal>ALIAS</> для переименования предопределенных имен.
   </para>
   </sect2>

  <sect2 id="plpgsql-declaration-type">
<!-- en
   <title>Copying Types</title>
-->
   <title>Наследование типов данных</title>

<synopsis>
<replaceable>variable</replaceable>%TYPE
</synopsis>

   <para>
    Конструкция <literal>%TYPE</literal> предоставляет тип данных переменной 
    или столбца таблицы. Её можно использовать для объявления переменных,
    содержащих значения из базы данных. Например, для объявления
    переменной с таким же типом, как и столбец <literal>user_id</literal>
    в таблице <literal>users</literal> нужно написать:
<programlisting>
user_id users.user_id%TYPE;
</programlisting>
   </para>

   <para>
    Используя <literal>%TYPE</literal> не нужно знать тип данных структуры, 
    на которую ссылаетесь. И самое главное, если в будущем тип данных изменится
    (например: тип данных для <literal>user_id</> поменяется с <type>integer</type> 
    на <type>real</type>), то вам может не понадобиться изменять определение функции.
   </para>

   <para>
    Использование <literal>%TYPE</literal> особенно полезно в полиморфных функциях, 
    поскольку типы данных, необходимые для внутренних переменных,
    могут меняться от одного вызова к другому. 
    Соответствующие переменные могут быть созданы с применением 
    <literal>%TYPE</literal> к аргументам и возвращаемому значению функции.
   </para>

  </sect2>

    <sect2 id="plpgsql-declaration-rowtypes">
<!-- en
     <title>Row Types</title>
-->
     <title>Строковый тип</title>

<synopsis>
<replaceable>name</replaceable> <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
<replaceable>name</replaceable> <replaceable>composite_type_name</replaceable>;
</synopsis>

   <para>
    Переменная составного типа называется строковой (<firstterm>row</>) переменной
    или переменной строкового типа (<firstterm>row-type</>).
    Значением такой переменной может быть целая строка, полученная в результате
    выполнения запроса <command>SELECT</> или <command>FOR</>, при условии, 
    что набор столбцов запроса соответствует заявленному типу переменной.
    Доступ к отдельным значениям полей строковой переменной осуществляется, как обычно,
    через точку, например <literal>rowvar.field</literal>.
   </para>

   <para>
    Строковая переменная может быть объявлена с таким же типом, как и строка
    в существующей таблице или представлении, используя нотацию
    <replaceable>table_name</replaceable><literal>%ROWTYPE</literal>;
    или при объявлении указывается имя составного типа.
    (Поскольку каждая таблица имеет соответствующий составной тип с таким же именем,
    то на самом деле, в <productname>PostgreSQL</> не имеет значения, пишете ли вы 
    <literal>%ROWTYPE</literal> или нет.  Но использование <literal>%ROWTYPE</literal>
    более переносимо.)
   </para>

   <para>
    Параметры функции могут быть составного типа (строки таблицы). В этом случае
    соответствующий идентификатор <literal>$<replaceable>n</replaceable></>
    будет строковой переменной, поля которой можно выбирать, 
    например <literal>$1.user_id</literal>.
   </para>

   <para>
    Только определенные пользователем столбцы таблицы доступны в переменной
    строкового типа, но не OID или другие системные столбцы (потому что это может
    быть строка представления). Поля строкового типа наследуют размер и точность 
    от типов данных столбцов таблицы, таких как
    <type>char(<replaceable>n</>)</type>.
   </para>

   <para>
    Ниже приведен пример использования составных типов.
    <structname>table1</> и <structname>table2</> это существующие таблицы,
    имеющие, по меньшей мере, перечисленные столбцы:

<programlisting>
CREATE FUNCTION merge_fields(t_row table1) RETURNS text AS $$
DECLARE
    t2_row table2%ROWTYPE;
BEGIN
    SELECT * INTO t2_row FROM table2 WHERE ... ;
    RETURN t_row.f1 || t2_row.f3 || t_row.f5 || t2_row.f7;
END;
$$ LANGUAGE plpgsql;

SELECT merge_fields(t.*) FROM table1 t WHERE ... ;
</programlisting>
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-records">
<!-- en
   <title>Record Types</title>
-->
   <title>Тип <type>record</></title>

<synopsis>
<replaceable>name</replaceable> RECORD;
</synopsis>

   <para>
    Переменные типа <type>record</> похожи на переменные строкового типа, но они
    не имеют предопределенной структуры. Они приобретают фактическую структуру
    от строки, которая им присваивается командами <command>SELECT</> или <command>FOR</>.
    Структура переменной типа <type>record</> может меняться каждый раз при присвоении значения.
    Следствием этого является то, что пока значение не присвоено первый раз,
    переменная типа <type>record</> не имеет структуры и любая попытка получить доступ 
    к отдельному полю приведет к ошибке во время исполнения. 
   </para>

   <para>
    Обратите внимание, что <literal>RECORD</> это не подлинный тип данных, 
    а только лишь заполнитель. Также следует понимать, что 
    <application>PL/pgSQL</application> функция,
    имеющая тип возвращаемого значения <type>record</>, это не то же самое, 
    что и переменная типа <type>record</>, хотя такая функция может использовать переменную
    типа <type>record</> для хранения своего результата. В обоих случаях фактическая
    структура строки неизвестна во время создания функции, но для функции,
    возвращающей <type>record</>, фактическая структура определяется 
    во время разбора вызывающего запроса, в то время как переменная
    типа <type>record</> может менять свою структуру на лету.
   </para>
  </sect2>

  <sect2 id="plpgsql-declaration-collation">
<!-- en
   <title>Collation of <application>PL/pgSQL</application> Variables</title>
-->
   <title>Упорядочение <application>PL/pgSQL</application> переменных</title>

   <indexterm>
    <primary>collation</>
    <secondary>in PL/pgSQL</>
   </indexterm>

   <para>
    При каждом вызове <application>PL/pgSQL</application> функции определяется схема 
    упорядочения, которая зависит от соответствующих схем каждого фактического 
    аргумента, как описано в <xref linkend="collation">. Если схема упорядочения 
    успешно определена (т.е. среди аргументов нет конфликтов между неявными схемами 
    упорядочения), то все соответствующие параметры неявно трактуются как имеющие эту 
    схему упорядочения.  Внутри функции это будет влиять на поведение операторов, 
    зависящих от используемой схемы упорядочения. Рассмотрим пример:

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b;
END;
$$ LANGUAGE plpgsql;

SELECT less_than(text_field_1, text_field_2) FROM table1;
SELECT less_than(text_field_1, text_field_2 COLLATE "C") FROM table1;
</programlisting>

    В первом случае <function>less_than</> будет использовать для сравнения общую 
    схему упорядочения для <structfield>text_field_1</> и <structfield>text_field_2</>, 
    в то время как во втором случае будет использоваться схема <literal>C</>.
   </para>

   <para>
    Кроме того, определенная для вызова функции схема упорядочения также будет 
    использоваться для любых локальных переменных соответствующего типа. Таким образом, 
    функция не станет работать по-другому, если её переписать так:

<programlisting>
CREATE FUNCTION less_than(a text, b text) RETURNS boolean AS $$
DECLARE
    local_a text := a;
    local_b text := b;
BEGIN
    RETURN local_a &lt; local_b;
END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
    Если нет параметров с типами данных, требующих схемы упорядочения, или для 
    параметров невозможно определить общую схему, тогда параметры и локальные 
    переменные используют схемы по умолчанию их типа данных (которые обычно совпадают 
    со схемой по умолчанию базы данных, но могут отличаться для переменных доменных 
    типов).
   </para>

   <para>
    Локальная переменная может иметь схему упорядочения отличную от схемы по умолчанию. 
    Для этого используется опция <literal>COLLATE</> в объявлении переменной, например:

<programlisting>
DECLARE
    local_a text COLLATE "en_US";
</programlisting>

    Эта опция переопределяет схему упорядочения, которую получила бы переменная 
    в соответствии с вышеуказанными правилами.
   </para>

   <para>
    И, конечно же, можно явно указывать опцию <literal>COLLATE</> для конкретных 
    операций внутри функции, если к ним требуется применить конкретную схему 
    упорядочения. Например:

<programlisting>
CREATE FUNCTION less_than_c(a text, b text) RETURNS boolean AS $$
BEGIN
    RETURN a &lt; b COLLATE "C";
END;
$$ LANGUAGE plpgsql;
</programlisting>

    Как и в обычной SQL команде, это переопределяет схемы упорядочения, связанные 
    с полями таблицы, параметрами и локальными переменными, которые используются 
    в данном выражении.
   </para>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-expressions">
<!-- en
  <title>Expressions</title>
-->
  <title>Выражения</title>
    <para>
     Все выражения, используемые в <application>PL/pgSQL</application>
     операторах, обрабатываются основной <acronym>SQL</acronym> машиной сервера.
     Например, для вычисления такого выражения:
<synopsis>
IF <replaceable>expression</replaceable> THEN ...
</synopsis>
     <application>PL/pgSQL</application> отправит следующий запрос 
     SQL машине:
<synopsis>
SELECT <replaceable>expression</replaceable>
</synopsis>
     При формировании команды <command>SELECT</> все вхождения
     имен <application>PL/pgSQL</application> переменных
     заменяются параметрами, как подробно описано в 
     <xref linkend="plpgsql-var-subst">.
     Это позволяет один раз подготовить план выполнения команды
     <command>SELECT</command> и повторно использовать его в последующих 
     вычислениях с различными значениями переменных.
     Таким образом, при первом использовании выражения, по сути происходит
     выполнение команды <command>PREPARE</>.
     Например, если мы объявили две целочисленные переменные 
     <literal>x</> и <literal>y</>, и написали:
<programlisting>
IF x &lt; y THEN ...
</programlisting>
     то, что реально происходит за сценой, эквивалентно:
<programlisting>
PREPARE <replaceable>statement_name</>(integer, integer) AS SELECT $1 &lt; $2;
</programlisting>
     и затем, эта подготовленная команда исполняется (<command>EXECUTE</>)
     для каждого оператора <command>IF</> с текущими значениями 
     <application>PL/pgSQL</application> переменных, переданных как
     значения параметров.
     Обычно эти детали не важны для пользователей 
     <application>PL/pgSQL</application>, но их полезно знать
     при диагностировании проблем. Более подробная информация появится в
     <xref linkend="plpgsql-plan-caching">.
    </para>
  </sect1>

  <sect1 id="plpgsql-statements">
<!-- en
  <title>Basic Statements</title>
-->
  <title>Основные операторы</title>

   <para>
    В этом и последующих разделах описаны все типы операторов, которые
    понимает <application>PL/pgSQL</application>. 
    Все, что не признается в качестве одного из этих типов операторов, 
    считается командой SQL и отправляется для исполнения в основную
    машину базы данных, как описано в 
    <xref linkend="plpgsql-statements-sql-noresult">
    и <xref linkend="plpgsql-statements-sql-onerow">.
   </para>

   <sect2 id="plpgsql-statements-assignment">
<!-- en
    <title>Assignment</title>
-->
    <title>Присваивания</title>

    <para>
     Присвоение значения <application>PL/pgSQL</application>
     переменной записывается в виде:
<synopsis>
<replaceable>variable</replaceable> { := | = } <replaceable>expression</replaceable>;
</synopsis>
     Как описывалось ранее, выражение в таком операторе вычисляется с помощью
     SQL команды <command>SELECT</>, посылаемой в основную машину базы данных.
     Выражение должно получить одно значение (возможно, значение строки, если
     переменная строкового типа или типа <type>record</>). Целевая переменная может
     быть простой переменной (опционально квалифицированной именем блока), 
     полем в переменной строкового типа или записи; или элементом массива,
     который является простой переменной или полем.
     Для присвоения можно использовать знак равенства (<literal>=</>) вместо 
     совместимого с PL/SQL <literal>:=</>.
    </para>

    <para>
     Если результирующий тип данных выражения не соответствует типу данных
     переменной, или переменная имеет определенный размер/точность (как
     <type>char(20)</type>), то результирующее значение будет неявно
     преобразовано интерпретатором <application>PL/pgSQL</application>,
     используя функцию вывода типа данных результата и функцию ввода типа данных
     переменной. Заметим, что это потенциально может привести к ошибкам времени 
     выполнения в функции ввода, если формат строки результирующего значения 
     не допустим для функции ввода.
    </para>

    <para>
     Примеры:
<programlisting>
tax := subtotal * 0.06;
my_record.user_id := 20;
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-noresult">
<!-- en
    <title>Executing a Command With No Result</title>
-->
    <title>Выполнение команды, не возвращающей результат</title>

    <para>
     В <application>PL/pgSQL</application> функции можно выполнить любую команду SQL, 
     не возвращающую строк, просто написав эту команду (например <command>INSERT</>
     без фразы <literal>RETURNING</>).
    </para>

    <para>
     Имя любой <application>PL/pgSQL</application> переменной в тексте команды 
     рассматривается как параметр, а затем текущее значение переменной подставляется 
     в качестве значения параметра во время выполнения. Это в точности совпадает 
     с описанной ранее обработкой для выражений; подробнее смотри 
     <xref linkend="plpgsql-var-subst">.
    </para>

    <para>
     При выполнении SQL команды таким образом, <application>PL/pgSQL</application>
     может кэшировать и повторно использовать план выполнения команды, 
     как обсуждается в <xref linkend="plpgsql-plan-caching">.
    </para>

    <para>
     Иногда бывает полезно вычислить значение выражения или запроса <command>SELECT</>, 
     но отказаться от результата, например, при вызове функции, у которой есть 
     побочные эффекты, но нет полезного результата.  
     Для этого в <application>PL/pgSQL</application>, 
     используется оператор <command>PERFORM</command>:

<synopsis>
PERFORM <replaceable>query</replaceable>;
</synopsis>

     Эта команда выполняет <replaceable>query</replaceable> и отбрасывает результат. 
     Запросы (<replaceable>query</replaceable>) пишутся таким же образом, 
     как и в команде SQL <command>SELECT</>, 
     но ключевое слово <command>SELECT</> заменяется на <command>PERFORM</command>. 
     Для запросов <command>WITH</> после <command>PERFORM</>
     нужно поместить запрос в скобки. (В этом случае запрос может вернуть только одну 
     строку.) <application>PL/pgSQL</application> переменные будут подставлены в запрос 
     так же, как и в команду, не возвращающую результат, план запроса также кэшируется.
     Кроме того, специальная переменная <literal>FOUND</literal> устанавливается 
     в истину, если запрос возвращает, по крайней мере, одну строку, или ложь, 
     если не возвращает ни одной строки (смотри 
     <xref linkend="plpgsql-statements-diagnostics">).
    </para>

    <note>
     <para>
      Можно предположить, что такой же результат получается непосредственно 
      командой <command>SELECT</command>, но в настоящее время использование 
      <command>PERFORM</command> является единственным  способом. 
      Команда SQL, которая может возвращать строки, например <command>SELECT</command>, 
      будет отклонена с ошибкой, если не имеет фразы <literal>INTO</>, 
      как описано в следующем разделе. 
     </para>
    </note>

    <para>
     Пример:
<programlisting>
PERFORM create_mv('cs_session_page_requests_mv', my_query);
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-sql-onerow">
<!-- en
    <title>Executing a Query with a Single-row Result</title>
-->
    <title>Выполнение запроса, возвращающего одну строку</title>

    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>SELECT INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <indexterm zone="plpgsql-statements-sql-onerow">
     <primary>RETURNING INTO</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <para>
     Результат SQL команды, возвращающей одну строку (возможно из нескольких столбцов), 
     может быть присвоен переменной типа <type>record</>, переменной строкового типа или 
     списку скалярных переменных. Для этого нужно к основной команде SQL добавить 
     фразу <literal>INTO</>. Так, например:

<synopsis>
SELECT <replaceable>select_expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable> FROM ...;
INSERT ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
UPDATE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
DELETE ... RETURNING <replaceable>expressions</replaceable> INTO <optional>STRICT</optional> <replaceable>target</replaceable>;
</synopsis>

     где <replaceable>target</replaceable> может быть переменной типа <type>record</>, 
     строковой переменной или разделенным через запятую списком скалярных переменных, 
     полей записи/строки. 
     <application>PL/pgSQL</application> переменные подставляются в оставшуюся 
     часть запроса, план выполнения кэшируется, так же, как было описано выше для команд, 
     не возвращающих строки. Это работает для команд 
     <command>SELECT</>, <command>INSERT</>/<command>UPDATE</>/<command>DELETE</> 
     с фразой <literal>RETURNING</> и утилит, возвращающих результат в виде набора строк 
     (таких, как <command>EXPLAIN</>). 
     За исключением фразы <literal>INTO</>, это те же SQL команды, 
     как их можно написать вне <application>PL/pgSQL</application>.
    </para>

   <tip>
    <para>
     Обратите внимание, что данная интерпретация <command>SELECT</> с <literal>INTO</> 
     полностью отличается от <productname>PostgreSQL</> команды 
     <command>SELECT INTO</command>, где в <literal>INTO</> указывается вновь 
     создаваемая таблица. Если вы хотите в <application>PL/pgSQL</application>
     функции создать таблицу, основанную на результате команды <command>SELECT</>, 
     используйте синтаксис <command>CREATE TABLE ... AS SELECT</command>. 
    </para>
   </tip>

    <para>
     Если результат запроса присваивается переменной строкового типа или списку 
     переменных, то они должны в точности соответствовать по количеству и типам 
     данных столбцам результата, иначе произойдет ошибка во время выполнения. 
     Если используется переменная типа <type>record</>, то она автоматически приводится к 
     строковому типу результата запроса. 
    </para>

    <para>
     Фраза INTO может появиться практически в любом месте SQL команды. 
     Обычно её записывают непосредственно перед или сразу после списка 
     <replaceable>select_expressions</replaceable> в <command>SELECT</>
     или в конце команды для команд других типов. Рекомендуется следовать 
     этому соглашению на случай, если парсер <application>PL/pgSQL</application>
     станет более строгим в будущих версиях.
    </para>

    <para>
     Если опция <literal>STRICT</literal> не указана во фразе <literal>INTO</>, 
     то в <replaceable>target</replaceable> присваивается первая строка 
     возвращенная запросом; или NULL, если запрос не вернул строк. 
     (Заметим, что понятие <quote>первая строка</> не четко определено 
     без использования <literal>ORDER BY</>.) 
     Все остальные строки результата после первой отбрасываются. 
     Можно проверить специальную переменную <literal>FOUND</literal> 
     (смотри <xref linkend="plpgsql-statements-diagnostics">), 
     чтобы определить была ли возвращена запись: 

<programlisting>
SELECT * INTO myrec FROM emp WHERE empname = myname;
IF NOT FOUND THEN
    RAISE EXCEPTION 'Сотрудник % не найден', myname;
END IF;
</programlisting>

     Если опция <literal>STRICT</literal> указана, то запрос должен вернуть ровно 
     одну строку или произойдет ошибка во время выполнения: 
     либо <literal>NO_DATA_FOUND</> (нет строк), либо <literal>TOO_MANY_ROWS</>
     (более одной строки). Можно использовать секцию исключений в блоке для 
     обработки ошибок, например:

<programlisting>
BEGIN
    SELECT * INTO STRICT myrec FROM emp WHERE empname = myname;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            RAISE EXCEPTION 'Сотрудник % не найден', myname;
        WHEN TOO_MANY_ROWS THEN
            RAISE EXCEPTION 'Сотрудник % уже существует', myname;
END;
</programlisting>

     После успешного выполнения команды с опцией <literal>STRICT</>, значение
     переменной <literal>FOUND</literal> всегда устанавливается в истину.
    </para>

    <para>
     Для <command>INSERT</>/<command>UPDATE</>/<command>DELETE</>
     с <literal>RETURNING</>, <application>PL/pgSQL</application> возвращает ошибку, 
     если выбрано более одной строки, даже в том случае, когда опция 
     <literal>STRICT</literal> не указана. Так происходит потому, 
     что у этих команд нет возможности, типа <literal>ORDER BY</>, 
     указать какая из задействованных строк должна быть возвращена.
    </para>

    <para>
     Если для функции доступна опция <literal>print_strict_params</>, то 
     при возникновении ошибки, связанной с нарушением условия 
     <literal>STRICT</>, в детальную (<literal>DETAIL</>) часть сообщения 
     об ошибке будет включена информация о параметрах переданных запросу.
     Изменить значение <literal>print_strict_params</> можно установкой 
     параметра <varname>plpgsql.print_strict_params</>. Но это повлияет
     только функции скомпилированные после изменения. Для конкретной функции
     можно использовать опцию компилятора, например:
<programlisting>
CREATE FUNCTION get_userid(username text) RETURNS int
AS $$
#print_strict_params on
DECLARE
    userid int;
BEGIN
    SELECT users.userid INTO STRICT userid
        FROM users WHERE users.username = get_userid.username;
    RETURN userid;
END
$$ LANGUAGE plpgsql;
</programlisting>
    В случае сбоя, будет сформировано примерно такое сообщение об ошибке
<programlisting>
ERROR:  query returned no rows
DETAIL:  parameters: $1 = 'nosuchuser'
CONTEXT:  PL/pgSQL function get_userid(text) line 6 at SQL statement
</programlisting>
    </para>

    <note>
     <para>
      Опция <literal>STRICT</> совпадает с поведением <command>SELECT INTO</command>
      и соответствующих операторов в Oracle PL/SQL.
     </para>
    </note>

    <para>
     Как действовать в случаях, когда требуется обработать несколько строк результата 
     смотри в <xref linkend="plpgsql-records-iterating">.
    </para>

   </sect2>

   <sect2 id="plpgsql-statements-executing-dyn">
<!-- en
    <title>Executing Dynamic Commands</title>
-->
    <title>Выполнение динамически формируемых команд</title>

    <para>
     Часто требуется динамически формировать команды внутри 
     <application>PL/pgSQL</application> функций, то есть такие команды, 
     в которых при каждом выполнении могут использоваться 
     разные таблицы или типы данных. Обычная практика <application>PL/pgSQL</application>
     кэшировать планы выполнения (как описано в <xref linkend="plpgsql-plan-caching">), 
     в случае с динамическими командами, работать не будет.
     Для исполнения динамических команд предусмотрен оператор <command>EXECUTE</command>:

<synopsis>
EXECUTE <replaceable class="command">command-string</replaceable> <optional> INTO <optional>STRICT</optional> <replaceable>target</replaceable> </optional> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     где <replaceable>command-string</replaceable> это выражение, формирующее строку 
     (типа <type>text</type>) с текстом команды, которую нужно выполнить.
     Необязательный <replaceable>target</replaceable>, куда присваивается результат команды, 
     может быть переменной типа <type>record</>, строковой переменной или разделенным через 
     запятую списком скалярных переменных, полей записи/строки. Необязательные выражения 
     во фразе <literal>USING</> формируют значения, которые будут вставлены в команду.
    </para>

    <para>
     В сформированном тексте команды замена имен переменных 
     <application>PL/pgSQL</> на их значения проводиться не будет.
     Все необходимые значения переменных должны быть вставлены в командную строку 
     при её построении, либо нужно использовать параметры, как описано ниже.
    </para>

    <para>
     Также, нет никакого плана кэширования для команд, выполняемых с помощью 
     <command>EXECUTE</command>. Вместо этого план создается каждый раз при выполнении. 
     Таким образом, строка команды может динамически создаваться внутри 
     функции для выполнения действий с различными таблицами и столбцами.
    </para>

    <para>
     Фраза <literal>INTO</literal> указывает, куда должны быть присвоены результаты SQL 
     команды, возвращающей строки. Если используется переменная строкового типа 
     или список переменных, то они должны в точности соответствовать структуре результата 
     запроса (когда используется переменная типа <type>record</>, она автоматически приводится 
     к строковому типу результата запроса). Если возвращается несколько строк, то только 
     первая будет присвоена переменной(-ым) в <literal>INTO</literal>. Если не возвращается 
     ни одной строки, то присваивается NULL. При отсутствии фразы 
     <literal>INTO</literal> результаты запроса отбрасываются.
    </para>

    <para>
     С опцией <literal>STRICT</> запрос должен вернуть ровно одну строку, 
     иначе выдается сообщение об ошибке.
    </para>

    <para>
     В тексте команды можно использовать значения параметров, ссылки на параметры 
     обозначаются как <literal>$1</>, <literal>$2</> и т.д. 
     Эти символы указывают на значения, находящиеся во фразе <literal>USING</>.
     Такой метод зачастую предпочтительнее, чем вставка значений в команду в виде текста: 
     это позволяет избегать во время исполнения дополнительных расходов на преобразования 
     значений в текст и обратно, и менее подвержено атакам при помощи 
     SQL-инъекций, так как не требуется заключать текст в кавычки и экранировать символы.
     Пример:
<programlisting>
EXECUTE 'SELECT count(*) FROM mytable WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
    </para>

    <para>
     Обратите внимание, что символы параметров могут быть использованы только в местах, 
     где должны быть значения.
     Если требуется динамически формировать имена таблиц или столбцов, то их необходимо 
     вставлять в виде текста. Например, если в предыдущем запросе необходимо динамически 
     задавать имя таблицы, можно сделать следующее:
<programlisting>
EXECUTE 'SELECT count(*) FROM '
    || tabname::regclass
    || ' WHERE inserted_by = $1 AND inserted &lt;= $2'
   INTO c
   USING checked_user, checked_date;
</programlisting>
     Еще одно ограничение состоит в том, что символы параметров могут использоваться только 
     в командах <command>SELECT</>, <command>INSERT</>, <command>UPDATE</>
     и <command>DELETE</>. В других типах операторов (обычно называемых утилитами), 
     необходимо вставлять значения в виде текста даже там, где требуются просто значения.
    </para>

    <para>
     Команда <command>EXECUTE</> c неизменяемым текстом и параметрами во фразе 
     USING (как в первом примере выше), функционально эквивалентна команде 
     записанной напрямую в <application>PL/pgSQL</application>, в которой переменные 
     <application>PL/pgSQL</application> автоматически заменяются значениями.
     Важное отличие в том, что <command>EXECUTE</> при каждом исполнении заново строит 
     план команды с учетом текущих значений параметров, тогда как 
     <application>PL/pgSQL</application> строит общий план выполнения и кэширует его 
     при повторном использовании. В тех случаях, когда наилучший план выполнения 
     сильно зависит от значений параметров, может быть полезно использовать 
     <command>EXECUTE</> для гарантии того, что не будет выбран общий план. 
    </para>

    <para>
     В настоящее время команда <command>SELECT INTO</command> не поддерживается в 
     <command>EXECUTE</command>, вместо этого нужно выполнять обычный <command>SELECT</>
     и использовать фразу <literal>INTO</> самой команды <command>EXECUTE</>.
    </para>

   <note>
    <para>
     Оператор <command>EXECUTE</command> в <application>PL/pgSQL</application>
     не имеет отношения к одноименному SQL оператору сервера 
     <productname>PostgreSQL</productname>. 
     Серверный <command>EXECUTE</command> не может напрямую использоваться в 
     <application>PL/pgSQL</> функциях (и в этом нет необходимости).
    </para>
   </note>

   <example id="plpgsql-quote-literal-example">
<!-- en
   <title>Quoting Values In Dynamic Queries</title>
-->
   <title>Использование кавычек в динамических запросах</title>

    <indexterm>
     <primary>quote_ident</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_literal</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>quote_nullable</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>

    <indexterm>
     <primary>format</primary>
     <secondary>use in PL/pgSQL</secondary>
    </indexterm>

    <para>
     При работе с динамическими командами часто приходится иметь дело с экранированием 
     одинарных кавычек. Рекомендуемым методом для взятия текста в кавычки в теле 
     функции является экранирование знаками доллара. (Если имеется унаследованный код, 
     не использующий этот метод, пожалуйста, обратитесь 
     к обзору в <xref linkend="plpgsql-quote-tips">, 
     это поможет сэкономить усилия при переводе кода к более приемлемому виду.)
    </para>

    <para>
     Необходимо соблюдать осторожность при вставке динамических значений в 
     конструируемый текст запроса, так как они могут сами содержать кавычки. 
     Пример (предполагается, что тело функции экранируется знаками доллара, 
     поэтому кавычки не нужно дублировать):
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_literal(newvalue)
        || ' WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
    </para>

    <para>
     Этот пример демонстрирует использование функций 
     <function>quote_ident</function> и <function>quote_literal</function>
     (смотри <xref linkend="functions-string">). 
     Для надежности, выражения, содержащие идентификаторы столбцов и таблиц должны 
     использовать функцию <function>quote_ident</function> при добавлении 
     в текст запроса. А для выражений со значениями, которые должны быть обычными 
     строками, используется функция <function>quote_literal</>. 
     Эти функции выполняют соответствующие шаги, чтобы вернуть текст, по ситуации 
     заключенный в двойные или одинарные кавычки и с правильно экранированными 
     специальными символами.
    </para>

    <para>
     Так как функция <function>quote_literal</function> помечена как 
     <literal>STRICT</literal>, то она всегда возвращает NULL, 
     если переданный ей аргумент имеет значение NULL. В приведенном выше примере, 
     если <literal>newvalue</> или <literal>keyvalue</> были NULL, 
     вся  строка с текстом запроса станет NULL, что приведет к ошибке в 
     <command>EXECUTE</command>. Для избегания этой проблемы
     используйте функцию <function>quote_nullable</>, 
     которая работает так же, как <function>quote_literal</> за исключением того, 
     что при вызове с пустым аргументом возвращает строку 'NULL'. Например:
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = '
        || quote_nullable(newvalue)
        || ' WHERE key = '
        || quote_nullable(keyvalue);
</programlisting>
     Если вы имеете дело со значениями, которые могут быть пустыми, то, как правило, 
     нужно использовать <function>quote_nullable</>
     вместо <function>quote_literal</>.
    </para>

    <para>
     Как обычно, необходимо убедиться, что пустые значения в запросе не принесут 
     неожиданных результатов. Например, следующая фраза <literal>WHERE</>
<programlisting>
'WHERE key = ' || quote_nullable(keyvalue)
</programlisting>
     никогда не вернет истину, если <literal>keyvalue</> - NULL, 
     так как применение <literal>=</> с операндом, имеющим значение NULL, 
     всегда дает NULL. Если требуется, чтобы NULL обрабатывалось как обычное значение, 
     то фразу выше нужно переписать так:
<programlisting>
'WHERE key IS NOT DISTINCT FROM ' || quote_nullable(keyvalue)
</programlisting>
     (В настоящее время <literal>IS NOT DISTINCT FROM</> работает 
     менее эффективно чем <literal>=</>, так что используйте этот способ, 
     если это действительно необходимо. 
     Смотри <xref linkend="functions-comparison"> для более подробной информации 
     о работе с NULL и <literal>IS DISTINCT</>.)
    </para>

    <para>
     Обратите внимание, что использование знака $ полезно только для взятия 
     в кавычки фиксированного текста. Плохая идея написать этот пример так:
<programlisting>
EXECUTE 'UPDATE tbl SET '
        || quote_ident(colname)
        || ' = $$'
        || newvalue
        || '$$ WHERE key = '
        || quote_literal(keyvalue);
</programlisting>
     потому что <literal>newvalue</> может также содержать <literal>$$</>.
     Эта же проблема может возникнуть и с любым другим разделителем, используемым 
     после знака <literal>$</>. 
     Поэтому, чтобы безопасно заключить заранее неизвестный текст 
     в кавычки, <emphasis>нужно</> использовать соответствующие функции: 
     <function>quote_literal</>, <function>quote_nullable</>, 
     или <function>quote_ident</>.
    </para>

    <para>
     Динамические операторы SQL также могут быть безопасно сконструированы при 
     помощи функции <function>format</function>
     (смотри <xref linkend="functions-string">).Так, например:
<programlisting>
EXECUTE format('UPDATE tbl SET %I = %L WHERE key = %L', colname, newvalue, keyvalue);
</programlisting>
     Функцию <function>format</function> можно использовать в сочетании с фразой 
     <literal>USING</literal>:
<programlisting>
EXECUTE format('UPDATE tbl SET %I = $1 WHERE key = $2', colname)
   USING newvalue, keyvalue;
</programlisting>
     Это более эффективная форма, так как параметры <literal>newvalue</literal> и 
     <literal>keyvalue</literal> не преобразуются в текст.
    </para>
   </example>

    <para>
     Более объемный пример использования динамической команды и 
     <command>EXECUTE</command> можно увидеть в 
     <xref linkend="plpgsql-porting-ex2">. В нем создается 
     и динамически выполняется команда <command>CREATE FUNCTION</>
     для определения новой функции.
    </para>
   </sect2>

   <sect2 id="plpgsql-statements-diagnostics">
<!-- en
    <title>Obtaining the Result Status</title>
-->
    <title>Статус выполнения команды</title>

    <para>
     Существует несколько способов определить статус выполнения команды. 
     Первый способ заключается в использовании команды 
     <command>GET DIAGNOSTICS</command>, которая имеет следующий вид:

<synopsis>
GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

     Эта команда позволяет получить значения индикаторов состояния системы. 
     Каждый <replaceable>item</replaceable> является ключевым словом, 
     идентифицирующим значение состояния, которое будет присвоено указанной переменной. 
     Переменная должна быть соответствующего типа данных. В настоящий момент доступны 
     следующие индикаторы: <varname>ROW_COUNT</> - количество строк, 
     обработанных последней командой <acronym>SQL</acronym>; 
     <varname>RESULT_OID</> - OID последней строки, 
     вставленной последней выполненной командой <acronym>SQL</acronym>. 
     Обратите внимание, что получать <varname>RESULT_OID</> имеет смысл только 
     после вставки  (<command>INSERT</command>) записей в таблицу, содержащую OID.
     Для <command>GET DIAGNOSTICS</> можно использовать двоеточие-равно 
     (<literal>:=</>) вместо <literal>=</literal> в стандарте SQL.
    </para>

    <para>
     Пример:
<programlisting>
GET DIAGNOSTICS integer_var = ROW_COUNT;
</programlisting>
    </para>

    <para>
     Второй способ определения статуса выполнения команды заключается в проверке 
     значения специальной переменной <literal>FOUND</literal>, имеющей тип 
     <type>boolean</type>. При вызове <application>PL/pgSQL</application> функции, 
     переменная <literal>FOUND</literal> инициализируется в ложь. 
     Далее, значение переменной изменяется следующими операторами: 

         <itemizedlist>
          <listitem>
           <para>
            <command>SELECT INTO</command> устанавливает <literal>FOUND</literal>
            в истину, если строка присвоена, или в ложь, если строки не выбраны.
           </para>
          </listitem>
          <listitem>
           <para>
            <command>PERFORM</> устанавливает <literal>FOUND</literal> в истину 
            если строки выбраны (затем они отбрасываются), или в ложь, 
            если строки не выбраны. 
           </para>
          </listitem>
          <listitem>
           <para>
            <command>UPDATE</>, <command>INSERT</> и <command>DELETE</>
            устанавливают <literal>FOUND</literal> в истину, если при их выполнении 
            была задействована хотя бы одна строка, или в ложь, 
            если ни одна строка не была задействована.
           </para>
          </listitem>
          <listitem>
           <para>
            <command>FETCH</> устанавливают <literal>FOUND</literal> в истину, 
            если команда вернула строку, или ложь, если строка не выбрана.
           </para>
          </listitem>
          <listitem>
           <para>
            <command>MOVE</> устанавливает <literal>FOUND</literal> в истину при 
            успешном перемещении курсора, в противном случае - в ложь.
           </para>
          </listitem>
          <listitem>
           <para>
            <command>FOR</>, как и <command>FOREACH</>, устанавливают 
            <literal>FOUND</literal> в истину, если была произведена хотя бы одна 
            итерация цикла, в противном случае - в ложь. При этом значение 
            <literal>FOUND</literal> будет установлено только после выхода из цикла. 
            Пока цикл выполняется, оператор цикла не изменяет значение переменной. 
            Но другие операторы внутри цикла могут менять значение  
            <literal>FOUND</literal>.
           </para>
          </listitem>
          <listitem>
           <para>
            <command>RETURN QUERY</command> и <command>RETURN QUERY EXECUTE</command>
            устанавливают <literal>FOUND</literal> в истину, если запрос вернул хотя бы 
            одну строку, или в ложь, если строки не выбраны.
           </para>
          </listitem>
         </itemizedlist>

     Другие операторы <application>PL/pgSQL</application> не меняют значение 
     <literal>FOUND</literal>. Помните в частности, что <command>EXECUTE</command> 
     изменяет вывод  <command>GET DIAGNOSTICS</command>, 
     но не меняет <literal>FOUND</literal>.
    </para>

    <para>
     <literal>FOUND</literal> является локальной переменной в каждой функции 
     <application>PL/pgSQL</application> и любые её изменения, 
     влияют только на текущую функцию.
    </para>

   </sect2>

   <sect2 id="plpgsql-statements-null">
<!-- en
    <title>Doing Nothing At All</title>
-->
    <title>Не делать ничего</title>

    <para>
      Иногда бывает полезен оператор, который не делает ничего.
      Например, он может показывать, что одна из ветвей if/then/else
      сознательно оставлена пустой. Для этих целей используется
      <command>NULL</command>:

<synopsis>
NULL;
</synopsis>
    </para>

    <para>
     В следующем примере два фрагмента кода эквивалентны:
<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        NULL;  -- игнорируем ошибку
END;
</programlisting>

<programlisting>
BEGIN
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN  -- игнорируем ошибку
END;
</programlisting>
     Какой вариант выбрать - дело вкуса.
    </para>

    <note>
     <para>
      В Oracle PL/SQL оператор не может отсутствовать, поэтому 
      <command>NULL</> <emphasis>обязателен</> в подобных ситуациях.
      В <application>PL/pgSQL</application> разрешается не писать ничего.
     </para>
    </note>

   </sect2>
  </sect1>

  <sect1 id="plpgsql-control-structures">
<!-- en
   <title>Control Structures</title>
-->
   <title>Управляющие структуры</title>

   <para>
    Управляющие структуры, вероятно, наиболее полезная и важная часть
    <application>PL/pgSQL</>. С их помощью можно очень гибко и эффективно
    манипулировать данными <productname>PostgreSQL</>.
   </para>

   <sect2 id="plpgsql-statements-returning">
<!-- en
    <title>Returning From a Function</title>
-->
    <title>Команды для возврата значения из функции</title>

    <para>
     Две команды позволяют вернуть данные из функции:
     <command>RETURN</command> и <command>RETURN NEXT</command>.
    </para>

    <sect3>
     <title><command>RETURN</></title>

<synopsis>
RETURN <replaceable>expression</replaceable>;
</synopsis>

     <para>
      <command>RETURN</command> с последующим выражением прекращает выполнение функции и возвращает 
      значение выражения в вызывающую программу. Эта форма используется для функций 
      <application>PL/pgSQL</>, которые не возвращают набор строк.
     </para>

     <para>
      В функции, возвращающей скалярный тип, результирующее выражение автоматически 
      приводится к типу возвращаемого значения. Однако, чтобы вернуть составной тип 
      (строку), возвращаемое выражение должно в точности содержать требуемый набор 
      столбцов. При этом может потребоваться явное приведение типов.
     </para>

     <para>
      Для функции с выходными параметрами просто используйте <command>RETURN</command>
      без выражения. Будут возвращены текущие значения выходных параметров.
     </para>

     <para>
      Для функции, возвращающей <type>void</type>, <command>RETURN</command> можно 
      использовать в любом месте, но без выражения после <command>RETURN</command>.
     </para>

     <para>
      Возвращаемое значение функции не может остаться не определенным. Если достигнут 
      конец блока верхнего уровня, а оператор <command>RETURN</command> так и 
      не встретился, происходит ошибка времени исполнения. Это не касается 
      функций с выходными параметрами и функций, возвращающих 
      <type>void</type>. Для них оператор <command>RETURN</command>
      выполняется автоматически по окончании блока верхнего уровня.
     </para>

     <para>
      Несколько примеров:

<programlisting>
-- Функции, возвращающие скалярный тип данных
RETURN 1 + 2;
RETURN scalar_var;

-- Функции, возвращающие составной тип данных
RETURN composite_type_var;
RETURN (1, 2, 'three'::text);  -- требуется приведение типов
</programlisting>
     </para>
    </sect3>

    <sect3>
     <title><command>RETURN NEXT</> и <command>RETURN QUERY</command></title>
    <indexterm>
     <primary>RETURN NEXT</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>
    <indexterm>
     <primary>RETURN QUERY</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

<synopsis>
RETURN NEXT <replaceable>expression</replaceable>;
RETURN QUERY <replaceable>query</replaceable>;
RETURN QUERY EXECUTE <replaceable class="command">command-string</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

     <para>
      Для <application>PL/pgSQL</> функций, возвращающих 
      <literal>SETOF <replaceable>sometype</></literal>, 
      нужно действовать несколько по-иному. Отдельные элементы возвращаемого 
      значения формируются командами <command>RETURN NEXT</command> или 
      <command>RETURN QUERY</command>, а финальная команда <command>RETURN</command>
      без аргументов завершает выполнение функции. <command>RETURN NEXT</command>
      используется как со скалярными, так и с составными типами данных. 
      Для составного типа результат функции возвращается в виде таблицы. 
      <command>RETURN QUERY</command> добавляет результат выполнения запроса 
      к результату функции. <command>RETURN NEXT</command> и 
      <command>RETURN QUERY</command> можно свободно смешивать в теле функции, 
      в этом случае их результаты будут объединены.
     </para>

     <para>
      <command>RETURN NEXT</command> и <command>RETURN QUERY</command> не выполняют 
      возврат из функции. Они просто добавляют строки в результирующее множество. 
      Затем выполнение продолжается со следующего оператора в функции. 
      Успешное выполнение <command>RETURN NEXT</command> и <command>RETURN QUERY</command>
      формирует множество строк результата. 
      Для выхода из функции используется <command>RETURN</command>, 
      обязательно без аргументов 
      (или можно просто дождаться окончания выполнения функции).
     </para>

     <para>
      <command>RETURN QUERY</command> имеет разновидность 
      <command>RETURN QUERY EXECUTE</command>, предназначенную для динамического 
      выполнения запроса. В тексте запроса можно использовать параметры, 
      используя фразу <literal>USING</>, также как и в команде <command>EXECUTE</>.
     </para>

     <para>
      Для функции с выходными параметрами просто используйте 
      <command>RETURN NEXT</command> без аргументов. При каждом исполнении 
      <command>RETURN NEXT</command> текущие значения выходных параметров сохраняются 
      для последующего возврата в качестве строки результата. Обратите внимание, 
      что если функция с выходными параметрами должна возвращать множество значений, то 
      при объявлении нужно указывать <literal>RETURNS SETOF</literal>. При этом если 
      выходных параметров несколько, то используется 
      <literal>RETURNS SETOF record</literal>, а если только один с типом 
      <replaceable>sometype</>, 
      то <literal>RETURNS SETOF <replaceable>sometype</></literal>.
     </para>

     <para>
      Пример использования <command>RETURN NEXT</command>:

<programlisting>
CREATE TABLE foo (fooid INT, foosubid INT, fooname TEXT);
INSERT INTO foo VALUES (1, 2, 'three');
INSERT INTO foo VALUES (4, 5, 'six');

CREATE OR REPLACE FUNCTION get_all_foo() RETURNS SETOF foo AS
$BODY$
DECLARE
    r foo%rowtype;
BEGIN
    FOR r IN
        SELECT * FROM foo WHERE fooid &gt; 0
    LOOP
        -- здесь возможна обработка данных
        RETURN NEXT r; -- добавляет текущую строку запроса к возвращаемому результату
    END LOOP;
    RETURN;
END
$BODY$
LANGUAGE plpgsql;

SELECT * FROM get_all_foo();
</programlisting>
     </para>

     <para>
      Пример использования <command>RETURN QUERY</command>:

<programlisting>
CREATE FUNCTION get_available_flightid(date) RETURNS SETOF integer AS
$BODY$
BEGIN
    RETURN QUERY SELECT flightid
                   FROM flight
                  WHERE flightdate >= $1
                    AND flightdate < ($1 + 1);

    -- Т.к. выполнение еще не закончено, можно проверить были ли возвращены строки
    -- Если нет, то вызываем исключение
    IF NOT FOUND THEN
        RAISE EXCEPTION 'Нет рейсов на дату: %.', $1;
    END IF;

    RETURN;
 END
$BODY$
LANGUAGE plpgsql;

-- Возвращает доступные рейсы, либо вызывает исключение
SELECT * FROM get_available_flightid(CURRENT_DATE);
</programlisting>
     </para>

     <note>
      <para>
       В текущей реализации <command>RETURN NEXT</command> и 
       <command>RETURN QUERY</command> результирующее множество накапливается целиком, 
       прежде чем будет возвращено из функции.
       Если множество очень большое, то это может отрицательно сказаться 
       на производительности, т.к. при нехватке оперативной памяти 
       данные записываются на диск. В следующих версиях <application>PL/pgSQL</> это 
       ограничение будет снято. В настоящее время управлять количеством оперативной
       памяти в подобных случаях можно параметром конфигурации <xref linkend="guc-work-mem">.
       При наличии свободной памяти администраторы должны рассмотреть возможность
       увеличения значения данного параметра.
      </para>
     </note>
    </sect3>
   </sect2>

   <sect2 id="plpgsql-conditionals">
<!-- en
    <title>Conditionals</title>
-->
    <title>Условные операторы</title>

    <para>
     Операторы <command>IF</> и <command>CASE</> позволяют выполнять команды в 
     зависимости от определенных условий.
     <application>PL/pgSQL</> поддерживает три формы <command>IF</>:
    <itemizedlist>
     <listitem>
      <para><literal>IF ... THEN</></>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSE</></>
     </listitem>
     <listitem>
      <para><literal>IF ... THEN ... ELSIF ... THEN ... ELSE</></>
     </listitem>
    </itemizedlist>

    и две формы <command>CASE</>:
    <itemizedlist>
     <listitem>
      <para><literal>CASE ... WHEN ... THEN ... ELSE ... END CASE</></>
     </listitem>
     <listitem>
      <para><literal>CASE WHEN ... THEN ... ELSE ... END CASE</></>
     </listitem>
    </itemizedlist>
    </para>

    <sect3>
     <title><literal>IF-THEN</></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <para>
        <literal>IF-THEN</literal> это простейшая форма <literal>IF</literal>.
        Операторы между <literal>THEN</literal> и <literal>END IF</literal> 
        выполняются, если условие (<replaceable>boolean-expression</replaceable>) 
        истинно. В противном случае они опускаются.
       </para>

       <para>
        Пример:
<programlisting>
IF v_user_id &lt;&gt; 0 THEN
    UPDATE users SET email = v_email WHERE user_id = v_user_id;
END IF;
</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSE</></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
ELSE
    <replaceable>statements</replaceable>
END IF;
</synopsis>

       <para>
        <literal>IF-THEN-ELSE</literal> добавляет к <literal>IF-THEN</literal> 
        возможность указать альтернативный набор операторов, которые будут выполнены,
        если условие не истинно (в том числе, если условие NULL).
       </para>

       <para>
        Примеры:
<programlisting>
IF parentid IS NULL OR parentid = ''
THEN
    RETURN fullname;
ELSE
    RETURN hp_true_filename(parentid) || '/' || fullname;
END IF;
</programlisting>

<programlisting>
IF v_count &gt; 0 THEN
    INSERT INTO users_count (count) VALUES (v_count);
    RETURN 't';
ELSE
    RETURN 'f';
END IF;
</programlisting>
     </para>
    </sect3>

     <sect3>
      <title><literal>IF-THEN-ELSIF</></title>

<synopsis>
IF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
<optional> ELSIF <replaceable>boolean-expression</replaceable> THEN
    <replaceable>statements</replaceable>
    ...
</optional>
</optional>
<optional> ELSE
    <replaceable>statements</replaceable> </optional>
END IF;
</synopsis>

       <para>
        В некоторых случаях двух альтернатив недостаточно.
        <literal>IF-THEN-ELSIF</> обеспечивает удобный способ проверки 
        нескольких вариантов по очереди.
        Условия в <literal>IF</> последовательно проверяются до тех пор, 
        пока не будет найдено первое истинное. После этого операторы,
        относящиеся к этому условию, выполняются, и управление переходит к 
        следующей после <literal>END IF</> команде. (Все последующие условия
        не проверяются.) Если ни одно из условий <literal>IF</> не является истинным,
        то выполняется блок <literal>ELSE</> (если присутствует).
       </para>

       <para>
        Пример:

<programlisting>
IF number = 0 THEN
    result := 'zero';
ELSIF number &gt; 0 THEN
    result := 'positive';
ELSIF number &lt; 0 THEN
    result := 'negative';
ELSE
    -- раз мы здесь, значит значение number не определено (NULL)
    result := 'NULL';
END IF;
</programlisting>
       </para>

       <para>
        Вместо ключевого слова <literal>ELSIF</> можно использовать <literal>ELSEIF</>.
       </para>

       <para>
        Другой вариант сделать то же самое, это использование вложенных
        операторов <literal>IF-THEN-ELSE</literal>, как в следующем примере:

<programlisting>
IF demo_row.sex = 'm' THEN
    pretty_sex := 'man';
ELSE
    IF demo_row.sex = 'f' THEN
        pretty_sex := 'woman';
    END IF;
END IF;
</programlisting>
       </para>

       <para>
        Однако это требует написания соответствующих <literal>END IF</> 
        для каждого <literal>IF</>, что при наличии нескольких альтернатив делает 
        код более громоздким, чем использование <literal>ELSIF</>.
       </para>
     </sect3>

     <sect3>
<!-- en
      <title>Simple <literal>CASE</></title>
-->
      <title>Простой <literal>CASE</></title>

<synopsis>
CASE <replaceable>search-expression</replaceable>
    WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>expression</replaceable> <optional>, <replaceable>expression</replaceable> <optional> ... </optional></optional> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <para>
       Простая форма <command>CASE</> реализует условное выполнение на основе 
       сравнения операндов. <replaceable>search-expression</> вычисляется (один раз) 
       и последовательно сравнивается с каждым <replaceable>expression</> 
       во фразах <literal>WHEN</>. Если совпадение найдено, то выполняются
       соответствующие <replaceable>statements</replaceable> и управление переходит 
       к следующей после <literal>END CASE</> команде. (Все последующие выражения
        <literal>WHEN</> не проверяются.) Если совпадение не было найдено, то
       выполняются <literal>ELSE</> <replaceable>statements</replaceable>. 
       Но если <literal>ELSE</> нет, то вызывается исключение 
       <literal>CASE_NOT_FOUND</literal>.
      </para>

      <para>
       Пример:

<programlisting>
CASE x
    WHEN 1, 2 THEN
        msg := 'один или два';
    ELSE
        msg := 'значение, отличное от один или два';
END CASE;
</programlisting>
      </para>
     </sect3>

     <sect3>
<!-- en
      <title>Searched <literal>CASE</></title>
-->
      <title><literal>CASE</> с перебором условий</title>

<synopsis>
CASE
    WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
  <optional> WHEN <replaceable>boolean-expression</replaceable> THEN
      <replaceable>statements</replaceable>
    ... </optional>
  <optional> ELSE
      <replaceable>statements</replaceable> </optional>
END CASE;
</synopsis>

      <para>
       Эта форма <command>CASE</> реализует условное выполнение, основываясь 
       на истинности логических условий.
       Каждое выражение <replaceable>boolean-expression</replaceable> во фразе 
       <literal>WHEN</> вычисляется по порядку до тех пор, пока не будет найдено 
       истинное. 
       Затем выполняются соответствующие <replaceable>statements</replaceable> 
       и управление переходит к следующей после <literal>END CASE</> команде.
       (Все последующие выражения <literal>WHEN</> не проверяются.)
       Если ни одно из условий не окажется истинным, то выполняются 
       <literal>ELSE</> <replaceable>statements</replaceable>.
       Но если <literal>ELSE</> нет, то вызывается исключение 
       <literal>CASE_NOT_FOUND</literal>.
      </para>

      <para>
       Пример:

<programlisting>
CASE
    WHEN x BETWEEN 0 AND 10 THEN
        msg := 'значение в диапазоне между 0 и 10';
    WHEN x BETWEEN 11 AND 20 THEN
        msg := 'значение в диапазоне между 11 и 20';
END CASE;
</programlisting>
      </para>

      <para>
       Эта форма <command>CASE</> полностью эквивалента <literal>IF-THEN-ELSIF</>, 
       за исключением того, что при невыполнении всех условий и отсутствии 
       <literal>ELSE</>, <literal>IF-THEN-ELSIF</> ничего не делает, 
       а <command>CASE</> вызывает ошибку.
      </para>

     </sect3>
   </sect2>

   <sect2 id="plpgsql-control-structures-loops">
<!-- en
    <title>Simple Loops</title>
-->
    <title>Простые циклы</title>

    <indexterm zone="plpgsql-control-structures-loops">
     <primary>loop</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <para>
     Операторы <literal>LOOP</>, <literal>EXIT</>, <literal>CONTINUE</>, <literal>WHILE</>, 
     <literal>FOR</> и <literal>FOREACH</> позволяют повторить серию команд в 
     <application>PL/pgSQL</> функции.
    </para>

    <sect3>
     <title><literal>LOOP</></title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     <para>
      <literal>LOOP</> организует безусловный цикл, который повторяется до бесконечности, 
      пока не будет прекращен операторами <literal>EXIT</> или <command>RETURN</command>. 
      Для вложенных циклов можно использовать <replaceable>label</replaceable> 
      в операторах <literal>EXIT</> и <literal>CONTINUE</literal>, 
      чтобы указать к какому циклу эти операторы относятся.
     </para>
    </sect3>

     <sect3>
      <title><literal>EXIT</></title>

     <indexterm>
      <primary>EXIT</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>

<synopsis>
EXIT <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <para>
        Если <replaceable>label</replaceable> не указана, то завершается самый внутренний цикл,
        далее выполняется оператор, следующий за <literal>END LOOP</>. 
        Если <replaceable>label</replaceable> указана, то она должна относиться к текущему 
        или внешнему циклу, или это может быть метка блока. При этом в именованном 
        цикле/блоке выполнение прекращается, а управление переходит к следующему оператору 
        после соответствующего <literal>END</>. 
       </para>

       <para>
        При наличии <literal>WHEN</> цикл прекращается, только
        если <replaceable>boolean-expression</> истинно. В противном случае управление 
        переходит к оператору следующему за <literal>EXIT</>.
       </para>

       <para>
        <literal>EXIT</> можно использовать со всеми типами циклов, не только с безусловным.
       </para>

       <para>
        Когда <literal>EXIT</literal> используется для выхода из блока, управление переходит 
        к следующему оператору после окончания блока. Обратите внимание, что для выхода из 
        блока нужно обязательно указывать <replaceable>label</replaceable>. 
        <literal>EXIT</literal> без <replaceable>label</replaceable> не позволяет прекратить 
        работу блока. (Это изменение по сравнению с версиями 
        <productname>PostgreSQL</productname> до 8.4, в которых разрешалось использовать 
        <literal>EXIT</literal> без <replaceable>label</replaceable> 
        для прекращения работы текущего блока.)
       </para>

       <para>
        Примеры:
<programlisting>
LOOP
    -- здесь вычисления 
    IF count &gt; 0 THEN
        EXIT;  -- выход из цикла
    END IF;
END LOOP;

LOOP
    -- здесь вычисления
    EXIT WHEN count &gt; 0;  -- аналогично предыдущему примеру
END LOOP;

&lt;&lt;ablock&gt;&gt;
BEGIN
    -- здесь вычисления
    IF stocks &gt; 100000 THEN
        EXIT ablock;  -- выход из блока ablock
    END IF;
    -- вычисления не будут выполнены, если stocks &gt; 100000
END;
</programlisting>
       </para>
     </sect3>

     <sect3>
      <title><literal>CONTINUE</></title>

     <indexterm>
      <primary>CONTINUE</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>

<synopsis>
CONTINUE <optional> <replaceable>label</replaceable> </optional> <optional> WHEN <replaceable>boolean-expression</replaceable> </optional>;
</synopsis>

       <para>
        Если <replaceable>label</> не указана, то начинается следующая итерация самого 
        внутреннего цикла. То есть все оставшиеся в цикле операторы пропускаются, 
        и управление переходит к управляющему выражению цикла (если есть) для определения, 
        нужна ли еще одна итерация цикла. Если <replaceable>label</> присутствует, то она 
        указывает на метку цикла, выполнение которого будет продолжено.
       </para>

       <para>
        При наличии <literal>WHEN</> следующая итерация цикла начинается только тогда, 
        когда <replaceable>boolean-expression</> истинно. В противном случае управление 
        переходит к оператору, следующему за <literal>CONTINUE</>.
       </para>

       <para>
        <literal>CONTINUE</> можно использовать со всеми типами циклов, 
        не только с безусловным.
       </para>

       <para>
        Пример:
<programlisting>
LOOP
    -- здесь вычисления
    EXIT WHEN count &gt; 100;
    CONTINUE WHEN count &lt; 50;
    -- Вычисления для count в диапазоне 50 .. 100
END LOOP;
</programlisting>
       </para>
     </sect3>


     <sect3>
      <title><literal>WHILE</></title>

     <indexterm>
      <primary>WHILE</primary>
      <secondary>in PL/pgSQL</secondary>
     </indexterm>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
WHILE <replaceable>boolean-expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <para>
        <literal>WHILE</> выполняет серию команд до тех пор, пока истинно выражение 
        <replaceable>boolean-expression</replaceable>. Выражение проверяется 
        непосредственно перед каждым входом в тело цикла.
       </para>

       <para>
        Пример:
<programlisting>
WHILE amount_owed &gt; 0 AND gift_certificate_balance &gt; 0 LOOP
    -- здесь вычисления
END LOOP;

WHILE NOT done LOOP
    -- здесь вычисления
END LOOP;
</programlisting>
       </para>
     </sect3>

     <sect3 id="plpgsql-integer-for">
      <title><literal>FOR</> (целочисленный вариант)</title>

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>name</replaceable> IN <optional> REVERSE </optional> <replaceable>expression</replaceable> .. <replaceable>expression</replaceable> <optional> BY <replaceable>expression</replaceable> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

       <para>
        В этой форме цикла <literal>FOR</> итерации выполняются по диапазону целых чисел. 
        Переменная <replaceable>name</replaceable> автоматически определяется с типом 
        <type>integer</> и существует только внутри цикла (если уже существует переменная 
        с таким именем, то внутри цикла она будет игнорироваться). Выражения для нижней 
        и верхней границы диапазона чисел вычисляются один раз при входе в цикл. 
        Если не указана фраза <literal>BY</>, то шаг итерации 1, в противном случае 
        используется значение в <literal>BY</>, которое вычисляется, опять же, один раз 
        при входе в цикл. Если указано <literal>REVERSE</>, то после каждой итерации 
        величина шага вычитается, а не добавляется.
       </para>

       <para>
        Примеры целочисленного <literal>FOR</>:
<programlisting>
FOR i IN 1..10 LOOP
    -- внутри цикла переменная i будет иметь значения 1,2,3,4,5,6,7,8,9,10
END LOOP;

FOR i IN REVERSE 10..1 LOOP
    -- внутри цикла переменная i будет иметь значения 10,9,8,7,6,5,4,3,2,1
END LOOP;

FOR i IN REVERSE 10..1 BY 2 LOOP
    -- внутри цикла переменная i будет иметь значения 10,8,6,4,2
END LOOP;
</programlisting>
       </para>

       <para>
        Если нижняя граница цикла больше верхней границы (или меньше, в случае 
        <literal>REVERSE</>), то тело цикла не выполняется вообще. 
        При этом ошибка не возникает.
       </para>

       <para>
        Если у цикла есть метка, то к переменной цикла можно обращаться 
        по имени, квалифицированному меткой.
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-records-iterating">
<!-- en
    <title>Looping Through Query Results</title>
-->
    <title>Цикл по результатам запроса</title>

    <para>
     Другой вариант <literal>FOR</> позволяет организовать цикл по результатам запроса. 
     Синтаксис:
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN <replaceable>query</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     Переменная <replaceable>target</replaceable> может быть строковой переменной, 
     переменной типа <type>record</> или  разделенным запятыми списком 
     скалярных переменных. В переменную <replaceable>target</replaceable> последовательно 
     присваиваются строки результата запроса, и для каждой строки выполняется тело цикла. 
     Пример:
<programlisting>
CREATE FUNCTION cs_refresh_mviews() RETURNS integer AS $$
DECLARE
    mviews RECORD;
BEGIN
    RAISE NOTICE 'Обновление материализованных представлений...';

    FOR mviews IN SELECT * FROM cs_materialized_views ORDER BY sort_key LOOP

        -- Сейчас "mviews" содержит одну запись из cs_materialized_views

        RAISE NOTICE 'Обновляется мат. представление %s ...', quote_ident(mviews.mv_name);
        EXECUTE 'TRUNCATE TABLE ' || quote_ident(mviews.mv_name);
        EXECUTE 'INSERT INTO '
                   || quote_ident(mviews.mv_name) || ' '
                   || mviews.mv_query;
    END LOOP;

    RAISE NOTICE 'Закончено обновление материализованных представлений.';
    RETURN 1;
END;
$$ LANGUAGE plpgsql;
</programlisting>

     Если цикл завершается по команде <literal>EXIT</>, то последняя присвоенная строка 
     доступна и после цикла.
    </para>

    <para>
     В цикле <literal>FOR</> можно использовать любые <literal>SQL</> команды, 
     возвращающие строки. Чаще всего это <command>SELECT</>, но могут быть и 
     <command>INSERT</>, <command>UPDATE</>, <command>DELETE</> с фразой 
     <literal>RETURNING</>. А также некоторые утилиты, например <command>EXPLAIN</>.
    </para>

    <para>
     Для <application>PL/pgSQL</> переменных в тексте запроса выполняется подстановка 
     значений, план запроса кэшируется для возможного повторного использования, 
     как подробно описано в <xref linkend="plpgsql-var-subst"> и
     <xref linkend="plpgsql-plan-caching">.
    </para>

    <para>
     Еще одна разновидность этого типа цикла <literal>FOR-IN-EXECUTE</>:
<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>target</replaceable> IN EXECUTE <replaceable>text_expression</replaceable> <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
     Она похожа на предыдущую форму, за исключением того, что текст запроса указывается 
     в виде строкового выражения. Текст запроса формируется и для него строится план 
     выполнения при каждом входе в цикл. Это дает программисту выбор между скоростью 
     предварительно разобранного запроса и гибкостью динамического запроса, так же, 
     как и в случае с обычным оператором <command>EXECUTE</command>. 
     Как и в <command>EXECUTE</command>, значения параметров могут быть добавлены 
     в команду с использованием <literal>USING</>.
    </para>

    <para>
     Еще один способ организовать цикл по результатам запроса это объявить курсор. 
     Описание в <xref linkend="plpgsql-cursor-for-loop">.
    </para>
   </sect2>

   <sect2 id="plpgsql-foreach-array">
<!-- en
    <title>Looping Through Arrays</title>
-->
    <title>Цикл по элементам массива</title>

    <para>
     Цикл <literal>FOREACH</> очень похож на <literal>FOR</>. Отличие в том, 
     что вместо перебора строк SQL запроса происходит перебор элементов массива. 
     (В целом, <literal>FOREACH</> предназначен для перебора выражений составного типа. 
     Варианты реализации цикла для работы с прочими составными выражениями помимо 
     массивов могут быть добавлены в будущем.) Синтаксис цикла <literal>FOREACH</>:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOREACH <replaceable>target</replaceable> <optional> SLICE <replaceable>number</replaceable> </optional> IN ARRAY <replaceable>expression</replaceable> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>
    </para>

    <para>
     Без указания <literal>SLICE</>, или если <literal>SLICE</> равен 0, цикл выполняется 
     по всем элементам массива, полученного из <replaceable>expression</replaceable>. 
     В переменную <replaceable>target</replaceable> последовательно присваивается каждый 
     элемент массива и для него выполняется тело цикла. 
     Пример цикла по элементам целочисленного массива:

<programlisting>
CREATE FUNCTION sum(int[]) RETURNS int8 AS $$
DECLARE
  s int8 := 0;
  x int;
BEGIN
  FOREACH x IN ARRAY $1
  LOOP
    s := s + x;
  END LOOP;
  RETURN s;
END;
$$ LANGUAGE plpgsql;
</programlisting>

     Обход элементов проводится в том порядке, в котором они сохранялись, независимо от 
     размерности массива. Как правило, <replaceable>target</replaceable> это одиночная переменная, 
     но может быть и списком переменных, когда элементы массива имеют составной тип (записи). 
     В этом случае переменным присваиваются значения из последовательных столбцов составного 
     элемента массива.
    </para>

    <para>
     При положительном значении <literal>SLICE</> <literal>FOREACH</> выполняет итерации 
     по срезам массива, а не по отдельным элементам. Значение <literal>SLICE</> должно быть 
     целым числом, не превышающим размерности массива. Переменная 
     <replaceable>target</replaceable> должна быть массивом, который получает последовательные 
     срезы исходного массива, где размерность каждого среза задается значением <literal>SLICE</>. 
     Пример цикла по одномерным срезам:

<programlisting>
CREATE FUNCTION scan_rows(int[]) RETURNS void AS $$
DECLARE
  x int[];
BEGIN
  FOREACH x SLICE 1 IN ARRAY $1
  LOOP
    RAISE NOTICE 'row = %', x;
  END LOOP;
END;
$$ LANGUAGE plpgsql;

SELECT scan_rows(ARRAY[[1,2,3],[4,5,6],[7,8,9],[10,11,12]]);

NOTICE:  row = {1,2,3}
NOTICE:  row = {4,5,6}
NOTICE:  row = {7,8,9}
NOTICE:  row = {10,11,12}
</programlisting>
    </para>
   </sect2>

   <sect2 id="plpgsql-error-trapping">
<!-- en
    <title>Trapping Errors</title>
-->
    <title>Обработка ошибок</title>

    <indexterm>
     <primary>exceptions</primary>
     <secondary>in PL/pgSQL</secondary>
    </indexterm>

    <para>
     По умолчанию любая возникающая ошибка прерывает выполнение <application>PL/pgSQL</>
     функции, а также транзакцию, относящуюся к этой функции. Использование в блоке 
     секции <literal>EXCEPTION</> позволяет перехватывать и обрабатывать ошибки. 
     Синтаксис секции <literal>EXCEPTION</> дополняет синтаксис обычного блока:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
<optional> DECLARE
    <replaceable>declarations</replaceable> </optional>
BEGIN
    <replaceable>statements</replaceable>
EXCEPTION
    WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
        <replaceable>handler_statements</replaceable>
    <optional> WHEN <replaceable>condition</replaceable> <optional> OR <replaceable>condition</replaceable> ... </optional> THEN
          <replaceable>handler_statements</replaceable>
      ... </optional>
END;
</synopsis>
    </para>

    <para>
     Если ошибок не было, то выполняются все <replaceable>statements</replaceable>
     блока и управление переходит к следующему оператору после <literal>END</>. 
     Но если при выполнении <replaceable>statements</replaceable> происходит ошибка, 
     то дальнейшая обработка прекращается и управление переходит к списку исключений 
     в секции <literal>EXCEPTION</>. В этом списке ищется первое исключение, условие 
     которого соответствует ошибке. Если исключение найдено, то выполняются 
     соответствующие <replaceable>handler_statements</replaceable> и управление переходит 
     к следующему оператору после <literal>END</>. Если исключение не найдено, 
     то ошибка передается наружу, как будто секции <literal>EXCEPTION</> не было. 
     При этом ошибку можно перехватить в секции <literal>EXCEPTION</> внешнего блока. 
     Если ошибка так и не была перехвачена, то обработка функции прекращается.
    </para>

    <para>
     Допустимые имена <replaceable>condition</> перечислены в <xref linkend="errcodes-appendix">.  
     Специальное имя <literal>OTHERS</> соответствует любой ошибке, за исключением  
     <literal>QUERY_CANCELED</>. Можно явно обработать <literal>QUERY_CANCELED</>, 
     но зачастую это неразумно. Имена исключений не чувствительны к регистру. 
     Кроме того, <replaceable>condition</> можно указать через соответствующий 
     <literal>SQLSTATE</> код. В следующем примере обе строки эквивалентны:
<programlisting>
WHEN division_by_zero THEN ...
WHEN SQLSTATE '22012' THEN ...
</programlisting>
    </para>

    <para>
     Если при выполнении <replaceable>handler_statements</replaceable> возникнет 
     новая ошибка, то она не может быть перехвачена в этой секции <literal>EXCEPTION</>. 
     Ошибка передается наружу и её можно перехватить в секции <literal>EXCEPTION</> 
     внешнего блока.
    </para>

    <para>
     При выполнении команд в секции <literal>EXCEPTION</> локальные переменные 
     <application>PL/pgSQL</> функции сохраняют те значения, которые были на момент 
     возникновения ошибки. Однако, будут отменены все изменения в базе данных, 
     выполненные в блоке. В качестве примера рассмотрим следующий фрагмент:

<programlisting>
INSERT INTO mytab(firstname, lastname) VALUES('Tom', 'Jones');
BEGIN
    UPDATE mytab SET firstname = 'Joe' WHERE lastname = 'Jones';
    x := x + 1;
    y := x / 0;
EXCEPTION
    WHEN division_by_zero THEN
        RAISE NOTICE 'перехватили ошибку division_by_zero';
        RETURN x;
END;
</programlisting>

     При присвоении значения переменной <literal>y</> произойдет ошибка 
     <literal>division_by_zero</>. Она будет перехвачена в секции <literal>EXCEPTION</>. 
     Оператор <command>RETURN</> вернет значение <literal>x</>, увеличенное на единицу, 
     но изменения сделанные командой <command>UPDATE</> будут отменены. Изменения, 
     выполненные командой <command>INSERT</>, которая предшествует блоку, не будут отменены. 
     В результате, база данных будет содержать <literal>Tom Jones</>, 
     а не <literal>Joe Jones</>.
    </para>

    <tip>
     <para>
      Наличие секции <literal>EXCEPTION</> значительно увеличивает накладные расходы 
      на вход/выход из блока. Поэтому не используйте <literal>EXCEPTION</> без надобности.
     </para>
    </tip>

    <example id="plpgsql-upsert-example">
<!-- en
    <title>Exceptions with <command>UPDATE</>/<command>INSERT</></title>
-->
    <title>Обработка исключений для команд <command>UPDATE</>/<command>INSERT</></title>
    <para>

    В этом примере обработка исключений используется для того, чтобы определить какую
    команду выполнить <command>UPDATE</> или <command>INSERT</>:

<programlisting>
CREATE TABLE db (a INT PRIMARY KEY, b TEXT);

CREATE FUNCTION merge_db(key INT, data TEXT) RETURNS VOID AS
$$
BEGIN
    LOOP
        -- для начала UPDATE записи по значению ключа
        UPDATE db SET b = data WHERE a = key;
        IF found THEN
            RETURN;
        END IF;
        -- записи с таким ключом нет, поэтому попытаемся её вставить
        -- если параллельно с нами кто-то еще пытается вставить запись с таким же ключом,
        -- то мы получим ошибку уникальности
        BEGIN
            INSERT INTO db(a,b) VALUES (key, data);
            RETURN;
        EXCEPTION WHEN unique_violation THEN
            -- Здесь ничего не делаем и идем на следующую итерацию цикла,
            -- чтобы повторно попытаться сделать UPDATE.
        END;
    END LOOP;
END;
$$
LANGUAGE plpgsql;

SELECT merge_db(1, 'david');
SELECT merge_db(1, 'dennis');
</programlisting>

     В примере предполагается, что ошибка <literal>unique_violation</> вызвана 
     командой <command>INSERT</> текущего блока, а не, скажем, <command>INSERT</> 
     из триггерной функции таблицы. Здесь также не учтено, что у таблицы может быть
     несколько уникальных ключей, поэтому попытка повторить операцию будет предприниматься
     вне зависимости от того, уникальность какого ключа привела к ошибке. 
     Далее будут рассмотрены возможности, позволяющие убедиться, что мы обрабатываем 
     именно ту ошибку, которую хотели.

    </para>
    </example>

   <sect3 id="plpgsql-exception-diagnostics">
    <title>Получение информации об ошибке</title>

    <para>
     При обработке исключений часто бывает необходимым получить детальную информацию 
     о произошедшей ошибке. Для этого в <application>PL/pgSQL</> есть два способа: 
     использование специальных переменных и команда 
     <command>GET STACKED DIAGNOSTICS</command>.
    </para>

    <para>
     Внутри секции <literal>EXCEPTION</> специальная переменная <varname>SQLSTATE</varname>
     содержит код ошибки, для которой было вызвано исключение (смотри список возможных 
     кодов ошибок в <xref linkend="errcodes-table">). Специальная переменная 
     <varname>SQLERRM</varname> содержит сообщение об ошибке, связанное с исключением. 
     Эти переменные являются неопределенными вне секции <literal>EXCEPTION</>.
    </para>

    <para>
     Также, при обработке исключений, дополнительную информацию можно получить командой 
     <command>GET STACKED DIAGNOSTICS</command>, которая имеет вид:

<synopsis>
GET STACKED DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

     Каждый <replaceable>item</replaceable> является ключевым словом, идентифицирующим 
     значение состояния, которое будет присвоено указанной переменной. Переменная должна 
     быть соответствующего типа данных. Идентификаторы, доступные в настоящее время, приведены в
     <xref linkend="plpgsql-exception-diagnostics-values">.
    </para>

     <table id="plpgsql-exception-diagnostics-values">
      <title>Диагностические коды ошибок</title>
      <tgroup cols="3">
       <thead>
        <row>
         <entry>Название</entry>
         <entry>Тип</entry>
         <entry>Описание</entry>
        </row>
       </thead>
       <tbody>
        <row>
         <entry><literal>RETURNED_SQLSTATE</literal></entry>
         <entry>text</entry>
         <entry>код исключения, возвращаемый SQLSTATE</entry>
        </row>
        <row>
         <entry><literal>COLUMN_NAME</literal></entry>
         <entry>text</entry>
         <entry>имя столбца, относящегося к исключению</entry>
        </row>
        <row>
         <entry><literal>CONSTRAINT_NAME</literal></entry>
         <entry>text</entry>
         <entry>имя ограничения целостности, относящегося к исключению</entry>
        </row>
        <row>
         <entry><literal>PG_DATATYPE_NAME</literal></entry>
         <entry>text</entry>
         <entry>имя типа данных, относящегося к исключению</entry>
        </row>
        <row>
         <entry><literal>MESSAGE_TEXT</literal></entry>
         <entry>text</entry>
         <entry>текст основного сообщения исключения</entry>
        </row>
        <row>
         <entry><literal>TABLE_NAME</literal></entry>
         <entry>text</entry>
         <entry>имя таблицы, относящейся к исключению</entry>
        </row>
        <row>
         <entry><literal>SCHEMA_NAME</literal></entry>
         <entry>text</entry>
         <entry>имя схемы, относящейся к исключению</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_DETAIL</literal></entry>
         <entry>text</entry>
         <entry>текст детального сообщения исключения (если есть)</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_HINT</literal></entry>
         <entry>text</entry>
         <entry>текст подсказки к исключению (если есть)</entry>
        </row>
        <row>
         <entry><literal>PG_EXCEPTION_CONTEXT</literal></entry>
         <entry>text</entry>
         <entry>строка(или строки) с описанием стека вызова</entry>
        </row>
       </tbody>
      </tgroup>
     </table>

    <para>
     Если исключение не устанавливает значение для идентификатора, 
     то возвращается пустая строка.
    </para>

    <para>
     Пример:
<programlisting>
DECLARE
  text_var1 text;
  text_var2 text;
  text_var3 text;
BEGIN
  -- здесь происходит обработка, которая может вызвать исключение
  ...
EXCEPTION WHEN OTHERS THEN
  GET STACKED DIAGNOSTICS text_var1 = MESSAGE_TEXT,
                          text_var2 = PG_EXCEPTION_DETAIL,
                          text_var3 = PG_EXCEPTION_HINT;
END;
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="plpgsql-get-diagnostics-context">
   <title>Получение информации о выполнении в текущий момент</title>

   <para>
    Команда <command>GET <optional> CURRENT </optional> DIAGNOSTICS</command>
    извлекает информацию о текущем состоянии выполнения (в то время как 
    обсуждавшаяся выше команда <command>GET STACKED DIAGNOSTICS</command> 
    выдает информацию о состоянии выполнения на момент предыдущей ошибки).
    Команда имеет следующий вид:
   </para>

<synopsis>
GET <optional> CURRENT </optional> DIAGNOSTICS <replaceable>variable</replaceable> { = | := } <replaceable>item</replaceable> <optional> , ... </optional>;
</synopsis>

   <para>
    В настоящий момент поддерживается только один 
    <replaceable>item</replaceable> <literal>PG_CONTEXT</>, который возвращает
    значение типа <literal>text</>, содержащее стек вызова. 
    Стек вызова может состоять из нескольких строк, первая строка относится
    к выполняемый в текущий момент команде <command>GET DIAGNOSTICS</command>
    в текущей функции. Вторая и последующие строки относятся к следующим 
    функциям далее вверх по стеку вызова. Например:

<programlisting>
CREATE OR REPLACE FUNCTION outer_func() RETURNS integer AS $$
BEGIN
  RETURN inner_func();
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION inner_func() RETURNS integer AS $$
DECLARE
  stack text;
BEGIN
  GET DIAGNOSTICS stack = PG_CONTEXT;
  RAISE NOTICE E'--- Стек вызова ---\n%', stack;
  RETURN 1;
END;
$$ LANGUAGE plpgsql;

SELECT outer_func();

NOTICE:  --- Стек вызова ---
PL/pgSQL function inner_func() line 5 at GET DIAGNOSTICS
PL/pgSQL function outer_func() line 3 at RETURN
CONTEXT:  PL/pgSQL function outer_func() line 3 at RETURN
 outer_func
 ------------
           1
(1 row)
</programlisting>

   </para>
  </sect2>
  </sect1>

  <sect1 id="plpgsql-cursors">
<!-- en
   <title>Cursors</title>
-->
   <title>Курсоры</title>

   <indexterm zone="plpgsql-cursors">
    <primary>cursor</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>

   <para>
    Вместо того чтобы сразу выполнять весь запрос, есть возможность настроить курсор, 
    инкапсулирующий запрос, и затем получать результат запроса по нескольку строк за раз. 
    Одна из причин так делать заключается в том, чтобы избежать переполнения памяти, 
    когда результат содержит большое количество строк. (Пользователям 
    <application>PL/pgSQL</> не нужно об этом беспокоиться, так как циклы 
    <literal>FOR</> автоматически используют курсоры, чтобы избежать проблем с памятью.) 
    Более интересным вариантом использования является возврат из функции ссылки на курсор, 
    что позволяет вызывающему получать строки запроса. Это эффективный способ получать 
    большие наборы строк из функций.
   </para>

   <sect2 id="plpgsql-cursor-declarations">
<!-- en
    <title>Declaring Cursor Variables</title>
-->
    <title>Объявление курсорных переменных</title>

    <para>
     Доступ к курсорам в <application>PL/pgSQL</> осуществляется через курсорные 
     переменные, которые всегда имеют специальный тип данных <type>refcursor</>. 
     Один из способов создать курсорную переменную, просто объявить её как переменную 
     типа <type>refcursor</>. Другой способ заключается в использовании синтаксиса 
     объявления курсора, который в общем виде выглядит так:
<synopsis>
<replaceable>name</replaceable> <optional> <optional> NO </optional> SCROLL </optional> CURSOR <optional> ( <replaceable>arguments</replaceable> ) </optional> FOR <replaceable>query</replaceable>;
</synopsis>
     (Для совместимости с Oracle, <literal>FOR</> можно заменять на <literal>IS</>.) 
     Если указана опция <literal>SCROLL</>, то курсор можно будет прокручивать назад. 
     При <literal>NO SCROLL</> прокрутка назад не разрешается. Если ничего не указано, 
     то возможность прокрутки назад зависит от запроса. Если указаны 
     <replaceable>arguments</replaceable>, то они должны представлять собой пары 
     <literal><replaceable>name</replaceable> <replaceable>datatype</replaceable></literal>,
     разделенные через запятую. Эти пары определяют имена, которые будут заменены 
     значениями параметров в данном запросе. Фактические значения для замены этих имен 
     появятся позже, при открытии курсора.
    </para>
    <para>
     Примеры:
<programlisting>
DECLARE
    curs1 refcursor;
    curs2 CURSOR FOR SELECT * FROM tenk1;
    curs3 CURSOR (key integer) FOR SELECT * FROM tenk1 WHERE unique1 = key;
</programlisting>
     Все три переменные имеют тип данных <type>refcursor</>. Первая может быть 
     использована с любым запросом, вторая связана (<literal>bound</>) с полностью 
     сформированным запросом, а последняя связана с параметризованным запросом. 
     (<literal>key</> будет заменен целочисленным значением параметра при открытии 
     курсора.) Про переменную <literal>curs1</> говорят, что она является несвязанной 
     (<literal>unbound</>), т.к. к ней не привязан никакой запрос.
    </para>
   </sect2>

   <sect2 id="plpgsql-cursor-opening">
<!-- en
    <title>Opening Cursors</title>
-->
    <title>Открытие курсора</title>

    <para>
     Прежде чем получать строки из курсора, его нужно открыть. (Это эквивалентно 
     действию SQL команды <command>DECLARE CURSOR</>.) В <application>PL/pgSQL</>
     есть три формы оператора <command>OPEN</>, две из которых используются для 
     несвязанных курсорных переменных, а третья для связанных.
    </para>

    <note>
     <para>
      Связанные курсорные переменные можно использовать с циклом <command>FOR</> 
      без явного открытия курсора, как описано в
      <xref linkend="plpgsql-cursor-for-loop">.
     </para>
    </note>

    <sect3>
     <title><command>OPEN FOR</command> <replaceable>query</replaceable></title>

<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR <replaceable>query</replaceable>;
</synopsis>

       <para>
        Курсорная переменная открывается и получает конкретный запрос для выполнения. 
        Курсор не может уже быть открытым, а курсорная переменная обязана быть 
        несвязанной (то есть просто переменной типа <type>refcursor</>). Запрос 
        должен быть командой <command>SELECT</command> или любой другой, которая 
        возвращает строки (к примеру <command>EXPLAIN</>). Запрос обрабатывается так же, 
        как и другие команды SQL в <application>PL/pgSQL</>:  имена 
        <application>PL/pgSQL</> переменных заменяются на значения, план запроса 
        кэшируется для повторного использования. Подстановка значений 
        <application>PL/pgSQL</> переменных проводится при открытии курсора командой 
        <command>OPEN</>, последующие изменения значений переменных не влияют на работу 
        курсора. <literal>SCROLL</> и <literal>NO SCROLL</> имеют тот же смысл, 
        что и для связанного курсора.
       </para>

       <para>
        Пример:
<programlisting>
OPEN curs1 FOR SELECT * FROM foo WHERE key = mykey;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><command>OPEN FOR EXECUTE</command></title>

<synopsis>
OPEN <replaceable>unbound_cursorvar</replaceable> <optional> <optional> NO </optional> SCROLL </optional> FOR EXECUTE <replaceable class="command">query_string</replaceable>
                                     <optional> USING <replaceable>expression</replaceable> <optional>, ... </optional> </optional>;
</synopsis>

         <para>
          Курсорная переменная открывается и получает конкретный запрос для выполнения. 
          Курсор не может уже быть открытым, а курсорная переменная обязана быть 
          несвязанной (то есть просто переменной типа <type>refcursor</>). Запрос 
          задается строковым выражением, так же, как в команде <command>EXECUTE</command>. 
          Как обычно, это дает гибкость, план запроса от раза к разу может меняться
          (смотри <xref linkend="plpgsql-plan-caching">). Это также означает, 
          что замена переменных выполняется не в командной строке. Как и в 
          <command>EXECUTE</command>, для вставки в динамическую команду значений 
          параметров используется <literal>USING</>. 
          <literal>SCROLL</> и <literal>NO SCROLL</> имеют тот же смысл, что и для 
          связанного курсора.
         </para>

       <para>
        Пример:
<programlisting>
OPEN curs1 FOR EXECUTE 'SELECT * FROM ' || quote_ident(tabname)
                                        || ' WHERE col1 = $1' USING keyvalue;
</programlisting>
        В этом примере имя таблицы вставляется в текст запроса, поэтому рекомендуется 
        использовать функцию <function>quote_ident()</> для защиты от SQL инъекций. 
        Значение для сравнения с <literal>col1</> вставляется через <literal>USING</>, 
        поэтому его не требуется заключать в кавычки.
       </para>
     </sect3>

    <sect3 id="plpgsql-open-bound-cursor">
<!-- en
     <title>Opening a Bound Cursor</title>
-->
     <title>Открытие связанного курсора</title>

<synopsis>
OPEN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional>;
</synopsis>

         <para>
          Эта форма <command>OPEN</command> используется для открытия курсорной 
          переменной, которая была связана с запросом при объявлении. Курсор не может 
          уже быть открытым. Список фактических значений аргументов должен присутствовать 
          только в том случае, если курсор объявлялся с параметрами. Эти значения 
          будут подставлены в запрос.
         </para>

         <para>
          План запроса для связанного курсора всегда считается кэшируемым. 
          В этом случае, нет эквивалента <command>EXECUTE</command>. Обратите 
          внимание, что <literal>SCROLL</> и <literal>NO SCROLL</> не могут быть указаны 
          в этой форме <command>OPEN</>, возможность прокрутки назад была определена 
          при объявлении курсора.
         </para>

         <para>
          При передаче значений аргументов можно использовать позиционную или именную 
          нотацию. В позиционной нотации все аргументы указываются по порядку. 
          В именной нотации имя каждого аргумента отделяется от выражения аргумента  
          с помощью <literal>:=</literal>. Это подобно вызову функций, описанному в 
          <xref linkend="sql-syntax-calling-funcs">. Также разрешается смешивать 
          позиционную и именную нотации.
         </para>

         <para>
          Примеры (здесь используются ранее объявленные курсоры):
<programlisting>
OPEN curs2;
OPEN curs3(42);
OPEN curs3(key := 42);
</programlisting>
         </para>

         <para>
          Так как для связанного курсора выполняется подстановка значений переменных, 
          то, на самом деле, существует два способа передать значения в курсор. 
          Либо  использовать явные аргументы в <command>OPEN</>, либо неявно, 
          ссылаясь на <application>PL/pgSQL</> переменные в запросе. В связанном 
          курсоре можно ссылаться только на те переменные, которые были объявлены 
          до самого курсора. В любом случае, значение переменной для подстановки 
          в запрос будет определяться на момент выполнения <command>OPEN</>. Вот еще 
          один способ получить тот же результат с <literal>curs3</>, как в примере выше:
<programlisting>
DECLARE
    key integer;
    curs4 CURSOR FOR SELECT * FROM tenk1 WHERE unique1 = key;
BEGIN
    key := 42;
    OPEN curs4;
</programlisting>
         </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-using">
<!-- en
    <title>Using Cursors</title>
-->
    <title>Использование курсоров</title>

    <para>
     После того, как курсор был открыт, с ним можно работать при помощи описанных 
     здесь операторов.
    </para>

    <para>
     Работать с курсором необязательно в той же функции, где он был открыт. 
     Из функции можно вернуть значение с типом <type>refcursor</>, что позволит 
     вызывающему продолжить работу с курсором. (Внутри <type>refcursor</> представляет 
     собой обычное строковое имя так называемого портала, содержащего активный запрос 
     курсора. Это имя можно передавать, присваивать другим переменным с типом 
     <type>refcursor</> и так далее, при этом портал не нарушается.)
    </para>

    <para>
     Все порталы неявно закрываются в конце транзакции. Поэтому значение 
     <type>refcursor</> можно использовать для ссылки на открытый курсор только 
     до конца транзакции.
    </para>

    <sect3>
     <title><literal>FETCH</></title>

<synopsis>
FETCH <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable> INTO <replaceable>target</replaceable>;
</synopsis>

    <para>
     <command>FETCH</command> извлекает следующую строку из курсора в 
     <replaceable>target</replaceable>. В качестве <replaceable>target</replaceable> 
     может быть строковая переменная, переменная типа <type>record</type>, 
     или разделенный запятыми список простых переменных, как и в 
     <command>SELECT INTO</command>. Если следующей строки нет, в 
     <replaceable>target</replaceable> присваивается NULL. Как и в 
     <command>SELECT INTO</command>, проверить была ли получена запись можно при 
     помощи специальной переменной <literal>FOUND</literal>.
    </para>

    <para>
     Значение <replaceable>direction</replaceable> может быть любым допустимым в 
     SQL команде <xref linkend="sql-fetch"> вариантом, кроме тех, что извлекают более 
     одной строки. А именно: 
     <literal>NEXT</>,
     <literal>PRIOR</>,
     <literal>FIRST</>,
     <literal>LAST</>,
     <literal>ABSOLUTE</> <replaceable>count</replaceable>,
     <literal>RELATIVE</> <replaceable>count</replaceable>,
     <literal>FORWARD</> или
     <literal>BACKWARD</>.
     Без указания <replaceable>direction</replaceable> используется значение 
     <literal>NEXT</>. Значения <replaceable>direction</replaceable>, которые требуют 
     перемещения назад, приведут к ошибке, если курсор не был объявлен или открыт 
     с опцией <literal>SCROLL</>.
    </para>

    <para>
     <replaceable>cursor</replaceable> это переменная с типом <type>refcursor</>, 
     которая ссылается на открытый портал курсора.
    </para>

    <para>
     Примеры:
<programlisting>
FETCH curs1 INTO rowvar;
FETCH curs2 INTO foo, bar, baz;
FETCH LAST FROM curs3 INTO x, y;
FETCH RELATIVE -2 FROM curs4 INTO x;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>MOVE</></title>

<synopsis>
MOVE <optional> <replaceable>direction</replaceable> { FROM | IN } </optional> <replaceable>cursor</replaceable>;
</synopsis>

    <para>
     <command>MOVE</command> перемещает курсор без извлечения данных. 
     <command>MOVE</command> работает точно также как и <command>FETCH</command>, 
     но при этом только перемещает курсор и не извлекает строку, к которой переместился. 
     Как и в <command>SELECT INTO</command>, проверить успешность перемещения можно с 
     помощью специальной переменной <literal>FOUND</literal>.
    </para>

    <para>
     Значение <replaceable>direction</replaceable> может быть любым допустимым в 
     SQL команде <xref linkend="sql-fetch"> вариантом, а именно: 
     <literal>NEXT</>,
     <literal>PRIOR</>,
     <literal>FIRST</>,
     <literal>LAST</>,
     <literal>ABSOLUTE</> <replaceable>count</replaceable>,
     <literal>RELATIVE</> <replaceable>count</replaceable>,
     <literal>ALL</>,
     <literal>FORWARD</> <optional> <replaceable>count</replaceable> | <literal>ALL</> </optional> или
     <literal>BACKWARD</> <optional> <replaceable>count</replaceable> | <literal>ALL</> </optional>.
     Без указания <replaceable>direction</replaceable> используется значение 
     <literal>NEXT</>. Значения <replaceable>direction</replaceable>, которые требуют 
     перемещения назад, приведут к ошибке, если курсор не был объявлен или открыт 
     с опцией <literal>SCROLL</>.
    </para>

    <para>
     Примеры:
<programlisting>
MOVE curs1;
MOVE LAST FROM curs3;
MOVE RELATIVE -2 FROM curs4;
MOVE FORWARD 2 FROM curs4;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>UPDATE/DELETE WHERE CURRENT OF</></title>

<synopsis>
UPDATE <replaceable>table</replaceable> SET ... WHERE CURRENT OF <replaceable>cursor</replaceable>;
DELETE FROM <replaceable>table</replaceable> WHERE CURRENT OF <replaceable>cursor</replaceable>;
</synopsis>

       <para>
        Когда курсор позиционирован на строку таблицы, эту строку можно изменить 
        или удалить при помощи курсора. Есть ограничения на то, каким может быть 
        запрос курсора (в частности, не должно быть группировок), 
        и крайне желательно использовать фразу <literal>FOR UPDATE</>. 
        Для дополнительной информации, смотри справку по <xref linkend="sql-declare">.
       </para>

       <para>
        Пример:
<programlisting>
UPDATE foo SET dataval = myval WHERE CURRENT OF curs1;
</programlisting>
       </para>
     </sect3>

    <sect3>
     <title><literal>CLOSE</></title>

<synopsis>
CLOSE <replaceable>cursor</replaceable>;
</synopsis>

       <para>
        <command>CLOSE</command> закрывает связанный с курсором портал. Используется 
        для того, чтобы освободить ресурсы раньше, чем закончится транзакция, 
        или чтобы освободить курсорную переменную для повторного открытия.
       </para>

       <para>
        Пример:
<programlisting>
CLOSE curs1;
</programlisting>
       </para>
     </sect3>

    <sect3>
<!-- en
     <title>Returning Cursors</title>
-->
     <title>Возврат курсора из функции</title>

       <para>
        Курсоры можно возвращать из <application>PL/pgSQL</> функции. Это полезно, 
        когда нужно вернуть множество строк и столбцов, особенно если выборки 
        очень большие. Для этого, в функции открывается курсор и его имя возвращается 
        вызывающему (или просто открывается курсор, используя указанное имя портала, 
        каким-либо образом известное вызывающему). Вызывающий затем может извлекать 
        строки из курсора. Курсор может быть закрыт вызывающим или он будет автоматически 
        закрыт при завершении транзакции.
       </para>

       <para>
        Имя портала, используемое для курсора, может быть указано разработчиком или 
        будет генерироваться автоматически. Чтобы указать имя портала, нужно просто 
        присвоить строку в переменную <type>refcursor</> перед его открытием. 
        Значение строки переменной <type>refcursor</> будет использоваться командой 
        <command>OPEN</> как имя портала. Однако, если переменная <type>refcursor</>
        имеет значение NULL, <command>OPEN</> автоматически генерирует имя, которое 
        не конфликтует с любым существующим порталом и присваивает его переменной 
        <type>refcursor</>.
       </para>

       <note>
        <para>
         Связанная курсорная переменная инициализируется в строковое значение, 
         представляющее собой имя самой переменной. Таким образом, имя портала 
         совпадает с именем курсорной переменной, кроме случаев, когда разработчик 
         переопределил имя, присвоив новое значение перед открытием курсора. 
         Несвязанная курсорная переменная инициализируется в NULL и получит 
         автоматически сгенерированное уникальное имя, если не будет переопределена.
        </para>
       </note>

       <para>
        Следующий пример показывает один из способов передачи имени курсора вызывающему:

<programlisting>
CREATE TABLE test (col text);
INSERT INTO test VALUES ('123');

CREATE FUNCTION reffunc(refcursor) RETURNS refcursor AS '
BEGIN
    OPEN $1 FOR SELECT col FROM test;
    RETURN $1;
END;
' LANGUAGE plpgsql;

BEGIN;
SELECT reffunc('funccursor');
FETCH ALL IN funccursor;
COMMIT;
</programlisting>
       </para>

       <para>
        В следующем примере используется автоматическая генерация имени курсора:

<programlisting>
CREATE FUNCTION reffunc2() RETURNS refcursor AS '
DECLARE
    ref refcursor;
BEGIN
    OPEN ref FOR SELECT col FROM test;
    RETURN ref;
END;
' LANGUAGE plpgsql;

-- для использования курсоров, необходимо начать транзакцию
BEGIN;
SELECT reffunc2();

      reffunc2
--------------------
 &lt;unnamed cursor 1&gt;
(1 row)

FETCH ALL IN "&lt;unnamed cursor 1&gt;";
COMMIT;
</programlisting>
       </para>

       <para>
        В следующем примере показан один из способов вернуть несколько курсоров 
        из одной функции:

<programlisting>
CREATE FUNCTION myfunc(refcursor, refcursor) RETURNS SETOF refcursor AS $$
BEGIN
    OPEN $1 FOR SELECT * FROM table_1;
    RETURN NEXT $1;
    OPEN $2 FOR SELECT * FROM table_2;
    RETURN NEXT $2;
END;
$$ LANGUAGE plpgsql;

-- для использования курсоров необходимо начать транзакцию
BEGIN;

SELECT * FROM myfunc('a', 'b');

FETCH ALL FROM a;
FETCH ALL FROM b;
COMMIT;
</programlisting>
       </para>
     </sect3>
   </sect2>

   <sect2 id="plpgsql-cursor-for-loop">
<!-- en
    <title>Looping Through a Cursor's Result</title>
-->
    <title>Обработка курсора в цикле</title>

    <para>
     Один из вариантов цикла <command>FOR</> позволяет перебирать строки, 
     возвращенные курсором. Вот его синтаксис:

<synopsis>
<optional> &lt;&lt;<replaceable>label</replaceable>&gt;&gt; </optional>
FOR <replaceable>recordvar</replaceable> IN <replaceable>bound_cursorvar</replaceable> <optional> ( <optional> <replaceable>argument_name</replaceable> := </optional> <replaceable>argument_value</replaceable> <optional>, ...</optional> ) </optional> LOOP
    <replaceable>statements</replaceable>
END LOOP <optional> <replaceable>label</replaceable> </optional>;
</synopsis>

     Курсорная переменная должна быть связана с запросом при объявлении. 
     Курсор <emphasis>не может</> быть открытым. Команда <command>FOR</> автоматически 
     открывает курсор и автоматически закрывает при завершении цикла. Список 
     фактических значений аргументов должен присутствовать только в том случае, 
     если курсор объявлялся с параметрами. Эти значения будут подставлены в запрос, 
     также как и при выполнении <command>OPEN</> 
     (смотри <xref linkend="plpgsql-open-bound-cursor">).
   </para>

   <para>
     Переменная <replaceable>recordvar</replaceable> автоматически определяется 
     как переменная типа <type>record</> и существует только внутри цикла 
     (другие объявленные переменные с таким именем игнорируется в цикле). 
     Каждая возвращаемая курсором строка последовательно присваивается этой переменной 
     и выполняется тело цикла.
    </para>
   </sect2>

  </sect1>

  <sect1 id="plpgsql-errors-and-messages">
<!-- en
   <title>Errors and Messages</title>
-->
   <title>Сообщения и ошибки</title>

   <indexterm>
    <primary>RAISE</primary>
   </indexterm>

   <indexterm>
    <primary>reporting errors</primary>
    <secondary>in PL/pgSQL</secondary>
   </indexterm>

   <para>
    Команда <command>RAISE</command> предназначена для вывода сообщений и вызова ошибок.

<synopsis>
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> '<replaceable class="parameter">format</replaceable>' <optional>, <replaceable class="parameter">expression</replaceable> <optional>, ... </optional></optional> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> <replaceable class="parameter">condition_name</> <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> SQLSTATE '<replaceable class="parameter">sqlstate</>' <optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional> </optional>;
RAISE <optional> <replaceable class="parameter">level</replaceable> </optional> USING <replaceable class="parameter">option</replaceable> = <replaceable class="parameter">expression</replaceable> <optional>, ... </optional>;
RAISE ;
</synopsis>

    <replaceable class="parameter">level</replaceable> задает уровень серьезности 
    ошибки. Возможные значения:
    <literal>DEBUG</literal>, <literal>LOG</literal>, <literal>INFO</literal>,
    <literal>NOTICE</literal>, <literal>WARNING</literal> и <literal>EXCEPTION</literal>. 
    По умолчанию используется <literal>EXCEPTION</literal>.
    <literal>EXCEPTION</literal> вызывает ошибку (что обычно прерывает текущую транзакцию),
    остальные значения <replaceable class="parameter">level</replaceable> только генерируют 
    сообщения с различными уровнями приоритета.
    Будут ли сообщения конкретного приоритета переданы клиенту, или записаны в лог сервера, 
    или и то и другое, зависит от конфигурационных переменных 
    <xref linkend="guc-log-min-messages"> и <xref linkend="guc-client-min-messages">.
    Смотри <xref linkend="runtime-config"> для дополнительной информации.
   </para>

   <para>
    После <replaceable class="parameter">level</replaceable> можно записать 
    <replaceable class="parameter">format</replaceable> (это должна быть простая 
    символьная строка, не являющаяся выражением).
    Строка <replaceable class="parameter">format</replaceable> задает текст сообщения 
    об ошибке. После <replaceable class="parameter">format</replaceable> может следовать 
    список необязательных аргументов выражений для вставки в текст сообщения.
    Внутри строки <replaceable class="parameter">format</replaceable> символ <literal>%</> 
    заменяется на текстовое представление следующего необязательного значения аргумента.
    Чтобы вставить символ <literal>%</>, используйте <literal>%%</>.
   </para>

   <para>
    В следующем примере символ <literal>%</> будет заменен на значение <literal>v_job_id</>:
<programlisting>
RAISE NOTICE 'Вызов функции cs_create_job(%)', v_job_id;
</programlisting>
   </para>

   <para>
    При помощи фразы <literal>USING</> и последующих элементов <replaceable
    class="parameter">option</replaceable> = <replaceable
    class="parameter">expression</replaceable> можно добавить дополнительную 
    информацию к отчету об ошибке. Все <replaceable class="parameter">expression</replaceable> 
    представляют собой строковые выражения. Возможные ключевые слова для
    <replaceable class="parameter">option</replaceable> следующие:

    <variablelist id="raise-using-options">
     <varlistentry>
      <term><literal>MESSAGE</literal></term>
      <listitem>
       <para>
        Устанавливает текст сообщения об ошибке. Эта опция не может использоваться,
        если в команде <command>RAISE</> присутствует 
        <replaceable class="parameter">format</replaceable> перед <literal>USING</>.
        </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>DETAIL</literal></term>
      <listitem>
       <para>Предоставляет детальное сообщение об ошибке.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>HINT</literal></term>
      <listitem>
       <para>Предоставляет подсказку по вызванной ошибке.</para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>ERRCODE</literal></term>
      <listitem>
       <para>
        Устанавливает код ошибки (<literal>SQLSTATE</>). Код ошибки задается
        либо по имени, как показано в <xref linkend="errcodes-appendix">,
        или напрямую, пятисимвольный код <literal>SQLSTATE</>.
        </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>COLUMN</literal></term>
      <term><literal>CONSTRAINT</literal></term>
      <term><literal>DATATYPE</literal></term>
      <term><literal>TABLE</literal></term>
      <term><literal>SCHEMA</literal></term>
      <listitem>
       <para>Предоставляет имя соответствующего объекта, связанного с ошибкой.</para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

   <para>
    Этот пример прерывает транзакцию и устанавливает сообщение об ошибке с подсказкой:
<programlisting>
RAISE EXCEPTION 'Несуществующий ID --> %', user_id
      USING HINT = 'Проверьте ваш пользовательский ID';
</programlisting>
   </para>

   <para>
    Следующие два примера демонстрируют эквивалентные способы задания <literal>SQLSTATE</>:
<programlisting>
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = 'unique_violation';
RAISE 'Duplicate user ID: %', user_id USING ERRCODE = '23505';
</programlisting>
   </para>

   <para>
    У команды <command>RAISE</> есть и другой синтаксис, в котором в качестве главного 
    аргумента используется имя или код <literal>SQLSTATE</> ошибки. Например:
<programlisting>
RAISE division_by_zero;
RAISE SQLSTATE '22012';
</programlisting>
    Фразу <literal>USING</> в этом синтаксисе можно использовать для того, 
    чтобы переопределить стандартное сообщение об ошибке, детальное сообщение, подсказку. 
    Еще один вариант предыдущего примера:
<programlisting>
RAISE unique_violation USING MESSAGE = 'ID пользователя уже существует: ' || user_id;
</programlisting>
   </para>

   <para>
    Еще один вариант - использовать <literal>RAISE USING</> или <literal>RAISE
    <replaceable class="parameter">level</replaceable> USING</>,
    а всё остальное прописать в опциях <literal>USING</>.
   </para>

   <para>
    И заключительный вариант, в котором <command>RAISE</> не имеет параметров вообще.
    Эта форма может использоваться только в секции <literal>EXCEPTION</> блока и 
    предназначена для того, чтобы повторно вызвать ошибку, которая сейчас перехвачена
    и обрабатывается.
   </para>

   <note>
    <para>
     До версии <productname>PostgreSQL</> 9.1 команда <command>RAISE</> без параметров 
     всегда вызывала ошибку с выходом из блока, содержащего активную секцию 
     <literal>EXCEPTION</>. Эту ошибку нельзя было перехватить, даже если 
     <command>RAISE</> в секции <literal>EXCEPTION</> поместить 
     во вложенный блок со своей секцией <literal>EXCEPTION</>. 
     Это было сочтено удивительным и не совместимым с Oracle PL/SQL.
    </para>
   </note>

   <para>
    Если в команде <command>RAISE EXCEPTION</command> не задано ни имя, 
    ни <literal>SQLSTATE</> код, то по умолчанию используются 
    <literal>RAISE_EXCEPTION</> (<literal>P0001</>).
    В качестве текста сообщения об ошибке (если не задан) используется 
    имя или <literal>SQLSTATE</> код.
   </para>

   <note>
    <para>
     При задании <literal>SQLSTATE</> кода необязательно использовать только
     список предопределенных кодов ошибок. В качестве кода ошибки может быть
     любое пятисимвольное значение, состоящее из цифр и/или ASCII символов в верхнем 
     регистре, кроме <literal>00000</>.
     Не рекомендуется использовать коды ошибок, которые заканчиваются на <literal>000</>,
     потому что так обозначаются коды категорий. И чтобы их перехватить, нужно
     перехватывать целую категорию.
    </para>
   </note>

 </sect1>

 <sect1 id="plpgsql-trigger">
<!-- en
  <title>Trigger Procedures</title>
-->
  <title>Триггерные процедуры</title>

  <indexterm zone="plpgsql-trigger">
   <primary>trigger</primary>
   <secondary>in PL/pgSQL</secondary>
  </indexterm>

  <sect2 id="plpgsql-dml-trigger">
<!-- en
   <title>Triggers on Data changes</title>
-->
   <title>Триггеры на изменение данных</title>

   <para>
    В <application>PL/pgSQL</application> можно создавать триггерные процедуры. 
    Триггерная процедура создается командой <command>CREATE FUNCTION</>, 
    при этом у функции не должно быть аргументов, а тип возвращаемого значения
    должен быть <type>trigger</type>. Обратите внимание, что функция создается 
    без аргументов, даже если ей нужно получить аргументы, указанные в команде 
    <command>CREATE TRIGGER</>.
    Аргументы триггера передаются через массив <varname>TG_ARGV</>, как будет показано ниже.
  </para>

  <para>
   Когда <application>PL/pgSQL</application> функция срабатывает как триггер, 
   в блоке верхнего уровня автоматически создаются несколько специальных переменных:

   <variablelist>
    <varlistentry>
     <term><varname>NEW</varname></term>
     <listitem>
      <para>
       Тип данных <type>RECORD</type>. Переменная содержит новую строку базы данных для
       команд <command>INSERT</>/<command>UPDATE</> в триггерах уровня строки. 
       В триггерах уровня оператора и для команды <command>DELETE</command> этой 
       переменной значение не присваивается.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>OLD</varname></term>
     <listitem>
      <para>
       Тип данных <type>RECORD</type>. Переменная содержит старую строку базы данных для
       команд <command>UPDATE</>/<command>DELETE</> в триггерах уровня строки. 
       В триггерах уровня оператора и для команды <command>INSERT</command> этой 
       переменной значение не присваивается.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NAME</varname></term>
     <listitem>
      <para>
       Тип данных <type>name</type>. Переменная содержит имя сработавшего триггера.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_WHEN</varname></term>
     <listitem>
      <para>
       Тип данных <type>text</type>. Строка, содержащая <literal>BEFORE</literal>, 
       <literal>AFTER</literal> или <literal>INSTEAD OF</literal>, 
       в зависимости от определения триггера.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_LEVEL</varname></term>
     <listitem>
      <para>
       Тип данных <type>text</type>. Строка, содержащая <literal>ROW</literal> или
       <literal>STATEMENT</literal>, в зависимости от определения триггера.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_OP</varname></term>
     <listitem>
      <para>
       Тип данных <type>text</type>. Строка, содержащая 
       <literal>INSERT</literal>, <literal>UPDATE</literal>,
       <literal>DELETE</literal> или <literal>TRUNCATE</>, 
       в зависимости от того, для какой операции сработал триггер.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELID</varname></term>
     <listitem>
      <para>
       Тип данных <type>oid</type>. OID таблицы, для которой сработал триггер.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_RELNAME</varname></term>
     <listitem>
      <para>
       Тип данных <type>name</type>. Имя таблицы, для которой сработал триггер.
       Эта переменная устарела и может стать недоступной в будущих релизах.
       Вместо неё нужно использовать <literal>TG_TABLE_NAME</>.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_NAME</varname></term>
     <listitem>
      <para>
       Тип данных <type>name</type>. Имя таблицы, для которой сработал триггер.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TABLE_SCHEMA</varname></term>
     <listitem>
      <para>
       Тип данных <type>name</type>. Имя схемы, содержащей таблицу, 
       для которой сработал триггер.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_NARGS</varname></term>
     <listitem>
      <para>
       Тип данных <type>integer</type>. Число аргументов в команде 
       <command>CREATE TRIGGER</command>, которые передаются в триггерную процедуру.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_ARGV[]</varname></term>
     <listitem>
      <para>
       Тип данных массив <type>text</type>. 
       Аргументы от оператора <command>CREATE TRIGGER</command>.
       Индекс массива начинается с 0. Для недопустимых значений индекса
       ( < 0 или >= <varname>tg_nargs</>) возвращается NULL.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <para>
    Триггерная функция должна вернуть либо <symbol>NULL</symbol>, 
    либо запись/строку, соответствующую структуре таблице, 
    для которой сработал триггер.
   </para>

   <para>
    Если <literal>BEFORE</> триггер уровня строки возвращает <symbol>NULL</symbol>,
    то все дальнейшие действия с этой строкой прекращаются (т.е. не срабатывают
    последующие триггера, команда 
    <command>INSERT</>/<command>UPDATE</>/<command>DELETE</> 
    для этой строки не выполняется).
    Если возвращается не <symbol>NULL</symbol>, то дальнейшая обработка продолжается 
    именно с этой строкой. Возвращение строки отличной от начальной <varname>NEW</>,
    изменяет строку, которая будет вставлена или изменена.
    Поэтому, если в триггерной функции нужно выполнить некоторые действия и не менять
    саму строку, то нужно возвратить переменную <varname>NEW</> (или её эквивалент).
    Для того чтобы изменить сохраняемую строку, можно поменять отдельные значения в
    переменной <varname>NEW</> и затем её вернуть. Либо создать и вернуть полностью 
    новую переменную.
    В случае строчного триггера <literal>BEFORE</> для команды <command>DELETE</> 
    само возвращаемое значение не имеет прямого эффекта, но оно должно быть
    отличным от <symbol>NULL</symbol>, чтобы не прерывать обработку строки.
    Обратите внимание, что переменная <varname>NEW</> всегда <symbol>NULL</symbol> в 
    триггерах на <command>DELETE</>, поэтому возвращать её не имеет смысла.
    Традиционной идиомой для триггеров <command>DELETE</> является возврат переменной 
    <varname>OLD</varname>.
   </para>

   <para>
    Триггеры <literal>INSTEAD OF</> могут создаваться только как триггеры уровня 
    строки и только для представлений. Если <literal>INSTEAD OF</> триггер возвращает 
    <symbol>NULL</symbol>, то это значит, что он не произвел никаких изменений и 
    дальнейшая обработка этой строки не требуется (т.е. для соответствующей команды
    <command>INSERT</>/<command>UPDATE</>/<command>DELETE</>
    не срабатывают последующие триггера и не увеличивается счетчик обработанных строк).
    В остальных случаях должно возвращаться значение, отличное от <symbol>NULL</symbol>, 
    что означает, что триггер выполнил требуемые действия.
    Команды <command>INSERT</> и <command>UPDATE</> должны возвращать <varname>NEW</>
    (которая может быть изменена в триггерной функции)
    для корректной работы <command>INSERT RETURNING</> и <command>UPDATE RETURNING</>. 
    Возвращаемое значение также влияет на значение строки, которое будет передано 
    в последующие триггеры. Для команды <command>DELETE</> возвращаемое значение 
    должно быть <varname>OLD</>.
   </para>

   <para>
    Возвращаемое значение для строчного триггера AFTER и триггеров уровня оператора
    (BEFORE или AFTER) всегда игнорируется. Это может быть и NULL.
    Однако, в этих триггерах по-прежнему можно прервать вызвавшую их команду,
    для этого нужно явно вызвать ошибку.
   </para>

   <para>
    <xref linkend="plpgsql-trigger-example"> показывает пример триггерной процедуры в 
    <application>PL/pgSQL</application>.
   </para>

   <example id="plpgsql-trigger-example">
<!-- en
    <title>A <application>PL/pgSQL</application> Trigger Procedure</title>
-->
    <title>Триггерная процедура <application>PL/pgSQL</application></title>

    <para>
     Триггер гарантирует, что всякий раз, когда в таблице добавляется или 
     изменяется запись, в этой записи сохраняется информация о текущем пользователе
     и временной метке.
     Также контролируется, что имя сотрудника указано и размер зарплаты выше нуля.
    </para>

<programlisting>
CREATE TABLE emp (
    empname text,
    salary integer,
    last_date timestamp,
    last_user text
);

CREATE FUNCTION emp_stamp() RETURNS trigger AS $emp_stamp$
    BEGIN
        -- Проверим, что указаны имя сотрудника и зарплата
        IF NEW.empname IS NULL THEN
            RAISE EXCEPTION 'Не указано имя сотрудника';
        END IF;
        IF NEW.salary IS NULL THEN
            RAISE EXCEPTION 'Не указана зарплата для %', NEW.empname;
        END IF;

        -- Зачем работать, если за это еще нужно платить?
        IF NEW.salary &lt; 0 THEN
            RAISE EXCEPTION 'У % не должна быть отрицательная зарплата', NEW.empname;
        END IF;

        -- Запомним кто и когда изменил запись
        NEW.last_date := current_timestamp;
        NEW.last_user := current_user;
        RETURN NEW;
    END;
$emp_stamp$ LANGUAGE plpgsql;

CREATE TRIGGER emp_stamp BEFORE INSERT OR UPDATE ON emp
    FOR EACH ROW EXECUTE PROCEDURE emp_stamp();
</programlisting>
   </example>

   <para>
    Другой вариант вести журнал изменений для таблицы предполагает создание
    новой таблицы, которая будет содержать отдельную запись для каждой 
    выполненной команды INSERT, UPDATE, DELETE.
    Этот подход можно рассматривать как аудирование изменений таблицы.
    <xref linkend="plpgsql-trigger-audit-example"> показывает реализацию 
    триггерной процедуры для аудита в <application>PL/pgSQL</application>.
   </para>

   <example id="plpgsql-trigger-audit-example">
<!-- en
    <title>A <application>PL/pgSQL</application> Trigger Procedure For Auditing</title>
-->
    <title>Триггерная процедура для аудита в <application>PL/pgSQL</application></title>

    <para>
     Триггер гарантирует, что любая команда на вставку, изменение или удаление строки 
     в таблице <literal>emp</> будет записана (аудирована) в таблице <literal>emp_audit</>.
     Также записывается информация о пользователе, выполнившем операцию, временной метке
     и типе операции.
    </para>

<programlisting>
CREATE TABLE emp (
    empname           text NOT NULL,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    stamp             timestamp NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary integer
);

CREATE OR REPLACE FUNCTION process_emp_audit() RETURNS TRIGGER AS $emp_audit$
    BEGIN
        --
        -- Создаем строку в emp_audit, которая отражает выполненную операцию.
        -- Воспользуемся переменной TG_OP для определения типа операции.
        --
        IF (TG_OP = 'DELETE') THEN
            INSERT INTO emp_audit SELECT 'D', now(), user, OLD.*;
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            INSERT INTO emp_audit SELECT 'U', now(), user, NEW.*;
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp_audit SELECT 'I', now(), user, NEW.*;
            RETURN NEW;
        END IF;
        RETURN NULL; -- возвращаемое значение для AFTER триггера не имеет значения
    END;
$emp_audit$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
AFTER INSERT OR UPDATE OR DELETE ON emp
    FOR EACH ROW EXECUTE PROCEDURE process_emp_audit();
</programlisting>
   </example>

   <para>
    У предыдущего примера есть разновидность, которая использует представление,
    соединяющее основную таблицу и таблицу аудита, для отображения даты последнего
    изменения каждой строки. При этом подходе по-прежнему ведется полный журнал
    аудита в отдельной таблице, но также имеется представление с упрощенным аудиторским
    следом. Это представление содержит временную метку, которая вычисляется
    для каждой строки из данных аудиторской таблицы.
    <xref linkend="plpgsql-view-trigger-audit-example"> показывает пример
    триггера на представление для аудита в <application>PL/pgSQL</application>.
   </para>

   <example id="plpgsql-view-trigger-audit-example">
<!-- en
    <title>A <application>PL/pgSQL</application> View Trigger Procedure For Auditing</title>
-->
    <title>Триггер на представление для аудита в <application>PL/pgSQL</application></title>

    <para>
     Триггер на представление используется для того, чтобы сделать это представление
     изменяемым и гарантировать, что любая команда на вставку, изменение или удаление
     строки в представлении будет записана (т.е. аудирована) в таблице
     <literal>emp_audit</>. Также записываются временная метка, имя пользователя и
     тип выполняемой операции. Представление показывает дату последнего изменения
     для каждой строки.
    </para>

<programlisting>
CREATE TABLE emp (
    empname           text PRIMARY KEY,
    salary            integer
);

CREATE TABLE emp_audit(
    operation         char(1)   NOT NULL,
    userid            text      NOT NULL,
    empname           text      NOT NULL,
    salary            integer,
    stamp             timestamp NOT NULL
);

CREATE VIEW emp_view AS
    SELECT e.empname,
           e.salary,
           max(ea.stamp) AS last_updated
      FROM emp e
      LEFT JOIN emp_audit ea ON ea.empname = e.empname
     GROUP BY 1, 2;

CREATE OR REPLACE FUNCTION update_emp_view() RETURNS TRIGGER AS $$
    BEGIN
        --
        -- Выполняем требуемую операцию в emp и создаем строку в emp_audit,
        -- которая отражает сделанную операцию.
        --
        IF (TG_OP = 'DELETE') THEN
            DELETE FROM emp WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            OLD.last_updated = now();
            INSERT INTO emp_audit VALUES('D', user, OLD.*);
            RETURN OLD;
        ELSIF (TG_OP = 'UPDATE') THEN
            UPDATE emp SET salary = NEW.salary WHERE empname = OLD.empname;
            IF NOT FOUND THEN RETURN NULL; END IF;

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('U', user, NEW.*);
            RETURN NEW;
        ELSIF (TG_OP = 'INSERT') THEN
            INSERT INTO emp VALUES(NEW.empname, NEW.salary);

            NEW.last_updated = now();
            INSERT INTO emp_audit VALUES('I', user, NEW.*);
            RETURN NEW;
        END IF;
    END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER emp_audit
INSTEAD OF INSERT OR UPDATE OR DELETE ON emp_view
    FOR EACH ROW EXECUTE PROCEDURE update_emp_view();
</programlisting>
   </example>

   <para>
    Один из вариантов использования триггеров это поддержание в актуальном 
    состоянии отдельной таблицы итогов для некоторой таблицы.
    В некоторых случаях отдельная таблица с итогами может использоваться в запросах
    вместо основной таблицы. При этом зачастую время выполнения запросов значительно 
    сокращается. Эта техника широко используется в хранилищах данных, где
    таблицы фактов могут быть очень большими.
    <xref linkend="plpgsql-trigger-summary-example"> показывает триггерную
    процедуру в <application>PL/pgSQL</application>, которая поддерживает таблицу 
    итогов для таблицы фактов в хранилище данных.
   </para>


   <example id="plpgsql-trigger-summary-example">
<!-- en
    <title>A <application>PL/pgSQL</application> Trigger Procedure For Maintaining A Summary Table</title>
-->
    <title>Триггерная процедура в <application>PL/pgSQL</application> для поддержки таблицы итогов</title>

    <para>
     Представленная здесь схема данных частично основана на примере 
     <emphasis>Grocery Store </emphasis>
     из книги <emphasis>The Data Warehouse Toolkit</emphasis> (автор Ralph Kimball).
    </para>

<programlisting>
--
-- Основные таблицы: таблица измерений временных периодов и таблица фактов продаж
--
CREATE TABLE time_dimension (
    time_key                    integer NOT NULL,
    day_of_week                 integer NOT NULL,
    day_of_month                integer NOT NULL,
    month                       integer NOT NULL,
    quarter                     integer NOT NULL,
    year                        integer NOT NULL
);
CREATE UNIQUE INDEX time_dimension_key ON time_dimension(time_key);

CREATE TABLE sales_fact (
    time_key                    integer NOT NULL,
    product_key                 integer NOT NULL,
    store_key                   integer NOT NULL,
    amount_sold                 numeric(12,2) NOT NULL,
    units_sold                  integer NOT NULL,
    amount_cost                 numeric(12,2) NOT NULL
);
CREATE INDEX sales_fact_time ON sales_fact(time_key);

--
-- Таблица с итогами продаж по периодам
--
CREATE TABLE sales_summary_bytime (
    time_key                    integer NOT NULL,
    amount_sold                 numeric(15,2) NOT NULL,
    units_sold                  numeric(12) NOT NULL,
    amount_cost                 numeric(15,2) NOT NULL
);
CREATE UNIQUE INDEX sales_summary_bytime_key ON sales_summary_bytime(time_key);

--
-- Функция и триггер, обновляющие столбцы с итоговыми значениями при выполнении
-- команд INSERT, UPDATE, DELETE
--
CREATE OR REPLACE FUNCTION maint_sales_summary_bytime() RETURNS TRIGGER
AS $maint_sales_summary_bytime$
    DECLARE
        delta_time_key          integer;
        delta_amount_sold       numeric(15,2);
        delta_units_sold        numeric(12);
        delta_amount_cost       numeric(15,2);
    BEGIN

        -- определим на сколько произошло увеличение/уменьшение количеств
        IF (TG_OP = 'DELETE') THEN

            delta_time_key = OLD.time_key;
            delta_amount_sold = -1 * OLD.amount_sold;
            delta_units_sold = -1 * OLD.units_sold;
            delta_amount_cost = -1 * OLD.amount_cost;

        ELSIF (TG_OP = 'UPDATE') THEN

            -- запрещаем изменять time_key
            -- для таких изменений больше подходит DELETE + INSERT
            IF ( OLD.time_key != NEW.time_key) THEN
                RAISE EXCEPTION 'Запрещено изменение time_key : % -&gt; %',
                                                      OLD.time_key, NEW.time_key;
            END IF;

            delta_time_key = OLD.time_key;
            delta_amount_sold = NEW.amount_sold - OLD.amount_sold;
            delta_units_sold = NEW.units_sold - OLD.units_sold;
            delta_amount_cost = NEW.amount_cost - OLD.amount_cost;

        ELSIF (TG_OP = 'INSERT') THEN

            delta_time_key = NEW.time_key;
            delta_amount_sold = NEW.amount_sold;
            delta_units_sold = NEW.units_sold;
            delta_amount_cost = NEW.amount_cost;

        END IF;


        -- вставляем или обновляем строку в таблице итогов.
        &lt;&lt;insert_update&gt;&gt;
        LOOP
            UPDATE sales_summary_bytime
                SET amount_sold = amount_sold + delta_amount_sold,
                    units_sold = units_sold + delta_units_sold,
                    amount_cost = amount_cost + delta_amount_cost
                WHERE time_key = delta_time_key;

            EXIT insert_update WHEN found;

            BEGIN
                INSERT INTO sales_summary_bytime (
                            time_key,
                            amount_sold,
                            units_sold,
                            amount_cost)
                    VALUES (
                            delta_time_key,
                            delta_amount_sold,
                            delta_units_sold,
                            delta_amount_cost
                           );

                EXIT insert_update;

            EXCEPTION
                WHEN UNIQUE_VIOLATION THEN
                    -- ничего не делаем
            END;
        END LOOP insert_update;

        RETURN NULL;

    END;
$maint_sales_summary_bytime$ LANGUAGE plpgsql;

CREATE TRIGGER maint_sales_summary_bytime
AFTER INSERT OR UPDATE OR DELETE ON sales_fact
    FOR EACH ROW EXECUTE PROCEDURE maint_sales_summary_bytime();

INSERT INTO sales_fact VALUES(1,1,1,10,3,15);
INSERT INTO sales_fact VALUES(1,2,1,20,5,35);
INSERT INTO sales_fact VALUES(2,2,1,40,15,135);
INSERT INTO sales_fact VALUES(2,3,1,10,1,13);
SELECT * FROM sales_summary_bytime;
DELETE FROM sales_fact WHERE product_key = 1;
SELECT * FROM sales_summary_bytime;
UPDATE sales_fact SET units_sold = units_sold * 2;
SELECT * FROM sales_summary_bytime;
</programlisting>
   </example>
</sect2>

  <sect2 id="plpgsql-event-trigger">
<!-- en
   <title>Triggers on Events</title>
-->
   <title>Триггеры событий</title>

   <para>
    В <application>PL/pgSQL</application> можно создавать триггеры событий.
    <productname>PostgreSQL</> требует, чтобы процедура, которая вызывается
    как триггер события, была объявлена без аргументов и имела тип возвращаемого 
    значения <literal>event_trigger</>.
   </para>

   <para>
    Когда <application>PL/pgSQL</application> функция срабатывает как триггер 
    события, в блоке верхнего уровня автоматически создаются несколько 
    специальных переменных:

   <variablelist>
    <varlistentry>
     <term><varname>TG_EVENT</varname></term>
     <listitem>
      <para>
       Тип данных <type>text</type>. Строка, содержащая событие, 
       по которому сработал триггер.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><varname>TG_TAG</varname></term>
     <listitem>
      <para>
       Тип данных <type>text</type>. Переменная, содержащая тэг команды,
       для которой сработал триггер.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

   <para>
    <xref linkend="plpgsql-event-trigger-example"> показывает пример процедуры 
    триггера события в <application>PL/pgSQL</application>.
   </para>

   <example id="plpgsql-event-trigger-example">
<!-- en
    <title>A <application>PL/pgSQL</application> Event Trigger Procedure</title>
-->
    <title>Процедура триггера события в <application>PL/pgSQL</application></title>

    <para>
     Триггер просто выдает сообщение всякий раз, когда выполняется поддерживаемая команда.
    </para>

<programlisting>
CREATE OR REPLACE FUNCTION snitch() RETURNS event_trigger AS $$
BEGIN
    RAISE NOTICE 'Произошло событие: % %', tg_event, tg_tag;
END;
$$ LANGUAGE plpgsql;

CREATE EVENT TRIGGER snitch ON ddl_command_start EXECUTE PROCEDURE snitch();
</programlisting>
   </example>
  </sect2>

  </sect1>

  <sect1 id="plpgsql-implementation">
<!-- en
   <title><application>PL/pgSQL</> Under the Hood</title>
-->
   <title><application>PL/pgSQL</> изнутри</title>

   <para>
    В этом разделе обсуждаются некоторые детали реализации, которые пользователям 
    <application>PL/pgSQL</> важно знать.
   </para>

  <sect2 id="plpgsql-var-subst">
<!-- en
   <title>Variable Substitution</title>
-->
   <title>Подстановка переменных</title>

   <para>
    SQL операторы и выражения внутри <application>PL/pgSQL</> функции могут ссылаться 
    на переменные и параметры этой функции. За кулисами <application>PL/pgSQL</> 
    заменяет параметры запросов для таких ссылок. Параметры будут заменены только 
    в местах, где параметр или ссылка на столбец синтаксически допустимы. 
    Как крайний случай, рассмотрим следующий пример плохого стиля программирования:
<programlisting>
INSERT INTO foo (foo) VALUES (foo);
</programlisting>
    Первый раз <literal>foo</> появляется на том месте, где синтаксически должно 
    быть имя таблицы, поэтому замены не будет, даже если функция имеет переменную 
    <literal>foo</>. Второй раз <literal>foo</> встречается там, где должно быть 
    имя столбца таблицы, поэтому замены не будет и здесь. Только третье вхождение 
    <literal>foo</> является кандидатом на то, чтобы быть ссылкой 
    на переменную функции.
   </para>

   <note>
    <para>
     Версии <productname>PostgreSQL</productname> до 9.0 пытаются заменить переменную 
     во всех трех случаях, что приводит к синтаксической ошибке.
    </para>
   </note>

   <para>
    Если имена переменных синтаксически не отличаются от названий столбцов таблицы, 
    то возможна двусмысленность и в ссылках на таблицы. Является ли данное имя 
    ссылкой на столбец таблицы или ссылкой на переменную? Изменим предыдущий пример:
<programlisting>
INSERT INTO dest (col) SELECT foo + bar FROM src;
</programlisting>
    Здесь <literal>dest</> и <literal>src</> должны быть именами таблиц, 
    <literal>col</> должен быть столбцом <literal>dest</>. Однако, <literal>foo</>
    и <literal>bar</> могут быть как переменными функции, так и столбцами <literal>src</>.
   </para>

   <para>
    По умолчанию, <application>PL/pgSQL</> выдаст ошибку, если имя в операторе SQL 
    может относиться как к переменной, так и к столбцу таблицы. Ситуацию можно 
    исправить переименованием переменной, переименованием столбца, точной квалификацией 
    неоднозначной ссылки или указанием <application>PL/pgSQL</> машине, 
    какую интерпретацию предпочесть.
   </para>

   <para>
    Самое простое решение - переименовать переменную или столбец. Общее правило 
    кодирования предполагает использование различных соглашений о наименовании 
    для переменных <application>PL/pgSQL</application> и столбцов таблиц. Например, 
    если имена переменных всегда имеют вид <literal>v_<replaceable>something</></literal>,
    а имена столбцов никогда не начинаются на <literal>v_</>, то конфликты исключены.
   </para>

   <para>
    В качестве альтернативы можно квалифицировать имена неоднозначных ссылок, 
    чтобы сделать их точными. В приведенном выше примере <literal>src.foo</>
    однозначно бы определялась, как ссылка на столбец таблицы. Чтобы сделать 
    однозначный ссылку на переменную, переменная должна быть объявлена в блоке 
    с меткой, и далее нужно использовать эту метку. 
    (смотри <xref linkend="plpgsql-structure">). Например:
<programlisting>
&lt;&lt;block&gt;&gt;
DECLARE
    foo int;
BEGIN
    foo := ...;
    INSERT INTO dest (col) SELECT block.foo + bar FROM src;
</programlisting>
    Здесь <literal>block.foo</> ссылается на переменную, даже если в таблице 
    <literal>src</> есть колонка <literal>foo</>. Параметры функции, а также 
    специальные переменные, такие как <literal>FOUND</>, могут быть квалифицированы 
    по имени функции, потому что они неявно объявлены во внешнем блоке, метка 
    которого совпадает с именем функции.
   </para>

   <para>
    Иногда может быть не очень практичным исправлять таким способом все неоднозначные 
    ссылки в большом куске <application>PL/pgSQL</> кода. В таких случаях можно указать, 
    чтобы <application>PL/pgSQL</> разрешал неоднозначные ссылки в пользу переменных 
    (это совместимо с <application>PL/pgSQL</> до версии <productname>PostgreSQL</> 
    9.0), или в пользу столбцов таблицы (совместимо с некоторыми другими системами, 
    такими как <productname>Oracle</productname>).
   </para>

   <indexterm>
     <primary><varname>plpgsql.variable_conflict</> configuration parameter</primary>
   </indexterm>

   <para>
    На уровне всей системы поведение <application>PL/pgSQL</> регулируется установкой 
    конфигурационного параметра <literal>plpgsql.variable_conflict</>, имеющего значения:  
    <literal>error</>, <literal>use_variable</> или <literal>use_column</> 
    (<literal>error</> устанавливается по умолчанию при установке системы). 
    Изменение этого параметра влияет на все последующие компиляции операторов в 
    <application>PL/pgSQL</> функциях, но не на операторы уже скомпилированные 
    в текущей сессии. Так как изменение этого параметра может привести к неожиданным 
    изменениям в поведении <application>PL/pgSQL</> функций, он может быть изменен 
    только суперпользователем.
   </para>

   <para>
    Поведение <application>PL/pgSQL</> можно изменять для каждой отдельной функции, 
    если добавить в начало функции одну из этих специальных команд:
<programlisting>
#variable_conflict error
#variable_conflict use_variable
#variable_conflict use_column
</programlisting>
    Эти команды влияют только на функцию, в которой они записаны и перекрывают 
    действие <literal>plpgsql.variable_conflict</>. Пример:
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    #variable_conflict use_variable
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = curtime, comment = comment
          WHERE users.id = id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    В команде <literal>UPDATE</>, <literal>curtime</>, <literal>comment</>
    и <literal>id</> будут ссылаться на переменные и параметры функции вне 
    зависимости от того, есть ли столбцы с такими именами в таблице <literal>users</>. 
    Обратите внимание, что нужно квалифицировать именем таблицы ссылку на <literal>users.id</>
    в предложении <literal>WHERE</>, чтобы она ссылалась на столбец таблицы. 
    При этом необязательно квалифицировать ссылку на <literal>comment</> в левой части 
    списка <literal>UPDATE</>, т.к. синтаксически в этом месте должно быть имя 
    столбца таблицы <literal>users</>. Эту функцию можно было бы записать и без 
    зависимости от значения <literal>variable_conflict</>:
<programlisting>
CREATE FUNCTION stamp_user(id int, comment text) RETURNS void AS $$
    &lt;&lt;fn&gt;&gt;
    DECLARE
        curtime timestamp := now();
    BEGIN
        UPDATE users SET last_modified = fn.curtime, comment = stamp_user.comment
          WHERE users.id = stamp_user.id;
    END;
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
    Замена переменных не происходит в строке, исполняемой командой <command>EXECUTE</>
    или её вариантом. Если нужно вставлять изменяющиеся значения в такую команду, 
    то это делается либо при построении самой командной строки или с использованием 
    <literal>USING</>, как показано в <xref linkend="plpgsql-statements-executing-dyn">.
   </para>

   <para>
    Замена переменных в настоящее время работает только в командах <command>SELECT</>,
    <command>INSERT</>, <command>UPDATE</> и <command>DELETE</>, потому что основная 
    SQL машина допускает использование параметров запроса только в этих командах. 
    Чтобы использовать изменяемые имена или значения в других типах операторов 
    (обычно называются утилиты), необходимо построить текст команды в виде строки 
    и выполнить её в <command>EXECUTE</>.
   </para>

  </sect2>

  <sect2 id="plpgsql-plan-caching">
<!-- en
   <title>Plan Caching</title>
-->
   <title>Кэширование плана</title>

   <para>
    Интерпретатор <application>PL/pgSQL</> анализирует исходный текст функции и строит 
    внутреннее бинарное дерево инструкций при первом вызове функции (для каждой сессии). 
    В дерево инструкций полностью переводится вся структура операторов 
    <application>PL/pgSQL</>, но для выражений и команд <acronym>SQL</acronym>, 
    используемых в функции, это происходит не сразу.
   </para>

   <para>
    <indexterm>
     <primary>preparing a query</>
     <secondary>in PL/pgSQL</>
    </indexterm>
    При первом выполнении в функции каждого выражения или команды <acronym>SQL</acronym> 
    интерпретатор <application>PL/pgSQL</> разбирает и анализирует команду для создания 
    подготовленного к выполнению оператора с помощью функции 
    <function>SPI_prepare</function> менеджера интерфейса программирования сервера. 
    Последующие обращения к этому выражению или команде повторно используют подготовленный 
    к выполнению оператор. Таким образом, <acronym>SQL</acronym> команды, находящиеся 
    в редко посещаемой ветке кода условного оператора, не несут накладных расходов 
    на разбор команд, если они так и не будут выполнены в текущей сессии. Здесь есть 
    недостаток, заключающийся в том, что ошибки в определенном выражении или команде 
    не могут быть обнаружены, пока выполнение не дойдет до этой части функции. 
    (Тривиальные синтаксические ошибки обнаружатся в ходе первоначального разбора, 
    но ничего более серьезного не будет обнаружено до исполнения.)
   </para>

   <para>
    Кроме того, <application>PL/pgSQL</> (точнее, менеджер интерфейса программирования 
    сервера) будет пытаться кэшировать план выполнения для любого подготовленного 
    к исполнению оператора. При каждом вызове оператора, если не используется план 
    из кэша, генерируется новый план выполнения, и текущие значения параметров 
    (то есть значения переменных <application>PL/pgSQL</>) могут быть использованы 
    для оптимизации нового плана. Если оператор не имеет параметров или выполняется 
    много раз, менеджер интерфейса программирования сервера рассмотрит вопрос о создании 
    и кэшировании (для повторного использования) общего плана, не зависящего от значений 
    параметров. Как правило, это происходит в тех случаях, когда план выполнения не очень 
    чувствителен к имеющимся ссылкам на значения переменных <application>PL/pgSQL</>. 
    В противном случае, выгоднее каждый раз формировать новый план. 
    Смотри <xref linkend="sql-prepare"> для более подробной информации об операторах, 
    подготовленных к выполнению.
   </para>

   <para>
    Чтобы <application>PL/pgSQL</application> мог сохранять подготовленные операторы 
    и планы выполнения, команды SQL, находящиеся в <application>PL/pgSQL</application> 
    функции, должны использовать одни и те же таблицы и столбцы при каждом исполнении. 
    А это значит, что в SQL командах нельзя использовать названия таблиц и столбцов в 
    качестве параметров. Чтобы обойти это ограничение, нужно построить динамическую 
    команду для <application>PL/pgSQL</application> оператора <command>EXECUTE</command>
    &mdash; ценой будет разбор и построение нового плана выполнения при каждом вызове.
   </para>

    <para>
     Изменчивая природа переменных типа <type>record</> представляет еще одну проблему 
     в этой связи. Когда поля переменной типа <type>record</> используются в выражениях или 
     операторах, типы данных полей не должны меняться от одного вызова функции к другому, 
     так как при анализе каждого выражения будет использоваться тот тип данных, который 
     присутствовал при первом вызове. При необходимости можно использовать 
     <command>EXECUTE</command> для решения этой проблемы.
    </para>

    <para>
     Если функция используется в качестве триггера более чем для одной таблицы, 
     <application>PL/pgSQL</application> независимо подготавливает и кэширует операторы 
     для каждой такой таблицы. То есть создается кэш для каждой комбинации 
     триггерная функция + таблица, а не только для каждой функции. Это устраняет 
     некоторые проблемы, связанные с различными типами данных. Например, триггерная 
     функция сможет успешно работать со столбцом <literal>key</>, даже если в разных 
     таблицах этот столбец имеет разные типы данных.
    </para>

    <para>
     Таким же образом, функции с полиморфными типами аргументов имеют отдельный кэш 
     для каждой комбинации фактических типов аргументов, так что различия типов данных 
     не вызывают неожиданных сбоев.
    </para>

   <para>
    Кэширование операторов иногда приводит к неожиданным эффектам при интерпретации 
    чувствительных ко времени значений. Например, есть разница между тем, что делают 
    эти две функции:

<programlisting>
CREATE FUNCTION logfunc1(logtxt text) RETURNS void AS $$
    BEGIN
        INSERT INTO logtable VALUES (logtxt, 'now');
    END;
$$ LANGUAGE plpgsql;
</programlisting>

     и 

<programlisting>
CREATE FUNCTION logfunc2(logtxt text) RETURNS void AS $$
    DECLARE
        curtime timestamp;
    BEGIN
        curtime := 'now';
        INSERT INTO logtable VALUES (logtxt, curtime);
    END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>

    <para>
     В случае <function>logfunc1</function>, при анализе <command>INSERT</command>, 
     основной парсер <productname>PostgreSQL</productname> знает, что строку 
     <literal>'now'</literal> следует толковать как <type>timestamp</type>, потому что 
     целевой столбец таблицы <classname>logtable</classname> имеет такой тип данных. 
     Таким образом, <literal>'now'</literal> будет преобразовано в константу 
     <type>timestamp</type> при анализе <command>INSERT</command>, а затем эта константа 
     будет использоваться в последующих вызовах <function>logfunc1</function> в течение 
     всей сессии. Разумеется, это не то, что хотел программист. Лучше было бы 
     использовать функцию <literal>now()</> или <literal>current_timestamp</>.
    </para>

    <para>
     В случае <function>logfunc2</function>, основной парсер 
     <productname>PostgreSQL</productname> не знает, какого типа будет 
     <literal>'now'</literal> и поэтому возвращает значение типа <type>text</type>, 
     содержащее строку <literal>now</literal>. При последующем присвоении локальной 
     переменной <varname>curtime</varname> интерпретатор <application>PL/pgSQL</> 
     преобразовывает эту строку к типу <type>timestamp</type>, вызывая функции 
     <function>text_out</function> и <function>timestamp_in</function>. Таким образом, 
     метка времени будет обновляться при каждом выполнении, как и ожидается программистом. 
     И хотя всё работает как ожидалось, это ужасно неэффективно, поэтому использование 
     функции <literal>now()</> по-прежнему значительно лучше.
    </para>

  </sect2>

  </sect1>

 <sect1 id="plpgsql-development-tips">
<!-- en
  <title>Tips for Developing in <application>PL/pgSQL</application></title>
-->
  <title>Советы по разработке на <application>PL/pgSQL</application></title>

   <para>
    Хороший способ разрабатывать на <application>PL/pgSQL</> заключается в том, 
    чтобы в одном окне с текстовым редактором по выбору создавать тексты функций, 
    а в другом окне с <application>psql</application> загружать и тестировать 
    эти функции. В таком случае удобно записывать функцию, используя 
    <command>CREATE OR REPLACE FUNCTION</>. Таким образом, можно легко загрузить 
    файл для обновления определения функции. Например:
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $$
          ....
$$ LANGUAGE plpgsql;
</programlisting>
   </para>

   <para>
    В <application>psql</application>, можно загрузить или перезагрузить такой файл 
    определения функции, выполнив:
<programlisting>
\i filename.sql
</programlisting>
    а затем сразу выполнять команды SQL для тестирования функции.
   </para>

   <para>
    Еще один хороший способ разрабатывать на <application>PL/pgSQL</> связан с 
    использованием GUI инструментов, облегчающих разработку на процедурном языке. 
    Один из примеров такого инструмента <application>pgAdmin</>, хотя есть и другие. 
    Такие инструменты часто предоставляют удобные возможности, такие как 
    экранирование одинарных кавычек, отладка и повторное создание функций.
   </para>

  <sect2 id="plpgsql-quote-tips">
<!-- en
   <title>Handling of Quotation Marks</title>
-->
   <title>Обработка кавычек</title>

   <para>
    Код <application>PL/pgSQL</> функции указывается в команде 
    <command>CREATE FUNCTION</command> в виде строки. Если писать строку в обычном 
    порядке, внутри одинарных кавычек, то любой символ одинарной кавычки должен быть 
    удвоен, также как и должен быть удвоен каждый знак обратной косой черты (если 
    используется синтаксис с экранированием в строках). Удвоение кавычек в лучшем 
    случае утомительно, а в более сложных случаях код может стать совершенно 
    непонятным, так как легко может потребоваться полудюжина или более кавычек идущих 
    подряд. Вместо этого при создании тела функции рекомендуется использовать 
    знаки доллара в качестве кавычек 
    (смотри <xref linkend="sql-syntax-dollar-quoting">). При таком подходе 
    никогда не потребуется дублировать кавычки, но придется позаботиться о том, чтобы 
    иметь разные долларовые разделители для каждого уровня вложенности. Например, 
    команду <command>CREATE FUNCTION</command> можно записать так:
<programlisting>
CREATE OR REPLACE FUNCTION testfunc(integer) RETURNS integer AS $PROC$
          ....
$PROC$ LANGUAGE plpgsql;
</programlisting>
    Внутри можно использовать кавычки для простых текстовых строк и <literal>$$</> 
    для разграничения фрагментов SQL команды, собираемой из отдельных строк. Если 
    нужно взять в кавычки текст, который включает <literal>$$</>, можно использовать 
    <literal>$Q$</>, и так далее.
   </para>

   <para>
    Следующая таблица показывает, как применяются знаки кавычек, если не 
    используется экранирование долларами. Это может быть полезно при переводе кода, 
    не использующего экранирование знаками доллара, в нечто более понятное.
  </para>

  <variablelist>
   <varlistentry>
    <term>1 кавычка</term>
    <listitem>
     <para>
      В начале и конце тела функции, например:
<programlisting>
CREATE FUNCTION foo() RETURNS integer AS '
          ....
' LANGUAGE plpgsql;
</programlisting>
      Внутри такой функции любая кавычка <emphasis>должна</> дублироваться.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>2 кавычки</term>
    <listitem>
     <para>
      Для строковых литералов внутри тела функции, например:
<programlisting>
a_output := ''Blah'';
SELECT * FROM users WHERE f_name=''foobar'';
</programlisting>
      При использовании знаков доллара можно просто написать:
<programlisting>
a_output := 'Blah';
SELECT * FROM users WHERE f_name='foobar';
</programlisting>
      и это именно то, что нужно <application>PL/pgSQL</> парсеру. 
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>4 кавычки</term>
    <listitem>
     <para>
      Когда нужны одинарные кавычки в строковой константе внутри тела функции, например:
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar'''' AND xyz''
</programlisting>
      К <literal>a_output</literal> будет добавлено:
      <literal> AND name LIKE 'foobar' AND xyz</literal>
     </para>
     <para>
      При использовании знаков доллара это записывается так:
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar' AND xyz$$
</programlisting>
      будьте внимательны, при этом не должно быть внешнего долларового разделителя 
      <literal>$$</>.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>6 кавычек</term>
    <listitem>
     <para>
      Когда нужны одинарные кавычки в строковой константе внутри тела функции, 
      при этом кавычки находятся в конце строковой константы. Например:
<programlisting>
a_output := a_output || '' AND name LIKE ''''foobar''''''
</programlisting>
      К <literal>a_output</literal> будет добавлено:
      <literal> AND name LIKE 'foobar'</literal>.
     </para>
     <para>
      При использовании знаков доллара это записывается так:
<programlisting>
a_output := a_output || $$ AND name LIKE 'foobar'$$
</programlisting>
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>10 кавычек</term>
    <listitem>
     <para>
      Когда нужны две одиночные кавычки в строковой константе (это уже 8 кавычек),
      примыкающие к концу строковой константы (еще 2). Вероятно, такое может понадобиться
      при разработке функции, которая генерирует другие функции, 
      как в <xref linkend="plpgsql-porting-ex2">. Например:
<programlisting>
a_output := a_output || '' if v_'' ||
    referrer_keys.kind || '' like ''''''''''
    || referrer_keys.key_string || ''''''''''
    then return ''''''  || referrer_keys.referrer_type
    || ''''''; end if;'';
</programlisting>
      Значение <literal>a_output</literal> затем будет:
<programlisting>
if v_... like ''...'' then return ''...''; end if;
</programlisting>
     </para>
     <para>
      При использовании знаков доллара:
<programlisting>
a_output := a_output || $$ if v_$$ || referrer_keys.kind || $$ like '$$
    || referrer_keys.key_string || $$'
    then return '$$  || referrer_keys.referrer_type
    || $$'; end if;$$;
</programlisting>
      где предполагается, что нужны только одиночные кавычки в <literal>a_output</literal>, 
      так как потребуется повторное взятие в кавычки перед использованием.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  </sect2>

  <sect2 id="plpgsql-extra-checks">
   <title>Дополнительные проверки во время компиляции</title>

   <para>
    Чтобы помочь найти и предупредить простые, но часто встречающиеся проблемы, 
    <application>PL/PgSQL</> предоставляет дополнительные проверки 
    <replaceable>checks</>.
    Если они включены в конфигурации, то во время компиляции функций 
    будут выдаваться дополнительные сообщения <literal>WARNING</> или 
    ошибки <literal>ERROR</>.
    Функция, при компиляции которой выдавалось <literal>WARNING</>, 
    при последующем выполнении не будет выдавать это сообщение 
    и её можно протестировать в отдельной среде разработки.
   </para>

 <para>
  Для включения этих проверок используются параметры конфигурации
  <varname>plpgsql.extra_warnings</> для предупреждений и 
  <varname>plpgsql.extra_errors</> для ошибок.
  Каждому из параметров можно присвоить список значений, разделенный 
  через запятую, значение <literal>"none"</> или <literal>"all"</>. 
  По умолчанию используется <literal>"none"</>. 
  В настоящий момент доступна только одна проверка:
  <variablelist>
   <varlistentry>
    <term><varname>shadowed_variables</varname></term>
    <listitem>
     <para>
      Проверяет, что объявление новой переменной не скрывает ранее 
      объявленную переменую.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  Следующий пример показывает эффект от установки 
  <varname>plpgsql.extra_warnings</> в значение 
  <varname>shadowed_variables</>:
<programlisting>
SET plpgsql.extra_warnings TO 'shadowed_variables';

CREATE FUNCTION foo(f1 int) RETURNS int AS $$
DECLARE
f1 int;
BEGIN
RETURN f1;
END
$$ LANGUAGE plpgsql;
WARNING:  variable "f1" shadows a previously defined variable
LINE 3: f1 int;
        ^
CREATE FUNCTION
</programlisting>
 </para>
 </sect2>

 </sect1>

  <!-- **** Porting from Oracle PL/SQL **** -->

 <sect1 id="plpgsql-porting">
<!-- en
  <title>Porting from <productname>Oracle</productname> PL/SQL</title>
-->
  <title>Портирование из <productname>Oracle</productname> PL/SQL</title>

  <indexterm zone="plpgsql-porting">
   <primary>Oracle</primary>
   <secondary>porting from PL/SQL to PL/pgSQL</secondary>
  </indexterm>

  <indexterm zone="plpgsql-porting">
   <primary>PL/SQL (Oracle)</primary>
   <secondary>porting to PL/pgSQL</secondary>
  </indexterm>

  <para>
   В этом разделе рассматриваются различия между языками <productname>PostgreSQL</>
   <application>PL/pgSQL</application> и Oracle <application>PL/SQL</application>, 
   чтобы помочь разработчикам, портирующим приложения из 
   <trademark class="registered">Oracle</> в <productname>PostgreSQL</>.
  </para>

  <para>
   <application>PL/pgSQL</application> во многих аспектах похож на PL/SQL . 
   Это блочно-структурированный, императивный язык, в котором все переменные должны 
   объявляться. Присвоения, циклы, условные операторы в обоих языках похожи. 
   Основные отличия, которые необходимо иметь в виду при портировании с 
   <application>PL/SQL</> в <application>PL/pgSQL</application>, следующие:

    <itemizedlist>
     <listitem>
      <para>
       Если имя, используемое в SQL команде, может быть как именем столбца таблицы, 
       так и ссылкой на переменную функции, то <application>PL/SQL</> считает, что 
       это имя столбца таблицы. Это соответствует поведению <application>PL/pgSQL</> 
       при <literal>plpgsql.variable_conflict</> = <literal>use_column</>, что не 
       является значением по умолчанию, как описано в <xref linkend="plpgsql-var-subst">.
       В первую очередь, было бы правильно избегать таких двусмысленностей, но если 
       требуется портировать большое количество кода, зависящее от данного поведения, 
       то установка переменной <literal>variable_conflict</> может быть лучшим решением.
      </para>
     </listitem>

     <listitem>
      <para>
       В <productname>PostgreSQL</> тело функции должно быть записано в виде строки. 
       Поэтому нужно использовать знак доллара в качестве кавычек или экранировать 
       одиночные кавычки в теле функции. (Смотри <xref linkend="plpgsql-quote-tips">.)
      </para>
     </listitem>

     <listitem>
      <para>
       Для группировки функций вместо пакетов используются схемы.
      </para>
     </listitem>

     <listitem>
      <para>
       Так как пакетов нет, нет и пакетных переменных. Это несколько раздражает. 
       Вместо этого можно хранить состояние каждого сеанса во временных таблицах.
      </para>
     </listitem>

     <listitem>
      <para>
       Целочисленные циклы <command>FOR</> с опцией <literal>REVERSE</> работают 
       по разному. В <application>PL/SQL</> значение счетчика уменьшается от второго 
       числа к первому, в то время как в <application>PL/pgSQL</> счетчик уменьшается 
       от первого ко второму. Поэтому при портировании нужно менять местами границы 
       цикла. Это печально, но вряд ли будет изменено. 
       (Смотри <xref linkend="plpgsql-integer-for">.)
      </para>
     </listitem>

     <listitem>
      <para>
       Циклы <command>FOR</> по запросам (не курсорам) также работают по разному. 
       Переменная цикла должна быть объявлена, в то время как в <application>PL/SQL</>
       она объявляется неявно. Преимущество в том, что значения переменных доступны 
       и после выхода из цикла.
      </para>
     </listitem>

     <listitem>
      <para>
       Существуют некоторые отличия в нотации при использовании курсорных переменных.
      </para>
     </listitem>

    </itemizedlist>
   </para>

  <sect2>
<!-- en
   <title>Porting Examples</title>
-->
   <title>Примеры портирования</title>

   <para>
    <xref linkend="pgsql-porting-ex1"> показывает, как портировать простую функцию из
    <application>PL/SQL</> в <application>PL/pgSQL</>.
   </para>

   <example id="pgsql-porting-ex1">
<!-- en
    <title>Porting a Simple Function from <application>PL/SQL</> to <application>PL/pgSQL</></title>
-->
    <title>Портирование простой функции из <application>PL/SQL</> в <application>PL/pgSQL</></title>

    <para>
     Функция <productname>Oracle</productname> <application>PL/SQL</>:
<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURN varchar IS
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
/
show errors;
</programlisting>
    </para>

    <para>
     Пройдемся по этой функции и посмотрим различия по сравнению с 
     <application>PL/pgSQL</>:

     <itemizedlist>
      <listitem>
       <para>
        Ключевое слово <literal>RETURN</literal> в прототипе функции (не в теле функции) 
        заменяется на <literal>RETURNS</literal> в <productname>PostgreSQL</>. 
        Кроме того, <literal>IS</> становится <literal>AS</>, и нужно добавить фразу 
        <literal>LANGUAGE</>, потому что <application>PL/pgSQL</> не единственный 
        возможный язык.
       </para>
      </listitem>

      <listitem>
       <para>
        В <productname>PostgreSQL</> тело функции является строкой, поэтому нужно 
        использовать кавычки или знаки доллара. Это заменяет завершающий <literal>/</> 
        в подходе Oracle.
       </para>
      </listitem>

      <listitem>
       <para>
        Команда <literal>show errors</literal> не существует в 
        <productname>PostgreSQL</> и не требуется, так как ошибки будут выводиться 
        автоматически.
       </para>
      </listitem>
     </itemizedlist>
    </para>

    <para>
     Вот как эта функция будет выглядеть после портирования в
     <productname>PostgreSQL</>:

<programlisting>
CREATE OR REPLACE FUNCTION cs_fmt_browser_version(v_name varchar,
                                                  v_version varchar)
RETURNS varchar AS $$
BEGIN
    IF v_version IS NULL THEN
        RETURN v_name;
    END IF;
    RETURN v_name || '/' || v_version;
END;
$$ LANGUAGE plpgsql;
</programlisting>
    </para>
   </example>

   <para>
    <xref linkend="plpgsql-porting-ex2"> показывает, как портировать функцию, которая 
     создает другую функцию, и как обрабатывать проблемы с кавычками.
   </para>

   <example id="plpgsql-porting-ex2">
<!-- en
    <title>Porting a Function that Creates Another Function from <application>PL/SQL</> to <application>PL/pgSQL</></title>
-->
    <title>Портирование из <application>PL/SQL</> to <application>PL/pgSQL</> функции создающей другую функцию</title>

    <para>
     Следующая процедура получает строки из <command>SELECT</command> и строит большую 
     функцию, в целях эффективности возвращающую результат в операторах 
     <literal>IF</literal>.
    </para>

    <para>
     Версия Oracle:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_update_referrer_type_proc IS
    CURSOR referrer_keys IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_cmd VARCHAR(4000);
BEGIN
    func_cmd := 'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host IN VARCHAR,
                 v_domain IN VARCHAR, v_url IN VARCHAR) RETURN VARCHAR IS BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_cmd := func_cmd ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ''' || referrer_key.key_string
          || ''' THEN RETURN ''' || referrer_key.referrer_type
          || '''; END IF;';
    END LOOP;

    func_cmd := func_cmd || ' RETURN NULL; END;';

    EXECUTE IMMEDIATE func_cmd;
END;
/
show errors;
</programlisting>
    </para>

    <para>
     В конечном итоге в <productname>PostgreSQL</> эта функция может выглядеть так:
<programlisting>
CREATE OR REPLACE FUNCTION cs_update_referrer_type_proc() RETURNS void AS $func$
DECLARE
    referrer_keys CURSOR IS
        SELECT * FROM cs_referrer_keys
        ORDER BY try_order;
    func_body text;
    func_cmd text;
BEGIN
    func_body := 'BEGIN';

    FOR referrer_key IN referrer_keys LOOP
        func_body := func_body ||
          ' IF v_' || referrer_key.kind
          || ' LIKE ' || quote_literal(referrer_key.key_string)
          || ' THEN RETURN ' || quote_literal(referrer_key.referrer_type)
          || '; END IF;' ;
    END LOOP;

    func_body := func_body || ' RETURN NULL; END;';

    func_cmd :=
      'CREATE OR REPLACE FUNCTION cs_find_referrer_type(v_host varchar,
                                                        v_domain varchar,
                                                        v_url varchar)
        RETURNS varchar AS '
      || quote_literal(func_body)
      || ' LANGUAGE plpgsql;' ;

    EXECUTE func_cmd;
END;
$func$ LANGUAGE plpgsql;
</programlisting>
     Обратите внимание, что тело функции строится отдельно, с использованием 
     <literal>quote_literal</> для удвоения кавычек. Эта техника необходима, потому 
     что мы не можем безопасно использовать знаки доллара при определении новой 
     функции: мы не знаем наверняка, какие строки будут вставлены из 
     <structfield>referrer_key.key_string</>. (Мы предполагаем, что 
     <structfield>referrer_key.kind</> всегда имеет значение из списка: 
     <literal>host</>, <literal>domain</> или <literal>url</>, но 
     <structfield>referrer_key.key_string</> может быть чем угодно, в частности,  
     может содержать знаки доллара.) На самом деле, в этой функций есть улучшение 
     по сравнению с оригиналом Oracle, потому что не будет генерироваться неправильный 
     код, когда <structfield>referrer_key.key_string</> или
     <structfield>referrer_key.referrer_type</> содержат кавычки.
    </para>
   </example>

   <para>
    <xref linkend="plpgsql-porting-ex3"> показывает, как портировать функцию с 
    <literal>OUT</> параметрами и манипулирующую строками. <productname>PostgreSQL</>
    не имеет встроенной функции <function>instr</function>, но её можно создать, 
    используя комбинацию других функций. <indexterm><primary>instr</></indexterm> <xref
    linkend="plpgsql-porting-appendix"> содержит реализацию <function>instr</function>
    в <application>PL/pgSQL</application>, которую можно использовать для облегчения 
    портирования.
   </para>

   <example id="plpgsql-porting-ex3">
<!-- en
    <title>Porting a Procedure With String Manipulation and
    <literal>OUT</> Parameters from <application>PL/SQL</> to
    <application>PL/pgSQL</></title>
-->
    <title>Портирование из <application>PL/SQL</> в <application>PL/pgSQL</>
    процедуры, которая манипулирует строками и содержит <literal>OUT</> параметры</title>

    <para>
     Следующая <productname>Oracle</productname> PL/SQL процедура используется для 
     разбора URL и возвращения несколько элементов (хост, путь и запрос).
    </para>

    <para>
     Версия Oracle:
<programlisting>
CREATE OR REPLACE PROCEDURE cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- Возвращается обратно 
    v_path OUT VARCHAR,  -- И это возвращается
    v_query OUT VARCHAR) -- И это
IS
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
/
show errors;
</programlisting>
    </para>

    <para>
     Вот возможная трансляция в <application>PL/pgSQL</>:
<programlisting>
CREATE OR REPLACE FUNCTION cs_parse_url(
    v_url IN VARCHAR,
    v_host OUT VARCHAR,  -- Возвращается обратно
    v_path OUT VARCHAR,  -- И это возвращается
    v_query OUT VARCHAR) -- И это
AS $$
DECLARE
    a_pos1 INTEGER;
    a_pos2 INTEGER;
BEGIN
    v_host := NULL;
    v_path := NULL;
    v_query := NULL;
    a_pos1 := instr(v_url, '//');

    IF a_pos1 = 0 THEN
        RETURN;
    END IF;
    a_pos2 := instr(v_url, '/', a_pos1 + 2);
    IF a_pos2 = 0 THEN
        v_host := substr(v_url, a_pos1 + 2);
        v_path := '/';
        RETURN;
    END IF;

    v_host := substr(v_url, a_pos1 + 2, a_pos2 - a_pos1 - 2);
    a_pos1 := instr(v_url, '?', a_pos2 + 1);

    IF a_pos1 = 0 THEN
        v_path := substr(v_url, a_pos2);
        RETURN;
    END IF;

    v_path := substr(v_url, a_pos2, a_pos1 - a_pos2);
    v_query := substr(v_url, a_pos1 + 1);
END;
$$ LANGUAGE plpgsql;
</programlisting>

     Эту функцию можно использовать так:
<programlisting>
SELECT * FROM cs_parse_url('http://foobar.com/query.cgi?baz');
</programlisting>
    </para>
   </example>

   <para>
    <xref linkend="plpgsql-porting-ex4"> показывает, как портировать процедуру, 
    использующую большое количество специфических для Oracle возможностей.
   </para>

   <example id="plpgsql-porting-ex4">
<!-- en
    <title>Porting a Procedure from <application>PL/SQL</> to <application>PL/pgSQL</></title>
-->
    <title>Портирование процедуры из <application>PL/SQL</> в <application>PL/pgSQL</></title>

    <para>
     Версия Oracle:

<programlisting>
CREATE OR REPLACE PROCEDURE cs_create_job(v_job_id IN INTEGER) IS
    a_running_job_count INTEGER;
    PRAGMA AUTONOMOUS_TRANSACTION;<co id="co.plpgsql-porting-pragma">
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;<co id="co.plpgsql-porting-locktable">

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        COMMIT; -- free lock<co id="co.plpgsql-porting-commit">
        raise_application_error(-20000,
                 'Не могу создать новое задание. Задание сейчас выполняется.');
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, sysdate);
    EXCEPTION
        WHEN dup_val_on_index THEN NULL; -- don't worry if it already exists
    END;
    COMMIT;
END;
/
show errors
</programlisting>
   </para>

   <para>
    Подобные процедуры легко конвертируются в функции <productname>PostgreSQL</>, 
    возвращающие <type>void</type>. На примере этой процедуры можно научиться следующему:

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-pragma">
      <para>
       В <productname>PostgreSQL</> нет оператора <literal>PRAGMA</literal>.
      </para>
     </callout>

     <callout arearefs="co.plpgsql-porting-locktable">
      <para>
       Если выполнить <command>LOCK TABLE</command> в <application>PL/pgSQL</>, 
       блокировка не будет снята, пока не завершится вызывающая транзакция.
      </para>
     </callout>

     <callout arearefs="co.plpgsql-porting-commit">
      <para>
       В <application>PL/pgSQL</> функции нельзя использовать <command>COMMIT</>. 
       Функция работает в рамках некоторой внешней транзакции, и поэтому 
       <command>COMMIT</> будет означать прекращение выполнения функции. Однако, 
       в данном конкретном случае, в этом нет необходимости, потому что блокировка, 
       полученная командой <command>LOCK TABLE</command>, будет снята при вызове ошибки.
      </para>
     </callout>
    </calloutlist>
   </para>

   <para>
    В <application>PL/pgSQL</> эту процедуру можно портировать так:

<programlisting>
CREATE OR REPLACE FUNCTION cs_create_job(v_job_id integer) RETURNS void AS $$
DECLARE
    a_running_job_count integer;
BEGIN
    LOCK TABLE cs_jobs IN EXCLUSIVE MODE;

    SELECT count(*) INTO a_running_job_count FROM cs_jobs WHERE end_stamp IS NULL;

    IF a_running_job_count &gt; 0 THEN
        RAISE EXCEPTION 'Не могу создать новое задание. Задание сейчас выполняется.';<co id="co.plpgsql-porting-raise">
    END IF;

    DELETE FROM cs_active_job;
    INSERT INTO cs_active_job(job_id) VALUES (v_job_id);

    BEGIN
        INSERT INTO cs_jobs (job_id, start_stamp) VALUES (v_job_id, now());
    EXCEPTION
        WHEN unique_violation THEN <co id="co.plpgsql-porting-exception">
            -- don't worry if it already exists
    END;
END;
$$ LANGUAGE plpgsql;
</programlisting>

    <calloutlist>
     <callout arearefs="co.plpgsql-porting-raise">
      <para>
       Синтаксис <literal>RAISE</> существенно отличается от Oracle, хотя основной 
       вариант 
       <literal>RAISE</> <replaceable class="parameter">exception_name</replaceable> 
       работает похоже.
      </para>
     </callout>
     <callout arearefs="co.plpgsql-porting-exception">
      <para>
       Имена исключений, поддерживаемые <application>PL/pgSQL</>, отличаются от 
       исключений в Oracle. Количество встроенных имен исключений значительно больше 
       (смотри <xref linkend="errcodes-appendix">). В настоящее время нет способа 
       задать пользовательское имя исключения, хотя вместо этого можно вызывать ошибку 
       с заданным пользователем значением SQLSTATE.
      </para>
     </callout>
    </calloutlist>

    Основное функциональное отличие между этой процедурой и Oracle эквивалента в том, 
    что монопольная блокировка таблицы <literal>cs_jobs</> будет продолжаться до 
    окончания вызывающей транзакции. Кроме того, если в последствии работа вызывающей 
    программы прервется (например из-за ошибки), произойдет откат всех действий, 
    выполненных в этой процедуре.
   </para>
   </example>
  </sect2>

  <sect2 id="plpgsql-porting-other">
<!-- en
   <title>Other Things to Watch For</title>
-->
   <title>На что еще обратить внимание</title>

   <para>
    В этом разделе рассматриваются еще несколько вещей, на которые нужно обращать 
    внимание при портировании функций из Oracle <application>PL/SQL</> в 
    <productname>PostgreSQL</productname>.
   </para>

   <sect3 id="plpgsql-porting-exceptions">
<!-- en
    <title>Implicit Rollback after Exceptions</title>
-->
    <title>Неявный откат изменений после возникновения исключения</title>

    <para>
     В <application>PL/pgSQL</> при перехвате исключения в секции <literal>EXCEPTION</>
     все изменения в базе данных с начала блока автоматически откатываются. 
     В Oracle это эквивалентно следующему:

<programlisting>
BEGIN
    SAVEPOINT s1;
    ... здесь код ...
EXCEPTION
    WHEN ... THEN
        ROLLBACK TO s1;
        ... здесь код ...
    WHEN ... THEN
        ROLLBACK TO s1;
        ... здесь код ...
END;
</programlisting>

     При портировании процедуры Oracle, которая использует <command>SAVEPOINT</> 
     и <command>ROLLBACK TO</> в таком же стиле, задача простая: достаточно убрать 
     операторы <command>SAVEPOINT</> и <command>ROLLBACK TO</>. Если же 
     <command>SAVEPOINT</> и <command>ROLLBACK TO</> используются по-другому, 
     то придется подумать.
    </para>
   </sect3>

   <sect3>
    <title><command>EXECUTE</command></title>

    <para>
     <application>PL/pgSQL</> версия <command>EXECUTE</command> работает аналогично 
     версии в <application>PL/SQL</>, но нужно помнить об использовании 
     <function>quote_literal</function> и <function>quote_ident</function>, 
     как описано в <xref linkend="plpgsql-statements-executing-dyn">. 
     Без использования этих функций конструкции типа 
     <literal>EXECUTE 'SELECT * FROM $1';</literal> будут работать ненадежно.
    </para>
   </sect3>

   <sect3 id="plpgsql-porting-optimization">
<!-- en
    <title>Optimizing <application>PL/pgSQL</application> Functions</title>
-->
    <title>Оптимизация <application>PL/pgSQL</application> функций</title>

    <para>
     Для оптимизации исполнения <productname>PostgreSQL</> предоставляет два 
     модификатора при создании функции: <quote>волатильность</> (будет ли функция всегда 
     возвращать тот же результат при тех же аргументах) и <quote>строгость</> 
     (возвращает ли функция NULL, если хотя бы один из аргументов NULL). 
     Для получения подробной информации обратитесь к справочной странице 
     <xref linkend="sql-createfunction">.
    </para>

    <para>
     При использовании этих атрибутов оптимизации оператор 
     <command>CREATE FUNCTION</command> может выглядеть примерно так:

<programlisting>
CREATE FUNCTION foo(...) RETURNS integer AS $$
...
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
    </para>
   </sect3>
  </sect2>

  <sect2 id="plpgsql-porting-appendix">
<!-- en
   <title>Appendix</title>
-->
   <title>Приложение</title>

   <para>
    Этот раздел содержит код для совместимых с Oracle функций <function>instr</function>,
    которые можно использовать для упрощения портирования.
   </para>

<programlisting>
--
-- instr functions that mimic Oracle's counterpart
-- Syntax: instr(string1, string2, [n], [m]) where [] denotes optional parameters.
--
-- Searches string1 beginning at the nth character for the mth occurrence
-- of string2.  If n is negative, search backwards.  If m is not passed,
-- assume 1 (search starts at first character).
--

CREATE FUNCTION instr(varchar, varchar) RETURNS integer AS $$
DECLARE
    pos integer;
BEGIN
    pos:= instr($1, $2, 1);
    RETURN pos;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar, beg_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index &gt; 0 THEN
        temp_str := substring(string FROM beg_index);
        pos := position(string_to_search IN temp_str);

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN pos + beg_index - 1;
        END IF;
    ELSIF beg_index &lt; 0 THEN
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                RETURN beg;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;


CREATE FUNCTION instr(string varchar, string_to_search varchar,
                      beg_index integer, occur_index integer)
RETURNS integer AS $$
DECLARE
    pos integer NOT NULL DEFAULT 0;
    occur_number integer NOT NULL DEFAULT 0;
    temp_str varchar;
    beg integer;
    i integer;
    length integer;
    ss_length integer;
BEGIN
    IF beg_index &gt; 0 THEN
        beg := beg_index;
        temp_str := substring(string FROM beg_index);

        FOR i IN 1..occur_index LOOP
            pos := position(string_to_search IN temp_str);

            IF i = 1 THEN
                beg := beg + pos - 1;
            ELSE
                beg := beg + pos;
            END IF;

            temp_str := substring(string FROM beg + 1);
        END LOOP;

        IF pos = 0 THEN
            RETURN 0;
        ELSE
            RETURN beg;
        END IF;
    ELSIF beg_index &lt; 0 THEN
        ss_length := char_length(string_to_search);
        length := char_length(string);
        beg := length + beg_index - ss_length + 2;

        WHILE beg &gt; 0 LOOP
            temp_str := substring(string FROM beg FOR ss_length);
            pos := position(string_to_search IN temp_str);

            IF pos &gt; 0 THEN
                occur_number := occur_number + 1;

                IF occur_number = occur_index THEN
                    RETURN beg;
                END IF;
            END IF;

            beg := beg - 1;
        END LOOP;

        RETURN 0;
    ELSE
        RETURN 0;
    END IF;
END;
$$ LANGUAGE plpgsql STRICT IMMUTABLE;
</programlisting>
  </sect2>

 </sect1>

</chapter>
